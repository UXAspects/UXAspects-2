(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('resize-observer-polyfill'), require('dragula/dist/dragula'), require('@angular/cdk/observers'), require('@angular/cdk/overlay'), require('angular-split'), require('@angular/common/http'), require('d3-ease'), require('@angular/cdk/portal'), require('d3-interpolate'), require('d3-shape'), require('d3-zoom'), require('@angular/router'), require('d3-hierarchy'), require('d3-scale'), require('d3-selection'), require('d3-transition'), require('d3-array'), require('@angular/cdk/platform'), require('@angular/cdk/coercion'), require('@angular/cdk/a11y'), require('@angular/animations'), require('@angular/forms'), require('@angular/common'), require('@angular/cdk/text-field'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/keycodes'), require('@angular/core')) :
        typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', 'resize-observer-polyfill', 'dragula/dist/dragula', '@angular/cdk/observers', '@angular/cdk/overlay', 'angular-split', '@angular/common/http', 'd3-ease', '@angular/cdk/portal', 'd3-interpolate', 'd3-shape', 'd3-zoom', '@angular/router', 'd3-hierarchy', 'd3-scale', 'd3-selection', 'd3-transition', 'd3-array', '@angular/cdk/platform', '@angular/cdk/coercion', '@angular/cdk/a11y', '@angular/animations', '@angular/forms', '@angular/common', '@angular/cdk/text-field', 'rxjs', 'rxjs/operators', '@angular/cdk/keycodes', '@angular/core'], factory) :
            (factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}), global.ResizeObserver, global.dragulaNamespace, global.ng.cdk.observers, global.ng.cdk.overlay, global.angularSplit, global.ng.common.http, global.d3Ease, global.ng.cdk.portal, global.d3Interpolate, global.d3Shape, global.d3Zoom, global.ng.router, global.d3Hierarchy, global.d3Scale, global.d3Selection, global.d3Transition, global.d3Array, global.ng.cdk.platform, global.ng.cdk.coercion, global.ng.cdk.a11y, global.ng.animations, global.ng.forms, global.ng.common, global.ng.cdk['text-field'], global.rxjs, global.rxjs.operators, global.ng.cdk.keycodes, global.ng.core));
}(this, (function (exports, ResizeObserver, dragulaNamespace, observers, overlay, angularSplit, http, d3Ease, portal, d3Interpolate, d3Shape, d3Zoom, router, d3Hierarchy, d3Scale, d3Selection, d3Transition, d3Array, platform, coercion, a11y, animations, forms, common, textField, rxjs, operators, keycodes, i0) {
    'use strict';
    ResizeObserver = ResizeObserver && ResizeObserver.hasOwnProperty('default') ? ResizeObserver['default'] : ResizeObserver;
    var dragulaNamespace__default = 'default' in dragulaNamespace ? dragulaNamespace['default'] : dragulaNamespace;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var Color = {
        Primary: 'primary',
        Accent: 'accent',
        Secondary: 'secondary',
        Alternate1: 'alternate1',
        Alternate2: 'alternate2',
        Alternate3: 'alternate3',
        Vibrant1: 'vibrant1',
        Vibrant2: 'vibrant2',
        Grey1: 'grey1',
        Grey2: 'grey2',
        Grey3: 'grey3',
        Grey4: 'grey4',
        Grey5: 'grey5',
        Grey6: 'grey6',
        Grey7: 'grey7',
        Grey8: 'grey8',
        Chart1: 'chart1',
        Chart2: 'chart2',
        Chart3: 'chart3',
        Chart4: 'chart4',
        Chart5: 'chart5',
        Chart6: 'chart6',
        Ok: 'ok',
        Warning: 'warning',
        Critical: 'critical',
        Partition1: 'partition1',
        Partition9: 'partition9',
        Partition10: 'partition10',
        Partition11: 'partition11',
        Partition12: 'partition12',
        Partition13: 'partition13',
        Partition14: 'partition14',
        SocialChartNode: 'social-chart-node',
        SocialChartEdge: 'social-chart-edge',
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Determine the type of icon based upon the identifier.
     *
     * We support the following iconset:
     *
     * - `hpe-icons` - HPE Icon Set
     * - `ux-icon` - UX Icon Set
     * - `component` - Component icon not tied to a specific set
     *
     * @param {?} identifier - The name of the icon
     * @return {?}
     */
    function getIconType(identifier) {
        if (identifier && identifier.trim().indexOf('hpe-') === 0) {
            return IconType.HpeIcon;
        }
        if (identifier && identifier.trim().indexOf('ux-') === 0) {
            return IconType.UxIcon;
        }
        return IconType.Component;
    }
    /** @enum {string} */
    var IconType = {
        HpeIcon: 'hpe-icon',
        UxIcon: 'ux-icon',
        Component: 'component',
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * This is a simple RxJS operator to allow us to avoid the
     * "expression has changed after it was checked issue"
     * by making the subscription asynchronous. We could just use a
     * delay operator but this uses a timeout which is significantly
     * slower than using requestAnimationFrame.
     * @type {?}
     */
    var tick = function () {
        return function (source) {
            return new rxjs.Observable(function (subscriber) {
                source.subscribe({
                    next: /**
                     * @param {?} value
                     * @return {?}
                     */ function (value) { requestAnimationFrame(function () { return subscriber.next(value); }); },
                    error: /**
                     * @param {?} err
                     * @return {?}
                     */ function (err) { subscriber.error(err); },
                    complete: /**
                     * @return {?}
                     */ function () { subscriber.complete(); },
                });
            });
        };
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * A button will trigger a click event whenever the a mouse click occurs or the enter key is pressed.
     * These functions can be used to identify if a `click` event was caused by the keyboard or
     * by a mouse.
     *
     * The `event.detail` property will change based on the source of the event.
     * A mouse click will have varying values based on the browser, however
     * the enter key will always have a value of `0` so we can check against that
     */
    /**
     * @param {?} event
     * @return {?}
     */
    function isKeyboardTrigger(event) {
        return event.detail === 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    function isMouseTrigger(event) {
        return !isKeyboardTrigger(event);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccordionPanelHeadingDirective = /** @class */ (function () {
        function AccordionPanelHeadingDirective() {
        }
        AccordionPanelHeadingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-accordion-panel-header'
                    },] }
        ];
        return AccordionPanelHeadingDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccordionService = /** @class */ (function () {
        function AccordionService() {
            this.collapseOthers = false;
            this.collapse = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        AccordionService.prototype.collapseAll = /**
         * @return {?}
         */
            function () {
                this.collapse.next();
            };
        AccordionService.decorators = [
            { type: i0.Injectable }
        ];
        return AccordionService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId = 1;
    var AccordionPanelComponent = /** @class */ (function () {
        function AccordionPanelComponent(accordion) {
            var _this = this;
            this.accordion = accordion;
            this.panelId = "ux-accordion-panel-" + uniqueId++;
            this.headingId = this.panelId + "-heading";
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new i0.EventEmitter();
            accordion.collapse.subscribe(function () { return _this.collapse(); });
        }
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.expanded) {
                    this.collapse();
                    return;
                }
                // check if we should collapse others
                if (this.accordion.collapseOthers) {
                    this.accordion.collapseAll();
                }
                // store the new expanded state
                this.expand();
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.expand = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === false) {
                    this.expanded = true;
                    this.expandedChange.next(true);
                }
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.collapse = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === true) {
                    this.expanded = false;
                    this.expandedChange.next(false);
                }
            };
        AccordionPanelComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-accordion-panel',
                        template: "<div class=\"panel-heading\"\n      role=\"button\"\n      uxFocusIndicator\n      [tabindex]=\"disabled ? -1 : 0\"\n      [id]=\"headingId\"\n      [attr.aria-expanded]=\"expanded\"\n      [attr.aria-controls]=\"panelId\"\n      (click)=\"toggle()\"\n      (keydown.enter)=\"toggle()\"\n      (keydown.space)=\"toggle(); $event.preventDefault()\"\n      (keydown.spacebar)=\"toggle(); $event.preventDefault()\">\n\n  <div class=\"panel-title\">\n      {{ heading }}\n      <ng-content select=\"ux-accordion-panel-header\"></ng-content>\n  </div>\n</div>\n\n<div [id]=\"panelId\"\n      class=\"panel-collapse collapse\"\n      [class.in]=\"expanded\"\n      role=\"tabpanel\"\n      [attr.aria-labelledby]=\"headingId\">\n\n  <div class=\"panel-body\">\n    <ng-content></ng-content>\n  </div>\n</div>",
                        host: {
                            'class': 'panel panel-default',
                            'role': 'tab'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionPanelComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionPanelComponent.propDecorators = {
            panelId: [{ type: i0.Input }],
            headingId: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            heading: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.panel-open',] }],
            expandedChange: [{ type: i0.Output }]
        };
        return AccordionPanelComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccordionComponent = /** @class */ (function () {
        function AccordionComponent(_accordion) {
            this._accordion = _accordion;
        }
        Object.defineProperty(AccordionComponent.prototype, "collapseOthers", {
            set: /**
             * @param {?} collapseOthers
             * @return {?}
             */ function (collapseOthers) {
                this._accordion.collapseOthers = collapseOthers;
            },
            enumerable: true,
            configurable: true
        });
        AccordionComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-accordion',
                        template: "<ng-content></ng-content>",
                        providers: [AccordionService],
                        host: {
                            'class': 'panel-group',
                            'role': 'tablist',
                            'aria-multiselectable': 'true'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionComponent.propDecorators = {
            collapseOthers: [{ type: i0.Input }]
        };
        return AccordionComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var KEPPEL_COLOR_SET = {
        'primary': '#00a7a2',
        'accent': '#7b63a3',
        'secondary': '#fff',
        'alternate1': '#3baa43',
        'alternate2': '#025662',
        'alternate3': '#b08f5c',
        'vibrant1': '#00cceb',
        'vibrant2': '#ff9048',
        'grey1': '#2a2a2a',
        'grey2': '#333',
        'grey3': '#666',
        'grey4': '#999',
        'grey5': '#ccc',
        'grey6': '#eee',
        'grey7': '#f5f5f5',
        'grey8': '#fafafa',
        'chart1': '#00a7a2',
        'chart2': '#7b63a3',
        'chart3': '#3baa43',
        'chart4': '#025662',
        'chart5': '#b08f5c',
        'chart6': '#ccc',
        'ok': '#3baa43',
        'warning': '#ff9048',
        'critical': '#ff454f',
        'partition1': '#635387',
        'partition9': '#4a4066',
        'partition10': '#308935',
        'partition11': '#023e42',
        'partition12': '#91744d',
        'partition13': '#999',
        'partition14': '#294266',
        'social-chart-node': '#00cceb',
        'social-chart-edge': '#00cceb'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MICRO_FOCUS_COLOR_SET = {
        'cerulean': '#1668c1',
        'aqua': '#29ceff',
        'aquamarine': '#2fd6c3',
        'fuchsia': '#c6179d',
        'indigo': '#7425ad',
        'dark-blue': '#231ca5',
        'white': '#ffffff',
        'slightly-gray': '#f5f7f8',
        'bright-gray': '#f1f2f3',
        'gray': '#dcdedf',
        'silver': '#bdbec0',
        'dim-gray': '#656668',
        'dark-gray': '#323435',
        'black': '#000000',
        'crimson-negative': '#e5004c',
        'apricot': '#f48b34',
        'yellow': '#fcdb1f',
        'green-positive': '#1aac60',
        'ultramarine': '#3939c6',
        'skyblue': '#00abf3',
        'pale-aqua': '#43e4ff',
        'pale-green': '#1ffbba',
        'lime': '#75da4d',
        'orange': '#ffce00',
        'magenta': '#eb23c2',
        'pale-purple': '#ba47e2',
        'dark-ultramarine': '#271782',
        'steelblue': '#014272',
        'arctic-blue': '#0b8eac',
        'emerald': '#00a989',
        'olive': '#5bba36',
        'goldenrod': '#ffb000',
        'purple': '#9b1e83',
        'pale-eggplant': '#5216ac',
        'red': '#ff454f',
        'pale-amber': '#ffb24d',
        'pale-lemon': '#fde159',
        'pale-emerald': '#33c180',
        'plum': '#b21646',
        'copper': '#e57828',
        'amber': '#ffc002',
        'leaf-green': '#118c4f',
        'forest-green': '#00645a',
        'primary': '#0073e7',
        'accent': '#7425ad',
        'secondary': '#ffffff',
        'alternate1': '#29ceff',
        'alternate2': '#2fd6c3',
        'alternate3': '#c6179d',
        'vibrant1': '#43e4ff',
        'vibrant2': '#ffce00',
        'grey1': '#000000',
        'grey2': '#323435',
        'grey3': '#656668',
        'grey4': '#bdbec0',
        'grey5': '#dcdedf',
        'grey6': '#f1f2f3',
        'grey7': '#f5f7f8',
        'grey8': '#ffffff',
        'chart1': '#3939c6',
        'chart2': '#00abf3',
        'chart3': '#75da4d',
        'chart4': '#ffce00',
        'chart5': '#eb23c2',
        'chart6': '#ba47e2',
        'ok': '#1aac60',
        'warning': '#f48b34',
        'critical': 'e5004c',
        'partition1': '#7425ad',
        'partition9': '#5216ac',
        'partition10': '#5bba36',
        'partition11': '#014272',
        'partition12': '#ffb000',
        'partition13': '#bdbec0',
        'partition14': '#271782',
        'social-chart-node': '#ff00ff',
        'social-chart-edge': '#ff00ff'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var colorSets = {
        keppel: {
            colorValueSet: KEPPEL_COLOR_SET,
        },
        microFocus: {
            colorValueSet: MICRO_FOCUS_COLOR_SET
        }
    };
    /**
     * Provide a default color set for an application
     * @type {?}
     */
    var COLOR_SET_TOKEN = new i0.InjectionToken('COLOR_SET_TOKEN');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColorServiceModule = /** @class */ (function () {
        function ColorServiceModule() {
        }
        /**
         * The function allows the consuming applications to specify the applications
         * color set once in the app module, eg:
         * ```
         * ColorServiceModule.forRoot(colorSets.microFocus);
         * ```
         * @param colorSet The color set the application should use
         */
        /**
         * The function allows the consuming applications to specify the applications
         * color set once in the app module, eg:
         * ```
         * ColorServiceModule.forRoot(colorSets.microFocus);
         * ```
         * @param {?} colorSet The color set the application should use
         * @return {?}
         */
        ColorServiceModule.forRoot = /**
         * The function allows the consuming applications to specify the applications
         * color set once in the app module, eg:
         * ```
         * ColorServiceModule.forRoot(colorSets.microFocus);
         * ```
         * @param {?} colorSet The color set the application should use
         * @return {?}
         */
            function (colorSet) {
                return {
                    ngModule: ColorServiceModule,
                    providers: [
                        { provide: COLOR_SET_TOKEN, useValue: colorSet ? colorSet : colorSets.keppel }
                    ]
                };
            };
        ColorServiceModule.decorators = [
            { type: i0.NgModule, args: [{},] }
        ];
        return ColorServiceModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ThemeColor = /** @class */ (function () {
        function ThemeColor(_r, _g, _b, _a) {
            if (_a === void 0) {
                _a = '1';
            }
            this._r = _r;
            this._g = _g;
            this._b = _b;
            this._a = _a;
        }
        /**
         * Create a ThemeColor object from a CSS color string
         * @param value The CSS color string to derive a ThemeColor object from
         */
        /**
         * Create a ThemeColor object from a CSS color string
         * @param {?} value The CSS color string to derive a ThemeColor object from
         * @return {?}
         */
        ThemeColor.parse = /**
         * Create a ThemeColor object from a CSS color string
         * @param {?} value The CSS color string to derive a ThemeColor object from
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var r;
                /** @type {?} */
                var g;
                /** @type {?} */
                var b;
                /** @type {?} */
                var a = '1';
                /** @type {?} */
                var rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
                /** @type {?} */
                var shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                /** @type {?} */
                var longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                /** @type {?} */
                var rgbaMatch = value.match(rgbaPattern);
                /** @type {?} */
                var shortHexMatch = value.match(shortHexPattern);
                /** @type {?} */
                var longHexMatch = value.match(longHexPattern);
                if (rgbaMatch) {
                    r = rgbaMatch[1];
                    g = rgbaMatch[2];
                    b = rgbaMatch[3];
                    a = rgbaMatch[4] ? rgbaMatch[4] : '1';
                }
                else if (longHexMatch) {
                    r = parseInt(longHexMatch[1], 16).toString();
                    g = parseInt(longHexMatch[2], 16).toString();
                    b = parseInt(longHexMatch[3], 16).toString();
                }
                else if (shortHexMatch) {
                    r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                    g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                    b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
                }
                else {
                    throw new Error("Cannot parse color - " + value + " is not a valid color.");
                }
                return new ThemeColor(r, g, b, a);
            };
        /**
         * Clone a theme color so it can be modified without affecting other places using the color
         * @param themeColor The original theme color to clone
         */
        /**
         * Clone a theme color so it can be modified without affecting other places using the color
         * @param {?} themeColor The original theme color to clone
         * @return {?}
         */
        ThemeColor.from = /**
         * Clone a theme color so it can be modified without affecting other places using the color
         * @param {?} themeColor The original theme color to clone
         * @return {?}
         */
            function (themeColor) {
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * Determine if an object is an instance of a theme color.
         * Using a simple instanceof check will not always work in plunker
         * where the ThemeColor is from @ux-aspects/ux-aspects and the color
         * comes from @micro-focus/ux-aspects
         */
        /**
         * Determine if an object is an instance of a theme color.
         * Using a simple instanceof check will not always work in plunker
         * where the ThemeColor is from \@ux-aspects/ux-aspects and the color
         * comes from \@micro-focus/ux-aspects
         * @param {?} themeColor
         * @return {?}
         */
        ThemeColor.isInstanceOf = /**
         * Determine if an object is an instance of a theme color.
         * Using a simple instanceof check will not always work in plunker
         * where the ThemeColor is from \@ux-aspects/ux-aspects and the color
         * comes from \@micro-focus/ux-aspects
         * @param {?} themeColor
         * @return {?}
         */
            function (themeColor) {
                return typeof themeColor.getRed === 'function' &&
                    typeof themeColor.getGreen === 'function' &&
                    typeof themeColor.getBlue === 'function' &&
                    typeof themeColor.getAlpha === 'function';
            };
        /**
         * Convert the theme color to a CSS hex color code
         */
        /**
         * Convert the theme color to a CSS hex color code
         * @return {?}
         */
        ThemeColor.prototype.toHex = /**
         * Convert the theme color to a CSS hex color code
         * @return {?}
         */
            function () {
                /** @type {?} */
                var red = parseInt(this._r).toString(16);
                /** @type {?} */
                var green = parseInt(this._g).toString(16);
                /** @type {?} */
                var blue = parseInt(this._b).toString(16);
                if (red.length < 2) {
                    red = '0' + red;
                }
                if (green.length < 2) {
                    green = '0' + green;
                }
                if (blue.length < 2) {
                    blue = '0' + blue;
                }
                return '#' + red + green + blue;
            };
        /**
         * Convert the theme color to a CSS rgb color code
         */
        /**
         * Convert the theme color to a CSS rgb color code
         * @return {?}
         */
        ThemeColor.prototype.toRgb = /**
         * Convert the theme color to a CSS rgb color code
         * @return {?}
         */
            function () {
                return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
            };
        /**
         * Convert the theme color to a CSS rgbs color code
         */
        /**
         * Convert the theme color to a CSS rgbs color code
         * @return {?}
         */
        ThemeColor.prototype.toRgba = /**
         * Convert the theme color to a CSS rgbs color code
         * @return {?}
         */
            function () {
                return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
            };
        /**
         * Get the red value from the RGBA color value
         */
        /**
         * Get the red value from the RGBA color value
         * @return {?}
         */
        ThemeColor.prototype.getRed = /**
         * Get the red value from the RGBA color value
         * @return {?}
         */
            function () {
                return this._r;
            };
        /**
         * Get the green value from the RGBA color value
         */
        /**
         * Get the green value from the RGBA color value
         * @return {?}
         */
        ThemeColor.prototype.getGreen = /**
         * Get the green value from the RGBA color value
         * @return {?}
         */
            function () {
                return this._g;
            };
        /**
         * Get the blue value from the RGBA color value
         */
        /**
         * Get the blue value from the RGBA color value
         * @return {?}
         */
        ThemeColor.prototype.getBlue = /**
         * Get the blue value from the RGBA color value
         * @return {?}
         */
            function () {
                return this._b;
            };
        /**
         * Get the alpha value from the RGBA color value
         */
        /**
         * Get the alpha value from the RGBA color value
         * @return {?}
         */
        ThemeColor.prototype.getAlpha = /**
         * Get the alpha value from the RGBA color value
         * @return {?}
         */
            function () {
                return this._a;
            };
        /**
         * Set the red value from the RGBA color value
         */
        /**
         * Set the red value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} red
         * @return {THIS}
         */
        ThemeColor.prototype.setRed = /**
         * Set the red value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} red
         * @return {THIS}
         */
            function (red) {
                ( /** @type {?} */(this))._r = red;
                return ( /** @type {?} */(this));
            };
        /**
         * Set the green value from the RGBA color value
         */
        /**
         * Set the green value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} green
         * @return {THIS}
         */
        ThemeColor.prototype.setGreen = /**
         * Set the green value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} green
         * @return {THIS}
         */
            function (green) {
                ( /** @type {?} */(this))._g = green;
                return ( /** @type {?} */(this));
            };
        /**
         * Set the blue value from the RGBA color value
         */
        /**
         * Set the blue value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} blue
         * @return {THIS}
         */
        ThemeColor.prototype.setBlue = /**
         * Set the blue value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} blue
         * @return {THIS}
         */
            function (blue) {
                ( /** @type {?} */(this))._b = blue;
                return ( /** @type {?} */(this));
            };
        /**
         * Set the alpha value from the RGBA color value
         */
        /**
         * Set the alpha value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} alpha
         * @return {THIS}
         */
        ThemeColor.prototype.setAlpha = /**
         * Set the alpha value from the RGBA color value
         * @template THIS
         * @this {THIS}
         * @param {?} alpha
         * @return {THIS}
         */
            function (alpha) {
                ( /** @type {?} */(this))._a = alpha.toString();
                return ( /** @type {?} */(this));
            };
        return ThemeColor;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColorService = /** @class */ (function () {
        /** Allow the color set to be provided in a forRoot function otherwise set it to the Keppel theme by default */
        function ColorService(_colorSet) {
            this._colorSet = _colorSet;
            /**
             * Set the default theme to the Keppel colorset
             */
            this._theme = this.getTheme(this._colorSet);
        }
        /**
         * Get a ThemeColor object from a color name
         * @param colorName The name of the color from the color palette
         */
        /**
         * Get a ThemeColor object from a color name
         * @param {?} colorName The name of the color from the color palette
         * @return {?}
         */
        ColorService.prototype.getColor = /**
         * Get a ThemeColor object from a color name
         * @param {?} colorName The name of the color from the color palette
         * @return {?}
         */
            function (colorName) {
                // get the matching ThemeColor from the active theme
                /** @type {?} */
                var themeColor = this._theme[this.resolveColorName(colorName)];
                // if there is not a match then throw an error
                if (!themeColor) {
                    throw new Error('Color not found: ' + colorName);
                }
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * Get the active color set
         */
        /**
         * Get the active color set
         * @return {?}
         */
        ColorService.prototype.getColorSet = /**
         * Get the active color set
         * @return {?}
         */
            function () {
                return this._colorSet;
            };
        /**
         * Define the current color set and produce a Theme from it
         */
        /**
         * Define the current color set and produce a Theme from it
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.setColorSet = /**
         * Define the current color set and produce a Theme from it
         * @param {?} colorSet
         * @return {?}
         */
            function (colorSet) {
                this._colorSet = colorSet;
                this._theme = this.getTheme(colorSet);
            };
        /**
         * Resolve a color value. This may be the name of a color from the color set
         * or it may simply be a hex or rgb(a) color value. This function will return
         * a CSS color value regardless of which one of these formats it is
         * @param value The color name, hex code or rgb(a) value to resolve
         * @returns If the color is the name of a color in the set, the `rgba` color will be returned, otherwise the original CSS value will be returned.
         */
        /**
         * Resolve a color value. This may be the name of a color from the color set
         * or it may simply be a hex or rgb(a) color value. This function will return
         * a CSS color value regardless of which one of these formats it is
         * @param {?} value The color name, hex code or rgb(a) value to resolve
         * @return {?} If the color is the name of a color in the set, the `rgba` color will be returned, otherwise the original CSS value will be returned.
         */
        ColorService.prototype.resolve = /**
         * Resolve a color value. This may be the name of a color from the color set
         * or it may simply be a hex or rgb(a) color value. This function will return
         * a CSS color value regardless of which one of these formats it is
         * @param {?} value The color name, hex code or rgb(a) value to resolve
         * @return {?} If the color is the name of a color in the set, the `rgba` color will be returned, otherwise the original CSS value will be returned.
         */
            function (value) {
                if (!value) {
                    return;
                }
                /** @type {?} */
                var colorName = this.resolveColorName(value);
                for (var color in this._theme) {
                    if (colorName === color.toLowerCase()) {
                        return this.getColor(colorName).toRgba();
                    }
                }
                return value;
            };
        /**
         * Converts a color name to an appropriate ColorSet name. For example
         * a color may be written in lower-camel-case, however color sets are in
         * kebab-case. This will convert to the appropriate naming format
         * @param colorName The color name to resolve
         */
        /**
         * Converts a color name to an appropriate ColorSet name. For example
         * a color may be written in lower-camel-case, however color sets are in
         * kebab-case. This will convert to the appropriate naming format
         * @param {?=} colorName The color name to resolve
         * @return {?}
         */
        ColorService.prototype.resolveColorName = /**
         * Converts a color name to an appropriate ColorSet name. For example
         * a color may be written in lower-camel-case, however color sets are in
         * kebab-case. This will convert to the appropriate naming format
         * @param {?=} colorName The color name to resolve
         * @return {?}
         */
            function (colorName) {
                if (colorName === void 0) {
                    colorName = '';
                }
                return colorName.replace(/\s+/g, '-').toLowerCase();
            };
        /** Determine if the current colorset has a specific color */
        /**
         * Determine if the current colorset has a specific color
         * @param {?} name
         * @return {?}
         */
        ColorService.prototype.colorExists = /**
         * Determine if the current colorset has a specific color
         * @param {?} name
         * @return {?}
         */
            function (name) {
                var _this = this;
                return !!Object.keys(this._theme).find(function (colorName) { return colorName === _this.resolveColorName(name); });
            };
        /** Create a theme from a colorset */
        /**
         * Create a theme from a colorset
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.getTheme = /**
         * Create a theme from a colorset
         * @param {?} colorSet
         * @return {?}
         */
            function (colorSet) {
                // create a new theme object
                /** @type {?} */
                var theme = {};
                // ensure we have a colorset
                if (!colorSet) {
                    colorSet = colorSets.keppel;
                }
                // iterate over each hex code and convert it to a theme color
                for (var color in colorSet.colorValueSet) {
                    theme[color] = ThemeColor.parse(colorSet.colorValueSet[color]);
                }
                return theme;
            };
        ColorService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ColorService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [COLOR_SET_TOKEN,] }] }
            ];
        };
        /** @nocollapse */ ColorService.ngInjectableDef = i0.defineInjectable({ factory: function ColorService_Factory() { return new ColorService(i0.inject(COLOR_SET_TOKEN, 8)); }, token: ColorService, providedIn: "root" });
        return ColorService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ContrastService = /** @class */ (function () {
        function ContrastService() {
        }
        /**
         * Calculate the contract ratio between two colors.
         * This uses the official WCAG Color Contrast Ratio
         * Algorithm: https://www.w3.org/TR/WCAG20-TECHS/G17.html
         */
        /**
         * Calculate the contract ratio between two colors.
         * This uses the official WCAG Color Contrast Ratio
         * Algorithm: https://www.w3.org/TR/WCAG20-TECHS/G17.html
         * @param {?} backgroundColor
         * @param {?} lightColor
         * @param {?} darkColor
         * @return {?}
         */
        ContrastService.prototype.getContrastColor = /**
         * Calculate the contract ratio between two colors.
         * This uses the official WCAG Color Contrast Ratio
         * Algorithm: https://www.w3.org/TR/WCAG20-TECHS/G17.html
         * @param {?} backgroundColor
         * @param {?} lightColor
         * @param {?} darkColor
         * @return {?}
         */
            function (backgroundColor, lightColor, darkColor) {
                // get a ThemeColor from the ColorPickerColor
                /** @type {?} */
                var themeColor = ThemeColor.parse(backgroundColor.toHex());
                /** @type {?} */
                var background = this.getLuminance(themeColor);
                /** @type {?} */
                var light = this.getLuminance(lightColor);
                /** @type {?} */
                var dark = this.getLuminance(darkColor);
                // determine the contrast for both black and white
                /** @type {?} */
                var whiteContrast = (light + 0.05) / (background + 0.05);
                /** @type {?} */
                var blackContrast = (background + 0.05) / (dark + 0.05);
                // return the color with the most contrast ratio
                return blackContrast > whiteContrast ? darkColor : lightColor;
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ContrastService.prototype.getLuminance = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                // normalize the colors
                /** @type {?} */
                var r = +color.getRed() / 255;
                /** @type {?} */
                var g = +color.getGreen() / 255;
                /** @type {?} */
                var b = +color.getBlue() / 255;
                // calculate the value required for each color component
                r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
                g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
                b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
                // return the luminance
                return (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
            };
        ContrastService.decorators = [
            { type: i0.Injectable }
        ];
        return ContrastService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColorContrastDirective = /** @class */ (function () {
        function ColorContrastDirective(_colorService, _contrastService) {
            this._colorService = _colorService;
            this._contrastService = _contrastService;
            /**
             * Store the light color as a ThemeColor object
             */
            this._lightColor = ThemeColor.parse('#fff');
            /**
             * Store the light color as a ThemeColor object
             */
            this._darkColor = ThemeColor.parse('#000');
        }
        Object.defineProperty(ColorContrastDirective.prototype, "uxColorContrast", {
            /**
             * Define the background color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: /**
             * Define the background color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             * @param {?} backgroundColor
             * @return {?}
             */ function (backgroundColor) {
                this._backgroundColor = ThemeColor.parse(this._colorService.resolve(backgroundColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "lightColor", {
            /**
             * Define the light color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: /**
             * Define the light color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             * @param {?} lightColor
             * @return {?}
             */ function (lightColor) {
                this._lightColor = ThemeColor.parse(this._colorService.resolve(lightColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "darkColor", {
            /**
             * Define the dark color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: /**
             * Define the dark color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             * @param {?} darkColor
             * @return {?}
             */ function (darkColor) {
                this._darkColor = ThemeColor.parse(this._colorService.resolve(darkColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "_color", {
            /** Determine the color to set based on the supplied parameters */
            get: /**
             * Determine the color to set based on the supplied parameters
             * @return {?}
             */ function () {
                return this._backgroundColor ? this._contrastService.getContrastColor(this._backgroundColor, this._lightColor, this._darkColor).toRgba() : null;
            },
            enumerable: true,
            configurable: true
        });
        ColorContrastDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxColorContrast]'
                    },] }
        ];
        /** @nocollapse */
        ColorContrastDirective.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: ContrastService }
            ];
        };
        ColorContrastDirective.propDecorators = {
            uxColorContrast: [{ type: i0.Input }],
            lightColor: [{ type: i0.Input }],
            darkColor: [{ type: i0.Input }],
            _color: [{ type: i0.HostBinding, args: ['style.color',] }]
        };
        return ColorContrastDirective;
    }());
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) {
                for (var p in b)
                    if (b.hasOwnProperty(p))
                        d[p] = b[p];
            };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                }
                catch (e) {
                    reject(e);
                }
            }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () {
                if (t[0] & 1)
                    throw t[1];
                return t[1];
            }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ACCESSIBILITY_OPTIONS_TOKEN = new i0.InjectionToken('ACCESSIBILITY_OPTIONS');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccessibilityOptionsService = /** @class */ (function () {
        /** Get the user specified options - but handle cases where they may not be specified */
        function AccessibilityOptionsService(_options) {
            if (_options === void 0) {
                _options = {};
            }
            this._options = _options;
            /**
             * Determine the default options
             */
            this._defaultOptions = {
                mouseFocusIndicator: false,
                touchFocusIndicator: false,
                keyboardFocusIndicator: true,
                programmaticFocusIndicator: false
            };
        }
        Object.defineProperty(AccessibilityOptionsService.prototype, "options", {
            /** Get the complete options populating unspecified options with the default values */
            get: /**
             * Get the complete options populating unspecified options with the default values
             * @return {?}
             */ function () {
                return __assign({}, this._defaultOptions, this._options);
            },
            enumerable: true,
            configurable: true
        });
        AccessibilityOptionsService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AccessibilityOptionsService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [ACCESSIBILITY_OPTIONS_TOKEN,] }] }
            ];
        };
        return AccessibilityOptionsService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var LocalFocusIndicatorOptions = /** @class */ (function () {
        function LocalFocusIndicatorOptions() {
        }
        return LocalFocusIndicatorOptions;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicator = /** @class */ (function () {
        function FocusIndicator(_element, _focusMonitor, _renderer, _options, _focusIndicatorOrigin) {
            this._element = _element;
            this._focusMonitor = _focusMonitor;
            this._renderer = _renderer;
            this._options = _options;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            /**
             * An observable to monitor the focus state
             */
            this.isFocused$ = new rxjs.BehaviorSubject(false);
            /**
             * An observable to monitor the focus origin
             */
            this.origin$ = new rxjs.Subject();
            /**
             * Remove all subscriptions on destroy
             */
            this._onDestroy = new rxjs.Subject();
            // check if the element is already being monitored
            if (!_element.classList.contains('ux-focus-indicator')) {
                this.initialise();
            }
        }
        Object.defineProperty(FocusIndicator.prototype, "isFocused", {
            /** Provide a convenience getter to allow access to focus state without a subscription */
            get: /**
             * Provide a convenience getter to allow access to focus state without a subscription
             * @return {?}
             */ function () {
                return this.isFocused$.value;
            },
            /** Apply a class when the item is focused */
            set: /**
             * Apply a class when the item is focused
             * @param {?} isFocused
             * @return {?}
             */ function (isFocused) {
                // update the class on the element
                isFocused ? this._renderer.addClass(this._element, 'ux-focus-indicator-active') :
                    this._renderer.removeClass(this._element, 'ux-focus-indicator-active');
                // emit the focus state
                this.isFocused$.next(isFocused);
            },
            enumerable: true,
            configurable: true
        });
        /** Setup the focus monitoring */
        /**
         * Setup the focus monitoring
         * @return {?}
         */
        FocusIndicator.prototype.initialise = /**
         * Setup the focus monitoring
         * @return {?}
         */
            function () {
                // add a class to the element to specify we are controlling the focus
                this._renderer.addClass(this._element, 'ux-focus-indicator');
                // watch for any changes to the focus state
                this._focusMonitor.monitor(this._element, this._options.checkChildren)
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(this.onFocusChange.bind(this));
            };
        /** Focus the element with a specific origin */
        /**
         * Focus the element with a specific origin
         * @param {?=} origin
         * @param {?=} options
         * @return {?}
         */
        FocusIndicator.prototype.focus = /**
         * Focus the element with a specific origin
         * @param {?=} origin
         * @param {?=} options
         * @return {?}
         */
            function (origin, options) {
                this._focusIndicatorOrigin.setOrigin(origin);
                this._element.focus(options);
            };
        /** Tear down the subscriptions */
        /**
         * Tear down the subscriptions
         * @return {?}
         */
        FocusIndicator.prototype.destroy = /**
         * Tear down the subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this.isFocused$.complete();
                this._focusMonitor.stopMonitoring(this._element);
            };
        /** Allow the options to be updates */
        /**
         * Allow the options to be updates
         * @param {?} options
         * @return {?}
         */
        FocusIndicator.prototype.setOptions = /**
         * Allow the options to be updates
         * @param {?} options
         * @return {?}
         */
            function (options) {
                this._options = __assign({}, this._options, options);
            };
        /** Monitor changes to an elements focus state */
        /**
         * Monitor changes to an elements focus state
         * @param {?} origin
         * @return {?}
         */
        FocusIndicator.prototype.onFocusChange = /**
         * Monitor changes to an elements focus state
         * @param {?} origin
         * @return {?}
         */
            function (origin) {
                // if the origin is null then we blurred
                if (origin === null) {
                    this.isFocused = false;
                    this.origin$.next(null);
                    return;
                }
                // get the origin if there is one
                /** @type {?} */
                var syntheticOrigin = this._focusIndicatorOrigin.getOrigin();
                // emit the origin
                this.origin$.next(syntheticOrigin || origin);
                switch (syntheticOrigin || origin) {
                    case 'mouse':
                        this.isFocused = this._options.mouseFocusIndicator;
                        break;
                    case 'touch':
                        this.isFocused = this._options.touchFocusIndicator;
                        break;
                    case 'keyboard':
                        this.isFocused = this._options.keyboardFocusIndicator;
                        break;
                    case 'program':
                        this.isFocused = this._options.programmaticFocusIndicator;
                        break;
                    default:
                        this.isFocused = false;
                }
            };
        return FocusIndicator;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicatorOriginService = /** @class */ (function () {
        function FocusIndicatorOriginService() {
        }
        /** Store the event source origin */
        /**
         * Store the event source origin
         * @param {?} origin
         * @return {?}
         */
        FocusIndicatorOriginService.prototype.setOrigin = /**
         * Store the event source origin
         * @param {?} origin
         * @return {?}
         */
            function (origin) {
                this._origin = origin;
            };
        /** Get the most recent event origin */
        /**
         * Get the most recent event origin
         * @return {?}
         */
        FocusIndicatorOriginService.prototype.getOrigin = /**
         * Get the most recent event origin
         * @return {?}
         */
            function () {
                // get the most recent origin if there is one
                /** @type {?} */
                var origin = this._origin;
                // we should clear the origin so this value doesn't cause issues with future focus events
                this._origin = null;
                return origin;
            };
        FocusIndicatorOriginService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ FocusIndicatorOriginService.ngInjectableDef = i0.defineInjectable({ factory: function FocusIndicatorOriginService_Factory() { return new FocusIndicatorOriginService(); }, token: FocusIndicatorOriginService, providedIn: "root" });
        return FocusIndicatorOriginService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicatorService = /** @class */ (function () {
        function FocusIndicatorService(_focusMonitor, _globalOptions, _focusIndicatorOrigin, _localOptions, rendererFactory) {
            this._focusMonitor = _focusMonitor;
            this._globalOptions = _globalOptions;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            this._localOptions = _localOptions;
            // programmatically create a renderer as it can't be injected into a service
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /** This is essentially just a factory method to prevent the user having to pass in focus monitor, renderer and global options each time */
        /**
         * This is essentially just a factory method to prevent the user having to pass in focus monitor, renderer and global options each time
         * @param {?} element
         * @param {?=} options
         * @return {?}
         */
        FocusIndicatorService.prototype.monitor = /**
         * This is essentially just a factory method to prevent the user having to pass in focus monitor, renderer and global options each time
         * @param {?} element
         * @param {?=} options
         * @return {?}
         */
            function (element, options) {
                if (options === void 0) {
                    options = __assign({}, this._globalOptions.options, this._localOptions, { checkChildren: false });
                }
                return new FocusIndicator(element, this._focusMonitor, this._renderer, __assign({}, this._globalOptions.options, this._localOptions, options), this._focusIndicatorOrigin);
            };
        FocusIndicatorService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        FocusIndicatorService.ctorParameters = function () {
            return [
                { type: a11y.FocusMonitor },
                { type: AccessibilityOptionsService },
                { type: FocusIndicatorOriginService },
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [ACCESSIBILITY_OPTIONS_TOKEN,] }] },
                { type: i0.RendererFactory2 }
            ];
        };
        return FocusIndicatorService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicatorDirective = /** @class */ (function () {
        function FocusIndicatorDirective(_elementRef, _focusIndicatorService, optionsService, _ngZone, localOptions) {
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this.optionsService = optionsService;
            this._ngZone = _ngZone;
            this.localOptions = localOptions;
            /**
             * Emit the latest focus state
             */
            this.indicator = new i0.EventEmitter();
            /**
             * Store a private reference for the checkChildren option
             */
            this._checkChildren = false;
            /**
             * Store all configuation options
             */
            this._options = new Map();
            /**
             * Unsubscribe on component destroy
             */
            this._onDestroy = new rxjs.Subject();
            // set the inital option values based on global options
            for (var option in (optionsService.options || {})) {
                this._options.set(option, optionsService.options[option]);
            }
            // set the inital option values based on local options (if there are any)
            for (var option in (localOptions || {})) {
                this._options.set(option, localOptions[option]);
            }
        }
        Object.defineProperty(FocusIndicatorDirective.prototype, "checkChildren", {
            /** Specify whether or not we should mark this element as having focus if a child is focused */
            set: /**
             * Specify whether or not we should mark this element as having focus if a child is focused
             * @param {?} checkChildren
             * @return {?}
             */ function (checkChildren) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                checkChildren = coercion.coerceBooleanProperty(checkChildren);
                if (checkChildren !== null && checkChildren !== undefined) {
                    this._checkChildren = checkChildren;
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "mouseFocusIndicator", {
            /** Indicate whether or not mouse events should cause the focus indicator to appear - will override any global setting */
            set: /**
             * Indicate whether or not mouse events should cause the focus indicator to appear - will override any global setting
             * @param {?} mouseFocusIndicator
             * @return {?}
             */ function (mouseFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                mouseFocusIndicator = coercion.coerceBooleanProperty(mouseFocusIndicator);
                if (mouseFocusIndicator !== null && mouseFocusIndicator !== undefined) {
                    this._options.set('mouseFocusIndicator', mouseFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "touchFocusIndicator", {
            /** Indicate whether or not touch events should cause the focus indicator to appear - will override any global setting */
            set: /**
             * Indicate whether or not touch events should cause the focus indicator to appear - will override any global setting
             * @param {?} touchFocusIndicator
             * @return {?}
             */ function (touchFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                touchFocusIndicator = coercion.coerceBooleanProperty(touchFocusIndicator);
                if (touchFocusIndicator !== null && touchFocusIndicator !== undefined) {
                    this._options.set('touchFocusIndicator', touchFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "keyboardFocusIndicator", {
            /** Indicate whether or not keyboard events should cause the focus indicator to appear - will override any global setting */
            set: /**
             * Indicate whether or not keyboard events should cause the focus indicator to appear - will override any global setting
             * @param {?} keyboardFocusIndicator
             * @return {?}
             */ function (keyboardFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                keyboardFocusIndicator = coercion.coerceBooleanProperty(keyboardFocusIndicator);
                if (keyboardFocusIndicator !== null && keyboardFocusIndicator !== undefined) {
                    this._options.set('keyboardFocusIndicator', keyboardFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "programmaticFocusIndicator", {
            /** Indicate whether or not programmatic events should cause the focus indicator to appear - will override any global setting */
            set: /**
             * Indicate whether or not programmatic events should cause the focus indicator to appear - will override any global setting
             * @param {?} programmaticFocusIndicator
             * @return {?}
             */ function (programmaticFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                programmaticFocusIndicator = coercion.coerceBooleanProperty(programmaticFocusIndicator);
                if (programmaticFocusIndicator !== null && programmaticFocusIndicator !== undefined) {
                    this._options.set('programmaticFocusIndicator', programmaticFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Setup the focus monitoring */
        /**
         * Setup the focus monitoring
         * @return {?}
         */
        FocusIndicatorDirective.prototype.ngOnInit = /**
         * Setup the focus monitoring
         * @return {?}
         */
            function () {
                var _this = this;
                // start the focus monitoring
                this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement, {
                    checkChildren: this._checkChildren,
                    mouseFocusIndicator: this._options.get('mouseFocusIndicator'),
                    touchFocusIndicator: this._options.get('touchFocusIndicator'),
                    keyboardFocusIndicator: this._options.get('keyboardFocusIndicator'),
                    programmaticFocusIndicator: this._options.get('programmaticFocusIndicator')
                });
                // subscribe to the focus state to emit an event on change
                this._focusIndicator.isFocused$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isFocused) {
                    // emit the latest value
                    _this._ngZone.run(function () { return _this.indicator.emit(isFocused); });
                });
            };
        /** Tear down the directive */
        /**
         * Tear down the directive
         * @return {?}
         */
        FocusIndicatorDirective.prototype.ngOnDestroy = /**
         * Tear down the directive
         * @return {?}
         */
            function () {
                if (this._focusIndicator) {
                    this._focusIndicator.destroy();
                }
                // unsubscribe from all observables
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Focus this element with a specific origin */
        /**
         * Focus this element with a specific origin
         * @param {?=} origin
         * @param {?=} options
         * @return {?}
         */
        FocusIndicatorDirective.prototype.focus = /**
         * Focus this element with a specific origin
         * @param {?=} origin
         * @param {?=} options
         * @return {?}
         */
            function (origin, options) {
                this._focusIndicator.focus(origin, options);
            };
        /** Update the focus indicator with the latest options */
        /**
         * Update the focus indicator with the latest options
         * @return {?}
         */
        FocusIndicatorDirective.prototype.setOptions = /**
         * Update the focus indicator with the latest options
         * @return {?}
         */
            function () {
                if (this._focusIndicator) {
                    this._focusIndicator.setOptions({
                        checkChildren: this._checkChildren,
                        mouseFocusIndicator: this._options.get('mouseFocusIndicator'),
                        touchFocusIndicator: this._options.get('touchFocusIndicator'),
                        keyboardFocusIndicator: this._options.get('keyboardFocusIndicator'),
                        programmaticFocusIndicator: this._options.get('programmaticFocusIndicator')
                    });
                }
            };
        FocusIndicatorDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFocusIndicator]',
                        exportAs: 'ux-focus-indicator'
                    },] }
        ];
        /** @nocollapse */
        FocusIndicatorDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: AccessibilityOptionsService },
                { type: i0.NgZone },
                { type: LocalFocusIndicatorOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        FocusIndicatorDirective.propDecorators = {
            checkChildren: [{ type: i0.Input }],
            mouseFocusIndicator: [{ type: i0.Input }],
            touchFocusIndicator: [{ type: i0.Input }],
            keyboardFocusIndicator: [{ type: i0.Input }],
            programmaticFocusIndicator: [{ type: i0.Input }],
            indicator: [{ type: i0.Output }]
        };
        return FocusIndicatorDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * This directive can be used to target specific elements based on their CSS
     * class so we can control when the focus shows. This will help prevent us
     * polluting the FocusIndicatorDirective with an lot of selectors.
     *
     * If the button has a uxFocusIndicator, uxMenuTriggerFor or uxMenuNavigationToggle directive applied we should skip this
     */
    var DefaultFocusIndicatorDirective = /** @class */ (function (_super) {
        __extends(DefaultFocusIndicatorDirective, _super);
        function DefaultFocusIndicatorDirective(elementRef, focusIndicatorService, optionsService, ngZone, localOptions) {
            var _this = _super.call(this, elementRef, focusIndicatorService, optionsService, ngZone, localOptions) || this;
            // Enable programmatic focus by default
            _this.programmaticFocusIndicator = true;
            return _this;
        }
        DefaultFocusIndicatorDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '.btn:not([uxFocusIndicator]):not([uxMenuNavigationToggle]):not([uxMenuTriggerFor]), a[href]:not([uxFocusIndicator]):not([uxMenuNavigationToggle]):not([uxMenuTriggerFor])',
                    },] }
        ];
        /** @nocollapse */
        DefaultFocusIndicatorDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: AccessibilityOptionsService },
                { type: i0.NgZone },
                { type: LocalFocusIndicatorOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        return DefaultFocusIndicatorDirective;
    }(FocusIndicatorDirective));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicatorOptionsDirective = /** @class */ (function () {
        function FocusIndicatorOptionsDirective(_options) {
            this._options = _options;
        }
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "mouseFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is clicked on. */
            set: /**
             * If `true`, this element will receive a focus indicator when the element is clicked on.
             * @param {?} mouseFocusIndicator
             * @return {?}
             */ function (mouseFocusIndicator) {
                this._options.mouseFocusIndicator = mouseFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "touchFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is touched. */
            set: /**
             * If `true`, this element will receive a focus indicator when the element is touched.
             * @param {?} touchFocusIndicator
             * @return {?}
             */ function (touchFocusIndicator) {
                this._options.touchFocusIndicator = touchFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "keyboardFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is focused using the keyboard. */
            set: /**
             * If `true`, this element will receive a focus indicator when the element is focused using the keyboard.
             * @param {?} keyboardFocusIndicator
             * @return {?}
             */ function (keyboardFocusIndicator) {
                this._options.keyboardFocusIndicator = keyboardFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "programmaticFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is programmatically focused. */
            set: /**
             * If `true`, this element will receive a focus indicator when the element is programmatically focused.
             * @param {?} programmaticFocusIndicator
             * @return {?}
             */ function (programmaticFocusIndicator) {
                this._options.programmaticFocusIndicator = programmaticFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        FocusIndicatorOptionsDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFocusIndicatorOptions]',
                        providers: [LocalFocusIndicatorOptions]
                    },] }
        ];
        /** @nocollapse */
        FocusIndicatorOptionsDirective.ctorParameters = function () {
            return [
                { type: LocalFocusIndicatorOptions, decorators: [{ type: i0.Self }] }
            ];
        };
        FocusIndicatorOptionsDirective.propDecorators = {
            mouseFocusIndicator: [{ type: i0.Input }],
            touchFocusIndicator: [{ type: i0.Input }],
            keyboardFocusIndicator: [{ type: i0.Input }],
            programmaticFocusIndicator: [{ type: i0.Input }]
        };
        return FocusIndicatorOptionsDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * When working with component host elements
     * we cannot apply directives, eg. FocusIndicatorOriginDirective
     * however we may still want the functionality to be applied to
     * the host element. This class allows the host element to become
     * a focus indicator origin
     */
    var /**
     * When working with component host elements
     * we cannot apply directives, eg. FocusIndicatorOriginDirective
     * however we may still want the functionality to be applied to
     * the host element. This class allows the host element to become
     * a focus indicator origin
     */ FocusIndicatorOrigin = /** @class */ (function () {
        function FocusIndicatorOrigin(_focusIndicatorOrigin, elementRef, renderer) {
            var _this = this;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            /**
             * Store all event handlers
             */
            this._handlers = [];
            // add event handlers
            this._handlers = [
                renderer.listen(elementRef.nativeElement, 'click', function () { return _this.onClick(); }),
                renderer.listen(elementRef.nativeElement, 'mousedown', function () { return _this.onMouseDown(); }),
                renderer.listen(elementRef.nativeElement, 'keydown', function () { return _this.onKeydown(); })
            ];
        }
        /** Remove all event handlers */
        /**
         * Remove all event handlers
         * @return {?}
         */
        FocusIndicatorOrigin.prototype.destroy = /**
         * Remove all event handlers
         * @return {?}
         */
            function () {
                this._handlers.forEach(function (handler) { return handler(); });
            };
        /**
         * @return {?}
         */
        FocusIndicatorOrigin.prototype.onMouseDown = /**
         * @return {?}
         */
            function () {
                this._isMouseEvent = true;
            };
        /**
         * @return {?}
         */
        FocusIndicatorOrigin.prototype.onClick = /**
         * @return {?}
         */
            function () {
                // if the click was triggered after a mousedown event then it is a keyboard event
                this._focusIndicatorOrigin.setOrigin(this._isMouseEvent ? 'mouse' : 'keyboard');
                // reset the mouse event flag
                this._isMouseEvent = false;
            };
        /**
         * @return {?}
         */
        FocusIndicatorOrigin.prototype.onKeydown = /**
         * @return {?}
         */
            function () {
                this._isMouseEvent = false;
                this._focusIndicatorOrigin.setOrigin('keyboard');
            };
        return FocusIndicatorOrigin;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIndicatorOriginDirective = /** @class */ (function () {
        function FocusIndicatorOriginDirective(focusOriginService, elementRef, renderer) {
            this._focusOrigin = new FocusIndicatorOrigin(focusOriginService, elementRef, renderer);
        }
        /**
         * @return {?}
         */
        FocusIndicatorOriginDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusOrigin.destroy();
            };
        FocusIndicatorOriginDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFocusIndicatorOrigin]',
                    },] }
        ];
        /** @nocollapse */
        FocusIndicatorOriginDirective.ctorParameters = function () {
            return [
                { type: FocusIndicatorOriginService },
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        return FocusIndicatorOriginDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusWithinDirective = /** @class */ (function () {
        /**
         * Note: We used to use @angular/cdk FocusMonitor here instead of manually listening
         * to focus blur events, however this was problematic as any child elements using the FocusMonitor,
         * eg: `uxFocusIndicator` which not get the correct `origin`, they will instead get a programmatic
         * origin even if it was clicked or focused via the keyboard.
         */
        function FocusWithinDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Emits when a child element gains focus
             */
            this.uxFocusWithin = new i0.EventEmitter();
            /**
             * Emits when a child element loses focus
             */
            this.uxBlurWithin = new i0.EventEmitter();
            // We need to listen in capture phase since focus events don't bubble.
            _elementRef.nativeElement.addEventListener('focus', this.onFocus.bind(this), true);
            _elementRef.nativeElement.addEventListener('blur', this.onBlur.bind(this), true);
        }
        /**
         * @return {?}
         */
        FocusWithinDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.removeEventListener('focus', this.onFocus.bind(this), true);
                this._elementRef.nativeElement.removeEventListener('blur', this.onBlur.bind(this), true);
            };
        /**
         * @return {?}
         */
        FocusWithinDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this.uxFocusWithin.emit();
            };
        /**
         * @return {?}
         */
        FocusWithinDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this.uxBlurWithin.emit();
            };
        FocusWithinDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFocusWithin],[uxBlurWithin]',
                    },] }
        ];
        /** @nocollapse */
        FocusWithinDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        FocusWithinDirective.propDecorators = {
            uxFocusWithin: [{ type: i0.Output }],
            uxBlurWithin: [{ type: i0.Output }]
        };
        return FocusWithinDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ManagedFocusContainerService = /** @class */ (function () {
        function ManagedFocusContainerService(rendererFactory) {
            this._containers = [];
            // programmatically create a renderer as it can't be injected into a service
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * Create or get an existing object which manages the tabindex of descendants.
         * @param element The element containing focusable descendants.
         * @param component The component requesting the managed focus container.
         */
        /**
         * Create or get an existing object which manages the tabindex of descendants.
         * @param {?} element The element containing focusable descendants.
         * @param {?} component The component requesting the managed focus container.
         * @return {?}
         */
        ManagedFocusContainerService.prototype.register = /**
         * Create or get an existing object which manages the tabindex of descendants.
         * @param {?} element The element containing focusable descendants.
         * @param {?} component The component requesting the managed focus container.
         * @return {?}
         */
            function (element, component) {
                // Only create a new instance if no other component has created a container on the same element
                /** @type {?} */
                var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
                if (!containerRef) {
                    containerRef = new ManagedFocusContainerWithReferences(new ManagedFocusContainer(element, this._renderer));
                    this._containers.push(containerRef);
                    // Start listening for focus
                    containerRef.container.register();
                }
                // Track references to dispose correctly
                if (component) {
                    containerRef.addReference(component);
                }
            };
        /**
         * Remove the container object. This will call `unregister` on the container if `component` is the last reference
         * to it.
         * @param element The element containing focusable descendants.
         * @param component The component requesting the managed focus container.
         */
        /**
         * Remove the container object. This will call `unregister` on the container if `component` is the last reference
         * to it.
         * @param {?} element The element containing focusable descendants.
         * @param {?} component The component requesting the managed focus container.
         * @return {?}
         */
        ManagedFocusContainerService.prototype.unregister = /**
         * Remove the container object. This will call `unregister` on the container if `component` is the last reference
         * to it.
         * @param {?} element The element containing focusable descendants.
         * @param {?} component The component requesting the managed focus container.
         * @return {?}
         */
            function (element, component) {
                // Remove the container's reference to the source component
                /** @type {?} */
                var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
                // technically this function can be called before the register function if ngOnDestroy runs before it
                // is fully initialized so we should stop here if there is no containRef.
                if (!containerRef) {
                    return;
                }
                containerRef.removeReference(component);
                if (!containerRef.isAlive()) {
                    // Last reference was removed, so unregister the listeners
                    containerRef.container.unregister();
                    // Clean up the reference tracking array
                    this._containers = this._containers.filter(function (c) { return c !== containerRef; });
                }
            };
        /**
         * Get an observable which can be used to determine when the element or one of its descendants has focus.
         * @param element The element containing focusable descendants.
         */
        /**
         * Get an observable which can be used to determine when the element or one of its descendants has focus.
         * @param {?} element The element containing focusable descendants.
         * @return {?}
         */
        ManagedFocusContainerService.prototype.hasFocus = /**
         * Get an observable which can be used to determine when the element or one of its descendants has focus.
         * @param {?} element The element containing focusable descendants.
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var container = this.getContainer(element);
                return container ? container.hasFocus$.asObservable() : null;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        ManagedFocusContainerService.prototype.getContainer = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
                return containerRef ? containerRef.container : null;
            };
        ManagedFocusContainerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ManagedFocusContainerService.ctorParameters = function () {
            return [
                { type: i0.RendererFactory2 }
            ];
        };
        return ManagedFocusContainerService;
    }());
    var ManagedFocusContainer = /** @class */ (function () {
        function ManagedFocusContainer(element, _renderer) {
            this.element = element;
            this._renderer = _renderer;
            /**
             * Whether the container or one of its descendants has focus.
             */
            this.hasFocus$ = new rxjs.BehaviorSubject(false);
            this._modifiedElements = [];
            this._unlisten = [];
        }
        /** Start managing the focus of child elements. */
        /**
         * Start managing the focus of child elements.
         * @return {?}
         */
        ManagedFocusContainer.prototype.register = /**
         * Start managing the focus of child elements.
         * @return {?}
         */
            function () {
                var _this = this;
                this._unlisten.push(this._renderer.listen(this.element, 'focusin', this.onFocusIn.bind(this)));
                this._unlisten.push(this._renderer.listen(this.element, 'focusout', this.onFocusOut.bind(this)));
                // Check if the container already has focus
                setTimeout(function () {
                    if (!_this.element.contains(document.activeElement)) {
                        _this.removeTabFocus();
                    }
                });
            };
        /** Stop managing the focus of child elements. */
        /**
         * Stop managing the focus of child elements.
         * @return {?}
         */
        ManagedFocusContainer.prototype.unregister = /**
         * Stop managing the focus of child elements.
         * @return {?}
         */
            function () {
                // Dispose the event handlers
                this._unlisten.forEach(function (unlisten) { return unlisten(); });
                this._unlisten = [];
                // Undo any tabindex modifications
                this.restoreTabFocus();
            };
        /**
         * @return {?}
         */
        ManagedFocusContainer.prototype.onFocusIn = /**
         * @return {?}
         */
            function () {
                this.restoreTabFocus();
            };
        /**
         * @return {?}
         */
        ManagedFocusContainer.prototype.onFocusOut = /**
         * @return {?}
         */
            function () {
                this.removeTabFocus();
            };
        /**
         * @return {?}
         */
        ManagedFocusContainer.prototype.removeTabFocus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.hasFocus$.next(false);
                // Clear the list of affected elements
                this._modifiedElements = [];
                // Get all focusable children
                /** @type {?} */
                var focusable = this.element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                // Remove focusable children from the tab ring
                Array.from(focusable).forEach(function (element) {
                    /** @type {?} */
                    var originalTabIndex = element.getAttribute('tabindex');
                    _this._renderer.setAttribute(element, 'tabindex', '-1');
                    _this._modifiedElements.push({
                        element: element,
                        tabindex: originalTabIndex
                    });
                });
            };
        /**
         * @return {?}
         */
        ManagedFocusContainer.prototype.restoreTabFocus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.hasFocus$.next(true);
                // Restore tab focus ability by removing the custom `tabindex` attribute
                this._modifiedElements.forEach(function (elementInfo) {
                    if (elementInfo.tabindex === null) {
                        _this._renderer.removeAttribute(elementInfo.element, 'tabindex');
                    }
                    else {
                        _this._renderer.setAttribute(elementInfo.element, 'tabindex', elementInfo.tabindex);
                    }
                });
                // Clear the list of affected elements
                this._modifiedElements = [];
            };
        return ManagedFocusContainer;
    }());
    var ManagedFocusContainerWithReferences = /** @class */ (function () {
        function ManagedFocusContainerWithReferences(container) {
            this.container = container;
            this._components = [];
        }
        /**
         * @param {?} component
         * @return {?}
         */
        ManagedFocusContainerWithReferences.prototype.addReference = /**
         * @param {?} component
         * @return {?}
         */
            function (component) {
                this._components.push(component);
            };
        /**
         * @param {?} component
         * @return {?}
         */
        ManagedFocusContainerWithReferences.prototype.removeReference = /**
         * @param {?} component
         * @return {?}
         */
            function (component) {
                this._components = this._components.filter(function (c) { return c !== component; });
            };
        /**
         * @return {?}
         */
        ManagedFocusContainerWithReferences.prototype.isAlive = /**
         * @return {?}
         */
            function () {
                return this._components.length > 0;
            };
        return ManagedFocusContainerWithReferences;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ManagedFocusContainerDirective = /** @class */ (function () {
        function ManagedFocusContainerDirective(_elementRef, _managedFocusContainerService) {
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
        }
        /**
         * @return {?}
         */
        ManagedFocusContainerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
            };
        /**
         * @return {?}
         */
        ManagedFocusContainerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
            };
        ManagedFocusContainerDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxManagedFocusContainer]'
                    },] }
        ];
        /** @nocollapse */
        ManagedFocusContainerDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ManagedFocusContainerService }
            ];
        };
        return ManagedFocusContainerDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SplitterAccessibilityDirective = /** @class */ (function () {
        function SplitterAccessibilityDirective(_elementRef, _renderer, _platform, _splitter, _focusIndicatorService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._platform = _platform;
            this._splitter = _splitter;
            this._focusIndicatorService = _focusIndicatorService;
            /**
             * Emit an event whenever the gutter is moved using the keyboard
             */
            this.gutterKeydown = new i0.EventEmitter();
            /**
             * Store all the gutter elements
             */
            this._gutters = [];
            /**
             * Teardown our observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Store references to all focus indicators
             */
            this._focusIndicators = [];
            // update aria values when the a gutter is dragged
            _splitter.dragProgress$
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.updateGutterAttributes(); });
        }
        /** Once initialised make the gutters accessible */
        /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngAfterViewInit = /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
            function () {
                var _this = this;
                // find the gutters
                this.onGutterChange();
                // if the number of split areas change then update the gutters and apply aria properties
                this.areas.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.onGutterChange(); });
                // we can't know when additional split-gutters appear using ContentChildren as the directive class is not exported and selector doesn't work - use mutation observer instead
                if (common.isPlatformBrowser(this._platform)) {
                    // create the mutation observer
                    this._observer = new MutationObserver(function () { return _this.onGutterChange(); });
                    // begin observing the child nodes
                    this._observer.observe(this._elementRef.nativeElement, { childList: true });
                }
            };
        /** Destroy all observables and observers */
        /**
         * Destroy all observables and observers
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngOnDestroy = /**
         * Destroy all observables and observers
         * @return {?}
         */
            function () {
                if (this._observer) {
                    this._observer.disconnect();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
                // destroy all existing focus indicators
                this._focusIndicators.forEach(function (indicator) { return indicator.destroy(); });
            };
        /** We should focus the gutter when it is clicked */
        /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onClick = /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    (( /** @type {?} */(event.target))).parentElement.focus();
                }
            };
        /** Find all the gutters and set their attributes */
        /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onGutterChange = /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
            function () {
                var _this = this;
                // destroy all existing focus indicators
                this._focusIndicators.forEach(function (indicator) { return indicator.destroy(); });
                // reset the array
                this._focusIndicators = [];
                // get the new gutter elements
                this._gutters = this.getGutters();
                // monitor the focus of each gutter
                this._gutters.forEach(function (gutter) { return _this._focusIndicators.push(_this._focusIndicatorService.monitor(gutter)); });
                // apply all required accessibility attributes to the gutter elements
                this.setGutterAttributes();
            };
        /** Get all the gutter elements */
        /**
         * Get all the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getGutters = /**
         * Get all the gutter elements
         * @return {?}
         */
            function () {
                // This function uses DOM accessing properties - which won't work if server side rendered
                if (common.isPlatformBrowser(this._platform)) {
                    /** @type {?} */
                    var gutters = [];
                    for (var idx = 0; idx < this._elementRef.nativeElement.children.length; idx++) {
                        /** @type {?} */
                        var node = this._elementRef.nativeElement.children.item(idx);
                        if (this.isSplitterGutter(( /** @type {?} */(node)))) {
                            gutters.push(( /** @type {?} */(node)));
                        }
                    }
                    return gutters;
                }
                return [];
            };
        /** Set the appropriate attributes on the gutter elements */
        /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterAttributes = /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
            function () {
                var _this = this;
                // apply attribute to every gutter
                this._gutters.forEach(function (gutter) {
                    // apply the separator role
                    _this._renderer.setAttribute(gutter, 'role', 'separator');
                    // make the gutters tabbable
                    _this._renderer.setAttribute(gutter, 'tabindex', '0');
                    // set the value now aria property
                    _this.updateGutterAttributes();
                });
            };
        /** Apply the aria attribute values */
        /**
         * Apply the aria attribute values
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.updateGutterAttributes = /**
         * Apply the aria attribute values
         * @return {?}
         */
            function () {
                var _this = this;
                // update the value now properties of each gutter
                this._gutters.forEach(function (gutter, idx) {
                    _this.setGutterValueNow(gutter, idx);
                    _this.setGutterValueMin(gutter, idx);
                    _this.setGutterValueMax(gutter, idx);
                });
            };
        /** Apply the value now aria attribute */
        /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueNow = /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                /** @type {?} */
                var area = this._splitter.displayedAreas[index];
                // indicate the size
                this._renderer.setAttribute(gutter, 'aria-valuenow', "" + Math.round(area.size));
            };
        /** Apply the value min aria attribute */
        /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMin = /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                /** @type {?} */
                var area = this.areas.toArray()[index];
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemin', "" + Math.round(area.minSize));
            };
        /** Apply the value max aria attribute */
        /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMax = /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get every other splitter area
                /** @type {?} */
                var availableSize = this.areas
                    .filter(function (_area, idx) { return index !== idx; })
                    .reduce(function (total, area) { return total + area.minSize; }, 0);
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemax', "" + (100 - Math.round(availableSize)));
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    this.gutterKeydown.emit(event);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onIncreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    this.setGutterPosition(( /** @type {?} */(event.target)), -1);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onDecreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    this.setGutterPosition(( /** @type {?} */(event.target)), 1);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onHomeKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    // get the affected panels
                    /** @type {?} */
                    var areas = this.getAreasFromGutter(( /** @type {?} */(event.target)));
                    // set the previous area to it's minimum size
                    /** @type {?} */
                    var delta = areas.previous.size - areas.previous.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(( /** @type {?} */(event.target)), delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onEndKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(( /** @type {?} */(event.target)))) {
                    // get the affected panels
                    /** @type {?} */
                    var areas = this.getAreasFromGutter(( /** @type {?} */(event.target)));
                    // set the next area to it's minimum size
                    /** @type {?} */
                    var delta = areas.next.size - areas.next.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(( /** @type {?} */(event.target)), -delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /** Determine if an element is a gutter */
        /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.isSplitterGutter = /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.classList.contains('as-split-gutter') || element.classList.contains('as-split-gutter-icon');
            };
        /** Update the gutter position */
        /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterPosition = /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
            function (gutter, delta) {
                // get the affected panels
                /** @type {?} */
                var areas = this.getAreasFromGutter(gutter);
                // ensure we can perform the resize
                if (areas.previous.size - delta < areas.previous.minSize || areas.next.size + delta < areas.next.minSize) {
                    return;
                }
                // perform the resize
                areas.previous.size -= delta;
                areas.next.size += delta;
                // update the splitter - this is a private method but we need to call it
                (( /** @type {?} */(this._splitter))).refreshStyleSizes();
                // update the gutter aria values
                this.updateGutterAttributes();
            };
        /** Get the split areas associated with a given gutter */
        /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getAreasFromGutter = /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
            function (gutter) {
                /** @type {?} */
                var index = this._gutters.indexOf(gutter);
                return {
                    previous: this._splitter.displayedAreas[index],
                    next: this._splitter.displayedAreas[index + 1]
                };
            };
        SplitterAccessibilityDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'as-split'
                    },] }
        ];
        /** @nocollapse */
        SplitterAccessibilityDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: angularSplit.SplitComponent },
                { type: FocusIndicatorService }
            ];
        };
        SplitterAccessibilityDirective.propDecorators = {
            gutterKeydown: [{ type: i0.Output }],
            areas: [{ type: i0.ContentChildren, args: [angularSplit.SplitAreaDirective,] }],
            onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
            onIncreaseKey: [{ type: i0.HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.ArrowRight', ['$event'],] }],
            onDecreaseKey: [{ type: i0.HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: i0.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            onHomeKey: [{ type: i0.HostListener, args: ['keydown.Home', ['$event'],] }],
            onEndKey: [{ type: i0.HostListener, args: ['keydown.End', ['$event'],] }]
        };
        return SplitterAccessibilityDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabbableListService = /** @class */ (function () {
        function TabbableListService() {
            /**
             * Indicate is this is being using on a hierarchichal set of items
             */
            this.hierarchy = false;
            /**
             * Determine if we all the alt key
             */
            this.allowAltModifier = true;
            /**
             * Determine if we all the ctrl key
             */
            this.allowCtrlModifier = true;
            /**
             * Determine if we allow the Home/End keys
             */
            this.allowBoundaryKeys = false;
            /**
             * Determine if we should scroll the item into view on focus
             */
            this.shouldScrollInView = true;
            /**
             * Indicate if we should refocus an item on QueryList change - for use within virtual lists
             */
            this.shouldFocusOnChange = true;
            /**
             * Emit whenever focus does not change but tabindexes have
             */
            this.onTabIndexChange = new rxjs.Subject();
            /**
             * Determine if focus is currently within the tabbable list
             */
            this.isFocused = false;
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        TabbableListService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this.onTabIndexChange.complete();
            };
        /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
        TabbableListService.prototype.initialize = /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
            function (items, direction, wrap) {
                var _this = this;
                // store the items
                this._items = items;
                // create the new focus key manager
                this.focusKeyManager = new a11y.FocusKeyManager(items);
                // set the direction of the list
                direction === 'vertical' ? this.focusKeyManager.withVerticalOrientation() : this.focusKeyManager.withHorizontalOrientation('ltr');
                this._direction = direction;
                // enable wrapping if required
                if (wrap) {
                    this.focusKeyManager.withWrap();
                }
                // make sure the first item in the list is tabbable
                this.setFirstItemTabbable();
                // call the init function on each item
                this._items.forEach(function (item) { return item.onInit(); });
                // if the list changes we need to ensure there is always at least one tabbable item
                this._items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    // call the on init function on any new items
                    _this._items.filter(function (item) { return !item.initialized; }).forEach(function (item) { return item.onInit(); });
                    // ensure we update the tab indexes
                    _this.onTabIndexChange.next();
                    // ensure there is at least one item tabbable at all times
                    _this.ensureTabbableItem();
                });
            };
        /** Give and item focus or just make it the current tabbable item */
        /**
         * Give and item focus or just make it the current tabbable item
         * @param {?} item
         * @param {?=} updateIndexOnly
         * @return {?}
         */
        TabbableListService.prototype.activate = /**
         * Give and item focus or just make it the current tabbable item
         * @param {?} item
         * @param {?=} updateIndexOnly
         * @return {?}
         */
            function (item, updateIndexOnly) {
                if (updateIndexOnly === void 0) {
                    updateIndexOnly = false;
                }
                if (!item) {
                    return;
                }
                // get the item index
                /** @type {?} */
                var index = this._items.toArray().indexOf(item);
                this.activateItemAtIndex(index, updateIndexOnly);
            };
        /** Give and item focus or just make it the current tabbable item */
        /**
         * Give and item focus or just make it the current tabbable item
         * @param {?} index
         * @param {?=} updateIndexOnly
         * @return {?}
         */
        TabbableListService.prototype.activateItemAtIndex = /**
         * Give and item focus or just make it the current tabbable item
         * @param {?} index
         * @param {?=} updateIndexOnly
         * @return {?}
         */
            function (index, updateIndexOnly) {
                if (updateIndexOnly === void 0) {
                    updateIndexOnly = false;
                }
                // if we only want to update the index
                if (updateIndexOnly) {
                    return this.updateActiveItemIndex(index);
                }
                // update active the item only if it is not already active
                if (this.focusKeyManager.activeItemIndex !== index) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        TabbableListService.prototype.isItemActive = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // if this is called before the items have been set then do nothing
                if (!this._items) {
                    return false;
                }
                // find the index of the item
                /** @type {?} */
                var index = this._items.toArray().findIndex(function (_item) { return _item.id === item.id; });
                // check if the item is active (we check against index as it can be updated without setting the activeItem)
                return this.focusKeyManager && this.focusKeyManager.activeItemIndex === index;
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.setFirstItemTabbable = /**
         * @return {?}
         */
            function () {
                // find the first item that is not disabled
                /** @type {?} */
                var first = this._items.toArray().findIndex(function (item) { return !item.disabled; });
                if (first !== -1) {
                    this.updateActiveItemIndex(first);
                }
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.ensureTabbableItem = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // check to see if any item is tabbable
                /** @type {?} */
                var active = this._items.find(function (item) { return _this.isItemActive(item); });
                if (!active) {
                    this.setFirstItemTabbable();
                }
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._items) {
                    return;
                }
                // find the item in the list with a tab index
                /** @type {?} */
                var index = this._items.toArray().findIndex(function (item) { return _this.isItemActive(item); });
                // if an item was found then focus it
                if (index !== -1) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
        TabbableListService.prototype.onKeydown = /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
            function (source, event) {
                // prevent anything happening when modifier keys are pressed if they have been disabled
                if (!this.allowAltModifier && event.altKey || !this.allowCtrlModifier && event.ctrlKey) {
                    return;
                }
                this.focusKeyManager.onKeydown(event);
                // if the key is a boundary key and boundary keys are enabled
                if (this.allowBoundaryKeys) {
                    switch (event.which) {
                        case keycodes.HOME:
                            this.focusKeyManager.setFirstItemActive();
                            event.preventDefault();
                            break;
                        case keycodes.END:
                            this.focusKeyManager.setLastItemActive();
                            event.preventDefault();
                            break;
                    }
                }
                if (this.hierarchy) {
                    if ((this._direction === 'horizontal' && event.keyCode === keycodes.DOWN_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.RIGHT_ARROW)) {
                        source.keyboardExpanded$.next(true);
                    }
                    else if ((this._direction === 'horizontal' && event.keyCode === keycodes.UP_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.LEFT_ARROW)) {
                        if (source.children.length > 0 && source.expanded) {
                            source.keyboardExpanded$.next(false);
                        }
                        else if (source.parent) {
                            source.parent.keyboardExpanded$.next(false);
                        }
                    }
                }
            };
        /**
         * @param {?} list
         * @return {?}
         */
        TabbableListService.prototype.sortItemsByHierarchy = /**
         * @param {?} list
         * @return {?}
         */
            function (list) {
                /** @type {?} */
                var topLevel = [];
                // Populating children - clear previously generated collection
                list.forEach(function (item) { return item.children = []; });
                // Populating children - map from child -> parent relationship
                list.forEach(function (item) {
                    if (item.parent) {
                        item.parent.children.push(item);
                    }
                    else {
                        topLevel.push(item);
                    }
                });
                // Flatten the tree to produce the cursor key order
                return this.flattenHierarchy(topLevel);
            };
        /**
         * In a uxVirtualFor list cells can be resused. This means that when we scroll
         * the data associated with a given element may change and not the actual elements. If only the data changes
         * then the QueryList will not emit a change so we may show focus indicatator on the element that previously displayed
         * the correct data but no longer does.
         *
         * We need to handle this correctly here. We already have keys implements to handle virtual elements so we can check
         * if a key changes and use it to update the focused item even if the QueryList doesn't inform us that we have changed.
         */
        /**
         * In a uxVirtualFor list cells can be resused. This means that when we scroll
         * the data associated with a given element may change and not the actual elements. If only the data changes
         * then the QueryList will not emit a change so we may show focus indicatator on the element that previously displayed
         * the correct data but no longer does.
         *
         * We need to handle this correctly here. We already have keys implements to handle virtual elements so we can check
         * if a key changes and use it to update the focused item even if the QueryList doesn't inform us that we have changed.
         * @param {?} previousKey
         * @param {?} origin
         * @return {?}
         */
        TabbableListService.prototype.itemReferenceChange = /**
         * In a uxVirtualFor list cells can be resused. This means that when we scroll
         * the data associated with a given element may change and not the actual elements. If only the data changes
         * then the QueryList will not emit a change so we may show focus indicatator on the element that previously displayed
         * the correct data but no longer does.
         *
         * We need to handle this correctly here. We already have keys implements to handle virtual elements so we can check
         * if a key changes and use it to update the focused item even if the QueryList doesn't inform us that we have changed.
         * @param {?} previousKey
         * @param {?} origin
         * @return {?}
         */
            function (previousKey, origin) {
                // find the item that now has the previously focused key
                /** @type {?} */
                var item = this.getItemByKey(previousKey);
                // if no key was found then we should ensure there is a tabbable item
                if (!item) {
                    return this.ensureTabbableItem();
                }
                // get the item index
                /** @type {?} */
                var index = this._items.toArray().indexOf(item);
                // activate the item without side effects
                this.updateActiveItemIndex(index);
                // focus the item with the same origin that it previously had
                item.focusWithOrigin(origin);
            };
        /** Update the active item without causing focus */
        /**
         * Update the active item without causing focus
         * @param {?} index
         * @return {?}
         */
        TabbableListService.prototype.updateActiveItemIndex = /**
         * Update the active item without causing focus
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this.focusKeyManager.updateActiveItemIndex(index);
                this.onTabIndexChange.next();
            };
        /** Determine if there is an item with a tabindex of 0 */
        /**
         * Determine if there is an item with a tabindex of 0
         * @return {?}
         */
        TabbableListService.prototype.hasTabbableItem = /**
         * Determine if there is an item with a tabindex of 0
         * @return {?}
         */
            function () {
                return this.focusKeyManager && this.focusKeyManager.activeItemIndex >= 0;
            };
        /**
         * @param {?} key
         * @return {?}
         */
        TabbableListService.prototype.getItemByKey = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this._items.find(function (item) { return item.key === key; });
            };
        /**
         * @param {?} items
         * @return {?}
         */
        TabbableListService.prototype.flattenHierarchy = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                /** @type {?} */
                var flatList = [];
                items.forEach(function (item) {
                    item.children.sort(function (a, b) { return a.rank - b.rank; });
                    flatList.push.apply(flatList, __spread([item], _this.flattenHierarchy(item.children)));
                });
                return flatList;
            };
        TabbableListService.decorators = [
            { type: i0.Injectable }
        ];
        return TabbableListService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    /** @type {?} */
    var uniqueKey = 0;
    var TabbableListItemDirective = /** @class */ (function () {
        function TabbableListItemDirective(_tabbableList, _elementRef, 
        /** Access the service to programmatically control focus indicators */
        focusIndicatorService, _managedFocusContainerService, _platform, _changeDetector, _focusOriginService, _renderer) {
            var _this = this;
            this._tabbableList = _tabbableList;
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            this._platform = _platform;
            this._changeDetector = _changeDetector;
            this._focusOriginService = _focusOriginService;
            this._renderer = _renderer;
            this.rank = 0;
            /**
             * Indicate if this item is disabled
             */
            this.disabled = false;
            /**
             * Indicate if the item is expanded if used as a hierarchical item.
             */
            this.expanded = false;
            /**
             * Emit when the expanded state changes.
             */
            this.expandedChange = new i0.EventEmitter();
            /**
             * Emit when the element receives focus via the tabbable list.
             */
            this.activated = new i0.EventEmitter();
            /**
             * Give each tabbable item a unique id
             */
            this.id = nextId++;
            /**
             * Each item in the list needs to be initialised by the service. When the item QueryList changes this is used to identify which items previously existed and which are new
             */
            this.initialized = false;
            /**
             * Store a list of all child tabbable items
             */
            this.children = [];
            /**
             * Emit whenever the expanded state changes
             */
            this.keyboardExpanded$ = new rxjs.Subject();
            /**
             * Automatically unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Store a default key to use if one is not provided
             */
            this._defaultKey = "tabbable-list-key-" + uniqueKey++;
            /**
             * Determine if this element has a focus indicator visible
             */
            this._focusOrigin = null;
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
            // store the most current focus origin
            this._focusIndicator.origin$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (origin) { return _this._focusOrigin = origin; });
            // watch for changes to tabindexes
            this._tabbableList.onTabIndexChange.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.setTabIndex(); });
            this.keyboardExpanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                // Emit event which may alter the DOM
                _this.expandedChange.emit(expanded);
                // Activate the appropriate item
                if (expanded) {
                    if (_this.children.length > 0) {
                        _this._tabbableList.activate(_this.children[0]);
                    }
                }
                else {
                    _this._tabbableList.activate(_this);
                }
            });
        }
        Object.defineProperty(TabbableListItemDirective.prototype, "key", {
            get: /**
             * @return {?}
             */ function () {
                return this._key || this._defaultKey;
            },
            /** Provide a unique key to help identify items when used in a virtual list */
            set: /**
             * Provide a unique key to help identify items when used in a virtual list
             * @param {?} key
             * @return {?}
             */ function (key) {
                // store the previous key
                /** @type {?} */
                var previousKey = this._key;
                // check if the key has changed eg. via cell reuse
                /** @type {?} */
                var didChangeRef = previousKey && key !== previousKey;
                // update the current key
                this._key = key;
                // if this element was the previously tabbable item then update the reference
                if (didChangeRef && this.isTabbable()) {
                    // allow the virtual scroll to update
                    this._changeDetector.detectChanges();
                    // this item should no longer be tabbable
                    this._tabbableList.focusKeyManager.updateActiveItemIndex(-1);
                    // store the focus origin before we blur
                    /** @type {?} */
                    var origin_1 = this._focusOrigin;
                    // blur this item
                    this._elementRef.nativeElement.blur();
                    // update the reference
                    this._tabbableList.itemReferenceChange(previousKey, origin_1);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListItemDirective.prototype, "tabindex", {
            get: /**
             * @return {?}
             */ function () {
                return this._tabbableList.isItemActive(this) ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.onInit = /**
         * @return {?}
         */
            function () {
                this.initialized = true;
                // Watch for focus within the container element and manage tabindex of descendants
                this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
                // ensure the tab index is initially set
                this.setTabIndex();
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // check if this is the currently focused item - if so we need to make another item tabbable
                if (this.tabindex === 0) {
                    this._tabbableList.setFirstItemTabbable();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
                this._focusIndicator.destroy();
                this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // check if there are currently any items that are tabbable
                /** @type {?} */
                var hasTabbableItem = this._tabbableList.hasTabbableItem();
                // determine the focus origin
                /** @type {?} */
                var origin = hasTabbableItem ? this._focusOriginService.getOrigin() || 'keyboard' : 'keyboard';
                // apply focus to the element
                this.focusWithOrigin(origin, !this._tabbableList.shouldScrollInView);
                // ensure the focus key manager updates the active item correctly
                this._tabbableList.activate(this, hasTabbableItem);
                // emit the focus event
                this.activated.emit(origin);
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                // if this item is not currently focused in the focusKeyManager set it as the active item
                if (!this._tabbableList.isItemActive(this)) {
                    this._tabbableList.activate(this, true);
                }
                // also inform the service that an item within the list is now focused
                this._tabbableList.isFocused = true;
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                // if this is the current active item and it is blurred then update the isFocused state
                if (this._tabbableList.isItemActive(this)) {
                    this._tabbableList.isFocused = false;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabbableListItemDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._tabbableList.onKeydown(this, event);
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.getFocused = /**
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement === document.activeElement;
            };
        /** We can programmatically focus an element but may want a different origin than 'programmatic' */
        /**
         * We can programmatically focus an element but may want a different origin than 'programmatic'
         * @param {?} origin
         * @param {?=} preventScroll
         * @return {?}
         */
        TabbableListItemDirective.prototype.focusWithOrigin = /**
         * We can programmatically focus an element but may want a different origin than 'programmatic'
         * @param {?} origin
         * @param {?=} preventScroll
         * @return {?}
         */
            function (origin, preventScroll) {
                if (preventScroll === void 0) {
                    preventScroll = true;
                }
                if (origin) {
                    /** @type {?} */
                    var scrollTop = this._tabbableList.containerRef.scrollTop;
                    // focus the item with a given origin
                    this._focusIndicator.focus(origin, { preventScroll: preventScroll });
                    // IE and Firefox don't support prevent scroll
                    if (preventScroll && !this._platform.WEBKIT) {
                        this._tabbableList.containerRef.scrollTop = scrollTop;
                    }
                }
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.isTabbable = /**
         * @return {?}
         */
            function () {
                return this.tabindex === 0;
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.setTabIndex = /**
         * @return {?}
         */
            function () {
                // update the tabindex attribute
                this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', this.tabindex.toString());
            };
        TabbableListItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTabbableListItem]',
                        exportAs: 'ux-tabbable-list-item'
                    },] }
        ];
        /** @nocollapse */
        TabbableListItemDirective.ctorParameters = function () {
            return [
                { type: TabbableListService },
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: ManagedFocusContainerService },
                { type: platform.Platform },
                { type: i0.ChangeDetectorRef },
                { type: FocusIndicatorOriginService },
                { type: i0.Renderer2 }
            ];
        };
        TabbableListItemDirective.propDecorators = {
            parent: [{ type: i0.Input }],
            rank: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            key: [{ type: i0.Input }],
            expandedChange: [{ type: i0.Output }],
            activated: [{ type: i0.Output }],
            onFocus: [{ type: i0.HostListener, args: ['focus',] }, { type: i0.HostListener, args: ['click',] }],
            onBlur: [{ type: i0.HostListener, args: ['blur',] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return TabbableListItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabbableListDirective = /** @class */ (function () {
        function TabbableListDirective(_tabbableList, 
        /** Access the native dom element */
        elementRef) {
            this._tabbableList = _tabbableList;
            /**
             * Determine whether the up/down arrows should be used or the left/right arrows
             */
            this.direction = 'vertical';
            /**
             * Indicate whether or not focus should loop back to the first element after the last
             */
            this.wrap = true;
            /**
             * Indicate whether or not the first item should receive focus on show - useful for modals and popovers
             */
            this.focusOnShow = false;
            /**
             * Indicate whether or not focus should be returned to the previous element (only applicable when using focusOnShow)
             */
            this.returnFocus = false;
            /**
             * Unsubscribe from all observables automatically on destroy
             */
            this._onDestroy = new rxjs.Subject();
            // store a reference to the container element
            this._tabbableList.containerRef = elementRef.nativeElement;
        }
        Object.defineProperty(TabbableListDirective.prototype, "hierarchy", {
            /** Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property. */
            set: /**
             * Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property.
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.hierarchy = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowAltModifier", {
            /** Prevent keyboard interaction when alt modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when alt modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowAltModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowCtrlModifier", {
            /** Prevent keyboard interaction when ctrl modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when ctrl modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowCtrlModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowBoundaryKeys", {
            /** Focus the first or last item when Home or End keys are pressed */
            set: /**
             * Focus the first or last item when Home or End keys are pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowBoundaryKeys = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "focusKeyManager", {
            get: /**
             * @return {?}
             */ function () {
                return this._tabbableList.focusKeyManager;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // store the currently focused element
                this._focusedElement = ( /** @type {?} */(document.activeElement));
                this._orderedItems = new i0.QueryList();
                if (this._tabbableList.hierarchy) {
                    // Sort items in a hierarchy
                    this._orderedItems.reset(this._tabbableList.sortItemsByHierarchy(this.items));
                    // Ensure that the child items remain sorted
                    this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                        _this._orderedItems.reset(_this._tabbableList.sortItemsByHierarchy(_this.items));
                        _this._orderedItems.notifyOnChanges();
                    });
                }
                else {
                    // Items are already in order
                    this._orderedItems = this.items;
                    // Ensure we reselect a selected item after the querylist has changed
                    this.items.changes.pipe(operators.filter(function () { return _this._tabbableList.shouldFocusOnChange && _this._tabbableList.isFocused; }), operators.takeUntil(this._onDestroy))
                        .subscribe(function (items) {
                        // check if an item is currently focused
                        /** @type {?} */
                        var activeItem = _this._tabbableList.focusKeyManager.activeItem;
                        // restore the selected item if there was one and it is still visible
                        if (activeItem) {
                            // find the matching index
                            /** @type {?} */
                            var index = items.toArray().findIndex(function (item) { return item.key === activeItem.key; });
                            // if the item is still in the list we want to focus it
                            if (index > -1) {
                                // however we are refocusing an item that was focused so we dont want to scroll into view again as this can prevent wheel scrolling
                                _this._tabbableList.shouldScrollInView = false;
                                // refocus the item again
                                _this._tabbableList.activateItemAtIndex(index, !_this._tabbableList.isFocused);
                                // re-enable scrolling into view
                                _this._tabbableList.shouldScrollInView = true;
                            }
                        }
                    });
                }
                // Set up the focus monitoring
                this._tabbableList.initialize(this._orderedItems, this.direction, this.wrap);
                // focus the first element if specified
                if (this.focusOnShow) {
                    this._tabbableList.focusKeyManager.setFirstItemActive();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.returnFocus && this._focusedElement instanceof HTMLElement) {
                    setTimeout(function () { return _this._focusedElement.focus(); });
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this._tabbableList.focusKeyManager && this._tabbableList.focusKeyManager.activeItem) {
                    this._tabbableList.focusKeyManager.activeItem.focus();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                this._tabbableList.focusTabbableItem();
            };
        TabbableListDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTabbableList]',
                        exportAs: 'ux-tabbable-list',
                        providers: [TabbableListService]
                    },] }
        ];
        /** @nocollapse */
        TabbableListDirective.ctorParameters = function () {
            return [
                { type: TabbableListService },
                { type: i0.ElementRef }
            ];
        };
        TabbableListDirective.propDecorators = {
            direction: [{ type: i0.Input }],
            wrap: [{ type: i0.Input }],
            focusOnShow: [{ type: i0.Input }],
            returnFocus: [{ type: i0.Input }],
            hierarchy: [{ type: i0.Input }],
            allowAltModifier: [{ type: i0.Input }],
            allowCtrlModifier: [{ type: i0.Input }],
            allowBoundaryKeys: [{ type: i0.Input }],
            items: [{ type: i0.ContentChildren, args: [TabbableListItemDirective, { descendants: true },] }]
        };
        return TabbableListDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccessibilityModule = /** @class */ (function () {
        function AccessibilityModule() {
        }
        /**
         * @param {?} options
         * @return {?}
         */
        AccessibilityModule.forRoot = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return {
                    ngModule: AccessibilityModule,
                    providers: [
                        { provide: ACCESSIBILITY_OPTIONS_TOKEN, useValue: options }
                    ]
                };
            };
        AccessibilityModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            DefaultFocusIndicatorDirective,
                            FocusIndicatorDirective,
                            FocusIndicatorOptionsDirective,
                            FocusIndicatorOriginDirective,
                            FocusWithinDirective,
                            ManagedFocusContainerDirective,
                            SplitterAccessibilityDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            FocusIndicatorOriginDirective,
                            ColorContrastDirective
                        ],
                        imports: [
                            a11y.A11yModule,
                            ColorServiceModule,
                            platform.PlatformModule
                        ],
                        exports: [
                            DefaultFocusIndicatorDirective,
                            FocusIndicatorDirective,
                            FocusIndicatorOptionsDirective,
                            FocusIndicatorOriginDirective,
                            FocusWithinDirective,
                            ManagedFocusContainerDirective,
                            SplitterAccessibilityDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            FocusIndicatorOriginDirective,
                            ColorContrastDirective
                        ],
                        providers: [
                            AccessibilityOptionsService,
                            ContrastService,
                            FocusIndicatorService,
                            ManagedFocusContainerService,
                        ]
                    },] }
        ];
        return AccessibilityModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AccordionModule = /** @class */ (function () {
        function AccordionModule() {
        }
        AccordionModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule
                        ],
                        declarations: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ],
                        exports: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ]
                    },] }
        ];
        return AccordionModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AlertIconDirective = /** @class */ (function () {
        function AlertIconDirective() {
        }
        AlertIconDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxAlertIcon]',
                    },] }
        ];
        return AlertIconDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AlertComponent = /** @class */ (function () {
        function AlertComponent(colorService) {
            this.colorService = colorService;
            /**
             * Determine the style of the alert
             */
            this.type = 'info';
            /**
             * Determine the the alert can be dismissed
             */
            this.dismissible = false;
            /**
             * Define a custom aria label for the dismiss button
             */
            this.dismissAriaLabel = 'Dismiss Alert';
            /**
             * Emit when the dismiss button is pressed
             */
            this.dismiss = new i0.EventEmitter();
        }
        Object.defineProperty(AlertComponent.prototype, "_backgroundColor", {
            /** Resolve the background color from the color set */
            get: /**
             * Resolve the background color from the color set
             * @return {?}
             */ function () {
                return this.backgroundColor ? this.getColor(this.backgroundColor) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertComponent.prototype, "_foregroundColor", {
            /** Resolve the foreground color from the color set */
            get: /**
             * Resolve the foreground color from the color set
             * @return {?}
             */ function () {
                return this.foregroundColor ? this.getColor(this.foregroundColor) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertComponent.prototype, "_isCustomColor", {
            /** Determine if we are using a prefined type or custom colors */
            get: /**
             * Determine if we are using a prefined type or custom colors
             * @return {?}
             */ function () {
                return !!this.backgroundColor && !!this.foregroundColor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} color
         * @return {?}
         */
        AlertComponent.prototype.getColor = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                // check if it is a color name from the color palette or just return the CSS color value
                return this.colorService.resolve(color);
            };
        AlertComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-alert',
                        template: "<div class=\"alert-icon\" *ngIf=\"icon\">\n    <ng-content select=\"[uxAlertIcon]\"></ng-content>\n</div>\n\n<div class=\"alert-content\">\n    <ng-content></ng-content>\n</div>\n\n<button *ngIf=\"dismissible\"\n        uxFocusIndicator\n        class=\"alert-close\"\n        type=\"button\"\n        (click)=\"dismiss.emit()\"\n        [attr.aria-label]=\"dismissAriaLabel\">\n    <ux-icon name=\"close\" class=\"alert-close-icon\"></ux-icon>\n</button>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'alert',
                            '[class.ux-alert-info]': 'type === "info" && !_isCustomColor',
                            '[class.ux-alert-error]': 'type === "error" && !_isCustomColor',
                            '[class.ux-alert-warning]': 'type === "warning" && !_isCustomColor',
                            '[class.ux-alert-success]': 'type === "success" && !_isCustomColor',
                            '[class.ux-alert-dark]': 'type === "dark" && !_isCustomColor',
                            '[style.background-color]': '_backgroundColor',
                            '[style.color]': '_foregroundColor'
                        }
                    }] }
        ];
        /** @nocollapse */
        AlertComponent.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        AlertComponent.propDecorators = {
            type: [{ type: i0.Input }],
            dismissible: [{ type: i0.Input }],
            backgroundColor: [{ type: i0.Input }],
            foregroundColor: [{ type: i0.Input }],
            dismissAriaLabel: [{ type: i0.Input }],
            dismiss: [{ type: i0.Output }],
            icon: [{ type: i0.ContentChild, args: [AlertIconDirective, { static: false },] }]
        };
        return AlertComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICON_OPTIONS_TOKEN = new i0.InjectionToken('ICON_OPTIONS_TOKEN');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** AUTOGENERATED: DO NOT MODIFY **/
    /** @type {?} */
    var commonIcons = [
        '3d',
        'achievement',
        'action',
        'actions',
        'active',
        'add',
        'advanced-search',
        'aggregate',
        'alarm',
        'alert-filled',
        'alert',
        'analytics',
        'announcement',
        'app',
        'archive',
        'article',
        'ascend',
        'assistant',
        'attachment',
        'bar-chart',
        'blog',
        'book',
        'bookmark-filled',
        'bookmark',
        'bundle',
        'calculator',
        'calendar',
        'camera-filled',
        'camera',
        'capacity',
        'caret-down-filled',
        'caret-down',
        'caret-next-filled',
        'caret-next',
        'caret-previous-filled',
        'caret-previous',
        'caret-up-filled',
        'caret-up',
        'catalog',
        'chapter-add',
        'chapter-next-filled',
        'chapter-next',
        'chapter-previous-filled',
        'chapter-previous',
        'chart-organization',
        'chart-partition',
        'chart-sankey',
        'chat-attachment',
        'chat',
        'checkbox-selected',
        'checkbox',
        'checkmark',
        'chevron-down',
        'chevron-left-double',
        'chevron-left',
        'chevron-right-double',
        'chevron-right',
        'chevron-up',
        'circular-view',
        'clipboard',
        'clone',
        'close',
        'cloud-computer',
        'cloud-download',
        'cloud-software',
        'cloud-upload',
        'cloud',
        'cluster',
        'code',
        'command-line',
        'compare',
        'compass',
        'compliance',
        'computer-personal',
        'configuration-filled',
        'configuration',
        'connect',
        'contact-card',
        'contact-us-filled',
        'contact-us',
        'contract',
        'copy',
        'cube-filled',
        'cube',
        'cubes',
        'cursor-filled',
        'cursor',
        'cut',
        'cycle',
        'dashboard',
        'database',
        'defect',
        'deliver',
        'deployment',
        'descend',
        'desktop',
        'detach',
        'directions',
        'dislike-filled',
        'dislike',
        'divide-four',
        'divide-right',
        'divide-three',
        'divide',
        'document-cloud',
        'document-compress',
        'document-config',
        'document-csv',
        'document-data',
        'document-download',
        'document-excel',
        'document-executable',
        'document-image',
        'document-locked',
        'document-missing',
        'document-notes',
        'document-outlook',
        'document-pdf',
        'document-performance',
        'document-powerpoint',
        'document-rtf',
        'document-sound',
        'document-test',
        'document-text',
        'document-threat',
        'document-time',
        'document-transfer',
        'document-txt',
        'document-update',
        'document-upload',
        'document-user',
        'document-verified',
        'document-video',
        'document-word',
        'document',
        'domain',
        'down',
        'download',
        'drag',
        'drive-cage',
        'duplicate',
        'edit-filled',
        'edit',
        'eject-filled',
        'eject',
        'expand',
        'fan',
        'fast-forward-filled',
        'fast-forward',
        'favorite-filled',
        'favorite',
        'filter-filled',
        'filter',
        'first-aid',
        'flag-filled',
        'flag',
        'folder-cycle',
        'folder-open',
        'folder',
        'gallery-filled',
        'gallery',
        'globe',
        'grid',
        'group',
        'grow',
        'halt',
        'help-circle',
        'help',
        'highlighting-remove',
        'highlighting',
        'history',
        'home-filled',
        'home',
        'host-maintenance',
        'host',
        'image-filled',
        'image',
        'impact',
        'in-progress',
        'inactive',
        'inbox',
        'indicator-filled',
        'indicator',
        'information-filled',
        'information',
        'inherit-filled',
        'inherit',
        'input-to-process',
        'install',
        'integration',
        'iteration-filled',
        'iteration',
        'java-filled',
        'java',
        'language',
        'launch',
        'license-filled',
        'license',
        'like-filled',
        'like',
        'line-chart',
        'link-bottom',
        'link-down',
        'link-next',
        'link-previous',
        'link-top',
        'link-up',
        'link',
        'list',
        'location-filled',
        'location-pin-filled',
        'location-pin',
        'location',
        'lock',
        'login',
        'logout',
        'mail-attachment',
        'mail-filled',
        'mail',
        'manual',
        'map-location',
        'map',
        'menu',
        'microphone-filled',
        'microphone',
        'monitor',
        'more',
        'multiple',
        'navigate',
        'new-window',
        'new',
        'news-aggregation',
        'news-collection',
        'news-content',
        'news',
        'next',
        'notes',
        'notification-filled',
        'notification',
        'optimization',
        'organization',
        'overview',
        'pan',
        'pause-filled',
        'pause',
        'payment-google-wallet',
        'payment-mastercard',
        'payment-paypal',
        'payment-square',
        'payment-visa',
        'pin-filled',
        'pin',
        'plan',
        'platform-apple',
        'platform-chrome',
        'platform-dropbox',
        'platform-edge',
        'platform-firefox',
        'platform-internet-explorer',
        'platform-skype',
        'platform-windows',
        'play-filled',
        'play',
        'power',
        'previous',
        'print',
        'quick-view',
        'radial-selected',
        'radial',
        'redo',
        'refresh',
        'resources',
        'rewind-filled',
        'rewind',
        'risk',
        'rss',
        'satellite',
        'save-filled',
        'save',
        'scale-out-repository',
        'schedule-clone',
        'schedule-new',
        'schedule-play',
        'schedule',
        'scorecard',
        'search',
        'secure',
        'select-left',
        'select',
        'server-cluster',
        'server-started',
        'server',
        'servers',
        'service-business',
        'service-start',
        'share',
        'shield-configure',
        'shield-filled',
        'shield',
        'shift',
        'shop-basket',
        'shop-cart',
        'soa',
        'social-email',
        'social-facebook',
        'social-github',
        'social-instagram',
        'social-linkedin',
        'social-medium',
        'social-pinterest',
        'social-reddit',
        'social-slack',
        'social-tumblr',
        'social-twitter',
        'social-vimeo',
        'social-youtube',
        'sort',
        'stakeholder',
        'star-filled',
        'star-half',
        'star',
        'status-approved-filled',
        'status-error-filled',
        'status-information-filled',
        'status-warning-filled',
        'steps-filled',
        'steps',
        'storage',
        'street-view-filled',
        'street-view',
        'subtitles',
        'subtract',
        'support',
        'sync',
        'system',
        'tab-next',
        'tab-previous',
        'tab-up',
        'table-add',
        'table',
        'tag-filled',
        'tag',
        'target',
        'task',
        'template',
        'test-desktop',
        'test',
        'text-wrap',
        'threats',
        'ticket',
        'tools',
        'tooltip',
        'transaction-filled',
        'transaction',
        'trash-filled',
        'trash',
        'tree',
        'trigger',
        'trophy-filled',
        'trophy',
        'troubleshooting',
        'undo',
        'unlock',
        'up',
        'update',
        'upgrade-filled',
        'upgrade',
        'upload',
        'user-add-filled',
        'user-add',
        'user-admin',
        'user-expert',
        'user-female-filled',
        'user-female',
        'user-filled',
        'user-manager',
        'user-new',
        'user-police',
        'user-settings',
        'user-worker',
        'user',
        'validation-filled',
        'validation',
        'video-filled',
        'video',
        'view-filled',
        'view',
        'virtual-machine',
        'vm-maintenance',
        'volume-filled',
        'volume-low-filled',
        'volume-low',
        'volume-mute-filled',
        'volume-mute',
        'volume',
        'vulnerability',
        'waypoint-filled',
        'waypoint',
        'workshop',
        'zoom-in',
        'zoom-out'
    ];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ɵ0 = function (icon) {
        return { name: icon, iconset: 'ux-icon', icon: "ux-icon-" + icon };
    };
    /**
     * We generate the iconset definition as hardcoding it increases bundle size by ~40kb per iconset
     * @type {?}
     */
    var uxIconset = __spread(commonIcons.map(ɵ0));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var IconService = /** @class */ (function () {
        /** Inject a parent service if one exists */
        function IconService(_iconService, options) {
            this._iconService = _iconService;
            /**
             * Emit whenever the iconset changes
             */
            this.iconsChanged$ = new rxjs.Subject();
            /**
             * Store a list of all icon
             */
            this._icons = __spread(uxIconset);
            // if the iconset was defined at the root or child module level apply this configuration
            if (options && options.icons) {
                this.setIcons(options.icons);
            }
        }
        /** Define multiple icon definitions. This will override icon definitions if a name and size collision occurs */
        /**
         * Define multiple icon definitions. This will override icon definitions if a name and size collision occurs
         * @param {?} icons
         * @return {?}
         */
        IconService.prototype.setIcons = /**
         * Define multiple icon definitions. This will override icon definitions if a name and size collision occurs
         * @param {?} icons
         * @return {?}
         */
            function (icons) {
                var _this = this;
                icons.forEach(function (icon) { return _this.setIcon(icon); });
            };
        /** Provide an icon definition which will override if necessary */
        /**
         * Provide an icon definition which will override if necessary
         * @param {?} __0
         * @return {?}
         */
        IconService.prototype.setIcon = /**
         * Provide an icon definition which will override if necessary
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var _this = this;
                var name = _a.name, icon = _a.icon, iconset = _a.iconset, size = _a.size;
                // if there are multiple sizes specified add them all as individual records
                if (Array.isArray(size)) {
                    return size.forEach(function (variant) { return _this.setIcon({ name: name, icon: icon, iconset: iconset, size: variant }); });
                }
                // remove any existing definition with the same parameters
                this._icons = this._icons.filter(function (definition) { return !(definition.name === name && definition.size === size); });
                // insert the new definition
                this._icons = __spread(this._icons, [{ name: name, icon: icon, iconset: iconset, size: size }]);
                // emit the icon change
                this.iconsChanged$.next({ name: name, size: size });
            };
        /** Find an icon based on the given name and size if provided */
        /**
         * Find an icon based on the given name and size if provided
         * @param {?} name
         * @param {?=} size
         * @return {?}
         */
        IconService.prototype.getIcon = /**
         * Find an icon based on the given name and size if provided
         * @param {?} name
         * @param {?=} size
         * @return {?}
         */
            function (name, size) {
                // if no name was specified then do nothing (this can occur if the name input on the component is not initially defined)
                if (!name) {
                    return;
                }
                // if there is a size specified then check for an exact match
                if (size) {
                    // get an icon definition that matches both name and size
                    /** @type {?} */
                    var sizedIcon = this._icons.find(function (definition) { return definition.name === name && definition.size === size; });
                    // if there is a match then return otherwise fallthrough to the default
                    if (sizedIcon) {
                        return sizedIcon;
                    }
                }
                // find a general match with no size constraint
                /** @type {?} */
                var icon = this._icons.find(function (definition) { return definition.name === name && definition.size === undefined; });
                // if no match is found and there is a parent service then we should check it
                if (!icon && this._iconService) {
                    return this._iconService.getIcon(name, size);
                }
                else if (!icon) {
                    console.warn("Icon '" + name + "' was not found.");
                }
                return icon;
            };
        IconService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IconService.ctorParameters = function () {
            return [
                { type: IconService, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [ICON_OPTIONS_TOKEN,] }] }
            ];
        };
        return IconService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var IconComponent = /** @class */ (function () {
        function IconComponent(_elementRef, _renderer, _iconService) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._iconService = _iconService;
            /**
             * Store the boolean value of flip vertical
             */
            this._flipVertical = false;
            /**
             * Store the boolean value of flip horizontal
             */
            this._flipHorizontal = false;
            /**
             * Automatically unsubscribe from observables
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(IconComponent.prototype, "rotate", {
            get: /**
             * @return {?}
             */ function () {
                return this._rotate;
            },
            /** The number of degrees to rotate the icon */
            set: /**
             * The number of degrees to rotate the icon
             * @param {?} rotation
             * @return {?}
             */ function (rotation) {
                this._rotate = ( /** @type {?} */(coercion.coerceNumberProperty(rotation)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "flipHorizontal", {
            get: /**
             * @return {?}
             */ function () {
                return this._flipHorizontal;
            },
            /** Define if the icon should be horizontally flipped */
            set: /**
             * Define if the icon should be horizontally flipped
             * @param {?} flipHorizontal
             * @return {?}
             */ function (flipHorizontal) {
                this._flipHorizontal = coercion.coerceBooleanProperty(flipHorizontal);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "flipVertical", {
            get: /**
             * @return {?}
             */ function () {
                return this._flipVertical;
            },
            /** Define if the icon should be horizontally flipped */
            set: /**
             * Define if the icon should be horizontally flipped
             * @param {?} flipVertical
             * @return {?}
             */ function (flipVertical) {
                this._flipVertical = coercion.coerceBooleanProperty(flipVertical);
            },
            enumerable: true,
            configurable: true
        });
        /** When inputs change ensure we have the best icon definition */
        /**
         * When inputs change ensure we have the best icon definition
         * @param {?} changes
         * @return {?}
         */
        IconComponent.prototype.ngOnChanges = /**
         * When inputs change ensure we have the best icon definition
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // if the name or size changes then update the icon
                if (changes.name && changes.name.currentValue !== changes.name.previousValue ||
                    changes.size && changes.size.currentValue !== changes.size.previousValue) {
                    this.updateIcon();
                }
            };
        /** Watch for changes to the iconset */
        /**
         * Watch for changes to the iconset
         * @return {?}
         */
        IconComponent.prototype.ngAfterViewInit = /**
         * Watch for changes to the iconset
         * @return {?}
         */
            function () {
                var _this = this;
                // watch for changes to the iconset to check if we need to update.
                this._iconService.iconsChanged$.pipe(operators.filter(function (event) { return _this._icon && event.name === _this._icon.name; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.updateIcon(); });
            };
        /** Cleanup on component destroy */
        /**
         * Cleanup on component destroy
         * @return {?}
         */
        IconComponent.prototype.ngOnDestroy = /**
         * Cleanup on component destroy
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** get the icon definition based on the name and size specified */
        /**
         * get the icon definition based on the name and size specified
         * @return {?}
         */
        IconComponent.prototype.updateIcon = /**
         * get the icon definition based on the name and size specified
         * @return {?}
         */
            function () {
                // remove the current icon set and icon classes of the old icon.
                // note we are using the renderer and not HostBindings as a HostBinding
                // on the `class` property will override any user added classes which is
                // not desirable.
                if (this._icon) {
                    this._renderer.removeClass(this._elementRef.nativeElement, this._icon.iconset);
                    this._renderer.removeClass(this._elementRef.nativeElement, this._icon.icon);
                }
                // update the stored icon definition with the best match based on name and size
                this._icon = this._iconService.getIcon(this.name, this.size);
                // add the new icon classes, again using the renderer to avoid overriding user classes
                if (this._icon) {
                    this._renderer.addClass(this._elementRef.nativeElement, this._icon.iconset);
                    this._renderer.addClass(this._elementRef.nativeElement, this._icon.icon);
                }
                else if (!!this.name) {
                    console.warn("The icon " + this.name + " could not be found. Ensure you are using the correct iconset.");
                }
            };
        IconComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-icon',
                        template: '',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[style.font-size]': 'size',
                            '[class.ux-flip-horizontal]': 'flipHorizontal',
                            '[class.ux-flip-vertical]': 'flipVertical',
                            '[class.ux-rotate-90]': 'rotate == 90',
                            '[class.ux-rotate-180]': 'rotate == 180',
                            '[class.ux-rotate-270]': 'rotate == 270',
                        }
                    }] }
        ];
        /** @nocollapse */
        IconComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: IconService }
            ];
        };
        IconComponent.propDecorators = {
            name: [{ type: i0.Input }],
            size: [{ type: i0.Input }],
            rotate: [{ type: i0.Input }],
            flipHorizontal: [{ type: i0.Input }],
            flipVertical: [{ type: i0.Input }]
        };
        return IconComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var IconModule = /** @class */ (function () {
        function IconModule() {
        }
        /** Allow configuration at AppModule level */
        /**
         * Allow configuration at AppModule level
         * @param {?=} options
         * @return {?}
         */
        IconModule.forRoot = /**
         * Allow configuration at AppModule level
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                return {
                    ngModule: IconModule,
                    providers: [
                        { provide: ICON_OPTIONS_TOKEN, useValue: options }
                    ]
                };
            };
        /** Allow configuration at a child module level */
        /**
         * Allow configuration at a child module level
         * @param {?=} options
         * @return {?}
         */
        IconModule.forChild = /**
         * Allow configuration at a child module level
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                // the `forChild` does the same as `forRoot` however this having
                // `forChild` follows the correct conventions as we should never
                // import `forRoot` in a child module
                return IconModule.forRoot(options);
            };
        IconModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            IconComponent
                        ],
                        exports: [
                            IconComponent
                        ],
                        providers: [
                            IconService
                        ]
                    },] }
        ];
        return IconModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ɵ0$1 = function (icon) {
        return { name: icon, iconset: 'hpe-icon', icon: "hpe-" + icon };
    };
    /**
     * We generate the iconset definition as hardcoding it increases bundle size by ~40kb per iconset
     * @type {?}
     */
    var hpeIconset = __spread(commonIcons.map(ɵ0$1));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AlertModule = /** @class */ (function () {
        function AlertModule() {
        }
        AlertModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule
                        ],
                        declarations: [
                            AlertComponent,
                            AlertIconDirective
                        ],
                        exports: [
                            AlertComponent,
                            AlertIconDirective
                        ]
                    },] }
        ];
        return AlertModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var BreadcrumbsComponent = /** @class */ (function () {
        function BreadcrumbsComponent() {
        }
        /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
        BreadcrumbsComponent.prototype.clickCrumb = /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
            function (event, crumb) {
                if (crumb.onClick) {
                    crumb.onClick.call(null, event);
                }
            };
        BreadcrumbsComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-breadcrumbs',
                        template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                uxFocusIndicator\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        BreadcrumbsComponent.propDecorators = {
            crumbs: [{ type: i0.Input }]
        };
        return BreadcrumbsComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var BreadcrumbsModule = /** @class */ (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [BreadcrumbsComponent],
                        declarations: [BreadcrumbsComponent]
                    },] }
        ];
        return BreadcrumbsModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizeService = /** @class */ (function () {
        function ResizeService(_zone) {
            this._zone = _zone;
            this._observer = new ResizeObserver(this.elementDidResize.bind(this));
            this._targets = new WeakMap();
        }
        /**
         * @return {?}
         */
        ResizeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._observer.disconnect();
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.addResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                var _this = this;
                this._zone.runOutsideAngular(function () { return _this._observer.observe(target); });
                if (this._targets.has(target)) {
                    return this._targets.get(target);
                }
                else {
                    /** @type {?} */
                    var emitter = new rxjs.ReplaySubject();
                    this._targets.set(target, emitter);
                    return emitter;
                }
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.removeResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                this._observer.unobserve(target);
            };
        /**
         * @param {?} entries
         * @return {?}
         */
        ResizeService.prototype.elementDidResize = /**
         * @param {?} entries
         * @return {?}
         */
            function (entries) {
                var _this = this;
                this._zone.run(function () {
                    var e_1, _a;
                    try {
                        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                            var entry = entries_1_1.value;
                            if (_this._targets.has(( /** @type {?} */(entry.target)))) {
                                /** @type {?} */
                                var emitter = _this._targets.get(( /** @type {?} */(entry.target)));
                                emitter.next({ width: (( /** @type {?} */(entry.target))).offsetWidth, height: (( /** @type {?} */(entry.target))).offsetHeight });
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
                                _a.call(entries_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                });
            };
        ResizeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ResizeService.ctorParameters = function () {
            return [
                { type: i0.NgZone }
            ];
        };
        return ResizeService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizeDirective = /** @class */ (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            /**
             * Debounce the resize event emitter
             */
            this.throttle = 0;
            /**
             * Emits whenever a resize event occurs
             */
            this.uxResize = new i0.EventEmitter();
            /**
             * Remove all subscriptions on component destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(this.throttle))
                    .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
            };
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        ResizeDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxResize]',
                        providers: [ResizeService]
                    },] }
        ];
        /** @nocollapse */
        ResizeDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizeService },
                { type: i0.NgZone }
            ];
        };
        ResizeDirective.propDecorators = {
            throttle: [{ type: i0.Input }],
            uxResize: [{ type: i0.Output }]
        };
        return ResizeDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizeModule = /** @class */ (function () {
        function ResizeModule() {
        }
        ResizeModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [ResizeDirective],
                        declarations: [ResizeDirective],
                        providers: [ResizeService]
                    },] }
        ];
        return ResizeModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CardTabContentDirective = /** @class */ (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxCardTabContent]'
                    },] }
        ];
        return CardTabContentDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CardTabsService = /** @class */ (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new rxjs.BehaviorSubject(null);
            this.tabs$ = new rxjs.BehaviorSubject([]);
            this.position$ = new rxjs.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        /**
         * @return {?}
         */
        CardTabsService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Add a tab to the list of tabs
         */
        /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.addTab = /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
            };
        /**
         * Remove a tab from the list
         */
        /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.removeTab = /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * Select the tab
         */
        /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.select = /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tab$.next(tab);
            };
        /**
         * Set the position of the tab content
         */
        /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
        CardTabsService.prototype.setPosition = /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
            function (position) {
                this.position$.next(position);
            };
        CardTabsService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        CardTabsService.ctorParameters = function () { return []; };
        return CardTabsService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CardTabComponent = /** @class */ (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        /**
         * @return {?}
         */
        CardTabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabService.removeTab(this);
            };
        CardTabComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-card-tab',
                        template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        CardTabComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabComponent.propDecorators = {
            content: [{ type: i0.ContentChild, args: [CardTabContentDirective, { read: i0.TemplateRef, static: false },] }]
        };
        return CardTabComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CardTabsetComponent = /** @class */ (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabService.position$.getValue();
            },
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.select = /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
            function (tab, element) {
                // select the tab
                this.tabService.select(tab);
                // ensure the tab is moved into view if required
                this.moveIntoView(element);
            };
        /**
         * @param {?} dimensions
         * @return {?}
         */
        CardTabsetComponent.prototype.resize = /**
         * @param {?} dimensions
         * @return {?}
         */
            function (dimensions) {
                this._width = dimensions.width;
                this._innerWidth = this.tablist.nativeElement.scrollWidth;
                this.bounds.lower = 0;
                this.bounds.upper = -(this._innerWidth - this._width);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.previous = /**
         * @return {?}
         */
            function () {
                this.offset += this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.min(this.offset, this.bounds.lower);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.next = /**
         * @return {?}
         */
            function () {
                this.offset -= this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.max(this.offset, this.bounds.upper);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.moveIntoView = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                // if we dont have the dimensions we cant check
                if (!this._width || !this._innerWidth) {
                    return;
                }
                // get the current element bounds
                var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
                var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
                // calculate the visible area
                /** @type {?} */
                var viewportStart = Math.abs(this.offset);
                /** @type {?} */
                var viewportEnd = viewportStart + this._width;
                /** @type {?} */
                var cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
                // if we need to move to the left - figure out how much
                if (offsetLeft < viewportStart) {
                    this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
                }
                // if we need to move to the right - figure out how much
                if ((offsetLeft + cardWidth) > viewportEnd) {
                    this.offset -= (offsetLeft + cardWidth) - viewportEnd;
                }
            };
        CardTabsetComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-card-tabset',
                        template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\n    <ng-content></ng-content>\n</div>\n\n<div class=\"card-tabs\" #tabs>\n\n    <button type=\"button\" class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\n        <ux-icon name=\"previous\"></ux-icon>\n    </button>\n\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\n\n        <div class=\"card-tab\"\n            role=\"tab\"\n            tabindex=\"0\" #card\n            *ngFor=\"let tab of tabService.tabs$ | async\"\n            [ngClass]=\"tabService.position$ | async\"\n            [class.active]=\"tab.active$ | async\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            (click)=\"select(tab, card)\"\n            (focus)=\"tabs.scrollLeft = 0\"\n            (keydown.enter)=\"select(tab, card)\">\n\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\n        </div>\n\n    </div>\n\n    <button type=\"button\" class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\n        <ux-icon name=\"next\"></ux-icon>\n    </button>\n</div>",
                        providers: [CardTabsService]
                    }] }
        ];
        /** @nocollapse */
        CardTabsetComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabsetComponent.propDecorators = {
            position: [{ type: i0.HostBinding, args: ['class',] }, { type: i0.Input }],
            tablist: [{ type: i0.ViewChild, args: ['tablist', { static: true },] }]
        };
        return CardTabsetComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CardTabsModule = /** @class */ (function () {
        function CardTabsModule() {
        }
        CardTabsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            IconModule
                        ],
                        declarations: [
                            CardTabsetComponent,
                            CardTabComponent,
                            CardTabContentDirective
                        ],
                        exports: [
                            CardTabsetComponent,
                            CardTabComponent,
                            CardTabContentDirective
                        ]
                    },] }
        ];
        return CardTabsModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    /** @type {?} */
    var uniqueCheckboxId = 0;
    /**
     * @template T
     */
    var CheckboxComponent = /** @class */ (function () {
        function CheckboxComponent() {
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            /**
             * Determines if the checkbox should be checked, unchecked or indeterminate.
             */
            this.id = this._checkboxId;
            /**
             * Specifies the tabindex of the input.
             */
            this.tabindex = 0;
            /**
             * If set to `true` the checkbox will not toggle state when clicked.
             */
            this.clickable = true;
            /**
             * If set to `true` the checkbox will be displayed without a border and background.
             */
            this.simplified = false;
            /**
             * If `value` is set to the indeterminate value specified using this attribute, it will neither
             * display the checkbox as checked or unchecked, and will instead show the indeterminate variation.
             */
            this.indeterminateValue = -1;
            /**
             * Specify if the checkbox should be disabled.
             */
            this.disabled = false;
            /**
             * Provide an aria label for the checkbox.
             */
            this.ariaLabel = '';
            /**
             * Provide an aria-labelled by property for the checkbox.
             */
            this.ariaLabelledby = null;
            /**
             * Emits when `value` has been changed.
             */
            this.valueChange = new i0.EventEmitter(false);
            this._value = false;
            this.indeterminate = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(CheckboxComponent.prototype, "value", {
            /** Determines if the checkbox should be checked, unchecked or indeterminate. */
            get: /**
             * Determines if the checkbox should be checked, unchecked or indeterminate.
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // determine if it is in the indeterminate state
                this.indeterminate = this._value === this.indeterminateValue;
                // determine the checked state
                this.ariaChecked = this.indeterminate ? 'mixed' : ( /** @type {?} */(this._value));
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._checkboxId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                if (this.value === this.indeterminateValue) {
                    this.value = true;
                    return;
                }
                // toggle the checked state
                this.value = !this.value;
            };
        // Functions required to update ngModel
        // Functions required to update ngModel
        /**
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue =
            // Functions required to update ngModel
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        CheckboxComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        CheckboxComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-checkbox',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n\n        <input type=\"checkbox\"\n               uxFocusIndicator\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (indicator)=\"focused = $event\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                        providers: [CHECKBOX_VALUE_ACCESSOR]
                    }] }
        ];
        CheckboxComponent.propDecorators = {
            id: [{ type: i0.Input }],
            name: [{ type: i0.Input }],
            required: [{ type: i0.Input }],
            tabindex: [{ type: i0.Input }],
            clickable: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            indeterminateValue: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: i0.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: i0.Output }],
            value: [{ type: i0.Input }]
        };
        return CheckboxComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CheckboxModule = /** @class */ (function () {
        function CheckboxModule() {
        }
        CheckboxModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            forms.FormsModule
                        ],
                        exports: [
                            CheckboxComponent
                        ],
                        declarations: [
                            CheckboxComponent
                        ]
                    },] }
        ];
        return CheckboxModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Type representing a color, including its descriptive name.
     */
    var /**
     * Type representing a color, including its descriptive name.
     */ ColorPickerColor = /** @class */ (function () {
        function ColorPickerColor(name, value, inputMode) {
            this.name = name;
            this._color = ThemeColor.parse(value);
            // Preserve the format entered by the user if it's valid
            if (inputMode === 'hex') {
                this._originalHexValue = value;
            }
            else if (inputMode === 'rgba') {
                this._originalRgbaValue = value;
            }
        }
        Object.defineProperty(ColorPickerColor.prototype, "hex", {
            /**
             * Hex value of the color, e.g. `#ffffff`.
             */
            get: /**
             * Hex value of the color, e.g. `#ffffff`.
             * @return {?}
             */ function () {
                return this._originalHexValue ? this._originalHexValue : this._color.toHex();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "rgba", {
            /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             */
            get: /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             * @return {?}
             */ function () {
                return this._originalRgbaValue ? this._originalRgbaValue : this._color.toRgba();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "r", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getRed());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "g", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getGreen());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "b", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getBlue());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "a", {
            get: /**
             * @return {?}
             */ function () {
                return parseFloat(this._color.getAlpha());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerColor.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this._color.toRgba();
            };
        return ColorPickerColor;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    // Values corresponding to stylesheet
    /** @type {?} */
    var BUTTON_MARGIN = 8;
    /** @type {?} */
    var BUTTON_WIDTHS = {
        'sm': 26,
        'md': 32,
        'lg': 40
    };
    /** @type {?} */
    var uniqueId$1 = 0;
    var ColorPickerComponent = /** @class */ (function () {
        function ColorPickerComponent() {
            this.id = "ux-color-picker-" + uniqueId$1++;
            /**
             * The style of the color swatch buttons.
             */
            this.buttonStyle = 'circle';
            /**
             * Whether to show tooltips above the color swatch buttons. These contain the color name if provided; otherwise the color hex/RGBA value.
             */
            this.showTooltips = false;
            /**
             * Whether to show the hex/RGBA input panel.
             */
            this.showInput = false;
            /**
             * The default input mode to display in the input panel. The user can switch modes using the toggle button.
             */
            this.inputMode = 'hex';
            /**
             * Defines a function that returns an aria-label for ColorPickerColor.
             */
            this.colorAriaLabel = this.getColorAriaLabel;
            /**
             * Defines a function that returns an aria-label for the button that switches input modes.
             */
            this.switchModeAriaLabel = this.getSwitchModeAriaLabel;
            /**
             * Define a function that returns an aria-label for the input control.
             */
            this.inputAriaLabel = this.getInputAriaLabel;
            /**
             * Emitted when the user changes the selected color, either by clicking a color swatch button, or entering a valid color value into the input panel text field.
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Emitted when the user presses enter in the input panel text field. This can be used to commit a color change and/or close a popup.
             */
            this.inputSubmit = new i0.EventEmitter();
            this.cssWidth = 'auto';
            this.colors = [];
            this.selected$ = new rxjs.BehaviorSubject(null);
            this.columns$ = new rxjs.BehaviorSubject(-1);
            this.buttonSize$ = new rxjs.BehaviorSubject('md');
            this.inputPatterns = {
                'hex': /^#(?:[\da-fA-F]{3}){1,2}$/,
                'rgba': /^(?:rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))|(?:rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*\d(\.\d+)?\))$/
            };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(ColorPickerComponent.prototype, "inputColors", {
            /**
             * The collection of colors to display in the color swatch.
             *
             * Colors can be specified either as a string, which is the hex or RGBA value of the color; or as a `ColorPickerColor` object,
             * which allows a name to be associated with the color. See below for details of the `ColorPickerColor` class.
             * This property is either a one-dimensional or two-dimensional array. If a two-dimensional array is provided,
             * the colors will be split into rows, providing more control over the appearance of the swatch.
             */
            set: /**
             * The collection of colors to display in the color swatch.
             *
             * Colors can be specified either as a string, which is the hex or RGBA value of the color; or as a `ColorPickerColor` object,
             * which allows a name to be associated with the color. See below for details of the `ColorPickerColor` class.
             * This property is either a one-dimensional or two-dimensional array. If a two-dimensional array is provided,
             * the colors will be split into rows, providing more control over the appearance of the swatch.
             * @param {?} colors
             * @return {?}
             */ function (colors) {
                /** @type {?} */
                var normalizedColors;
                // If it's a 1d array, convert it to 2d
                if (colors.length === 0 || !Array.isArray(colors[0])) {
                    normalizedColors = [( /** @type {?} */(colors))];
                }
                else {
                    normalizedColors = ( /** @type {?} */(colors));
                }
                // Convert any string colors to ColorPickerColor
                this.colors = normalizedColors.map(function (row) {
                    return row.map(function (color) { return color instanceof ColorPickerColor ? color : new ColorPickerColor(color, color); });
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "selected", {
            /**
             * The currently selected color. If this is one of the `colors` in the colors collection, it will be visually
             * highlighted in the swatch. It will also be shown in the input panel, if enabled (see showInput).
             * Note that this will always be a `ColorPickerColor` object, even if plain strings are provided to the colors property.
             * See below for details of the `ColorPickerColor` class.
             */
            set: /**
             * The currently selected color. If this is one of the `colors` in the colors collection, it will be visually
             * highlighted in the swatch. It will also be shown in the input panel, if enabled (see showInput).
             * Note that this will always be a `ColorPickerColor` object, even if plain strings are provided to the colors property.
             * See below for details of the `ColorPickerColor` class.
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                this.selected$.next(selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "columns", {
            /**
             * The number of columns to display in the color swatch. Set this to -1 if the width should be specified by a stylesheet
             * instead, e.g. to provide a responsive layout.
             */
            set: /**
             * The number of columns to display in the color swatch. Set this to -1 if the width should be specified by a stylesheet
             * instead, e.g. to provide a responsive layout.
             * @param {?} columns
             * @return {?}
             */ function (columns) {
                this.columns$.next(columns);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "buttonSize", {
            /** The size of the color swatch buttons. Three size variants are currently supported. */
            set: /**
             * The size of the color swatch buttons. Three size variants are currently supported.
             * @param {?} buttonSize
             * @return {?}
             */ function (buttonSize) {
                this.buttonSize$.next(buttonSize);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Skip emitting the initial selectedChange
                this.selected$.pipe(operators.pairwise(), operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                    var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                    if (prev) {
                        _this.selectedChange.emit(curr);
                    }
                });
                // Set the width based on column count and button size
                rxjs.combineLatest(this.columns$, this.buttonSize$)
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (_a) {
                    var _b = __read(_a, 2), columns = _b[0], buttonSize = _b[1];
                    if (columns > 0) {
                        /** @type {?} */
                        var w = columns * (BUTTON_WIDTHS[buttonSize] + (2 * BUTTON_MARGIN));
                        _this.cssWidth = w + "px";
                    }
                    else {
                        _this.cssWidth = 'auto';
                    }
                });
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
        ColorPickerComponent.prototype.updateColorValue = /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
            function (input, mode) {
                if (this.inputPatterns[mode].test(input)) {
                    this.selected$.next(new ColorPickerColor('Custom', input, mode));
                }
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.toggleColorEntryType = /**
         * @return {?}
         */
            function () {
                this.inputMode = (this.inputMode === 'hex') ? 'rgba' : 'hex';
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorPickerComponent.prototype.getColorAriaLabel = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                return "Select color " + color.name;
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        ColorPickerComponent.prototype.getSwitchModeAriaLabel = /**
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                return "Switch input mode to " + (mode === 'hex' ? 'RGBA' : 'hex');
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        ColorPickerComponent.prototype.getInputAriaLabel = /**
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                return "Edit " + mode + " color value";
            };
        ColorPickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-color-picker',
                        exportAs: 'ux-color-picker',
                        template: "<div class=\"ux-color-picker\" uxTabbableList direction=\"horizontal\">\n    <div class=\"ux-color-picker-swatch\">\n        <div *ngFor=\"let row of colors\" class=\"ux-color-picker-swatch-row\">\n\n            <div *ngFor=\"let color of row\"\n                class=\"ux-color-picker-color\"\n                [class.ux-small]=\"(buttonSize$ | async) === 'sm'\"\n                [class.ux-large]=\"(buttonSize$ | async) === 'lg'\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"\n                [class.ux-selected]=\"color === (selected$ | async)\">\n\n                <button type=\"button\"\n                    uxFocusIndicator\n                    [attr.aria-label]=\"colorAriaLabel(color)\"\n                    aria-selected=\"color === (selected$ | async)\"\n                    class=\"btn btn-icon\"\n                    [uxColorContrast]=\"color.hex\"\n                    [style.background-color]=\"color.rgba\"\n                    (click)=\"selected$.next(color)\"\n                    uxTabbableListItem\n                    [uxTooltip]=\"color.name\"\n                    [tooltipDisabled]=\"!showTooltips\">\n\n                    <ux-icon name=\"checkmark\"></ux-icon>\n                </button>\n\n            </div>\n        </div>\n    </div>\n\n    <div *ngIf=\"showInput\" class=\"ux-color-picker-input-panel\">\n        <div class=\"ux-color-picker-input-header\">\n\n            <div class=\"ux-color-picker-preview\"\n                [style.background-color]=\"(selected$ | async).rgba\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\">\n            </div>\n\n            <label *ngIf=\"inputMode === 'hex'\" attr.for=\"{{ id }}-input-field\">HEX</label>\n            <label *ngIf=\"inputMode === 'rgba'\" attr.for=\"{{ id }}-input-field\">RGBA</label>\n\n            <button type=\"button\"\n                [attr.aria-label]=\"switchModeAriaLabel(inputMode)\"\n                class=\"btn btn-link btn-icon button-secondary ux-color-picker-input-toggle\"\n                (click)=\"toggleColorEntryType(); $event.stopPropagation()\">\n                <ux-icon name=\"chevron-right\"></ux-icon>\n            </button>\n        </div>\n\n        <div class=\"ux-color-picker-input\"\n            [class.has-error]=\"inputField.errors\"\n            [class.has-feedback]=\"inputField.errors\">\n\n            <input type=\"text\"\n                attr.id=\"{{id}}-input-field\"\n                [attr.aria-description]=\"inputAriaLabel(inputMode)\"\n                class=\"form-control\"\n                #inputField=\"ngModel\"\n                [ngModel]=\"(selected$ | async)[inputMode]\"\n                (ngModelChange)=\"updateColorValue($event, inputMode)\"\n                [pattern]=\"inputPatterns[inputMode].source\"\n                (keyup.enter)=\"inputSubmit.emit()\">\n\n                <ux-icon class=\"form-control-feedback\" name=\"alert\"></ux-icon>\n        </div>\n    </div>\n</div>\n"
                    }] }
        ];
        ColorPickerComponent.propDecorators = {
            id: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.id',] }],
            inputColors: [{ type: i0.Input, args: ['colors',] }],
            selected: [{ type: i0.Input }],
            columns: [{ type: i0.Input }],
            buttonStyle: [{ type: i0.Input }],
            buttonSize: [{ type: i0.Input }],
            showTooltips: [{ type: i0.Input }],
            showInput: [{ type: i0.Input }],
            inputMode: [{ type: i0.Input }],
            colorAriaLabel: [{ type: i0.Input }],
            switchModeAriaLabel: [{ type: i0.Input }],
            inputAriaLabel: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            inputSubmit: [{ type: i0.Output }],
            cssWidth: [{ type: i0.HostBinding, args: ['style.width',] }]
        };
        return ColorPickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$2 = 0;
    /** @type {?} */
    var NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = /** @class */ (function () {
        function NumberPickerComponent(_changeDetector, _formGroup) {
            this._changeDetector = _changeDetector;
            this._formGroup = _formGroup;
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            /**
             * Sets the id of the number picker. The child input will have this value with a -input suffix as its id.
             */
            this.id = "ux-number-picker-" + uniqueId$2++;
            /**
             * @deprecated - Use reactive form validation instead.
             * Can be used to show a red outline around the input to indicate an invalid value. By default the error state will appear if the user enters a number below the minimum value or above the maximum value.
             */
            this.valid = true;
            /**
             * Define the precision of floating point values
             */
            this.precision = 6;
            /**
             * If two way binding is used this value will be updated any time the number picker value changes.
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Store the current valid state
             */
            this._valid = true;
            /**
             * This is a flag to indicate when the component has been destroyed to avoid change detection being made after the component
             *  is no longer instantiated. A workaround for Angular Forms bug (https://github.com/angular/angular/issues/27803)
             */
            this._isDestroyed = false;
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            /** Sets the value displayed in the number picker component. */
            get: /**
             * Sets the value displayed in the number picker component.
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this._propagateChange(value);
                this._valid = this.isValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            /** Defines the minimum value the number picker can set. */
            get: /**
             * Defines the minimum value the number picker can set.
             * @return {?}
             */ function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            /** Defines the maximum value the number picker can set. */
            get: /**
             * Defines the maximum value the number picker can set.
             * @return {?}
             */ function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            /** Defines the amount the number picker should increase or decrease when the buttons or arrow keys are used. */
            get: /**
             * Defines the amount the number picker should increase or decrease when the buttons or arrow keys are used.
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._step = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            /** Indicate if the number picker is disabled or not. */
            get: /**
             * Indicate if the number picker is disabled or not.
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return this.id + '-input';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._isDestroyed = true;
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        NumberPickerComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.valid && changes.valid.isFirstChange()) {
                    console.warn("ux-number-picker [valid] property has been deprecated. Instead use reactive form validation.");
                }
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        NumberPickerComponent.prototype.increment = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                if (event) {
                    event.preventDefault();
                }
                if (!this.disabled) {
                    this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                    // account for javascripts terrible handling of floating point numbers
                    this.value = parseFloat(this.value.toPrecision(this.precision));
                }
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        NumberPickerComponent.prototype.decrement = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                if (event) {
                    event.preventDefault();
                }
                if (!this.disabled) {
                    this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                    // account for javascripts terrible handling of floating point numbers
                    this.value = parseFloat(this.value.toPrecision(this.precision));
                }
            };
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.isValid = /**
         * @return {?}
         */
            function () {
                if (this.value < this.min || this.value > this.max) {
                    return false;
                }
                return this.valid;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.onScroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // get the distance scrolled
                /** @type {?} */
                var scrollValue = event.deltaY || (( /** @type {?} */(event))).wheelDelta;
                // increment or decrement accordingly
                scrollValue < 0 ? this.increment(event) : this.decrement(event);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NumberPickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== undefined) {
                    this._value = value;
                    this._valid = this.isValid();
                    // if the component is not destroyed then run change detection
                    // workaround for Angular bug (https://portal.digitalsafe.net/browse/EL-3694)
                    if (!this._isDestroyed) {
                        this._changeDetector.detectChanges();
                    }
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NumberPickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        NumberPickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-number-picker, ux-number-picker-inline',
                        template: "<input type=\"number\"\n    [id]=\"inputId\"\n    role=\"spinbutton\"\n    class=\"form-control number-picker-input\"\n    [(ngModel)]=\"value\"\n    [min]=\"min\"\n    [max]=\"max\"\n    (keydown.ArrowDown)=\"decrement($event)\"\n    (keydown.ArrowUp)=\"increment($event)\"\n    (wheel)=\"onScroll($event)\"\n    step=\"any\"\n    [disabled]=\"disabled\"\n    [attr.aria-valuemin]=\"min\"\n    [attr.aria-valuenow]=\"value\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-labelledby]=\"labelledBy\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <ux-icon name=\"up\"></ux-icon>\n    </div>\n\n    <div class=\"number-picker-control number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n         <ux-icon name=\"down\"></ux-icon>\n    </div>\n\n</div>",
                        providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                        host: {
                            '[class.ux-number-picker-invalid]': '!_valid && !disabled && !_formGroup'
                        }
                    }] }
        ];
        /** @nocollapse */
        NumberPickerComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: forms.FormGroupDirective, decorators: [{ type: i0.Optional }] }
            ];
        };
        NumberPickerComponent.propDecorators = {
            id: [{ type: i0.Input }],
            valid: [{ type: i0.Input }],
            labelledBy: [{ type: i0.Input, args: ['aria-labelledby',] }],
            precision: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            value: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            step: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }]
        };
        return NumberPickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NumberPickerModule = /** @class */ (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            IconModule,
                            forms.FormsModule
                        ],
                        exports: [NumberPickerComponent],
                        declarations: [NumberPickerComponent]
                    },] }
        ];
        return NumberPickerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueTooltipId = 0;
    /**
     * @template T
     */
    var TooltipComponent = /** @class */ (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a unique id for each tooltip
             */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /**
             * Define the tooltip role
             */
            this.role = 'tooltip';
            /**
             * Allow a custom class to be added to the tooltip to allow custom styling
             */
            this.customClass = '';
            /**
             * Emit when the tooltip need to update it's position
             */
            this.reposition$ = new rxjs.Subject();
        }
        Object.defineProperty(TooltipComponent.prototype, "isTemplateRef", {
            /** Indicates whether or not the content is a string or a TemplateRef */
            get: /**
             * Indicates whether or not the content is a string or a TemplateRef
             * @return {?}
             */ function () {
                return this.content instanceof i0.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        TooltipComponent.prototype.ngOnDestroy = /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
            function () {
                this.reposition$.complete();
            };
        /** Inform the parent directive that it needs to recalulate the position */
        /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
        TooltipComponent.prototype.reposition = /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
            function () {
                this.reposition$.next();
            };
        /** This will update the content of the tooltip and trigger change detection */
        /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
        TooltipComponent.prototype.setContent = /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
            function (content) {
                this.content = content;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip placement and trigger change detection */
        /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
        TooltipComponent.prototype.setPlacement = /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
            function (placement) {
                if (!placement) {
                    return;
                }
                this.placement = placement;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip alignment and trigger change detection */
        /**
         * This will update the tooltip alignment and trigger change detection
         * @param {?} alignment
         * @return {?}
         */
        TooltipComponent.prototype.setAlignment = /**
         * This will update the tooltip alignment and trigger change detection
         * @param {?} alignment
         * @return {?}
         */
            function (alignment) {
                if (!alignment) {
                    return;
                }
                this.alignment = alignment;
                this._changeDetectorRef.markForCheck();
            };
        /** This will set a custom class on the tooltip and trigger change detection */
        /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
        TooltipComponent.prototype.setClass = /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
            function (customClass) {
                if (!customClass) {
                    return;
                }
                this.customClass = customClass;
                this._changeDetectorRef.markForCheck();
            };
        /** Updates the context used by the TemplateRef */
        /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
        TooltipComponent.prototype.setContext = /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (!context) {
                    return;
                }
                this.context = context;
                this._changeDetectorRef.markForCheck();
            };
        /** Specify the tooltip role attribute */
        /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
        TooltipComponent.prototype.setRole = /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
            function (role) {
                if (!role) {
                    return;
                }
                this.role = role;
                this._changeDetectorRef.markForCheck();
            };
        TooltipComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-tooltip',
                        template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        TooltipComponent.propDecorators = {
            content: [{ type: i0.Input }],
            context: [{ type: i0.Input }],
            placement: [{ type: i0.Input }],
            alignment: [{ type: i0.Input }]
        };
        return TooltipComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TooltipService = /** @class */ (function () {
        function TooltipService() {
            this.shown$ = new rxjs.Subject();
        }
        TooltipService.decorators = [
            { type: i0.Injectable }
        ];
        return TooltipService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TooltipDirective = /** @class */ (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /**
             * All the user to add a custom class to the tooltip
             */
            this.customClass = '';
            /**
             * All the user to add a role to the tooltip - default is tooltip
             */
            this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            this.context = {};
            /**
             * Delay the showing of the tooltip by a number of miliseconds
             */
            this.delay = 0;
            /**
             * Programmatically show and hide the tooltip
             */
            this.isOpen = false;
            /**
             * Customize how the tooltip should be positioned relative to the element
             */
            this.placement = 'top';
            /**
             * Customize the position of the callout
             */
            this.alignment = 'center';
            /**
             * Specify which events should show the tooltip
             */
            this.showTriggers = ['mouseenter', 'focus'];
            /**
             * Specify which events should hide the tooltip
             */
            this.hideTriggers = ['mouseleave', 'blur'];
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new i0.EventEmitter();
            /**
             * Emits a event when the tooltip is hidden
             */
            this.hidden = new i0.EventEmitter();
            /**
             * Allow two way binding to track the visibility of the tooltip
             */
            this.isOpenChange = new i0.EventEmitter();
            /**
             * Keep track of the tooltip visibility
             */
            this.isVisible = false;
            /**
             * Define the overlay class
             */
            this._overlayClass = 'ux-tooltip-pane';
            /**
             * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Store the timeout interval for cancelation
             */
            this._showTimeoutId = null;
            /**
             * Internally store the type of this component - usual for distinctions when extending this class
             */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        TooltipDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                var _this = this;
                // set up show and hide event triggers
                rxjs.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
                rxjs.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
                rxjs.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
                rxjs.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
                rxjs.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
                // when any other tooltips open hide this one
                this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip) { return tooltip !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
                // if the tooltip should be initially visible then open it
                if (this.isOpen) {
                    this.show();
                }
            };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        TooltipDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // we can ignore the first change as it's handled in ngOnInit
                if (changes.isOpen && !changes.isOpen.firstChange && changes.isOpen.currentValue !== this.isVisible) {
                    changes.isOpen.currentValue ? this.show() : this.hide();
                }
                // destroy the overlay ref so a new correctly positioned instance will be created next time
                if (changes.placement) {
                    this.destroyOverlay();
                }
                if (this._instance && changes.placement) {
                    this._instance.setPlacement(changes.placement.currentValue);
                }
                if (this._instance && changes.alignment) {
                    this._instance.setAlignment(changes.alignment.currentValue);
                }
                if (this._instance && changes.content) {
                    this._instance.setContent(changes.content.currentValue);
                }
                if (this._instance && changes.customClass) {
                    this._instance.setClass(changes.customClass.currentValue);
                }
                if (this._instance && changes.context) {
                    this._instance.setContext(changes.context.currentValue);
                }
                if (this._instance && changes.role) {
                    this._instance.setContext(changes.role.currentValue);
                }
            };
        /** Ensure we clean up after ourselves */
        /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
        TooltipDirective.prototype.ngOnDestroy = /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
            function () {
                // ensure we close the tooltip when the host is destroyed
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._instance = null;
                }
                // emit this event to automatically unsubscribe from all subscriptions
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make the tooltip open */
        /**
         * Make the tooltip open
         * @return {?}
         */
        TooltipDirective.prototype.show = /**
         * Make the tooltip open
         * @return {?}
         */
            function () {
                var _this = this;
                // if the tooltip is disabled then do nothing
                if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                    return;
                }
                // delay the show by the delay amount
                this._showTimeoutId = window.setTimeout(function () {
                    // create the tooltip and get the overlay ref
                    /** @type {?} */
                    var overlayRef = _this.createOverlay();
                    // create the portal to create the tooltip component
                    _this._portal = _this.createPortal();
                    _this._instance = _this.createInstance(overlayRef);
                    // watch for any changes to the content
                    _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                    // store the visible state
                    _this.isVisible = true;
                    // ensure the overlay has the correct initial position
                    _this.reposition();
                    // emit the show events
                    _this.shown.emit();
                    _this.isOpenChange.next(true);
                    // clear the interval id
                    _this._showTimeoutId = null;
                    // emit the show event to close any other tooltips
                    _this._tooltipService.shown$.next(_this._instance);
                    // ensure change detection is run
                    _this._changeDetectorRef.detectChanges();
                }, this.delay);
            };
        /** If a tooltip exists and is visible, hide it */
        /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
        TooltipDirective.prototype.hide = /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
            function () {
                // if we are waiting to show a tooltip then cancel the pending timeout
                if (this._showTimeoutId) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                    return;
                }
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                this.setAriaDescribedBy(null);
                this._instance = null;
                // store the visible state
                this.isVisible = false;
                // emit the hide events
                this.hidden.emit();
                this.isOpenChange.next(false);
                // ensure change detection is run
                this._changeDetectorRef.detectChanges();
            };
        /** Toggle the visibility of the tooltip */
        /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
        TooltipDirective.prototype.toggle = /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
            function () {
                this.isVisible ? this.hide() : this.show();
            };
        /** Recalculate the position of the popover */
        /**
         * Recalculate the position of the popover
         * @return {?}
         */
        TooltipDirective.prototype.reposition = /**
         * Recalculate the position of the popover
         * @return {?}
         */
            function () {
                if (this.isVisible && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
        TooltipDirective.prototype.createInstance = /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                /** @type {?} */
                var instance = ( /** @type {?} */(overlayRef.attach(this._portal).instance));
                // supply the tooltip with the correct properties
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setAlignment(this.alignment);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                return instance;
            };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
        TooltipDirective.prototype.createPortal = /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
            };
        /** Create the overlay and set up the scroll handling behavior */
        /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
        TooltipDirective.prototype.createOverlay = /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
            function () {
                // if the tooltip has already been created then just return the existing instance
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                // configure the tooltip
                /** @type {?} */
                var strategy = this._overlay.position()
                    .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
                // correctly handle scrolling
                /** @type {?} */
                var scrollableAncestors = this._scrollDispatcher
                    .getAncestorScrollContainers(this._elementRef);
                strategy.withScrollableContainers(scrollableAncestors);
                this._overlayRef = this._overlay.create({
                    positionStrategy: strategy,
                    panelClass: this._overlayClass,
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    hasBackdrop: false
                });
                return this._overlayRef;
            };
        /** Recreate the overlay ref using the updated origin and overlay positions */
        /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
        TooltipDirective.prototype.destroyOverlay = /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
            function () {
                // destroy the existing overlay
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this.isVisible = false;
            };
        /** Get the origin position based on the specified tooltip placement */
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOrigin = /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement === 'top' || this.placement === 'bottom') {
                    return { originX: ( /** @type {?} */(this.alignment)), originY: this.placement };
                }
                if (this.placement === 'left') {
                    return { originX: 'start', originY: this.getVerticalAlignment() };
                }
                if (this.placement === 'right') {
                    return { originX: 'end', originY: this.getVerticalAlignment() };
                }
            };
        /** Calculate the overlay position based on the specified tooltip placement */
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOverlayPosition = /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement === 'top') {
                    return { overlayX: ( /** @type {?} */(this.alignment)), overlayY: 'bottom' };
                }
                if (this.placement === 'bottom') {
                    return { overlayX: ( /** @type {?} */(this.alignment)), overlayY: 'top' };
                }
                if (this.placement === 'left') {
                    return { overlayX: 'end', overlayY: this.getVerticalAlignment() };
                }
                if (this.placement === 'right') {
                    return { overlayX: 'start', overlayY: this.getVerticalAlignment() };
                }
            };
        /** Convert the alignment property to a valid CDK alignment value */
        /**
         * Convert the alignment property to a valid CDK alignment value
         * @return {?}
         */
        TooltipDirective.prototype.getVerticalAlignment = /**
         * Convert the alignment property to a valid CDK alignment value
         * @return {?}
         */
            function () {
                switch (this.alignment) {
                    case 'start':
                        return 'top';
                    case 'end':
                        return 'bottom';
                    default:
                        return this.alignment;
                }
            };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
        TooltipDirective.prototype.includes = /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
            function (array, value) {
                return Array.isArray(array) && !!array.find(function (item) { return item === value; });
            };
        /** Handle the click event - show or hide accordingly */
        /**
         * Handle the click event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
        TooltipDirective.prototype.onClick = /**
         * Handle the click event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
            function (_) {
                // if its not visible and click is a show trigger open it
                if (!this.isVisible && this.includes(this.showTriggers, 'click') && this._showTimeoutId === null) {
                    return this.show();
                }
                // if its visible and click is a hide trigger close it
                if (this.isVisible && this.includes(this.hideTriggers, 'click') && this._showTimeoutId === null) {
                    return this.hide();
                }
                // if its not visible and click is a hide trigger close it and there is a pending tooltip
                if (!this.isVisible && this.includes(this.hideTriggers, 'click') && this._showTimeoutId !== null) {
                    return this.cancelTooltip();
                }
            };
        /** Handle the mouse enter event - show or hide accordingly */
        /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
        TooltipDirective.prototype.onMouseEnter = /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
            function (_) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the mouse leave event - show or hide accordingly */
        /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
        TooltipDirective.prototype.onMouseLeave = /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
            function (_) {
                // If the tooltip is pending then cancel showing it
                if (!this.isVisible && this.includes(this.hideTriggers, 'mouseleave') && this._showTimeoutId !== null) {
                    return this.cancelTooltip();
                }
                // if the tooltip is not visible or mouseleave isn't a hide trigger then do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Handle the focus event - show or hide accordingly */
        /**
         * Handle the focus event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
        TooltipDirective.prototype.onFocus = /**
         * Handle the focus event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
            function (_) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the blur event - show or hide accordingly */
        /**
         * Handle the blur event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
        TooltipDirective.prototype.onBlur = /**
         * Handle the blur event - show or hide accordingly
         * @param {?} _
         * @return {?}
         */
            function (_) {
                // If the tooltip is pending then cancel showing it
                if (!this.isVisible && this.includes(this.hideTriggers, 'blur') && this._showTimeoutId !== null) {
                    return this.cancelTooltip();
                }
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        TooltipDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (id === null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                }
                else {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
                }
            };
        /** Cancel any pending tooltip (waiting on delay ellapsing) */
        /**
         * Cancel any pending tooltip (waiting on delay ellapsing)
         * @return {?}
         */
        TooltipDirective.prototype.cancelTooltip = /**
         * Cancel any pending tooltip (waiting on delay ellapsing)
         * @return {?}
         */
            function () {
                if (this._showTimeoutId !== null) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                }
            };
        TooltipDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTooltip]',
                        exportAs: 'ux-tooltip'
                    },] }
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.ViewContainerRef },
                { type: overlay.Overlay },
                { type: overlay.ScrollDispatcher },
                { type: i0.ChangeDetectorRef },
                { type: i0.Renderer2 },
                { type: TooltipService }
            ];
        };
        TooltipDirective.propDecorators = {
            content: [{ type: i0.Input, args: ['uxTooltip',] }],
            disabled: [{ type: i0.Input, args: ['tooltipDisabled',] }],
            customClass: [{ type: i0.Input, args: ['tooltipClass',] }],
            role: [{ type: i0.Input, args: ['tooltipRole',] }],
            context: [{ type: i0.Input, args: ['tooltipContext',] }],
            delay: [{ type: i0.Input, args: ['tooltipDelay',] }],
            isOpen: [{ type: i0.Input }],
            placement: [{ type: i0.Input }],
            alignment: [{ type: i0.Input }],
            showTriggers: [{ type: i0.Input }],
            hideTriggers: [{ type: i0.Input }],
            shown: [{ type: i0.Output }],
            hidden: [{ type: i0.Output }],
            isOpenChange: [{ type: i0.Output }]
        };
        return TooltipDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TooltipModule = /** @class */ (function () {
        function TooltipModule() {
        }
        TooltipModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule
                        ],
                        exports: [TooltipDirective, TooltipComponent],
                        declarations: [TooltipComponent, TooltipDirective],
                        providers: [TooltipService],
                        entryComponents: [TooltipComponent]
                    },] }
        ];
        return TooltipModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColorPickerModule = /** @class */ (function () {
        function ColorPickerModule() {
        }
        ColorPickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            NumberPickerModule,
                            TooltipModule,
                            IconModule
                        ],
                        exports: [
                            ColorPickerComponent
                        ],
                        declarations: [
                            ColorPickerComponent
                        ],
                    },] }
        ];
        return ColorPickerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColumnSortingDirective = /** @class */ (function () {
        function ColumnSortingDirective() {
            /**
             * Emit the current sort state for all columns within the table
             */
            this.events = new rxjs.Subject();
            /**
             * Store the current sort state for all columns within the table
             */
            this.order = [];
        }
        /**
         * @return {?}
         */
        ColumnSortingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.events.complete();
            };
        /** Toggle the sorting state of a column */
        /**
         * Toggle the sorting state of a column
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleColumn = /**
         * Toggle the sorting state of a column
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // apply sorting based on the single or multiple sort
                this.order = this.singleSort ? this.toggleSingleColumn(sorting) : this.toggleMultipleColumn(sorting);
                // emit the latest order
                this.events.next(this.order);
                return this.order;
            };
        /** Toggle the sorting state of a column when using single select */
        /**
         * Toggle the sorting state of a column when using single select
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleSingleColumn = /**
         * Toggle the sorting state of a column when using single select
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                return sorting.state === ColumnSortingState.NoSort ? [] : [{ key: sorting.key, state: sorting.state }];
            };
        /** Toggle the sorting state of a column when using multiple select */
        /**
         * Toggle the sorting state of a column when using multiple select
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleMultipleColumn = /**
         * Toggle the sorting state of a column when using multiple select
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // reorder columns here
                /** @type {?} */
                var idx = this.order.findIndex(function (column) { return column.key === sorting.key; });
                // if wasnt previously selected add to list
                if (idx === -1) {
                    return __spread(this.order, [{ key: sorting.key, state: sorting.state }]);
                }
                // if we are sorting it change the sorting order
                if (sorting.state === ColumnSortingState.Ascending || sorting.state === ColumnSortingState.Descending) {
                    return __spread(this.order.filter(function (_column) { return _column.key !== sorting.key; }), [{ key: sorting.key, state: sorting.state }]);
                }
                // Otherwise remove the item
                return this.order.filter(function (_column) { return _column.key !== sorting.key; });
            };
        ColumnSortingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxColumnSorting]'
                    },] }
        ];
        ColumnSortingDirective.propDecorators = {
            singleSort: [{ type: i0.Input }],
            sortIndicator: [{ type: i0.Input }]
        };
        return ColumnSortingDirective;
    }());
    /** @enum {string} */
    var ColumnSortingState = {
        Ascending: 'ascending',
        Descending: 'descending',
        NoSort: 'none',
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColumnSortingComponent = /** @class */ (function () {
        function ColumnSortingComponent(_sorter, _changeDetector) {
            this._sorter = _sorter;
            this._changeDetector = _changeDetector;
            /**
             * Changes the state of the sorting on the column between `NoSort`, `Ascending` and `Descending`.
             * This returns an array of objects for each column being sorted containing `key: string` and `state: ColumnSortingState`.
             * State can be used to find the current sorting state of the column eg. `(state === ColumnSortingState.Ascending)`.
             * The `ColumnSortingOrder` interface has been provided for objects in the array.
             */
            this.stateChange = new i0.EventEmitter();
            /**
             * Expose the sorting state enum to the view
             */
            this.columnSortingState = ColumnSortingState;
            /**
             * Unsubscribe from all observables on component destroy
             */
            this._onDestroy = new rxjs.Subject();
            // listen for changes triggered by the directive
            this._sorter.events.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(this.updateState.bind(this));
        }
        Object.defineProperty(ColumnSortingComponent.prototype, "state", {
            get: /**
             * @return {?}
             */ function () {
                return this._state;
            },
            /** Defines the sorting order of a column: `NoSort`, `Ascending` or `Descending`. */
            set: /**
             * Defines the sorting order of a column: `NoSort`, `Ascending` or `Descending`.
             * @param {?} state
             * @return {?}
             */ function (state) {
                this._state = state;
                // update the column sorting icon
                if (this.state === ColumnSortingState.Ascending) {
                    this._icon = 'ascend';
                }
                if (this.state === ColumnSortingState.Descending) {
                    this._icon = 'descend';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnSortingComponent.prototype, "_sortIndicator", {
            /** Access the custom sort indicator if one was provided */
            get: /**
             * Access the custom sort indicator if one was provided
             * @return {?}
             */ function () {
                return this._sorter.sortIndicator;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Toggle the sorting state of a column - this is designed to be programmtically called by the consuming component */
        /**
         * Toggle the sorting state of a column - this is designed to be programmtically called by the consuming component
         * @return {?}
         */
        ColumnSortingComponent.prototype.changeState = /**
         * Toggle the sorting state of a column - this is designed to be programmtically called by the consuming component
         * @return {?}
         */
            function () {
                switch (this.state) {
                    case ColumnSortingState.Ascending:
                        this.state = ColumnSortingState.Descending;
                        break;
                    case ColumnSortingState.Descending:
                        this.state = ColumnSortingState.NoSort;
                        break;
                    default:
                        this.state = ColumnSortingState.Ascending;
                }
                // change detection should be run
                this._changeDetector.markForCheck();
                // inform parent
                return this._sorter.toggleColumn({ key: this.key, state: this.state });
            };
        /** Update the state based on column order */
        /**
         * Update the state based on column order
         * @param {?} columns
         * @return {?}
         */
        ColumnSortingComponent.prototype.updateState = /**
         * Update the state based on column order
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // if we are sorting this column then find the matching data
                /** @type {?} */
                var columnIdx = columns.findIndex(function (_column) { return _column.key === _this.key; });
                // if we are not sorting this column then mark it as NoSort
                if (columnIdx === -1) {
                    this.state = ColumnSortingState.NoSort;
                }
                // only store the number if we have 2 or more columns being sorted
                this.order = columns.length < 2 || columnIdx === -1 ? null : columnIdx + 1;
                // change detection should be run
                this._changeDetector.markForCheck();
                // Emit the latest change
                this.stateChange.emit(this.state);
            };
        ColumnSortingComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-column-sorting',
                        template: "<div class=\"ux-column-sorting\">\n\n    <!-- The default sort indicator -->\n    <ng-container *ngIf=\"!_sortIndicator\">\n\n        <ux-icon\n            class=\"ux-column-sorting-icon\"\n            [class.column-sorting-icon-hidden]=\"_state === columnSortingState.NoSort\"\n            [name]=\"_icon\">\n        </ux-icon>\n\n        <p class=\"ux-column-sorting-number\" aria-hidden=\"true\">{{ order }}</p>\n    </ng-container>\n\n    <!-- Custom sort indicator -->\n    <ng-container\n        *ngIf=\"_sortIndicator\"\n        [ngTemplateOutlet]=\"_sortIndicator\"\n        [ngTemplateOutletContext]=\"{ state: _state, order: order }\">\n    </ng-container>\n\n</div>",
                        exportAs: 'ux-column-sorting',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        ColumnSortingComponent.ctorParameters = function () {
            return [
                { type: ColumnSortingDirective },
                { type: i0.ChangeDetectorRef }
            ];
        };
        ColumnSortingComponent.propDecorators = {
            state: [{ type: i0.Input }],
            key: [{ type: i0.Input }],
            stateChange: [{ type: i0.Output }]
        };
        return ColumnSortingComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColumnSortingModule = /** @class */ (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            IconModule
                        ],
                        exports: [
                            ColumnSortingComponent,
                            ColumnSortingDirective
                        ],
                        declarations: [
                            ColumnSortingComponent,
                            ColumnSortingDirective
                        ]
                    },] }
        ];
        return ColumnSortingModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ConduitSubject = /** @class */ (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new rxjs.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
        ConduitSubject.prototype.getInitialValue = /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
            function () {
                var _this = this;
                // if we do not accept inputs then do nothing
                if (this.conduit.acceptsInput === false) {
                    return;
                }
                // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
                /** @type {?} */
                var subjects = this._zone.getSubjects().filter(function (subject) {
                    // If this is itself or if it has not value to give us then do nothing
                    if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                        return false;
                    }
                    // if acceptsInput is true then we return every time
                    if (_this.conduit.acceptsInput === true) {
                        return true;
                    }
                    if (Array.isArray(_this.conduit.acceptsInput)) {
                        return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                    }
                });
                // if there are no matches then do nothing
                if (subjects.length === 0) {
                    return;
                }
                // otherwise sort by the last modified field
                subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
                // get the most recent value
                this._subject.next(subjects[0].conduit.currentValue);
            };
        /** This will be triggered when a conduits value has changed */
        /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
        ConduitSubject.prototype.onInput = /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if we dont accept input or we emitted this value then do nothing
                if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                    return;
                }
                // check if the conduit produces output - if not we only do something if we are in the same zone
                if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                    return;
                }
                // check if we only accept inputs from specific zones
                if (Array.isArray(this.conduit.acceptsInput)) {
                    // check if the event came from an acceptable zone
                    if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                        return;
                    }
                }
                // if required transform the value
                /** @type {?} */
                var outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
                // update the subject
                this._subject.next(outputValue);
            };
        /** This will be fired when this conduit emits a new value */
        /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
        ConduitSubject.prototype.onOutput = /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
                this.conduit.currentValue = value;
                this.conduit.lastModified = new Date();
                // check if this should produce output
                if (this.conduit.producesOutput) {
                    this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
                }
            };
        /** Unsubscribe once this subject is destroyed */
        /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
        ConduitSubject.prototype.destroy = /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        return ConduitSubject;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * This utility is to ensure a all functions with the specified name are called in all super classes
     * @param {?} target
     * @param {?} functionName
     * @return {?}
     */
    function invokeSuperFunction(target, functionName) {
        // get all instances of the function
        /** @type {?} */
        var functionList = [];
        // store the current prototype we are checking
        /** @type {?} */
        var prototype = target;
        // look through every base class and check it
        do {
            if (prototype.hasOwnProperty(functionName)) {
                functionList.push(prototype[functionName]);
            }
            prototype = prototype.__proto__;
        } while (prototype.__proto__);
        // augment the top level function to call all the functions
        target[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
        };
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ConduitZone = /** @class */ (function () {
        function ConduitZone() {
        }
        /**
         * @return {?}
         */
        ConduitZone.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all conduit subjects that are part of this zone
                ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                    .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
            };
        /** Store reference to the repository and begin watching for and emitting changes */
        /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.registerConduit = /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
            };
        /** Destroy a conduit */
        /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduit = /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                /** @type {?} */
                var subject = this.getConduitSubject(conduit.subject);
                if (subject) {
                    // remove the subject from the internal list of conduit subjects
                    ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
                    // perform all unsubscriptions
                    subject.destroy();
                }
            };
        /** Provide the zone with an ID */
        /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
        ConduitZone.prototype.setZoneId = /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
            function (zoneId) {
                this._zoneId = zoneId;
            };
        /** Emit a value to all zones for checking */
        /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
        ConduitZone.prototype.emit = /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
            function (event) {
                ConduitZone.events.next(event);
            };
        /** Retrieve a conduit subsject object from the rxjs subject */
        /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
        ConduitZone.prototype.getConduitSubject = /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
            function (subject) {
                return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
            };
        /** Get all subjects from all zones */
        /**
         * Get all subjects from all zones
         * @return {?}
         */
        ConduitZone.prototype.getSubjects = /**
         * Get all subjects from all zones
         * @return {?}
         */
            function () {
                return ConduitZone.subjects;
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // find the conduit with the matching subject
                /** @type {?} */
                var conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
                // if a match was found update the properties
                if (conduitSubject) {
                    // update each specified property
                    for (var prop in properties) {
                        conduitSubject.conduit[prop] = properties[prop];
                    }
                }
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // register the conduit with the zone
                this.registerConduit(__assign({}, properties, { subject: subject }));
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.registerConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
                }
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
                }
            };
        /** Return the global event stream */
        /**
         * Return the global event stream
         * @return {?}
         */
        ConduitZone.prototype.getEvents = /**
         * Return the global event stream
         * @return {?}
         */
            function () {
                return ConduitZone.events;
            };
        /**
         * Create a global subject store
         */
        ConduitZone.subjects = [];
        /**
         * Expose an event stream of new values
         */
        ConduitZone.events = new rxjs.Subject();
        ConduitZone.decorators = [
            { type: i0.Injectable }
        ];
        return ConduitZone;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ConduitComponent = /** @class */ (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
            // we want to ensure these functions get called even if a class overrides them
            invokeSuperFunction(this, 'ngOnInit');
            invokeSuperFunction(this, 'ngOnDestroy');
        }
        /** We need to register the conduits with the zone when the component is initialised */
        /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
        ConduitComponent.prototype.ngOnInit = /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
            function () {
                // register the conduit in the zone and ensure it gets the correct instance of the target
                this._zone.registerConduits(this);
            };
        /** We need to unregister the conduits when the component is destroyed */
        /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
        ConduitComponent.prototype.ngOnDestroy = /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
            function () {
                this._zone.unregisterConduits(this);
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.setConduitProperties(subject, properties);
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.createConduit(subject, properties);
            };
        /** @nocollapse */
        ConduitComponent.ctorParameters = function () {
            return [
                { type: ConduitZone, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ConduitComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ConduitZoneComponent = /** @class */ (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        ConduitZoneComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._zone.setZoneId(this.zoneId);
            };
        return ConduitZoneComponent;
    }(ConduitComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Expose the property that conduits will be stored in
     * @type {?}
     */
    var CONDUITS = '_conduits';
    /**
     * Create the conduit property decorator
     * @param {?} properties
     * @return {?}
     */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(( /** @type {?} */(__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey }))));
        };
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragService = /** @class */ (function () {
        function DragService() {
            /**
             * Emit when dragging begins
             */
            this.onDragStart = new rxjs.Subject();
            /**
             * Emit when dragging moves
             */
            this.onDrag = new rxjs.Subject();
            /**
             * Emit when dragging ends
             */
            this.onDragEnd = new rxjs.Subject();
            /**
             * Emit when the user is dragging over the drop area
             */
            this.onDropEnter = new rxjs.Subject();
            /**
             * Emit when the user is dragging out of the drop area
             */
            this.onDropLeave = new rxjs.Subject();
            /**
             * Emit when a drop occurs
             */
            this.onDrop = new rxjs.Subject();
        }
        /** Destroy all observables */
        /**
         * Destroy all observables
         * @return {?}
         */
        DragService.prototype.ngOnDestroy = /**
         * Destroy all observables
         * @return {?}
         */
            function () {
                this.onDragStart.complete();
                this.onDrag.complete();
                this.onDragEnd.complete();
                this.onDrop.complete();
                this.onDropEnter.complete();
                this.onDropLeave.complete();
            };
        DragService.decorators = [
            { type: i0.Injectable }
        ];
        return DragService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragDirective = /** @class */ (function () {
        function DragDirective(_elementRef, _ngZone, _renderer, _drag) {
            var _this = this;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            this._drag = _drag;
            /**
             * Detemine if we should show a clone when dragging
             */
            this.clone = false;
            /**
             * Allow the dragging to be enabled/disabled
             */
            this.draggable = true;
            /**
             * Emit an event when dragging starts
             */
            this.onDragStart = new i0.EventEmitter();
            /**
             * Emit an event when the mouse moves while dragging
             */
            this.onDrag = new i0.EventEmitter();
            /**
             * Emit an event when the dragging finishes
             */
            this.onDragEnd = new i0.EventEmitter();
            /**
             * Emit when the user drops an item in a drop area
             */
            this.onDrop = new i0.EventEmitter();
            /**
             * Emit when the user drags over a drop area
             */
            this.onDropEnter = new i0.EventEmitter();
            /**
             * Emit when the user drags out of a drop area
             */
            this.onDropLeave = new i0.EventEmitter();
            /**
             * Store the dragging state
             */
            this._isDragging = false;
            /**
             * Create an observable from the mouse down event
             */
            this._mousedown$ = rxjs.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /**
             * Create an observable from the mouse move event
             */
            this._mousemove$ = rxjs.fromEvent(document, 'mousemove');
            /**
             * Create an observable from the mouse up event
             */
            this._mouseup$ = rxjs.fromEvent(document, 'mouseup');
            /**
             * Use an observable to unsubscribe from all subscriptions
             */
            this._onDestroy = new rxjs.Subject();
            // ensure all mouse down events on the object are captured
            this._mousedown$.pipe(operators.filter(function () { return _this.draggable; }), operators.takeUntil(this._onDestroy))
                .subscribe(this.dragStart.bind(this));
            // emit the outputs when drag events occur
            _drag.onDragStart.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (dragEvent) { return _this.onDragStart.emit(dragEvent.event); });
            _drag.onDrag.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (dragEvent) { return _this.onDrag.emit(dragEvent.event); });
            _drag.onDragEnd.pipe(operators.filter(function (event) { return _this._isDragging || (_this.model && _this.model === event.data); }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDragEnd.emit(); });
            _drag.onDrop.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this.onDrop.emit(event); });
            _drag.onDropEnter.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDropEnter.emit(); });
            _drag.onDropLeave.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDropLeave.emit(); });
        }
        /** Emit events and create clone when drag starts */
        /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragStart = /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this.clone) {
                    // clone the node
                    this.cloneNode(event);
                }
                // apply a class to the element being dragged
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // store the dragging state
                this._isDragging = true;
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDragStart.next({ event: event, group: _this.group, data: _this.model }); });
                this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                    .subscribe(this.dragMove.bind(this));
                // When dragging stops emit the drag end
                this._mouseup$.pipe(operators.first()).subscribe(this.dragEnd.bind(this));
            };
        /** Emit event and update clone position when dragging moves */
        /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragMove = /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this._clone) {
                    this.updateNodePosition(event);
                }
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDrag.next({ event: event, group: _this.group, data: _this.model }); });
            };
        /** Emit event and destroy clone when dragging ends */
        /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
        DragDirective.prototype.dragEnd = /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
            function () {
                var _this = this;
                // if there was a clone, remove it
                if (this._clone) {
                    this._renderer.removeChild(document.body, this._clone);
                    this._clone = null;
                }
                // remove the dragging class
                this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // emit the on drag end output
                this._ngZone.run(function () { return _this._drag.onDragEnd.next({ group: _this.group, data: _this.model }); });
                // store the dragging state
                this._isDragging = false;
            };
        /** Create an exact clone of an element */
        /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.cloneNode = /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // duplicate the node
                this._clone = this._elementRef.nativeElement.cloneNode(true);
                // store the position within the draggable element
                var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left, width = _a.width;
                this._offset = { x: event.clientX - left, y: event.clientY - top };
                // inline all styles so it looks identical regardless of its position in the DOM
                this.inlineStyles(this._elementRef.nativeElement, this._clone);
                // IE doesn't always calculate the correct width value using getComputedStyles... use bounding client value instead
                this._renderer.setStyle(this._clone, 'width', width + 'px');
                // ensure we can easily position the node an it is above all other elements
                this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
                this._renderer.setStyle(this._clone, 'position', 'absolute');
                this._renderer.setStyle(this._clone, 'z-index', '99999');
                // apply a class to allow custom styling
                this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
                // insert the cloned element
                this._renderer.appendChild(document.body, this._clone);
                // set the cloned element initial position
                this.updateNodePosition(event);
            };
        /** Position the clone relative to the mouse */
        /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.updateNodePosition = /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
                this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
            };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        DragDirective.prototype.inlineStyles = /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // get all the computed styles from the source element
                /** @type {?} */
                var styles = getComputedStyle(source);
                // inline every specified style
                for (var idx = 0; idx < styles.length; idx++) {
                    /** @type {?} */
                    var style = styles.item(idx);
                    if (style !== undefined) {
                        this._renderer.setStyle(target, styles[idx], styles[style]);
                    }
                }
                // ensure we dont capture any move events
                this._renderer.setStyle(target, 'pointer-events', 'none');
                // do the same for all the child elements
                for (var idx = 0; idx < source.children.length; idx++) {
                    this.inlineStyles(source.children[idx], target.children[idx]);
                }
            };
        /** Unsubscribe from all subscriptions */
        /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
        DragDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        DragDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxDrag]'
                    },] }
        ];
        /** @nocollapse */
        DragDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.NgZone },
                { type: i0.Renderer2 },
                { type: DragService }
            ];
        };
        DragDirective.propDecorators = {
            clone: [{ type: i0.Input }],
            group: [{ type: i0.Input }],
            model: [{ type: i0.Input }],
            draggable: [{ type: i0.Input }],
            onDragStart: [{ type: i0.Output }],
            onDrag: [{ type: i0.Output }],
            onDragEnd: [{ type: i0.Output }],
            onDrop: [{ type: i0.Output }],
            onDropEnter: [{ type: i0.Output }],
            onDropLeave: [{ type: i0.Output }]
        };
        return DragDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DropDirective = /** @class */ (function () {
        function DropDirective(_dragService) {
            var _this = this;
            this._dragService = _dragService;
            /**
             * Define whether or not dropping is enabled
             */
            this.dropDisabled = false;
            /**
             * Emit the model of the item dropped
             */
            this.onDrop = new i0.EventEmitter();
            /**
             * Determine whether or not the mouse is within the drop region
             */
            this.isMouseOver = false;
            /**
             * Determine whether or not we are currently dragging an item
             */
            this.isDragging = false;
            /**
             * Ensure we destroy all subscriptions
             */
            this._onDestroy = new rxjs.Subject();
            // subscribe to drag events
            _dragService.onDragStart.pipe(operators.tap(function (event) { return _this._group = event.group; }), operators.filter(function (event) { return _this.isDropAllowed(event.group); }), operators.takeUntil(this._onDestroy))
                .subscribe(this.onDragStart.bind(this));
            _dragService.onDragEnd.pipe(operators.filter(function (event) { return _this.isDropAllowed(event.group); }), operators.takeUntil(this._onDestroy))
                .subscribe(this.onDragEnd.bind(this));
        }
        /**
         * @return {?}
         */
        DropDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseOver = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                if (this.isDropAllowed(this._group)) {
                    this.isMouseOver = true;
                    // emit that we are over a drop area
                    this._dragService.onDropEnter.next();
                }
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseLeave = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                // always ensure this value is reset
                this.isMouseOver = false;
                // only emit the dropd leave event when appropriate
                if (this.isDropAllowed(this._group)) {
                    this._dragService.onDropLeave.next();
                }
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @return {?}
         */
        DropDirective.prototype.onDragStart = /**
         * Update the dragging state
         * @return {?}
         */
            function () {
                this.isDragging = true;
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
        DropDirective.prototype.onDragEnd = /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // update the dragging state
                this.isDragging = false;
                // clear the cached group
                this._group = null;
                // if the mouse is over and it is in an allowed group emit the dop event
                if (this.isMouseOver && this.isDropAllowed(event.group)) {
                    this.onDrop.emit(event.data);
                    this._dragService.onDrop.next(event.data);
                }
            };
        /** Determine whether or not the event is part of the specified groups */
        /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
        DropDirective.prototype.isDropAllowed = /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
            function (group) {
                // if dropping is disabled then it is never allowed
                if (this.dropDisabled) {
                    return false;
                }
                // if no group specified allow all groups
                if (!this.group) {
                    return true;
                }
                // if it is an array then ensure it is allowed
                if (Array.isArray(this.group)) {
                    return !!this.group.find(function (_group) { return _group === group; });
                }
                return this.group === group;
            };
        DropDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxDrop]',
                        host: {
                            '[class.ux-drop-hover]': 'isMouseOver && isDragging && !dropDisabled'
                        }
                    },] }
        ];
        /** @nocollapse */
        DropDirective.ctorParameters = function () {
            return [
                { type: DragService }
            ];
        };
        DropDirective.propDecorators = {
            group: [{ type: i0.Input }],
            dropDisabled: [{ type: i0.Input }],
            onDrop: [{ type: i0.Output }],
            onMouseOver: [{ type: i0.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: i0.HostListener, args: ['mouseleave',] }]
        };
        return DropDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DragModule = /** @class */ (function () {
        function DragModule() {
        }
        DragModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [DragDirective, DropDirective],
                        declarations: [DragDirective, DropDirective],
                        providers: [DragService]
                    },] }
        ];
        return DragModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var DashboardStackMode = {
        Regular: 0,
        Stacked: 1,
        /** Determine the mode automatically based on dashboard width. */
        Auto: 2,
    };
    DashboardStackMode[DashboardStackMode.Regular] = 'Regular';
    DashboardStackMode[DashboardStackMode.Stacked] = 'Stacked';
    DashboardStackMode[DashboardStackMode.Auto] = 'Auto';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardService = /** @class */ (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new rxjs.BehaviorSubject([]);
            this.options$ = new rxjs.BehaviorSubject(defaultOptions);
            this.dimensions$ = new rxjs.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(tick(), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new rxjs.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new rxjs.Subject();
            this.stacked$ = new rxjs.BehaviorSubject(false);
            this.isDragging$ = new rxjs.BehaviorSubject(null);
            this.isGrabbing$ = new rxjs.BehaviorSubject(null);
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
            this.layout$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: /**
             * @return {?}
             */ function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: /**
             * @return {?}
             */ function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DashboardService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
        DashboardService.prototype.addWidget = /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
            };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
        DashboardService.prototype.removeWidget = /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
            };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
        DashboardService.prototype.setDimensions = /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
            function (width, height) {
                if (width === void 0) {
                    width = this.dimensions.width;
                }
                if (height === void 0) {
                    height = this.dimensions.height;
                }
                if (this.dimensions.width !== width || this.dimensions.height !== height) {
                    this.dimensions$.next({ width: width, height: height });
                }
            };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
        DashboardService.prototype.getLayoutData = /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
            function () {
                return this.widgets.map(function (widget) {
                    return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
                });
            };
        /**
         * Position widgets programatically
         */
        /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
        DashboardService.prototype.setLayoutData = /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
            function (widgets) {
                var _this = this;
                // iterate through each widget data and find a match
                widgets.forEach(function (widget) {
                    // find the matching widget
                    /** @type {?} */
                    var target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                    if (target) {
                        target.setColumn(widget.col);
                        target.setRow(widget.row);
                        target.setColumnSpan(widget.colSpan);
                        target.setRowSpan(widget.rowSpan);
                    }
                });
            };
        /**
         * Update the positions and sizes of the widgets
         */
        /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
        DashboardService.prototype.renderDashboard = /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
            function () {
                var _this = this;
                // get the dimensions of the dashboard
                this._rowHeight = this.options.rowHeight || this.columnWidth;
                // ensure the column width is not below the min widths
                this.stacked$.next(this.columnWidth < this.options.minWidth);
                // ensure the row height is not below the min widths
                if (this._rowHeight < this.options.minWidth) {
                    this._rowHeight = this.options.minWidth;
                }
                this.setDashboardLayout();
                // iterate through each widget and set the size - except the one being resized
                this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                    .forEach(function (widget) { return widget.render(); });
            };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
        DashboardService.prototype.setDashboardLayout = /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
            function () {
                var _this = this;
                // find any widgets that do not currently have a position set
                this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                    .forEach(function (widget) { return _this.setWidgetPosition(widget); });
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.updateWhenStacked = /**
         * @return {?}
         */
            function () {
                // iterate through each widget set it's stacked state and retain the rowSpan
                this.getWidgetsByOrder().forEach(function (widget, idx, widgets) {
                    /** @type {?} */
                    var widgetsAbove = widgets.slice(0, idx);
                    /** @type {?} */
                    var row = widgetsAbove.reduce(function (currentRow, _widget) { return currentRow + _widget.getRowSpan(); }, 0);
                    widget.setColumn(0);
                    widget.setRow(row);
                });
            };
        /** Get widgets in the order they visually appear as the widgets array order does not reflect this */
        /**
         * Get widgets in the order they visually appear as the widgets array order does not reflect this
         * @return {?}
         */
        DashboardService.prototype.getWidgetsByOrder = /**
         * Get widgets in the order they visually appear as the widgets array order does not reflect this
         * @return {?}
         */
            function () {
                var _this = this;
                return __spread(this.widgets).sort(function (w1, w2) {
                    /** @type {?} */
                    var w1Position = w1.getColumn(DashboardStackMode.Regular) + (w1.getRow(DashboardStackMode.Regular) * _this.options.columns);
                    /** @type {?} */
                    var w2Position = w2.getColumn(DashboardStackMode.Regular) + (w2.getRow(DashboardStackMode.Regular) * _this.options.columns);
                    if (w1Position < w2Position) {
                        return -1;
                    }
                    if (w1Position > w2Position) {
                        return 1;
                    }
                    return 0;
                });
            };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
        DashboardService.prototype.setWidgetPosition = /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
            function (widget) {
                // find a position for the widget
                /** @type {?} */
                var position = 0;
                /** @type {?} */
                var success = false;
                // repeat until a space is found
                while (!success) {
                    // get a position to try
                    /** @type {?} */
                    var column = position % this.options.columns;
                    /** @type {?} */
                    var row = Math.floor(position / this.options.columns);
                    // check the current position
                    if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                        success = true;
                        widget.setColumn(column);
                        widget.setRow(row);
                        return;
                    }
                    if (column === 0 && widget.colSpan > this.options.columns) {
                        throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                    }
                    position++;
                }
            };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
        DashboardService.prototype.getPositionAvailable = /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
            function (column, row, columnSpan, rowSpan, ignoreWidget) {
                // get a list of grid spaces that are populated
                /** @type {?} */
                var spaces = this.getOccupiedSpaces();
                // check if the block would still be in bounds
                if (column + columnSpan > this.options.columns) {
                    return false;
                }
                var _loop_1 = function (x) {
                    var _loop_2 = function (y) {
                        if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                            return { value: false };
                        }
                    };
                    for (var y = row; y < row + rowSpan; y++) {
                        var state_2 = _loop_2(y);
                        if (typeof state_2 === "object")
                            return state_2;
                    }
                };
                // check each required position
                for (var x = column; x < column + columnSpan; x++) {
                    var state_1 = _loop_1(x);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
                return true;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getOccupiedSpaces = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all spaces that are currently occupied
                return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                    .reduce(function (value, widget) {
                    _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                    return value;
                }, []);
            };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
        DashboardService.prototype.onResizeStart = /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
            function (action) {
                // store the mouse event
                this._event = action.event;
                this._actionWidget = action;
                // bring the widget to the font
                this.bringToFront(action.widget);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onResizeDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                /** @type {?} */
                var mousePosX = this._event.pageX - pageXOffset;
                /** @type {?} */
                var mousePosY = this._event.pageY - pageYOffset;
                // if there was no movement then do nothing
                if (action.event.x === mousePosX && action.event.y === mousePosY) {
                    return;
                }
                // update the stored mouse event
                this._event = action.event;
                // get handle for direction
                var handle = action.handle;
                // get the bounds of the handle
                /** @type {?} */
                var bounds = handle.getBoundingClientRect();
                // get the center of the handle
                /** @type {?} */
                var centerX = bounds.left + (bounds.width / 2);
                /** @type {?} */
                var centerY = bounds.top + (bounds.height / 2);
                // get the current mouse position
                /** @type {?} */
                var mouseX = mousePosX - centerX;
                /** @type {?} */
                var mouseY = mousePosY - centerY;
                // store the new proposed dimensions for the widget
                /** @type {?} */
                var dimensions = {
                    x: action.widget.x,
                    y: action.widget.y,
                    width: action.widget.width,
                    height: action.widget.height
                };
                // update widget based on the handle being dragged
                switch (action.direction) {
                    case ActionDirection.Right:
                        dimensions.width += mouseX;
                        break;
                    case ActionDirection.Left:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            /** @type {?} */
                            var difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.Bottom:
                        dimensions.height += mouseY;
                        break;
                    case ActionDirection.Top:
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            /** @type {?} */
                            var difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    // Support resizing on multiple axis simultaneously
                    case ActionDirection.TopLeft:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            /** @type {?} */
                            var difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            /** @type {?} */
                            var difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.TopRight:
                        dimensions.width += mouseX;
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            /** @type {?} */
                            var difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.BottomLeft:
                        dimensions.height += mouseY;
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            /** @type {?} */
                            var difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.BottomRight:
                        dimensions.height += mouseY;
                        dimensions.width += mouseX;
                        break;
                }
                /** @type {?} */
                var currentWidth = action.widget.x + action.widget.width;
                /** @type {?} */
                var currentHeight = action.widget.y + action.widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                    dimensions.width = this.dimensions.width - dimensions.x;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.options.minWidth) {
                    dimensions.x = action.widget.x;
                    dimensions.width = this.options.minWidth;
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.options.minHeight) {
                    dimensions.y = action.widget.y;
                    dimensions.height = this.options.minHeight;
                }
                // update the widget actual values
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.updateWidgetPositions(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onResizeEnd = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                // commit resize changes
                this.commitWidgetChanges();
                // hide placeholder
                placeholder.visible = false;
                // update the placeholder
                this.placeholder$.next(placeholder);
                this._actionWidget = null;
                this._event = null;
                // ensure any vacant upper spaces are filled where required
                this.shiftWidgetsUp();
                // update dashboard height
                this.setDashboardHeight();
                // emit information about the layout
                this.layout$.next(this.getLayoutData());
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDragStart = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this.onResizeStart(action);
                // store the starting placeholder position
                this.setWidgetOrigin();
                this.cacheWidgets();
                // emit the widget we are dragging
                this.isDragging$.next(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onDragEnd = /**
         * @return {?}
         */
            function () {
                this.onResizeEnd();
                this._widgetOrigin = {};
                this.isDragging$.next(null);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                // if there was no movement then do nothing
                if (action.event.pageX === this._event.pageX && action.event.pageY === this._event.pageY) {
                    return;
                }
                // get the current mouse position
                /** @type {?} */
                var mouseX = action.event.pageX - this._event.pageX;
                /** @type {?} */
                var mouseY = action.event.pageY - this._event.pageY;
                // store the latest event
                this._event = action.event;
                /** @type {?} */
                var dimensions = {
                    x: action.widget.x + mouseX,
                    y: action.widget.y + mouseY,
                    width: action.widget.width,
                    height: action.widget.height
                };
                this.restoreWidgets(true);
                // update widget position
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getRowHeight = /**
         * @return {?}
         */
            function () {
                return this._rowHeight;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.cacheWidgets = /**
         * @return {?}
         */
            function () {
                this._cache = this.widgets.map(function (widget) {
                    return ({
                        id: widget.id,
                        column: widget.getColumn(),
                        row: widget.getRow(),
                        columnSpan: widget.getColumnSpan(),
                        rowSpan: widget.getRowSpan(),
                    });
                });
                // return a new array of the cache for custom caching
                return __spread(this._cache);
            };
        /**
         * @param {?=} ignoreActionWidget
         * @param {?=} cache
         * @param {?=} restoreSize
         * @return {?}
         */
        DashboardService.prototype.restoreWidgets = /**
         * @param {?=} ignoreActionWidget
         * @param {?=} cache
         * @param {?=} restoreSize
         * @return {?}
         */
            function (ignoreActionWidget, cache, restoreSize) {
                var _this = this;
                if (ignoreActionWidget === void 0) {
                    ignoreActionWidget = false;
                }
                if (cache === void 0) {
                    cache = this._cache;
                }
                if (restoreSize === void 0) {
                    restoreSize = false;
                }
                cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                    /** @type {?} */
                    var match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                    if (match) {
                        match.setColumn(widget.column);
                        match.setRow(widget.row);
                        if (restoreSize) {
                            match.setColumnSpan(widget.columnSpan);
                            match.setRowSpan(widget.rowSpan);
                        }
                    }
                });
            };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
        DashboardService.prototype.shiftWidgets = /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var widgetsToMove = [];
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                var _loop_3 = function (row) {
                    var _loop_4 = function (column) {
                        // store reference to any widgets that need moved
                        this_1.getOccupiedSpaces()
                            .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                            .forEach(function (space) { return widgetsToMove.push(space.widget); });
                    };
                    for (var column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                        _loop_4(column);
                    }
                };
                var this_1 = this;
                // check if there are any widgets under the placeholder
                for (var row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    _loop_3(row);
                }
                // remove any duplicates
                widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
                // if no widgets need moved then we can stop here
                if (widgetsToMove.length === 0) {
                    return;
                }
                // create a duplicate we can use to keep track of which have been moved
                /** @type {?} */
                var unmovedWidgets = widgetsToMove.slice();
                // attempt to move any widgets to the previous widget position
                widgetsToMove.forEach(function (widget) {
                    // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                    /** @type {?} */
                    var grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                    // iterate each free block
                    for (var row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                        for (var column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                            // determine if the block can fit in this space
                            /** @type {?} */
                            var requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                            // check if widget would fit in space
                            /** @type {?} */
                            var available = requiredSpaces.every(function (space) {
                                return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                            });
                            if (available) {
                                widget.setColumn(column);
                                widget.setRow(row);
                                unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                                return;
                            }
                        }
                    }
                    // if we get to here then we can't simply swap the positions - next try moving right
                    if (_this.canWidgetMoveRight(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Right);
                        return;
                    }
                    // next try moving left
                    if (_this.canWidgetMoveLeft(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Left);
                        return;
                    }
                    // determine the distance that the widget needs to be moved down
                    /** @type {?} */
                    var distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                    // as a last resort move the widget downwards
                    _this.moveWidgetDown(widget, distance);
                });
            };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
        DashboardService.prototype.validatePlaceholderPosition = /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
            function (shiftDirection) {
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                // check if the placeholder is over a widget
                if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                    // move the placeholder the opposite direction
                    switch (shiftDirection) {
                        case ActionDirection.Left:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                        case ActionDirection.Right:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                    }
                    // validate this new position again
                    this.validatePlaceholderPosition(shiftDirection);
                }
            };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveLeft = /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the action widget or occupies the first column
                if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                    return false;
                }
                // find the positions required
                /** @type {?} */
                var targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if any of the target spaces are out of bounds
                if (targetSpaces.find(function (space) { return space.column < 0; })) {
                    return false;
                }
                // check if there are widget in the required positions and if so, can they move right?
                /** @type {?} */
                var moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the left
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                    // find the target column
                    /** @type {?} */
                    var column = targetSpaces.reduce(function (target, space) { return Math.min(target, space.column); }, Infinity);
                    // move current widget to the left
                    if (column !== Infinity) {
                        widget.setColumn(column);
                    }
                }
                return moveable;
            };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveRight = /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the dragging widget or the widget occupies the final column
                if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                    return false;
                }
                // find the positions required
                /** @type {?} */
                var targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if any of the target spaces are out of bounds
                if (targetSpaces.find(function (space) { return space.column >= _this.getColumnCount(); })) {
                    return false;
                }
                // check if there are widget in the required positions and if so, can they move right?
                /** @type {?} */
                var moveable = targetSpaces.every(function (space) {
                    return _this.getWidgetsAtPosition(space.column, space.row)
                        .filter(function (wgt) { return wgt !== space.widget; })
                        .every(function (wgt) { return _this.canWidgetMoveRight(wgt); });
                });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() + 1);
                }
                return moveable;
            };
        /**
         * Store the initial position of the widget being dragged
         */
        /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
        DashboardService.prototype.setWidgetOrigin = /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
            function () {
                this._widgetOrigin = {
                    column: this._actionWidget.widget.getColumn(),
                    row: this._actionWidget.widget.getRow(),
                    columnSpan: this._actionWidget.widget.getColumnSpan(),
                    rowSpan: this._actionWidget.widget.getRowSpan()
                };
            };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
        DashboardService.prototype.getRequiredSpacesFromPoint = /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
            function (widget, column, row) {
                /** @type {?} */
                var spaces = [];
                for (var y = row; y < row + widget.getRowSpan(); y++) {
                    for (var x = column; x < column + widget.getColumnSpan(); x++) {
                        spaces.push({ column: x, row: y, widget: widget });
                    }
                }
                return spaces;
            };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.updateWidgetPositions = /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                var _this = this;
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                // check all spaces the placeholder will occupy and move any widget currently in them down
                for (var column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    for (var row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                        this.getWidgetsAtPosition(column, row, true)
                            .filter(function (wgt) { return wgt !== widget; })
                            .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                    }
                }
                // update the height of the dashboard
                this.setDashboardHeight();
                // if we arent dragging the top handle then fill spaces
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
        DashboardService.prototype.getWidgetsAtPosition = /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
            function (column, row, ignoreResizing) {
                var _this = this;
                if (ignoreResizing === void 0) {
                    ignoreResizing = false;
                }
                return this.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row; })
                    .filter(function (space) { return _this._actionWidget && space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                    .map(function (space) { return space.widget; });
            };
        /**
         * Update the placeholder visibility, position and size
         */
        /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.setPlaceholderBounds = /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (visible, x, y, width, height) {
                var _this = this;
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                placeholder.visible = visible;
                placeholder.column = this.getPlaceholderColumn(x, width);
                placeholder.row = this.getPlaceholderRow(y, height);
                placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
                placeholder.rowSpan = this.getPlaceholderRowSpan(height);
                // calculate the maximum number of rows
                /** @type {?} */
                var rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                    .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
                // constrain maximum placeholder row
                placeholder.row = Math.min(placeholder.row, rowCount);
                placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
                placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
                placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
                placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
                // set the values of the widget to match the values of the placeholder - however do not render the changes
                this._actionWidget.widget.setColumn(placeholder.column, false);
                this._actionWidget.widget.setRow(placeholder.row, false);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
                // update the placeholder
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the placeholder column position
         */
        /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumn = /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
            function (x, width) {
                /** @type {?} */
                var column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                /** @type {?} */
                var columnSpan = Math.floor(width / this.getColumnWidth());
                /** @type {?} */
                var upperLimit = this.getColumnCount() - columnSpan;
                // if we arent dragging left then just return the column
                if (this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(Math.min(column, upperLimit), 0);
                }
                // get any overflow
                /** @type {?} */
                var overflow = width % this.getColumnWidth();
                return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                    Math.max(Math.min(column, upperLimit), 0) :
                    Math.max(Math.min(column + 1, upperLimit), 0);
            };
        /**
         * Get the column span of the placeholder
         */
        /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumnSpan = /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
            function (width) {
                /** @type {?} */
                var columnSpan = this.getColumnFromPx(width);
                // if we arent dragging right or left then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Right &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.BottomRight &&
                    this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(columnSpan, 1);
                }
                // get the current column span and any overflow
                /** @type {?} */
                var overflow = width % this.getColumnWidth();
                return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
            };
        /**
         * Get the row position of the placeholder
         */
        /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRow = /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
            function (y, height) {
                /** @type {?} */
                var row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                /** @type {?} */
                var rowSpan = Math.ceil(height / this._rowHeight);
                // if we arent dragging up then just return the row
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    return Math.max(row, 0);
                }
                // get any overflow
                /** @type {?} */
                var overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
                return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
            };
        /**
         * Get the row span of the placeholder
         */
        /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRowSpan = /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
            function (height) {
                /** @type {?} */
                var rowSpan = this.getRowFromPx(height);
                // if we arent dragging up or down then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.Bottom &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomRight) {
                    return Math.max(rowSpan, 1);
                }
                // get the current column span and any overflow
                /** @type {?} */
                var overflow = height % this._rowHeight;
                return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
            };
        /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getColumnFromPx = /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
            function (x, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                /** @type {?} */
                var column = Math.floor(x / Math.floor(this.getColumnWidth()));
                /** @type {?} */
                var overflow = (x % Math.floor(this.getColumnWidth()));
                /** @type {?} */
                var half = this.getColumnWidth() / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return column;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? column : column + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? column + 1 : column;
                    case Rounding.RoundUp:
                        return overflow > 0 ? column + 1 : column;
                }
            };
        /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getRowFromPx = /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
            function (y, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                /** @type {?} */
                var row = Math.floor(y / Math.floor(this._rowHeight));
                /** @type {?} */
                var overflow = (y % Math.floor(this._rowHeight));
                /** @type {?} */
                var half = this._rowHeight / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return row;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? row : row + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? row + 1 : row;
                    case Rounding.RoundUp:
                        return overflow > 0 ? row + 1 : row;
                }
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.commitWidgetChanges = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var placeholder = this.placeholder$.getValue();
                // check that we have all the values we need
                if (placeholder.column === undefined || placeholder.row === undefined ||
                    placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                    return;
                }
                if (this._actionWidget) {
                    this._actionWidget.widget.setColumn(placeholder.column);
                    this._actionWidget.widget.setRow(placeholder.row);
                    this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                    this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
                }
                // reset all placeholder values
                placeholder.column = undefined;
                placeholder.row = undefined;
                placeholder.columnSpan = undefined;
                placeholder.rowSpan = undefined;
                // emit the new placeholder values
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the current column width
         */
        /**
         * Get the current column width
         * @return {?}
         */
        DashboardService.prototype.getColumnWidth = /**
         * Get the current column width
         * @return {?}
         */
            function () {
                return Math.floor(this.columnWidth);
            };
        /**
         * Calculate the number of rows populated with widgets
         */
        /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
        DashboardService.prototype.getRowCount = /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
            function () {
                return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            };
        /**
         * Set the height of the dashboard container element
         */
        /**
         * Set the height of the dashboard container element
         * @return {?}
         */
        DashboardService.prototype.setDashboardHeight = /**
         * Set the height of the dashboard container element
         * @return {?}
         */
            function () {
                // size the dashboard container to ensure all rows fit
                /** @type {?} */
                var rowCount = this.getRowCount();
                // if we should show an empty row increment the row count by 1
                if (this.options.emptyRow) {
                    rowCount++;
                }
                this.setDimensions(undefined, rowCount * this._rowHeight);
            };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
        DashboardService.prototype.bringToFront = /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
            function (widget) {
                this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
            };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
        DashboardService.prototype.moveWidgetDown = /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
            function (widget, distance) {
                var _this = this;
                if (distance === void 0) {
                    distance = 1;
                }
                // move the widget down one position
                widget.setRow((widget.getRow(DashboardStackMode.Auto)) + distance);
                // check every space the widget occupies for collisions
                this.forEachBlock(widget, function (column, row) {
                    return _this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
                });
            };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
        DashboardService.prototype.shiftWidgetsUp = /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
            function () {
                var _this = this;
                // check whether or not changes have been made - if so we need to repeat until stable
                /** @type {?} */
                var stable = true;
                // iterate each widget and
                this.widgets.forEach(function (widget) {
                    // if widget is already on the top row then do nothing
                    if (widget.getRow() === 0) {
                        return;
                    }
                    // if we are currently dragging and this is the dragging widget then skip
                    if (_this._actionWidget && _this._actionWidget.widget === widget) {
                        return;
                    }
                    if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                        widget.setRow(widget.getRow() - 1);
                        stable = false;
                    }
                });
                // if changes occurred then we should repeat the process
                if (!stable) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
        DashboardService.prototype.forEachBlock = /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
            function (widget, callback) {
                for (var row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                    for (var column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                        callback.call(widget, column, row);
                    }
                }
            };
        /**
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.getWidgetBelow = /**
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                /** @type {?} */
                var target = this.getWidgetsAtPosition(widget.getColumn(), widget.getRow() + widget.getRowSpan(), true);
                return target.length > 0 ? target[0] : null;
            };
        /**
         * Returns the number of columns available
         */
        /**
         * Returns the number of columns available
         * @return {?}
         */
        DashboardService.prototype.getColumnCount = /**
         * Returns the number of columns available
         * @return {?}
         */
            function () {
                return this.stacked ? 1 : this.options.columns;
            };
        /**
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.onShiftStart = /**
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                this.onDragStart({ direction: ActionDirection.Move, widget: widget });
            };
        /** Programmatically move a widget in a given direction */
        /**
         * Programmatically move a widget in a given direction
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardService.prototype.onShift = /**
         * Programmatically move a widget in a given direction
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                // get the current mouse position
                /** @type {?} */
                var deltaX = 0;
                /** @type {?} */
                var deltaY = 0;
                // move based on the direction
                switch (direction) {
                    case ActionDirection.Top:
                        deltaY = -this.getRowHeight();
                        break;
                    case ActionDirection.Right:
                        deltaX = this.getColumnWidth();
                        break;
                    case ActionDirection.Bottom: {
                        deltaY = this.getRowHeight();
                        break;
                    }
                    case ActionDirection.Left:
                        deltaX = -this.getColumnWidth();
                        break;
                }
                /** @type {?} */
                var dimensions = {
                    x: widget.x + deltaX,
                    y: widget.y + deltaY,
                    width: widget.width,
                    height: widget.height
                };
                // update placeholder position and value
                this.setPlaceholderBounds(false, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update widget position
                var _a = this.placeholder$.value, x = _a.x, y = _a.y;
                // move the widget to the placeholder position
                widget.setBounds(x - this.options.padding, y - this.options.padding, dimensions.width, dimensions.height);
                // update the height of the dashboard
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onShiftEnd = /**
         * @return {?}
         */
            function () {
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                // the height of the dashboard may have changed after moving widgets
                this.setDashboardHeight();
                // reset all properties
                this.onDragEnd();
            };
        /** Programmatically resize a widget in a given direction */
        /**
         * Programmatically resize a widget in a given direction
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardService.prototype.onResize = /**
         * Programmatically resize a widget in a given direction
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                // do not perform resizing if we are in stacked mode
                if (this.stacked) {
                    return;
                }
                // perform the resizing
                /** @type {?} */
                var deltaX = 0;
                /** @type {?} */
                var deltaY = 0;
                // move based on the direction
                switch (direction) {
                    case ActionDirection.Top:
                        deltaY = -this.getRowHeight();
                        break;
                    case ActionDirection.Right:
                        deltaX = this.getColumnWidth();
                        break;
                    case ActionDirection.Bottom:
                        deltaY = this.getRowHeight();
                        break;
                    case ActionDirection.Left:
                        deltaX = -this.getColumnWidth();
                        break;
                }
                /** @type {?} */
                var dimensions = {
                    x: widget.x,
                    y: widget.y,
                    width: widget.width + deltaX,
                    height: widget.height + deltaY
                };
                /** @type {?} */
                var currentWidth = widget.x + widget.width;
                /** @type {?} */
                var currentHeight = widget.y + widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.getColumnWidth() * this.getColumnCount()) {
                    dimensions.width = widget.width;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.getColumnWidth()) {
                    dimensions.x = widget.x;
                    dimensions.width = this.getColumnWidth();
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.getRowHeight()) {
                    dimensions.y = widget.y;
                    dimensions.height = this.getRowHeight();
                }
                // move the widget to the placeholder position
                widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(false, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // the height of the dashboard may have changed after moving widgets
                this.setDashboardHeight();
            };
        /**
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardService.prototype.getSurroundingWidgets = /**
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                /** @type {?} */
                var widgets = [];
                for (var column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                    switch (direction) {
                        case ActionDirection.Top:
                            widgets = __spread(widgets, this.getWidgetsAtPosition(column, widget.getRow() - 1));
                            break;
                        case ActionDirection.Bottom:
                            widgets = __spread(widgets, this.getWidgetsAtPosition(column, widget.getRow() + widget.getRowSpan()));
                            break;
                    }
                }
                return widgets;
            };
        DashboardService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DashboardService.ctorParameters = function () { return []; };
        return DashboardService;
    }());
    /** @type {?} */
    var defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    /** @enum {number} */
    var ActionDirection = {
        Top: 0,
        TopRight: 1,
        Right: 2,
        BottomRight: 3,
        Bottom: 4,
        BottomLeft: 5,
        Left: 6,
        TopLeft: 7,
        Move: 8,
    };
    ActionDirection[ActionDirection.Top] = 'Top';
    ActionDirection[ActionDirection.TopRight] = 'TopRight';
    ActionDirection[ActionDirection.Right] = 'Right';
    ActionDirection[ActionDirection.BottomRight] = 'BottomRight';
    ActionDirection[ActionDirection.Bottom] = 'Bottom';
    ActionDirection[ActionDirection.BottomLeft] = 'BottomLeft';
    ActionDirection[ActionDirection.Left] = 'Left';
    ActionDirection[ActionDirection.TopLeft] = 'TopLeft';
    ActionDirection[ActionDirection.Move] = 'Move';
    /** @enum {number} */
    var Rounding = {
        RoundDown: 0,
        RoundDownBelowHalf: 1,
        RoundUp: 2,
        RoundUpOverHalf: 3,
    };
    Rounding[Rounding.RoundDown] = 'RoundDown';
    Rounding[Rounding.RoundDownBelowHalf] = 'RoundDownBelowHalf';
    Rounding[Rounding.RoundUp] = 'RoundUp';
    Rounding[Rounding.RoundUpOverHalf] = 'RoundUpOverHalf';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardWidgetComponent = /** @class */ (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            /**
             * Defines the number of columns this widget should occupy.
             */
            this.colSpan = 1;
            /**
             * Defines the number of rows this widget should occupy.
             */
            this.rowSpan = 1;
            /**
             * Defines whether or not this widget can be resized.
             */
            this.resizable = false;
            /**
             * Defines a function that returns an aria label for the widget
             */
            this.widgetAriaLabel = this.getDefaultAriaLabel;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this.isDragging = false;
            this.isGrabbing = false;
            this.isResizing = false;
            this.isDraggable = false;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._onDestroy = new rxjs.Subject();
            // subscribe to option changes
            dashboardService.options$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.update(); });
            // every time the layout changes we want to update the aria label
            dashboardService.layout$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.ariaLabel = _this.getAriaLabel(); });
            // allow widget movements to be animated
            dashboardService.isDragging$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return widget === _this; }))
                .subscribe(function (isDragging) { return _this.isDragging = isDragging; });
            // allow widget movements to be animated
            dashboardService.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return widget === _this; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._columnSpan.regular = this.colSpan;
                this._rowSpan.regular = this.rowSpan;
                this._rowSpan.stacked = this.rowSpan;
                if (!this.id) {
                    console.warn('Dashboard Widget is missing an ID.');
                    // set random id - keeps things working but prevents exporting of positions
                    this.id = Math.floor(Math.random() * 100000).toString();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // add the widget to the dashboard
                this.dashboardService.addWidget(this);
                // apply the current options
                this.update();
            };
        /**
         * If component is removed, then unregister it from the service
         */
        /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnDestroy = /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this.dashboardService.removeWidget(this);
            };
        /**
         * Apply the current dashboard options
         */
        /**
         * Apply the current dashboard options
         * @return {?}
         */
        DashboardWidgetComponent.prototype.update = /**
         * Apply the current dashboard options
         * @return {?}
         */
            function () {
                // get the current options at the time
                var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
                this.padding = padding;
                this._columnSpan.stacked = columns;
            };
        /**
         * Set the actual position and size values
         */
        /**
         * Set the actual position and size values
         * @return {?}
         */
        DashboardWidgetComponent.prototype.render = /**
         * Set the actual position and size values
         * @return {?}
         */
            function () {
                this.x = this.getColumn() * this.dashboardService.getColumnWidth();
                this.y = this.getRow() * this.dashboardService.getRowHeight();
                this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
                this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
            };
        /**
         * @param {?=} mode
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumn = /**
         * @param {?=} mode
         * @return {?}
         */
            function (mode) {
                if (mode === void 0) {
                    mode = DashboardStackMode.Auto;
                }
                switch (mode) {
                    case DashboardStackMode.Auto:
                        return this.getStackableValue(this._column);
                    case DashboardStackMode.Regular:
                        return this._column.regular;
                    case DashboardStackMode.Stacked:
                        return this._column.stacked;
                }
            };
        /**
         * @param {?=} mode
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRow = /**
         * @param {?=} mode
         * @return {?}
         */
            function (mode) {
                if (mode === void 0) {
                    mode = DashboardStackMode.Auto;
                }
                switch (mode) {
                    case DashboardStackMode.Auto:
                        return this.getStackableValue(this._row);
                    case DashboardStackMode.Regular:
                        return this._row.regular;
                    case DashboardStackMode.Stacked:
                        return this._row.stacked;
                }
            };
        /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumn = /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
            function (column, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._column, column);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRow = /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
            function (row, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._row, row);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumnSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._columnSpan);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRowSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._rowSpan);
            };
        /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumnSpan = /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
            function (columnSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._columnSpan, columnSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRowSpan = /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
            function (rowSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._rowSpan, rowSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.bringToFront = /**
         * @return {?}
         */
            function () {
                this.zIndex = 1;
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.sendToBack = /**
         * @return {?}
         */
            function () {
                this.zIndex = 0;
            };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setBounds = /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragstart = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.isResizing = true;
                this.dashboardService.isGrabbing$.next(null);
                this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.drag = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragend = /**
         * @return {?}
         */
            function () {
                this.isResizing = false;
                this.dashboardService.onResizeEnd();
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getAriaLabel = /**
         * @return {?}
         */
            function () {
                if (this.widgetAriaLabel && typeof this.widgetAriaLabel === 'string') {
                    return this.widgetAriaLabel;
                }
                else if (this.widgetAriaLabel && typeof this.widgetAriaLabel === 'function') {
                    return this.widgetAriaLabel(this);
                }
                return this.ariaLabel;
            };
        /**
         * @param {?} widget
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getDefaultAriaLabel = /**
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                /** @type {?} */
                var options = '';
                if (widget.resizable && widget.isDraggable) {
                    options = 'It can be moved and resized.';
                }
                else if (widget.resizable) {
                    options = 'It can be resized.';
                }
                else if (widget.isDraggable) {
                    options = 'It can be moved.';
                }
                return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. " + options;
            };
        /**
         * Allows automatic setting of stackable value
         * @param property The current StackableValue object
         * @param value The value to set in the appropriate field
         */
        /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setStackableValue = /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
            function (property, value) {
                if (this.dashboardService.stacked) {
                    property.stacked = value;
                }
                else {
                    property.regular = value;
                }
            };
        /**
         * Return the appropriate value from a stackable value
         * @param property The Stackable value object
         */
        /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getStackableValue = /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
            function (property) {
                return this.dashboardService.stacked ? property.stacked : property.regular;
            };
        DashboardWidgetComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-dashboard-widget',
                        template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag\n     #handleTop\n     class=\"resizer-handle handle-top\"\n     (onDragStart)=\"dragstart(handleTop, $event, 0)\"\n     (onDrag)=\"drag(handleTop, $event, 0)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleTopRight\n     class=\"resizer-handle handle-top-right\"\n     (onDragStart)=\"dragstart(handleTopRight, $event, 1)\"\n     (onDrag)=\"drag(handleTopRight, $event, 1)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleRight\n     class=\"resizer-handle handle-right\"\n     (onDragStart)=\"dragstart(handleRight, $event, 2)\"\n     (onDrag)=\"drag(handleRight, $event, 2)\"\n     (onDragEnd)=\"dragend()\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottomRight\n     class=\"resizer-handle handle-bottom-right\"\n     (onDragStart)=\"dragstart(handleBottomRight, $event, 3)\"\n     (onDrag)=\"drag(handleBottomRight, $event, 3)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottom\n     class=\"resizer-handle handle-bottom\"\n     (onDragStart)=\"dragstart(handleBottom, $event, 4)\"\n     (onDrag)=\"drag(handleBottom, $event, 4)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleBottomLeft\n     class=\"resizer-handle handle-bottom-left\"\n     (onDragStart)=\"dragstart(handleBottomLeft, $event, 5)\"\n     (onDrag)=\"drag(handleBottomLeft, $event, 5)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleLeft\n     class=\"resizer-handle handle-left\"\n     (onDragStart)=\"dragstart(handleLeft, $event, 6)\"\n     (onDrag)=\"drag(handleLeft, $event, 6)\"\n     (onDragEnd)=\"dragend()\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleTopLeft\n     class=\"resizer-handle handle-top-left\"\n     (onDragStart)=\"dragstart(handleTopLeft, $event, 7)\"\n     (onDrag)=\"drag(handleTopLeft, $event, 7)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                    }] }
        ];
        /** @nocollapse */
        DashboardWidgetComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardWidgetComponent.propDecorators = {
            id: [{ type: i0.Input }],
            name: [{ type: i0.Input }],
            col: [{ type: i0.Input }],
            row: [{ type: i0.Input }],
            colSpan: [{ type: i0.Input }],
            rowSpan: [{ type: i0.Input }],
            resizable: [{ type: i0.Input }],
            widgetAriaLabel: [{ type: i0.Input }],
            x: [{ type: i0.HostBinding, args: ['style.left.px',] }],
            y: [{ type: i0.HostBinding, args: ['style.top.px',] }],
            width: [{ type: i0.HostBinding, args: ['style.width.px',] }],
            height: [{ type: i0.HostBinding, args: ['style.height.px',] }],
            padding: [{ type: i0.HostBinding, args: ['style.padding.px',] }],
            zIndex: [{ type: i0.HostBinding, args: ['style.z-index',] }],
            ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
            isDragging: [{ type: i0.HostBinding, args: ['class.dragging',] }],
            isGrabbing: [{ type: i0.HostBinding, args: ['class.grabbing',] }],
            isResizing: [{ type: i0.HostBinding, args: ['class.resizing',] }]
        };
        return DashboardWidgetComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardGrabHandleService = /** @class */ (function () {
        function DashboardGrabHandleService(_dashboard) {
            var _this = this;
            this._dashboard = _dashboard;
            /**
             * Self-registered drag handles in the dashboard.
             */
            this._handles = [];
            /**
             * Automatically unsubscribe from all observables when destroyed
             */
            this._onDestroy = new rxjs.Subject();
            // if a drag is performed by the mouse we should update the focusable item to be the first again
            _dashboard.layout$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return !_this._dashboard.isGrabbing$.value; }))
                .subscribe(function () { return _this.setFirstItemFocusable(); });
        }
        /** Perform unsubscriptions */
        /**
         * Perform unsubscriptions
         * @return {?}
         */
        DashboardGrabHandleService.prototype.ngOnDestroy = /**
         * Perform unsubscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Register a new grab handle. */
        /**
         * Register a new grab handle.
         * @param {?} handle
         * @return {?}
         */
        DashboardGrabHandleService.prototype.addHandle = /**
         * Register a new grab handle.
         * @param {?} handle
         * @return {?}
         */
            function (handle) {
                var _this = this;
                this._handles = this.getHandlesInOrder(__spread(this._handles, [handle]));
                // we want to make the first item focusable (raf to avoid expression changed error)
                requestAnimationFrame(function () { return _this.ensureFocusable(); });
            };
        /** Unregister a removed grab handle. */
        /**
         * Unregister a removed grab handle.
         * @param {?} handle
         * @return {?}
         */
        DashboardGrabHandleService.prototype.removeHandle = /**
         * Unregister a removed grab handle.
         * @param {?} handle
         * @return {?}
         */
            function (handle) {
                this._handles = this._handles.filter(function (h) { return h !== handle; });
                // Make sure there is still a focusable handle
                this.ensureFocusable();
            };
        /** Make the first visual item in the list focusable */
        /**
         * Make the first visual item in the list focusable
         * @return {?}
         */
        DashboardGrabHandleService.prototype.setFirstItemFocusable = /**
         * Make the first visual item in the list focusable
         * @return {?}
         */
            function () {
                this.setItemFocus(0, false);
            };
        /** Set an item at a given index focused */
        /**
         * Set an item at a given index focused
         * @param {?} index
         * @param {?=} focusElement
         * @return {?}
         */
        DashboardGrabHandleService.prototype.setItemFocus = /**
         * Set an item at a given index focused
         * @param {?} index
         * @param {?=} focusElement
         * @return {?}
         */
            function (index, focusElement) {
                if (focusElement === void 0) {
                    focusElement = true;
                }
                // if the list is empty then do nothing
                if (!this._handles || this._handles.length === 0) {
                    return;
                }
                // check if the index is out of bounds
                if (index < 0) {
                    return this.setItemFocus(0);
                }
                if (index > this._handles.length - 1) {
                    return this.setItemFocus(this._handles.length - 1);
                }
                // try focusing a specific index
                this.getHandlesInOrder().forEach(function (handle, idx) { return idx === index ? handle.focus(focusElement) : handle.blur(); });
                // for safety we want to ensure one of the items is definitely still focusabled
                this.ensureFocusable();
            };
        /** Focus the previous grab handle */
        /**
         * Focus the previous grab handle
         * @param {?} handle
         * @return {?}
         */
        DashboardGrabHandleService.prototype.setPreviousItemFocus = /**
         * Focus the previous grab handle
         * @param {?} handle
         * @return {?}
         */
            function (handle) {
                this.setItemFocus(this.getHandleIndex(handle) - 1);
            };
        /** Focus the next grab handle */
        /**
         * Focus the next grab handle
         * @param {?} handle
         * @return {?}
         */
        DashboardGrabHandleService.prototype.setNextItemFocus = /**
         * Focus the next grab handle
         * @param {?} handle
         * @return {?}
         */
            function (handle) {
                this.setItemFocus(this.getHandleIndex(handle) + 1);
            };
        /** Focus the grab handle on the widget above */
        /**
         * Focus the grab handle on the widget above
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardGrabHandleService.prototype.setSiblingItemFocus = /**
         * Focus the grab handle on the widget above
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                var _this = this;
                // find all widgets that are directly above and have grab handles
                /** @type {?} */
                var target = this._dashboard.getSurroundingWidgets(widget, direction)
                    .map(function (_widget) { return _this._handles.find(function (handle) { return handle.widget === _widget; }); })
                    .filter(function (handle) { return !!handle; })
                    .reduce(function (handle, current) { return !handle || current.widget.getColumn() > handle.widget.getColumn() ? current : handle; }, null);
                // ensure we have a target before focusing
                if (!target) {
                    return;
                }
                // get the index of the target handle
                /** @type {?} */
                var index = this.getHandleIndex(target);
                // focus the item
                this.setItemFocus(index);
            };
        /** Get handles in the order they appear rather than the order they are in the DOM */
        /**
         * Get handles in the order they appear rather than the order they are in the DOM
         * @param {?=} handles
         * @return {?}
         */
        DashboardGrabHandleService.prototype.getHandlesInOrder = /**
         * Get handles in the order they appear rather than the order they are in the DOM
         * @param {?=} handles
         * @return {?}
         */
            function (handles) {
                if (handles === void 0) {
                    handles = this._handles;
                }
                /** @type {?} */
                var widgets = this._dashboard.getWidgetsByOrder();
                // sort the handles according to the position of the widget it belongs to
                return handles.sort(function (handleOne, handleTwo) { return widgets.indexOf(handleOne.widget) - widgets.indexOf(handleTwo.widget); });
            };
        /**
         * @param {?} handle
         * @return {?}
         */
        DashboardGrabHandleService.prototype.getHandleIndex = /**
         * @param {?} handle
         * @return {?}
         */
            function (handle) {
                return this.getHandlesInOrder().findIndex(function (_handle) { return _handle === handle; });
            };
        /** If the current focusable handle is removed we need to make another one focusable */
        /**
         * If the current focusable handle is removed we need to make another one focusable
         * @return {?}
         */
        DashboardGrabHandleService.prototype.ensureFocusable = /**
         * If the current focusable handle is removed we need to make another one focusable
         * @return {?}
         */
            function () {
                if (!this._handles.find(function (handle) { return handle.tabIndex === 0; })) {
                    this.setFirstItemFocusable();
                }
            };
        DashboardGrabHandleService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DashboardGrabHandleService.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        return DashboardGrabHandleService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardGrabHandleDirective = /** @class */ (function () {
        function DashboardGrabHandleDirective(widget, _dashboard, _handle, _elementRef, _announcer) {
            var _this = this;
            this.widget = widget;
            this._dashboard = _dashboard;
            this._handle = _handle;
            this._elementRef = _elementRef;
            this._announcer = _announcer;
            /**
             * Specify whether or not this handle can be used to perform moving
             */
            this.uxGrabAllowMove = true;
            /**
             * Specify whether or not this handle can be used to perform resizing
             */
            this.uxGrabAllowResize = true;
            /**
             * The aria label for the grab handle
             */
            this.uxGrabAriaLabel = this.getDefaultAriaLabel.bind(this);
            /**
             * Customize the announcement that is made whenever an item has successfully been moved or resized
             */
            this.uxGrabChangeSuccessAnnouncement = this.getChangeSuccessAnnouncement.bind(this);
            /**
             * Customize the announcement that is made whenever an item enters 'grab' mode
             */
            this.uxGrabStartAnnouncement = this.getStartAnnouncement.bind(this);
            /**
             * Customize the announcement thqt is made whenever an item cannot be moved
             */
            this.uxGrabMoveFailAnnouncement = this.getMoveFailAnnouncement.bind(this);
            /**
             * Customize the announcement thqt is made whenever an item cannot be resized
             */
            this.uxGrabResizeFailAnnouncement = this.getResizeFailAnnouncement.bind(this);
            /**
             * Customize the announcement made whenever the moving/resizing is commited
             */
            this.uxGrabConfirmAnnouncement = this.getConfirmAnnouncement.bind(this);
            /**
             * Customize the announcement made whenever the moving/resizing is cancelled
             */
            this.uxGrabCancelAnnouncement = this.getCancellationAnnouncement.bind(this);
            /**
             * We must programmatically control the focus of the drag handles
             */
            this.tabIndex = -1;
            /**
             * Store the current dragging state
             */
            this.isGrabbing = false;
            /**
             * Emit when the directive is destroyed to unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
            if (!widget) {
                throw new Error('uxDashboardGrabHandle must be used within a dashboard widget');
            }
            _handle.addHandle(this);
            // subscribe to changes to the current grab state
            _dashboard.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (_widget) { return _widget === widget; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        /** Set the initial aria label and subscribe to layout changes */
        /**
         * Set the initial aria label and subscribe to layout changes
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.ngOnInit = /**
         * Set the initial aria label and subscribe to layout changes
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.widget.name) {
                    console.warn("Dashboard widget " + this.widget.id + " must have a valid 'name' to use uxDashboardGrabHandle");
                }
                // set the initial aria label
                this.ariaLabel = this.getAnnouncement(this.uxGrabAriaLabel);
                // update the aria label when layout changes occur
                this._dashboard.layout$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.ariaLabel = _this.getAnnouncement(_this.uxGrabAriaLabel); });
            };
        /** Unsubscribe from all observables */
        /**
         * Unsubscribe from all observables
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from all observables
         * @return {?}
         */
            function () {
                this._handle.removeHandle(this);
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Begin drag mode and cache initial state */
        /**
         * Begin drag mode and cache initial state
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.enableDragMode = /**
         * Begin drag mode and cache initial state
         * @return {?}
         */
            function () {
                if (!this.isGrabbing) {
                    // cache the widgets so we can restore when escape is pressed
                    this._cache = this._lastMovement = this._dashboard.cacheWidgets();
                    // store the current widget being grabbed
                    this._dashboard.isGrabbing$.next(this.widget);
                    this._dashboard.onShiftStart(this.widget);
                    // announce the grab start
                    this._announcer.announce(this.getAnnouncement(this.uxGrabStartAnnouncement));
                }
            };
        /** Finish drag mode and commit the current state */
        /**
         * Finish drag mode and commit the current state
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.disableDragMode = /**
         * Finish drag mode and commit the current state
         * @return {?}
         */
            function () {
                if (this.isGrabbing) {
                    this._dashboard.isGrabbing$.next(null);
                    this._lastMovement = null;
                    this._dashboard.onShiftEnd();
                    // announce the confirmation
                    this._announcer.announce(this.getAnnouncement(this.uxGrabConfirmAnnouncement));
                }
            };
        /** Finish the drag mode and restore the original state */
        /**
         * Finish the drag mode and restore the original state
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.cancelDragMode = /**
         * Finish the drag mode and restore the original state
         * @return {?}
         */
            function () {
                if (this.isGrabbing) {
                    this._dashboard.onShiftEnd();
                    this._dashboard.restoreWidgets(false, this._cache, true);
                    this._dashboard.setDashboardHeight();
                    this._dashboard.layout$.next(this._dashboard.getLayoutData());
                    this._dashboard.isGrabbing$.next(null);
                    // announce the cancellation
                    this._announcer.announce(this.getAnnouncement(this.uxGrabCancelAnnouncement));
                }
            };
        /** Toggle the drag mode state */
        /**
         * Toggle the drag mode state
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.toggleDragMode = /**
         * Toggle the drag mode state
         * @return {?}
         */
            function () {
                this.isGrabbing ? this.disableDragMode() : this.enableDragMode();
            };
        /** Set the tab index and optionally focus the DOM element */
        /**
         * Set the tab index and optionally focus the DOM element
         * @param {?=} focusElement
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.focus = /**
         * Set the tab index and optionally focus the DOM element
         * @param {?=} focusElement
         * @return {?}
         */
            function (focusElement) {
                if (focusElement === void 0) {
                    focusElement = true;
                }
                this.tabIndex = 0;
                if (focusElement) {
                    this._elementRef.nativeElement.focus();
                }
            };
        /** Make this item non-tabbable */
        /**
         * Make this item non-tabbable
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.blur = /**
         * Make this item non-tabbable
         * @return {?}
         */
            function () {
                this.tabIndex = -1;
            };
        /** When the grab handle loses focus then exit 'grab' mode */
        /**
         * When the grab handle loses focus then exit 'grab' mode
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.onBlur = /**
         * When the grab handle loses focus then exit 'grab' mode
         * @return {?}
         */
            function () {
                this.disableDragMode();
            };
        /** Handle key events */
        /**
         * Handle key events
         * @param {?} event
         * @param {?} key
         * @param {?} ctrlKey
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.onKeydown = /**
         * Handle key events
         * @param {?} event
         * @param {?} key
         * @param {?} ctrlKey
         * @return {?}
         */
            function (event, key, ctrlKey) {
                switch (key) {
                    case keycodes.ESCAPE:
                        this.cancelDragMode();
                        break;
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        this.toggleDragMode();
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                    case keycodes.UP_ARROW:
                    case keycodes.RIGHT_ARROW:
                    case keycodes.DOWN_ARROW:
                    case keycodes.LEFT_ARROW:
                        if (this.isGrabbing) {
                            ctrlKey ? this.resizeWidget(event, key) : this.moveWidget(event, key);
                        }
                        else {
                            this.moveFocus(event, key);
                        }
                }
            };
        /** Get an announcement from the inputs - they may be a string or a function so handle both */
        /**
         * Get an announcement from the inputs - they may be a string or a function so handle both
         * @param {?} announcement
         * @param {...?} args
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getAnnouncement = /**
         * Get an announcement from the inputs - they may be a string or a function so handle both
         * @param {?} announcement
         * @param {...?} args
         * @return {?}
         */
            function (announcement) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return typeof announcement === 'function' ? announcement.apply(void 0, __spread([this.widget], args)) : announcement;
            };
        /** Move the widget in a given direction based on arrow keys */
        /**
         * Move the widget in a given direction based on arrow keys
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.moveWidget = /**
         * Move the widget in a given direction based on arrow keys
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
            function (event, key) {
                // check if moving is allowed
                if (!this.widget.isDraggable || !this.uxGrabAllowMove) {
                    return;
                }
                // attempt to perform the move
                this._dashboard.onShift(this.widget, this.getDirectionFromKey(key));
                // get the announcable diff
                /** @type {?} */
                var changes = this.getLayoutDiff();
                // if there were changes then announce them
                if (changes.length > 0) {
                    this._announcer.announce(this.getAnnouncement(this.uxGrabChangeSuccessAnnouncement, changes));
                }
                else {
                    this._announcer.announce(this.getAnnouncement(this.uxGrabMoveFailAnnouncement, this.getDirectionFromKey(key)));
                }
                this._lastMovement = this._dashboard.cacheWidgets();
                event.preventDefault();
                event.stopPropagation();
            };
        /** Resize the widgets accordingly based on the arrow keys */
        /**
         * Resize the widgets accordingly based on the arrow keys
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.resizeWidget = /**
         * Resize the widgets accordingly based on the arrow keys
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
            function (event, key) {
                // check if resizing is allowed
                if (!this.widget.resizable || !this.uxGrabAllowResize) {
                    return;
                }
                this._dashboard.onResize(this.widget, this.getDirectionFromKey(key));
                // get the announcable diff
                /** @type {?} */
                var changes = this.getLayoutDiff();
                // if there were changes then announce them
                if (changes.length > 0) {
                    this._announcer.announce(this.getAnnouncement(this.uxGrabChangeSuccessAnnouncement, changes));
                }
                else {
                    this._announcer.announce(this.getAnnouncement(this.uxGrabResizeFailAnnouncement, this.getDirectionFromKey(key)));
                }
                this._lastMovement = this._dashboard.cacheWidgets();
                event.preventDefault();
                event.stopPropagation();
            };
        /** Shift focus between the variour grab handles */
        /**
         * Shift focus between the variour grab handles
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.moveFocus = /**
         * Shift focus between the variour grab handles
         * @param {?} event
         * @param {?} key
         * @return {?}
         */
            function (event, key) {
                switch (key) {
                    case keycodes.UP_ARROW:
                        this._handle.setSiblingItemFocus(this.widget, ActionDirection.Top);
                        break;
                    case keycodes.RIGHT_ARROW:
                        this._handle.setNextItemFocus(this);
                        break;
                    case keycodes.DOWN_ARROW:
                        this._handle.setSiblingItemFocus(this.widget, ActionDirection.Bottom);
                        break;
                    case keycodes.LEFT_ARROW:
                        this._handle.setPreviousItemFocus(this);
                        break;
                }
                event.preventDefault();
                event.stopPropagation();
            };
        /** Convert an arrow key code into an ActionDirection enum */
        /**
         * Convert an arrow key code into an ActionDirection enum
         * @param {?} key
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getDirectionFromKey = /**
         * Convert an arrow key code into an ActionDirection enum
         * @param {?} key
         * @return {?}
         */
            function (key) {
                switch (key) {
                    case keycodes.UP_ARROW:
                        return ActionDirection.Top;
                    case keycodes.RIGHT_ARROW:
                        return ActionDirection.Right;
                    case keycodes.DOWN_ARROW:
                        return ActionDirection.Bottom;
                    case keycodes.LEFT_ARROW:
                        return ActionDirection.Left;
                }
            };
        /** Supply the default grab handle aria label based on the provided constraints */
        /**
         * Supply the default grab handle aria label based on the provided constraints
         * @param {?} widget
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getDefaultAriaLabel = /**
         * Supply the default grab handle aria label based on the provided constraints
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                if (widget.resizable && this.uxGrabAllowResize && widget.isDraggable && this.uxGrabAllowMove) {
                    return "Press space to move and resize the " + widget.name + " panel.";
                }
                else if (widget.resizable && this.uxGrabAllowResize) {
                    return "Press space to resize the " + widget.name + " panel.";
                }
                else if (widget.isDraggable && this.uxGrabAllowMove) {
                    return "Press space to move the " + widget.name + " panel.";
                }
            };
        /** Get the default announcement whenever a movement or resize was successful */
        /**
         * Get the default announcement whenever a movement or resize was successful
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getChangeSuccessAnnouncement = /**
         * Get the default announcement whenever a movement or resize was successful
         * @return {?}
         */
            function () {
                return this.getDiffAnnouncements().join(' ') + " Use the cursor keys to continue moving and resizing, enter to commit, or escape to cancel.";
            };
        /**
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getDiffAnnouncements = /**
         * @return {?}
         */
            function () {
                // map the differences to strings
                return this.getLayoutDiff().map(function (diff) {
                    /** @type {?} */
                    var changes = [];
                    // Handle movement strings
                    if (diff.isMovedHorizontally && diff.isMovedVertically) {
                        changes.push("moved to row " + diff.currentRow + ", column " + diff.currentColumn);
                    }
                    else if (diff.isMovedDown) {
                        changes.push("moved down to row " + diff.currentRow + ", column " + diff.currentColumn);
                    }
                    else if (diff.isMovedUp) {
                        changes.push("moved up to row " + diff.currentRow + ", column " + diff.currentColumn);
                    }
                    else if (diff.isMovedLeft) {
                        changes.push("moved left to row " + diff.currentRow + ", column " + diff.currentColumn);
                    }
                    else if (diff.isMovedRight) {
                        changes.push("moved right to row " + diff.currentRow + ", column " + diff.currentColumn);
                    }
                    // handle resize strings
                    if (diff.isResized) {
                        changes.push("resized to " + diff.currentColumnSpan + " columns wide and " + diff.currentRowSpan + " rows high");
                    }
                    return diff.widget.name + " panel is " + changes.join(' and ') + ".";
                });
            };
        /** Get the default announcement whenever a movement is not possible due to dashboard boundaries */
        /**
         * Get the default announcement whenever a movement is not possible due to dashboard boundaries
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getMoveFailAnnouncement = /**
         * Get the default announcement whenever a movement is not possible due to dashboard boundaries
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                switch (direction) {
                    case ActionDirection.Top:
                        return "Cannot move the " + widget.name + " panel up, because it is at the top edge of the dashboard";
                    case ActionDirection.Bottom:
                        return "Cannot move the " + widget.name + " panel down, because it is at the bottom edge of the dashboard";
                    case ActionDirection.Right:
                        return "Cannot move the " + widget.name + " panel right, because it is at the right edge of the dashboard";
                    case ActionDirection.Left:
                        return "Cannot move the " + widget.name + " panel left, because it is at the left edge of the dashboard";
                }
            };
        /** Get the default announcement whenever a resize is not possible due to either widget constraints of dashboard bounds */
        /**
         * Get the default announcement whenever a resize is not possible due to either widget constraints of dashboard bounds
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getResizeFailAnnouncement = /**
         * Get the default announcement whenever a resize is not possible due to either widget constraints of dashboard bounds
         * @param {?} widget
         * @param {?} direction
         * @return {?}
         */
            function (widget, direction) {
                switch (direction) {
                    case ActionDirection.Top:
                        return "Cannot make the " + widget.name + " panel shorter, because it is currently at its minimum height.";
                    case ActionDirection.Bottom:
                        return "Cannot make the " + widget.name + " panel taller, because it is currently at its maximum height.";
                    case ActionDirection.Right:
                        return "Cannot make the " + widget.name + " panel wider, because it is at the right edge of the dashboard.";
                    case ActionDirection.Left:
                        return "Cannot make the " + widget.name + " panel narrower, because it is currently at its minimum width.";
                }
            };
        /** Get the default announcement whenever we enter 'grab' mode */
        /**
         * Get the default announcement whenever we enter 'grab' mode
         * @param {?} widget
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getStartAnnouncement = /**
         * Get the default announcement whenever we enter 'grab' mode
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                    return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + " and is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. Use the cursor keys to move the widget and the cursor keys with the control modifier to resize the widget. Press enter to commit changes and press escape to cancel changes.";
                }
                else if (widget.isDraggable && this.uxGrabAllowMove) {
                    return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + ". Use the cursor keys to move the widget. Press enter to commit changes and press escape to cancel changes.";
                }
                else if (widget.resizable && this.uxGrabAllowResize) {
                    return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + " and is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. Use the cursor keys with the control modifier to resize the widget. Press enter to commit changes and press escape to cancel changes.";
                }
            };
        /** Get the default announcement whenever grab mode is exited after a movement or resize */
        /**
         * Get the default announcement whenever grab mode is exited after a movement or resize
         * @param {?} widget
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getConfirmAnnouncement = /**
         * Get the default announcement whenever grab mode is exited after a movement or resize
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                    return "Moving and resizing complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
                else if (widget.isDraggable && this.uxGrabAllowMove) {
                    return "Moving complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
                else if (widget.resizable && this.uxGrabAllowResize) {
                    return "Resizing complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
            };
        /** Get the default announcement whenever grab mode is exited after being cancelled */
        /**
         * Get the default announcement whenever grab mode is exited after being cancelled
         * @param {?} widget
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getCancellationAnnouncement = /**
         * Get the default announcement whenever grab mode is exited after being cancelled
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                    return "Moving and resizing cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
                else if (widget.isDraggable && this.uxGrabAllowMove) {
                    return "Moving cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
                else if (widget.resizable && this.uxGrabAllowResize) {
                    return "Resizing cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
                }
            };
        /** Get a description of all dashboard widgets, their positions and sizes */
        /**
         * Get a description of all dashboard widgets, their positions and sizes
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getDashboardAriaLabel = /**
         * Get a description of all dashboard widgets, their positions and sizes
         * @return {?}
         */
            function () {
                return "Dashboard with " + this._dashboard.options.columns + " columns, containing " + this._dashboard.widgets.length + " panels. " + this._dashboard.widgets.map(this.getWidgetAriaLabel).join(' ');
            };
        /** Get a description of a given widget */
        /**
         * Get a description of a given widget
         * @param {?} widget
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getWidgetAriaLabel = /**
         * Get a description of a given widget
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high.";
            };
        /** Get an object describing all the changes that have been made to all widgets since the last change */
        /**
         * Get an object describing all the changes that have been made to all widgets since the last change
         * @return {?}
         */
        DashboardGrabHandleDirective.prototype.getLayoutDiff = /**
         * Get an object describing all the changes that have been made to all widgets since the last change
         * @return {?}
         */
            function () {
                var _this = this;
                // find all changes
                /** @type {?} */
                var diffs = this._dashboard.getLayoutData().map(function (layout) {
                    // get the most recent cache
                    /** @type {?} */
                    var cache = _this._lastMovement || _this._cache;
                    // get the actual widget
                    /** @type {?} */
                    var widget = _this._dashboard.widgets.find(function (_widget) { return _widget.id === layout.id; });
                    // get previous position
                    /** @type {?} */
                    var previousLayout = cache.find(function (_widget) { return _widget.id === layout.id; });
                    // ensure they are all numbers
                    layout.row = Number(layout.row);
                    layout.rowSpan = Number(layout.rowSpan);
                    layout.col = Number(layout.col);
                    layout.colSpan = Number(layout.colSpan);
                    previousLayout.row = Number(previousLayout.row);
                    previousLayout.rowSpan = Number(previousLayout.rowSpan);
                    previousLayout.column = Number(previousLayout.column);
                    previousLayout.columnSpan = Number(previousLayout.columnSpan);
                    return ( /** @type {?} */({
                        widget: widget,
                        currentRow: layout.row,
                        currentColumn: layout.col,
                        currentRowSpan: layout.rowSpan,
                        currentColumnSpan: layout.colSpan,
                        previousColumn: previousLayout.column,
                        previousRow: previousLayout.row,
                        previousColumnSpan: previousLayout.columnSpan,
                        previousRowSpan: previousLayout.rowSpan,
                        isMovedLeft: layout.col < previousLayout.column,
                        isMovedRight: layout.col > previousLayout.column,
                        isMovedUp: layout.row < previousLayout.row,
                        isMovedDown: layout.row > previousLayout.row,
                        isMovedHorizontally: layout.col !== previousLayout.column,
                        isMovedVertically: layout.row !== previousLayout.row,
                        isMoved: layout.col !== previousLayout.column || layout.row !== previousLayout.row,
                        isResized: previousLayout.columnSpan !== layout.colSpan || previousLayout.rowSpan !== layout.rowSpan
                    }));
                });
                // get the order the widgets appear visually
                /** @type {?} */
                var order = this._handle.getHandlesInOrder().map(function (handle) { return handle.widget; });
                // only return items that have been repositioned or resized
                return diffs.filter(function (diff) { return diff.isMoved || diff.isResized; }).sort(function (diffOne, diffTwo) {
                    // sort this so that the item that the user moved is first in the list, and the remainder are in their new order as seen in the dashboard
                    if (diffOne.widget === _this.widget) {
                        return -1;
                    }
                    if (diffTwo.widget === _this.widget) {
                        return 1;
                    }
                    // otherwise sort based on their visual order
                    return order.indexOf(diffOne.widget) < order.indexOf(diffTwo.widget) ? -1 : 1;
                });
            };
        DashboardGrabHandleDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxDashboardGrabHandle]',
                        exportAs: 'ux-dashboard-grab-handle'
                    },] }
        ];
        /** @nocollapse */
        DashboardGrabHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent },
                { type: DashboardService },
                { type: DashboardGrabHandleService },
                { type: i0.ElementRef },
                { type: a11y.LiveAnnouncer }
            ];
        };
        DashboardGrabHandleDirective.propDecorators = {
            uxGrabAllowMove: [{ type: i0.Input }],
            uxGrabAllowResize: [{ type: i0.Input }],
            uxGrabAriaLabel: [{ type: i0.Input }],
            uxGrabChangeSuccessAnnouncement: [{ type: i0.Input }],
            uxGrabStartAnnouncement: [{ type: i0.Input }],
            uxGrabMoveFailAnnouncement: [{ type: i0.Input }],
            uxGrabResizeFailAnnouncement: [{ type: i0.Input }],
            uxGrabConfirmAnnouncement: [{ type: i0.Input }],
            uxGrabCancelAnnouncement: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
            tabIndex: [{ type: i0.HostBinding, args: ['tabIndex',] }],
            onBlur: [{ type: i0.HostListener, args: ['blur',] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event', '$event.which', '$event.ctrlKey'],] }]
        };
        return DashboardGrabHandleDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardComponent = /** @class */ (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.isGrabbing = false;
            this.customAriaLabel = this.getDefaultAriaLabel;
            /**
             * Emits when layout has been changed.
             */
            this.layoutChange = new i0.EventEmitter();
            /**
             * Ensure we unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
            dashboardService.layout$.pipe(operators.takeUntil(this._onDestroy), operators.tap(function () { return _this.ariaLabel = _this.getAriaLabel(); }))
                .subscribe(function (layout) { return _this.layoutChange.emit(layout); });
            // subscribe to changes to the grab mode
            dashboardService.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return !!widget; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            /** If defined or changed this will set the positions of the widgets within the dashboard. This is a two way binding that will be updated with the current layout when it changes. */
            set: /**
             * If defined or changed this will set the positions of the widgets within the dashboard. This is a two way binding that will be updated with the current layout when it changes.
             * @param {?} layout
             * @return {?}
             */ function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            /** Configures the options for the dashboard, if an option is not specified the default value will be used. */
            set: /**
             * Configures the options for the dashboard, if an option is not specified the default value will be used.
             * @param {?} options
             * @return {?}
             */ function (options) {
                this.dashboardService.options$.next(__assign({}, defaultOptions, options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        /**
         * Set the initial dimensions
         * @return {?}
         */
        DashboardComponent.prototype.ngAfterViewInit = /**
         * Set the initial dimensions
         * @return {?}
         */
            function () {
                // set the initial dimensions
                this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
            };
        /**
         * @return {?}
         */
        DashboardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DashboardComponent.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dashboardService.setDimensions(event.width, event.height);
            };
        /**
         * @return {?}
         */
        DashboardComponent.prototype.getAriaLabel = /**
         * @return {?}
         */
            function () {
                if (this.customAriaLabel && typeof this.customAriaLabel === 'string') {
                    return this.customAriaLabel;
                }
                else if (this.customAriaLabel && typeof this.customAriaLabel === 'function') {
                    return this.customAriaLabel(this.dashboardService.widgets, this.dashboardService.options);
                }
                return this.ariaLabel;
            };
        /**
         * @param {?} widgets
         * @param {?} options
         * @return {?}
         */
        DashboardComponent.prototype.getDefaultAriaLabel = /**
         * @param {?} widgets
         * @param {?} options
         * @return {?}
         */
            function (widgets, options) {
                return "Dashboard with " + options.columns + " columns, containing " + widgets.length + " panels. " + widgets.map(this.getWidgetAriaLabel).join(' ');
            };
        /**
         * @param {?} widget
         * @return {?}
         */
        DashboardComponent.prototype.getWidgetAriaLabel = /**
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high.";
            };
        DashboardComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-dashboard',
                        template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n\n    <!-- Wrap with ngIf so we only have one subscription rather than one for each property -->\n    <ng-container *ngIf=\"dashboardService.placeholder$ | async; let placeholder\">\n        <div class=\"position-indicator\"\n            *ngIf=\"placeholder.visible\"\n            [style.left.px]=\"placeholder.x\"\n            [style.top.px]=\"placeholder.y\"\n            [style.width.px]=\"placeholder.width\"\n            [style.height.px]=\"placeholder.height\">\n        </div>\n    </ng-container>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            DashboardService,
                            DashboardGrabHandleService
                        ]
                    }] }
        ];
        /** @nocollapse */
        DashboardComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardComponent.propDecorators = {
            customAriaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            layout: [{ type: i0.Input }],
            options: [{ type: i0.Input }],
            layoutChange: [{ type: i0.Output }],
            ariaLabel: [{ type: i0.HostBinding, args: ['attr.aria-label',] }],
            dashboardElement: [{ type: i0.ViewChild, args: ['dashboard', { static: true },] }],
            handles: [{ type: i0.ContentChildren, args: [DashboardGrabHandleDirective, { descendants: true },] }]
        };
        return DashboardComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DashboardDragHandleDirective = /** @class */ (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer, drag) {
            var _this = _super.call(this, elementRef, ngZone, renderer, drag) || this;
            // inform the widget that it can be dragged
            widget.isDraggable = true;
            _this.onDragStart.pipe(operators.takeUntil(_this._onDestroy), operators.tap(function () { return dashboardService.isGrabbing$.next(null); }))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDrag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDragEnd.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                    },] }
        ];
        /** @nocollapse */
        DashboardDragHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent },
                { type: DashboardService },
                { type: i0.ElementRef },
                { type: i0.NgZone },
                { type: i0.Renderer2 },
                { type: DragService }
            ];
        };
        return DashboardDragHandleDirective;
    }(DragDirective));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective,
        DashboardGrabHandleDirective
    ];
    var DashboardModule = /** @class */ (function () {
        function DashboardModule() {
        }
        DashboardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            common.CommonModule,
                            ResizeModule,
                            DragModule
                        ],
                        exports: DECLARATIONS,
                        declarations: DECLARATIONS,
                        providers: [DashboardService],
                    },] }
        ];
        return DashboardModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Convert a single dimension array to a double dimension array
     * @template T
     * @param {?} items the single dimension array to convert
     * @param {?} columns the number of items each array should have
     * @return {?}
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        /** @type {?} */
        var grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param {?} start the lower limit
     * @param {?} end the upper limit
     * @return {?}
     */
    function range(start, end) {
        /** @type {?} */
        var list = [];
        for (var idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param {?} start the date to start the array
     * @param {?} end the date to end the array
     * @return {?}
     */
    function dateRange(start, end) {
        // don't alter the start date object
        start = new Date(start);
        /** @type {?} */
        var dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param {?} day1 the first date to compare
     * @param {?} day2 the second date to compare
     * @return {?}
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     * @param {?} dateOne
     * @param {?} dateTwo
     * @return {?}
     */
    function dateComparator(dateOne, dateTwo) {
        if (!dateOne && dateTwo || dateOne && !dateTwo) {
            return false;
        }
        if (!dateOne && !dateTwo) {
            return true;
        }
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Calculate the number of days between two dates
     * @param {?} start The start date
     * @param {?} end The end date
     * @param {?=} fullDay Whether or not we should take from 00:00 on the start date and 23:59 on the end date
     * @return {?}
     */
    function differenceBetweenDates(start, end, fullDay) {
        if (fullDay === void 0) {
            fullDay = true;
        }
        if (!start || !end) {
            return null;
        }
        /** @type {?} */
        var millisecondsInDay = 86400000;
        /** @type {?} */
        var startDay = new Date(start.getTime() < end.getTime() ? start : end);
        /** @type {?} */
        var endDay = new Date(start.getTime() > end.getTime() ? start : end);
        // get the start of day
        if (fullDay) {
            startDay.setHours(0, 0, 0, 0);
            endDay.setHours(23, 59, 59, 0);
        }
        return Math.round((endDay.getTime() - startDay.getTime()) / millisecondsInDay);
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     * @param {?} zoneOne
     * @param {?} zoneTwo
     * @return {?}
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Get a date object with the time of the start of the given day
     * @param {?} date The date to get the start of day
     * @return {?}
     */
    function getStartOfDay(date) {
        /** @type {?} */
        var startOfDay = new Date(date);
        startOfDay.setHours(0, 0, 0, 0);
        return startOfDay;
    }
    /**
     * @param {?} date
     * @param {?} after
     * @param {?=} isEqual
     * @return {?}
     */
    function isDateAfter(date, after, isEqual) {
        if (isEqual === void 0) {
            isEqual = false;
        }
        return isEqual ? getStartOfDay(date).getTime() >= getStartOfDay(after).getTime() : getStartOfDay(date).getTime() > getStartOfDay(after).getTime();
    }
    /**
     * @param {?} date
     * @param {?} before
     * @param {?=} isEqual
     * @return {?}
     */
    function isDateBefore(date, before, isEqual) {
        if (isEqual === void 0) {
            isEqual = false;
        }
        return isEqual ? getStartOfDay(date).getTime() <= getStartOfDay(before).getTime() : getStartOfDay(date).getTime() < getStartOfDay(before).getTime();
    }
    /**
     * Export an array of all the available months
     * @type {?}
     */
    var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var ɵ0$2 = function (month) { return month.substring(0, 3); };
    /** @type {?} */
    var monthsShort = months.map(ɵ0$2);
    /**
     * Export an array of all the available days of the week
     * @type {?}
     */
    var weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var ɵ1 = function (weekday) { return weekday.substring(0, 3); };
    /** @type {?} */
    var weekdaysShort = weekdays.map(ɵ1);
    /** @type {?} */
    var meridians = ['AM', 'PM'];
    /**
     * Export the default set of time zone
     * @type {?}
     */
    var timezones = [
        { name: 'GMT-11', offset: 660 },
        { name: 'GMT-10', offset: 600 },
        { name: 'GMT-9', offset: 540 },
        { name: 'GMT-8', offset: 480 },
        { name: 'GMT-7', offset: 420 },
        { name: 'GMT-6', offset: 360 },
        { name: 'GMT-5', offset: 300 },
        { name: 'GMT-4', offset: 240 },
        { name: 'GMT-3', offset: 180 },
        { name: 'GMT-2', offset: 120 },
        { name: 'GMT-1', offset: 60 },
        { name: 'GMT', offset: 0 },
        { name: 'GMT+1', offset: -60 },
        { name: 'GMT+2', offset: -120 },
        { name: 'GMT+3', offset: -180 },
        { name: 'GMT+4', offset: -240 },
        { name: 'GMT+5', offset: -300 },
        { name: 'GMT+6', offset: -360 },
        { name: 'GMT+7', offset: -420 },
        { name: 'GMT+8', offset: -480 },
        { name: 'GMT+9', offset: -540 },
        { name: 'GMT+10', offset: -600 },
        { name: 'GMT+11', offset: -660 },
        { name: 'GMT+12', offset: -720 }
    ];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateRangeService = /** @class */ (function () {
        function DateRangeService() {
            /**
             * Indicate whether we want to show a date range
             */
            this.isRange = false;
            /**
             * Specify the direction of the selection
             */
            this.direction = DateRangePicker.Start;
            /**
             * Emit whenever the start date changes
             */
            this.onStartChange = new rxjs.Subject();
            /**
             * Emit whenever the end date changes
             */
            this.onEndChange = new rxjs.Subject();
            /**
             * Emit whenever the range has changed
             */
            this.onRangeChange = new rxjs.Subject();
            /**
             * Emit whenever the hover date changes
             */
            this.onHoverChange = new rxjs.Subject();
            /**
             * Emit whenever the range is cleared
             */
            this.onClear = new rxjs.Subject();
            /**
             * Indicate if we should show time
             */
            this.showTime = false;
            /**
             * Defines the aria label for the range start picker
             */
            this.startPickerAriaLabel = 'Selecting the start date';
            /**
             * Defines the aria label for the range end picker
             */
            this.endPickerAriaLabel = 'Selecting the end date';
            /**
             * Indicate if we are currently changing the time
             */
            this.isChangingTime = false;
            /**
             * Store the current start time
             */
            this.startTime = { hours: 0, minutes: 0, seconds: 0 };
            /**
             * Store the current end time
             */
            this.endTime = { hours: 23, minutes: 59, seconds: 59 };
        }
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangeService.prototype.setStartDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                // if the start date is after the end date the clear the end date
                if (date && this.end && isDateAfter(date, this.end)) {
                    this.clear();
                }
                this.start = date;
                this.onStartChange.next(this.start);
                this.onRangeChange.next();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangeService.prototype.setEndDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                // if the end date is before the start date the clear the start date
                if (date && this.start && isDateBefore(date, this.start)) {
                    this.clear();
                }
                this.end = date;
                this.onEndChange.next(this.end);
                this.onRangeChange.next();
            };
        /**
         * @return {?}
         */
        DateRangeService.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.setStartDate(null);
                this.setEndDate(null);
                this.onClear.next();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangeService.prototype.setDateMouseEnter = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                this.hover = date;
                this.onHoverChange.next();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangeService.prototype.setDateMouseLeave = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (date && this.hover && compareDays(date, this.hover)) {
                    this.setDateMouseEnter(null);
                }
            };
        return DateRangeService;
    }());
    /** @enum {string} */
    var DateRangePicker = {
        Start: 'start',
        End: 'end',
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateRangePickerComponent = /** @class */ (function () {
        function DateRangePickerComponent(rangeService) {
            var _this = this;
            this.rangeService = rangeService;
            /**
             * Defines whether or not the time picker should allow the user to specify seconds.
             */
            this.showSeconds = false;
            /**
             * Defines whether or not the time picker should show an AM/PM button, or time should be represented in 24hr format instead.
             */
            this.showMeridian = true;
            /**
             * Defines whether or not the time picker should allow the user to select the time using spinners.
             */
            this.showSpinners = true;
            /**
             * If defined will override the weekday names displayed.
             */
            this.weekdays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            /**
             * Specify whether or not the show now button should be visible
             */
            this.showNowBtn = false;
            /**
             * Defines the title to display above the start picker.
             */
            this.selectStartTitle = 'Select Start Date';
            /**
             * Defines the title to display above the end picker.
             */
            this.selectEndTitle = 'Select End Date';
            /**
             * Define the aria label for the now button
             */
            this.nowBtnAriaLabel = 'Set date to now';
            /**
             * Defines the list of available timezones. The `DateTimePickerTimezone` interface specifies that each timezone should
             * be an object with a `name` property that represents the timezone, eg. `GMT+2`, and an `offset` property that represents
             * the number of minutes relative to GMT the timezone is.
             */
            this.timezones = timezones;
            /**
             * Will set the selected start timezone.
             */
            this.startTimezone = this.getCurrentTimezone();
            /**
             * Will set the selected end timezone.
             */
            this.endTimezone = this.getCurrentTimezone();
            /**
             * Defines the day of the week that should appear in the first column. `WeekDay` is an enumeration available in `\@angular/common`.
             */
            this.startOfWeek = common.WeekDay.Sunday;
            /**
             * Define a function to return the number of days within the selected range
             */
            this.durationTitle = this.getDurationTitle;
            /**
             * Emit when the start date changes
             */
            this.startChange = new i0.EventEmitter();
            /**
             * Emit when the end date changes
             */
            this.endChange = new i0.EventEmitter();
            /**
             * Emit when the start timezone changes.
             */
            this.startTimezoneChange = new i0.EventEmitter();
            /**
             * Emit when the end timezone changes.
             */
            this.endTimezoneChange = new i0.EventEmitter();
            /**
             * Use an observable to debounce rapid start changes
             */
            this.startChange$ = new rxjs.Subject();
            /**
             * Use an observable to debounce rapid end changes
             */
            this.endChange$ = new rxjs.Subject();
            /**
             * Unsubscribe from all observablesprivate
             */
            this._onDestroy = new rxjs.Subject();
            this.startChange$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (date) { return _this.onStartChange(date); });
            this.endChange$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (date) { return _this.onEndChange(date); });
        }
        Object.defineProperty(DateRangePickerComponent.prototype, "start", {
            /** The selected start date to be displayed in the component. */
            set: /**
             * The selected start date to be displayed in the component.
             * @param {?} start
             * @return {?}
             */ function (start) {
                this.rangeService.start = start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "end", {
            /** The selected end date to be displayed in the component. */
            set: /**
             * The selected end date to be displayed in the component.
             * @param {?} end
             * @return {?}
             */ function (end) {
                this.rangeService.end = end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "startPickerAriaLabel", {
            /** Defines the aria label for the range start picker */
            set: /**
             * Defines the aria label for the range start picker
             * @param {?} label
             * @return {?}
             */ function (label) {
                this.rangeService.startPickerAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "endPickerAriaLabel", {
            /** Defines the aria label for the range end picker */
            set: /**
             * Defines the aria label for the range end picker
             * @param {?} label
             * @return {?}
             */ function (label) {
                this.rangeService.endPickerAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "showTime", {
            get: /**
             * @return {?}
             */ function () {
                return this.rangeService.showTime;
            },
            /** Defines whether or not the time picker should be visible. */
            set: /**
             * Defines whether or not the time picker should be visible.
             * @param {?} showTime
             * @return {?}
             */ function (showTime) {
                this.rangeService.showTime = showTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "_duration", {
            /** Calculate the number of days between the start and end date */
            get: /**
             * Calculate the number of days between the start and end date
             * @return {?}
             */ function () {
                if (this.rangeService.start && this.rangeService.end) {
                    return differenceBetweenDates(this.rangeService.start, this.rangeService.end, false);
                }
                if (this.rangeService.start && !this.rangeService.end && this.rangeService.hover) {
                    // apply the time from the time picker
                    /** @type {?} */
                    var hoverDate = new Date(this.rangeService.hover);
                    hoverDate.setHours(this.rangeService.endTime.hours, this.rangeService.endTime.minutes, this.rangeService.endTime.seconds);
                    return this.rangeService.start.getTime() <= hoverDate.getTime() ? differenceBetweenDates(this.rangeService.start, hoverDate, false) : null;
                }
                // if we only have one selected date and have a hover date
                if (this.rangeService.end && !this.rangeService.start && this.rangeService.hover) {
                    // apply the time from the time picker
                    /** @type {?} */
                    var hoverDate = new Date(this.rangeService.hover);
                    hoverDate.setHours(this.rangeService.startTime.hours, this.rangeService.startTime.minutes, this.rangeService.startTime.seconds);
                    return this.rangeService.end.getTime() >= hoverDate.getTime() ? differenceBetweenDates(this.rangeService.end, hoverDate, false) : null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateRangePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Clear the selected date range */
        /**
         * Clear the selected date range
         * @return {?}
         */
        DateRangePickerComponent.prototype.clear = /**
         * Clear the selected date range
         * @return {?}
         */
            function () {
                this.rangeService.clear();
            };
        /** Get the timezome based on the machine timezone */
        /**
         * Get the timezome based on the machine timezone
         * @return {?}
         */
        DateRangePickerComponent.prototype.getCurrentTimezone = /**
         * Get the timezome based on the machine timezone
         * @return {?}
         */
            function () {
                return this.timezones.find(function (timezone) { return timezone.offset === new Date().getTimezoneOffset(); });
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangePickerComponent.prototype.onStartChange = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                this.rangeService.setStartDate(date);
                this.startChange.emit(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateRangePickerComponent.prototype.onEndChange = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                this.rangeService.setEndDate(date);
                this.endChange.emit(date);
            };
        /** Get the text to display to indicate the duration */
        /**
         * Get the text to display to indicate the duration
         * @param {?} days
         * @return {?}
         */
        DateRangePickerComponent.prototype.getDurationTitle = /**
         * Get the text to display to indicate the duration
         * @param {?} days
         * @return {?}
         */
            function (days) {
                return days + ' ' + (days > 1 ? 'days' : 'day');
            };
        DateRangePickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-range-picker',
                        template: "<div class=\"range-header\">\n\n    <div class=\"header-section\">\n        <div *ngIf=\"!rangeService.start\" class=\"select-header\">{{ selectStartTitle }}</div>\n        <div *ngIf=\"rangeService.start\" class=\"date-header\">\n            {{ rangeService.start | formatDate: dateFormat || 'd MMMM y' }}\n        </div>\n        <div [style.visibility]=\"rangeService.start && showTime ? 'visible' : 'hidden'\" class=\"time-header\">\n            {{ rangeService.start | formatDate: timeFormat || (showMeridian ? 'shortTime' : 'HH:mm') }}\n        </div>\n    </div>\n\n    <div class=\"header-separator\">\n        <ux-icon name=\"link-next\"></ux-icon>\n        <p class=\"duration\"\n           [style.visibility]=\"_duration !== null && _duration !== undefined ? 'visible' : 'hidden'\">\n            {{ durationTitle(_duration || 0) }}\n        </p>\n    </div>\n\n    <div class=\"header-section\">\n        <div *ngIf=\"!rangeService.end\" class=\"select-header\">{{ selectEndTitle }}</div>\n        <div *ngIf=\"rangeService.end\" class=\"date-header\">\n            {{ rangeService.end | formatDate: dateFormat || 'd MMMM y'}}\n        </div>\n        <div [style.visibility]=\"rangeService.end && showTime ? 'visible' : 'hidden'\" class=\"time-header\">\n            {{ rangeService.end | formatDate: timeFormat || (showMeridian ? 'shortTime' : 'HH:mm') }}\n        </div>\n    </div>\n\n</div>\n\n<div class=\"content\">\n    <ux-date-time-picker\n        uxDateRangePicker\n        picker=\"start\"\n        class=\"start-date-picker\"\n        [date]=\"rangeService.start\"\n        (dateChange)=\"startChange$.next($event)\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [weekdays]=\"weekdays\"\n        [startOfWeek]=\"startOfWeek\"\n        [showTime]=\"showTime\"\n        [showTimezone]=\"showTimezone\"\n        [showSeconds]=\"showSeconds\"\n        [showMeridian]=\"showMeridian\"\n        [showSpinners]=\"showSpinners\"\n        [months]=\"months\"\n        [monthsShort]=\"monthsShort\"\n        [meridians]=\"meridians\"\n        [nowBtnText]=\"nowBtnText\"\n        [showNowBtn]=\"showNowBtn\"\n        [nowBtnAriaLabel]=\"nowBtnAriaLabel\"\n        [timezones]=\"timezones\"\n        [(timezone)]=\"startTimezone\"\n        (timezoneChange)=\"startTimezoneChange.emit($event)\">\n    </ux-date-time-picker>\n\n    <ux-date-time-picker\n        uxDateRangePicker\n        picker=\"end\"\n        class=\"end-date-picker\"\n        [date]=\"rangeService.end\"\n        (dateChange)=\"endChange$.next($event)\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [weekdays]=\"weekdays\"\n        [startOfWeek]=\"startOfWeek\"\n        [showTime]=\"showTime\"\n        [showTimezone]=\"showTimezone\"\n        [showSeconds]=\"showSeconds\"\n        [showMeridian]=\"showMeridian\"\n        [showSpinners]=\"showSpinners\"\n        [months]=\"months\"\n        [monthsShort]=\"monthsShort\"\n        [meridians]=\"meridians\"\n        [nowBtnText]=\"nowBtnText\"\n        [showNowBtn]=\"showNowBtn\"\n        [nowBtnAriaLabel]=\"nowBtnAriaLabel\"\n        [timezones]=\"timezones\"\n        [(timezone)]=\"endTimezone\"\n        (timezoneChange)=\"endTimezoneChange.emit($event)\">\n    </ux-date-time-picker>\n</div>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [DateRangeService]
                    }] }
        ];
        /** @nocollapse */
        DateRangePickerComponent.ctorParameters = function () {
            return [
                { type: DateRangeService }
            ];
        };
        DateRangePickerComponent.propDecorators = {
            start: [{ type: i0.Input }],
            end: [{ type: i0.Input }],
            dateFormat: [{ type: i0.Input }],
            timeFormat: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            showTimezone: [{ type: i0.Input }],
            showSeconds: [{ type: i0.Input }],
            showMeridian: [{ type: i0.Input }],
            showSpinners: [{ type: i0.Input }],
            weekdays: [{ type: i0.Input }],
            months: [{ type: i0.Input }],
            monthsShort: [{ type: i0.Input }],
            meridians: [{ type: i0.Input }],
            nowBtnText: [{ type: i0.Input }],
            showNowBtn: [{ type: i0.Input }],
            selectStartTitle: [{ type: i0.Input }],
            selectEndTitle: [{ type: i0.Input }],
            nowBtnAriaLabel: [{ type: i0.Input }],
            startPickerAriaLabel: [{ type: i0.Input }],
            endPickerAriaLabel: [{ type: i0.Input }],
            showTime: [{ type: i0.Input }],
            timezones: [{ type: i0.Input }],
            startTimezone: [{ type: i0.Input }],
            endTimezone: [{ type: i0.Input }],
            startOfWeek: [{ type: i0.Input }],
            durationTitle: [{ type: i0.Input }],
            startChange: [{ type: i0.Output }],
            endChange: [{ type: i0.Output }],
            startTimezoneChange: [{ type: i0.Output }],
            endTimezoneChange: [{ type: i0.Output }]
        };
        return DateRangePickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateRangeOptions = /** @class */ (function () {
        function DateRangeOptions() {
            this.picker = DateRangePicker.Start;
        }
        return DateRangeOptions;
    }());
    var DateRangePickerDirective = /** @class */ (function () {
        function DateRangePickerDirective(_options) {
            this._options = _options;
        }
        Object.defineProperty(DateRangePickerDirective.prototype, "picker", {
            /** Specify whether this is the start or end picker */
            set: /**
             * Specify whether this is the start or end picker
             * @param {?} picker
             * @return {?}
             */ function (picker) {
                this._options.picker = picker;
            },
            enumerable: true,
            configurable: true
        });
        DateRangePickerDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxDateRangePicker]',
                        providers: [DateRangeOptions]
                    },] }
        ];
        /** @nocollapse */
        DateRangePickerDirective.ctorParameters = function () {
            return [
                { type: DateRangeOptions, decorators: [{ type: i0.Self }] }
            ];
        };
        DateRangePickerDirective.propDecorators = {
            picker: [{ type: i0.Input }]
        };
        return DateRangePickerDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateTimePickerConfig = /** @class */ (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.showNowBtn = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = timezones;
            this.months = months;
            this.monthsShort = monthsShort;
            this.meridians = meridians;
            this.min = null;
            this.max = null;
        }
        DateTimePickerConfig.decorators = [
            { type: i0.Injectable }
        ];
        return DateTimePickerConfig;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateTimePickerService = /** @class */ (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new rxjs.BehaviorSubject(DatePickerMode.Day);
            this.date$ = new rxjs.BehaviorSubject(new Date());
            this.timezone$ = new rxjs.BehaviorSubject(this.getCurrentTimezone());
            this.selected$ = new rxjs.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new rxjs.BehaviorSubject(new Date().getMonth());
            this.year$ = new rxjs.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new rxjs.BehaviorSubject(this._config ? this._config.showDate : true);
            this.showTime$ = new rxjs.BehaviorSubject(this._config ? this._config.showTime : true);
            this.showTimezone$ = new rxjs.BehaviorSubject(this._config ? this._config.showTimezone : true);
            this.showSeconds$ = new rxjs.BehaviorSubject(this._config ? this._config.showSeconds : false);
            this.showMeridian$ = new rxjs.BehaviorSubject(this._config ? this._config.showMeridian : true);
            this.showSpinners$ = new rxjs.BehaviorSubject(this._config ? this._config.showSpinners : true);
            this.showNowBtn$ = new rxjs.BehaviorSubject(this._config ? this._config.showNowBtn : true);
            this.weekdays$ = new rxjs.BehaviorSubject(this._config ? this._config.weekdays : weekdaysShort);
            this.nowBtnText$ = new rxjs.BehaviorSubject(this._config ? this._config.nowBtnText : 'Today');
            this.timezones$ = new rxjs.BehaviorSubject(this._config ? this._config.timezones : timezones);
            this.min$ = new rxjs.BehaviorSubject(this._config ? this._config.min : null);
            this.max$ = new rxjs.BehaviorSubject(this._config ? this._config.max : null);
            this.header$ = new rxjs.BehaviorSubject(null);
            this.headerEvent$ = new rxjs.Subject();
            this.modeDirection = ModeDirection.None;
            this.startOfWeek$ = new rxjs.BehaviorSubject(common.WeekDay.Sunday);
            this.months = this._config ? this._config.months : months;
            this.monthsShort = this._config ? this._config.monthsShort : monthsShort;
            this.meridians = this._config ? this._config.meridians : meridians;
            /**
             * Store whether or not the component has fully initialised or not. We use this to prevent initial
             * focus on the end date range picker when the popover is first opened
             */
            this.initialised = false;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                if (date instanceof Date) {
                    _this.setViewportMonth(date.getMonth());
                    _this.setViewportYear(date.getFullYear());
                }
                // emit the new date to the component host but only if they are different
                if (dateComparator(date, _this.date$.value)) {
                    _this.date$.next(date);
                }
            });
        }
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMonth = /**
         * @param {?} month
         * @return {?}
         */
            function (month) {
                if (month < 0) {
                    this.month$.next(11);
                    this.year$.next(this.year$.value - 1);
                }
                else if (month > 11) {
                    this.month$.next(0);
                    this.year$.next(this.year$.value + 1);
                }
                else {
                    this.month$.next(month);
                }
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportYear = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.year$.next(year);
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @param {?=} hours
         * @param {?=} minutes
         * @param {?=} seconds
         * @return {?}
         */
        DateTimePickerService.prototype.setDate = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @param {?=} hours
         * @param {?=} minutes
         * @param {?=} seconds
         * @return {?}
         */
            function (day, month, year, hours, minutes, seconds) {
                /** @type {?} */
                var date = new Date(this.selected$.value);
                date.setDate(day);
                date.setMonth(month);
                date.setFullYear(year);
                if (hours !== undefined) {
                    date.setHours(hours);
                }
                if (minutes !== undefined) {
                    date.setMinutes(minutes);
                }
                if (seconds !== undefined) {
                    date.setSeconds(seconds);
                }
                if (this.isInRange(date)) {
                    this.selected$.next(date);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.setDateToNow = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var now = new Date();
                if (this.isInRange(now)) {
                    this.selected$.next(now);
                }
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMode = /**
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                this.mode$.next(mode);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToChildMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Descend;
                switch (this.mode$.value) {
                    case DatePickerMode.Year:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Day);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToParentMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Ascend;
                switch (this.mode$.value) {
                    case DatePickerMode.Day:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Year);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToNext = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Next);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToPrevious = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Previous);
            };
        /**
         * @param {?} header
         * @return {?}
         */
        DateTimePickerService.prototype.setHeader = /**
         * @param {?} header
         * @return {?}
         */
            function (header) {
                this.header$.next(header);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.getCurrentTimezone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var offset = new Date().getTimezoneOffset();
                /** @type {?} */
                var zones = this._config ? this._config.timezones : timezones;
                return zones.find(function (timezone) { return timezone.offset === offset; });
            };
        /**
         * @param {?} timezone
         * @return {?}
         */
        DateTimePickerService.prototype.setTimezone = /**
         * @param {?} timezone
         * @return {?}
         */
            function (timezone) {
                this.timezone$.next(timezone);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateTimePickerService.prototype.isInRange = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return (!this.min$.value || date >= this.min$.value) && (!this.max$.value || date <= this.max$.value);
            };
        DateTimePickerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DateTimePickerService.ctorParameters = function () {
            return [
                { type: DateTimePickerConfig, decorators: [{ type: i0.Optional }] }
            ];
        };
        return DateTimePickerService;
    }());
    /** @enum {number} */
    var DatePickerMode = {
        Day: 0,
        Month: 1,
        Year: 2,
    };
    DatePickerMode[DatePickerMode.Day] = 'Day';
    DatePickerMode[DatePickerMode.Month] = 'Month';
    DatePickerMode[DatePickerMode.Year] = 'Year';
    /** @enum {number} */
    var ModeDirection = {
        None: 0,
        Ascend: 1,
        Descend: 2,
    };
    ModeDirection[ModeDirection.None] = 'None';
    ModeDirection[ModeDirection.Ascend] = 'Ascend';
    ModeDirection[ModeDirection.Descend] = 'Descend';
    /** @enum {number} */
    var DatePickerHeaderEvent = {
        Previous: 0,
        Next: 1,
    };
    DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = 'Previous';
    DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = 'Next';
    var DateTimePickerComponent = /** @class */ (function () {
        function DateTimePickerComponent(datepicker, _rangeService, _rangeOptions) {
            var _this = this;
            this.datepicker = datepicker;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            /**
             * Define the aria label for the now button
             */
            this.nowBtnAriaLabel = 'Set date to now';
            /**
             * Emits an event when the date is changed using the component.
             */
            this.dateChange = new i0.EventEmitter();
            /**
             * If not defined the picker will try to use the user's timezone. If that is not available, it will revert to GMT.
             */
            this.timezoneChange = new i0.EventEmitter();
            // expose enum to view
            this.DatePickerMode = DatePickerMode;
            this._onDestroy = new rxjs.Subject();
            datepicker.selected$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(dateComparator))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
            datepicker.timezone$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(timezoneComparator))
                .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            /** Defines whether or not the date picker should be visible. */
            set: /**
             * Defines whether or not the date picker should be visible.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showDate$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            /** Defines whether or not the time picker should be visible. */
            set: /**
             * Defines whether or not the time picker should be visible.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showTime$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            /** Defines whether or not the time picker should allow the user to choose a timezone. */
            set: /**
             * Defines whether or not the time picker should allow the user to choose a timezone.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showTimezone$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            /** Defines whether or not the time picker should allow the user to specify seconds. */
            set: /**
             * Defines whether or not the time picker should allow the user to specify seconds.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showSeconds$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            /** Defines whether or not the time picker should show an AM/PM button, or time should be represented in 24hr format instead. */
            set: /**
             * Defines whether or not the time picker should show an AM/PM button, or time should be represented in 24hr format instead.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showMeridian$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            /** Defines whether or not the time picker should allow the user to select the time using spinners. */
            set: /**
             * Defines whether or not the time picker should allow the user to select the time using spinners.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showSpinners$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            /** If defined will override the weekday names displayed. */
            set: /**
             * If defined will override the weekday names displayed.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.weekdays$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "months", {
            /** Defines the names of the months. */
            set: /**
             * Defines the names of the months.
             * @param {?} months
             * @return {?}
             */ function (months$$1) {
                if (months$$1 !== undefined) {
                    this.datepicker.months = months$$1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "monthsShort", {
            /** Defines the short names of each month. */
            set: /**
             * Defines the short names of each month.
             * @param {?} months
             * @return {?}
             */ function (months$$1) {
                if (months$$1 !== undefined) {
                    this.datepicker.monthsShort = months$$1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "meridians", {
            /** Defines the labels to show in the meridian (AM/PM) selector. */
            set: /**
             * Defines the labels to show in the meridian (AM/PM) selector.
             * @param {?} meridians
             * @return {?}
             */ function (meridians$$1) {
                if (meridians$$1 !== undefined) {
                    this.datepicker.meridians = meridians$$1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            /** Defines the text to be displayed in the button used to set the selected time to the current time. */
            set: /**
             * Defines the text to be displayed in the button used to set the selected time to the current time.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.nowBtnText$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showNowBtn", {
            /** Specify whether or not to show the show now button */
            set: /**
             * Specify whether or not to show the show now button
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.showNowBtn$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            /**
             * Defines the list of available timezones. The `DateTimePickerTimezone` interface specifies that each timezone should
             * be an object with a `name` property that represents the timezone, eg. `GMT+2`, and an `offset` property that represents
             * the number of minutes relative to GMT the timezone is.
             */
            set: /**
             * Defines the list of available timezones. The `DateTimePickerTimezone` interface specifies that each timezone should
             * be an object with a `name` property that represents the timezone, eg. `GMT+2`, and an `offset` property that represents
             * the number of minutes relative to GMT the timezone is.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.timezones$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "startOfWeek", {
            /** Defines the day of the week that should appear in the first column. `WeekDay` is an enumeration available in `@angular/common`. */
            set: /**
             * Defines the day of the week that should appear in the first column. `WeekDay` is an enumeration available in `\@angular/common`.
             * @param {?} startOfWeek
             * @return {?}
             */ function (startOfWeek) {
                if (startOfWeek !== undefined) {
                    this.datepicker.startOfWeek$.next(startOfWeek);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            /** The selected date to be displayed in the component. */
            set: /**
             * The selected date to be displayed in the component.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value && !dateComparator(value, this.datepicker.selected$.value)) {
                    this.datepicker.selected$.next(new Date(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            /** Will set the selected timezone. */
            set: /**
             * Will set the selected timezone.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== undefined) {
                    this.datepicker.timezone$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "min", {
            /** The earliest selectable date. */
            set: /**
             * The earliest selectable date.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.min$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "max", {
            /** The latest selectable date. */
            set: /**
             * The latest selectable date.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.max$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isTodayDisabled", {
            /** Determine if the today button is disabled */
            get: /**
             * Determine if the today button is disabled
             * @return {?}
             */ function () {
                /** @type {?} */
                var min = this.datepicker.min$.value;
                /** @type {?} */
                var max = this.datepicker.max$.value;
                if (!min && !max) {
                    return false;
                }
                if (min && !max) {
                    return isDateBefore(new Date(), min);
                }
                if (!min && max) {
                    return isDateAfter(new Date(), max);
                }
                return isDateBefore(new Date(), min) || isDateAfter(new Date(), max);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () { return _this.datepicker.initialised = true; });
            };
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Change the date to the current date and time
         */
        /**
         * Change the date to the current date and time
         * @return {?}
         */
        DateTimePickerComponent.prototype.setToNow = /**
         * Change the date to the current date and time
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    /** @type {?} */
                    var date = new Date();
                    if (this._isRangeStart && !this._rangeService.showTime) {
                        this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 0, 0, 0);
                    }
                    else if (this._isRangeEnd && !this._rangeService.showTime) {
                        this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 23, 59, 59);
                    }
                    else {
                        this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), this.datepicker.hours, this.datepicker.minutes, this.datepicker.seconds);
                    }
                }
                else {
                    // set the date to the current moment
                    this.datepicker.setDateToNow();
                }
            };
        DateTimePickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker',
                        template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n        <!-- Display days in the current month -->\n        <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n        <!-- Display the months in the current year -->\n        <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n        <!-- Display a decade -->\n        <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button type=\"button\"\n    *ngIf=\"datepicker.showNowBtn$ | async\"\n    uxFocusIndicator\n    class=\"now-button\"\n    [attr.aria-label]=\"nowBtnAriaLabel\"\n    [disabled]=\"_isTodayDisabled\"\n    (click)=\"setToNow()\">\n    {{ datepicker.nowBtnText$ | async }}\n</button>",
                        providers: [DateTimePickerService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DateTimePickerComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        DateTimePickerComponent.propDecorators = {
            showDate: [{ type: i0.Input }],
            showTime: [{ type: i0.Input }],
            showTimezone: [{ type: i0.Input }],
            showSeconds: [{ type: i0.Input }],
            showMeridian: [{ type: i0.Input }],
            showSpinners: [{ type: i0.Input }],
            weekdays: [{ type: i0.Input }],
            months: [{ type: i0.Input }],
            monthsShort: [{ type: i0.Input }],
            meridians: [{ type: i0.Input }],
            nowBtnText: [{ type: i0.Input }],
            showNowBtn: [{ type: i0.Input }],
            timezones: [{ type: i0.Input }],
            startOfWeek: [{ type: i0.Input }],
            nowBtnAriaLabel: [{ type: i0.Input }],
            dateChange: [{ type: i0.Output }],
            timezoneChange: [{ type: i0.Output }],
            date: [{ type: i0.Input }],
            timezone: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            max: [{ type: i0.Input }]
        };
        return DateTimePickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIfDirective = /** @class */ (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * The delay that should ellapse before focussing the element
             */
            this.focusIfDelay = 0;
            /**
             * Determine if we should scroll the element into view when focused
             */
            this.focusIfScroll = true;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            /** Focus when the boolean value is true */
            set: /**
             * Focus when the boolean value is true
             * @param {?} focus
             * @return {?}
             */ function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus({ preventScroll: !_this.focusIfScroll });
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FocusIfDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._timeout !== null) {
                    clearTimeout(this._timeout);
                }
            };
        FocusIfDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[focusIf]'
                    },] }
        ];
        /** @nocollapse */
        FocusIfDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        FocusIfDirective.propDecorators = {
            focusIfDelay: [{ type: i0.Input }],
            focusIfScroll: [{ type: i0.Input }],
            focusIf: [{ type: i0.Input }]
        };
        return FocusIfDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FocusIfModule = /** @class */ (function () {
        function FocusIfModule() {
        }
        FocusIfModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [FocusIfDirective],
                        declarations: [FocusIfDirective]
                    },] }
        ];
        return FocusIfModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = /** @class */ (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.maxLength = Infinity;
            this.valueChange = new i0.EventEmitter();
            this.increment = new i0.EventEmitter();
            this.decrement = new i0.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this._regexKeypress = RegExp(/^[0-9.,-]+$/);
            this._regexPaste = RegExp(/^\-?\d+(\.\d+)?$/);
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.scroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.scrolling) {
                    return;
                }
                if (event.deltaY > 0) {
                    this.triggerDecrement();
                }
                else {
                    this.triggerIncrement();
                }
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerIncrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.increment.emit();
                }
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerDecrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.decrement.emit();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SpinButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.onKeypress = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // we only need to perform checks if the type is number
                if (this.type !== 'number') {
                    return;
                }
                if (!this._regexKeypress.test(event.key)) {
                    return false;
                }
                return true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.onPaste = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // we only need to perform checks if the type is number
                if (this.type !== 'number') {
                    return;
                }
                // get the value being pasted
                /** @type {?} */
                var value = event.clipboardData.getData('text');
                // check if it contains the character
                if (!this._regexPaste.test(value)) {
                    // inset the numeric value only if there is one
                    /** @type {?} */
                    var numericValue = parseFloat(value);
                    if (!isNaN(numericValue)) {
                        this.value = numericValue;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @param {?} input
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.onValueChange = /**
         * @param {?} input
         * @param {?} value
         * @return {?}
         */
            function (input, value) {
                // ensure the value is not longer than the maxLength (verify value is a string in case it is
                // null or undefined, before trying to check the length.
                if (typeof value === 'string' && value.length > this.maxLength) {
                    // if the type specified is a number then it may begin with a 0
                    // e.g. "02", in which case if we add a second digit we should drop
                    // the leading "0" and allow the non-zero number to be added
                    if (this.type === 'number') {
                        value = parseFloat(value).toString();
                    }
                    // remove any characters over the max length
                    value = value.substring(0, this.maxLength);
                    // We must manually update the input value in this case rather than relying
                    // on Angular, as if value was previously "11" and we add an additional digit
                    // e.g. "112", after performing the substring, the outputted value would again
                    // be "11" which Angular would not recognize as having changed so it will not
                    // update the value displayed in the input.
                    input.value = value;
                }
                // emit the value after all length checks
                this.valueChange.emit(value);
            };
        SpinButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-spin-button',
                        template: "<button type=\"button\"\n        uxFocusIndicator\n        class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n    <ux-icon name=\"up\" class=\"spin-button-up-icon\"></ux-icon>\n</button>\n\n<input #input\n       type=\"text\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"onValueChange(input, $event)\"\n       (wheel)=\"scroll($event)\"\n       (keypress)=\"onKeypress($event)\"\n       (paste)=\"onPaste($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button type=\"button\"\n        uxFocusIndicator\n        class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n    <ux-icon name=\"down\" class=\"spin-button-down-icon\"></ux-icon>\n</button>\n",
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        SpinButtonComponent.propDecorators = {
            value: [{ type: i0.Input }],
            type: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            spinners: [{ type: i0.Input }],
            readOnly: [{ type: i0.Input }],
            scrolling: [{ type: i0.Input }],
            arrowkeys: [{ type: i0.Input }],
            maxLength: [{ type: i0.Input }],
            incrementAriaLabel: [{ type: i0.Input }],
            inputAriaLabel: [{ type: i0.Input }],
            decrementAriaLabel: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            increment: [{ type: i0.Output }],
            decrement: [{ type: i0.Output }]
        };
        return SpinButtonComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SpinButtonModule = /** @class */ (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            IconModule,
                        ],
                        exports: [SpinButtonComponent],
                        declarations: [SpinButtonComponent]
                    },] }
        ];
        return SpinButtonModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = /** @class */ (function () {
        function TimePickerComponent() {
            /**
             * Whether the arrow keys can be used to increment or decrement the selected time component.
             */
            this.arrowkeys = true;
            /**
             * Whether the mouse scroll wheel can be used to increment or decrement the selected time component.
             */
            this.mousewheel = true;
            /**
             * Whether the control is disabled.
             */
            this.disabled = false;
            /**
             * Whether the control is readonly.
             */
            this.readOnly = false;
            /**
             * Whether to show the meridian (AM/PM) selector. If this is false, the 24-hour clock will be used.
             */
            this.showMeridian = false;
            /**
             * Whether to show the hour selector.
             */
            this.showHours = true;
            /**
             * Whether to show the minute selector.
             */
            this.showMinutes = true;
            /**
             * Whether to show the second selector.
             */
            this.showSeconds = false;
            /**
             * Whether to show increment and decrement buttons in the time picker.
             */
            this.showSpinners = true;
            /**
             * The number of hours to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel.
             */
            this.hourStep = 1;
            /**
             * The number of minutes to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel.
             */
            this.minuteStep = 1;
            /**
             * The number of seconds to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel.
             */
            this.secondStep = 1;
            /**
             * An array containing the labels to show in the meridian selector.
             */
            this.meridians = ['AM', 'PM'];
            /**
             * Emitted when the `value` changes.
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Emitted when the validity of the control changes.
             */
            this.isValid = new i0.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this._value = new Date();
            this._isValid = true;
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return new Date(this._value);
            },
            /** The value to display. */
            set: /**
             * The value to display.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = new Date(value);
                this.valueChange.emit(this._value);
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimePickerComponent.prototype, "_meridian", {
            get: /**
             * @return {?}
             */ function () {
                return this._value.getHours() < 12 ? this.meridians[0] : this.meridians[1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimePickerComponent.prototype, "_valid", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkValidity(this._value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TimePickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.getMeridianTime = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                return hour > 12 ? hour - 12 : hour;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.setHour = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                /** @type {?} */
                var date = this.value;
                date.setHours(hour ? hour : 0);
                this.value = date;
            };
        /**
         * @param {?} minute
         * @return {?}
         */
        TimePickerComponent.prototype.setMinute = /**
         * @param {?} minute
         * @return {?}
         */
            function (minute) {
                /** @type {?} */
                var date = this.value;
                date.setMinutes(minute ? minute : 0);
                this.value = date;
            };
        /**
         * @param {?} seconds
         * @return {?}
         */
        TimePickerComponent.prototype.setSeconds = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                /** @type {?} */
                var date = this.value;
                date.setSeconds(seconds ? seconds : 0);
                this.value = date;
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() + this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() - this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() + this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() - this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() + this.secondStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() - this.secondStep);
            };
        /**
         * @param {?} meridian
         * @return {?}
         */
        TimePickerComponent.prototype.selectMeridian = /**
         * @param {?} meridian
         * @return {?}
         */
            function (meridian) {
                // get the current time
                /** @type {?} */
                var hour = this.value.getHours();
                // if we have selected AM
                if (meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        this.setHour(hour - 12);
                    }
                }
                // if we have selected PM
                if (meridian === this.meridians[1]) {
                    if (hour < 12) {
                        this.setHour(hour + 12);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimePickerComponent.prototype.checkValidity = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                /** @type {?} */
                var valid = true;
                // Fix min and max date components in order to compare time only
                /** @type {?} */
                var min = this.normalizeDate(this.min, date);
                /** @type {?} */
                var max = this.normalizeDate(this.max, date);
                if ((min && date.getTime() < min.getTime()) || (max && date.getTime() > max.getTime())) {
                    valid = false;
                }
                // if the valid state has changed then emit the isValid output
                if (valid !== this._isValid) {
                    this._isValid = valid;
                    this.isValid.emit(valid);
                }
                return valid;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.hourChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // if the value is empty then emit nothing
                if (value && value.trim() === '') {
                    return;
                }
                // convert the string to a number
                /** @type {?} */
                var hour = parseInt(value);
                // ensure the hours is valid
                if (!isNaN(hour)) {
                    if (hour < 0) {
                        hour = 0;
                    }
                    if (hour > (this.showMeridian ? 12 : 23)) {
                        hour = this.showMeridian ? 12 : 23;
                    }
                }
                /** @type {?} */
                var currentHour = this.value.getHours();
                // if the value hasn't changed, do nothing
                if (hour === currentHour) {
                    return;
                }
                hour = isNaN(hour) ? currentHour : hour;
                if (this.showMeridian) {
                    // if the number is invalid then restore it to the previous value
                    if (this._meridian === this.meridians[0]) {
                        if (hour >= 12) {
                            hour -= 12;
                        }
                    }
                    // if we have selected PM
                    if (this._meridian === this.meridians[1]) {
                        if (hour < 12) {
                            hour += 12;
                        }
                    }
                }
                this.setHour(hour);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.minuteChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                /** @type {?} */
                var minute = parseInt(value);
                /** @type {?} */
                var currentMinute = this.value.getMinutes();
                // if the value hasn't changed, do nothing
                if (minute === currentMinute) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(minute)) {
                    if (minute < 0) {
                        minute = 59;
                    }
                    if (minute > 59) {
                        minute = 0;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setMinute(isNaN(minute) ? currentMinute : minute);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.secondChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                /** @type {?} */
                var second = parseInt(value);
                /** @type {?} */
                var currentSecond = this.value.getSeconds();
                // if the value hasn't changed, do nothing
                if (second === currentSecond) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(second)) {
                    if (second < 0) {
                        second = 0;
                    }
                    if (second > 59) {
                        second = 59;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setSeconds(isNaN(second) ? currentSecond : second);
            };
        /** Normalise a date's year/month/date components. */
        /**
         * Normalise a date's year/month/date components.
         * @param {?} date
         * @param {?} reference
         * @return {?}
         */
        TimePickerComponent.prototype.normalizeDate = /**
         * Normalise a date's year/month/date components.
         * @param {?} date
         * @param {?} reference
         * @return {?}
         */
            function (date, reference) {
                if (!date) {
                    return null;
                }
                /** @type {?} */
                var normalized = new Date(date);
                normalized.setFullYear(reference.getFullYear());
                normalized.setMonth(reference.getMonth());
                normalized.setDate(reference.getDate());
                return normalized;
            };
        TimePickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-time-picker',
                        template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"value | date: showMeridian ? 'h' : 'HH'\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"value | date: 'mm'\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"SS\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"value | date: 'ss'\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button type=\"button\"\n                class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === _meridian\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === _meridian\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [TIME_PICKER_VALUE_ACCESSOR],
                        host: {
                            'aria-label': 'Time Picker'
                        }
                    }] }
        ];
        TimePickerComponent.propDecorators = {
            arrowkeys: [{ type: i0.Input }],
            mousewheel: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            readOnly: [{ type: i0.Input }],
            showMeridian: [{ type: i0.Input }],
            showHours: [{ type: i0.Input }],
            showMinutes: [{ type: i0.Input }],
            showSeconds: [{ type: i0.Input }],
            showSpinners: [{ type: i0.Input }],
            hourStep: [{ type: i0.Input }],
            minuteStep: [{ type: i0.Input }],
            secondStep: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            meridians: [{ type: i0.Input }],
            value: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            isValid: [{ type: i0.Output }]
        };
        return TimePickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TimePickerModule = /** @class */ (function () {
        function TimePickerModule() {
        }
        TimePickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            SpinButtonModule
                        ],
                        exports: [TimePickerComponent],
                        declarations: [TimePickerComponent],
                    },] }
        ];
        return TimePickerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DayViewService = /** @class */ (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._subscription = rxjs.combineLatest(_datepicker.month$, _datepicker.year$, _datepicker.startOfWeek$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        /**
         * @return {?}
         */
        DayViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.setFocus = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (day, month, year) {
                this.focused$.next({ day: day, month: month, year: year });
                // update the date picker to show the required month and year
                this._datepicker.setViewportMonth(month);
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.createDayGrid = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(this._datepicker.months[month] + ' ' + year);
                // find the lower and upper boundaries
                /** @type {?} */
                var start = new Date(year, month, 1);
                /** @type {?} */
                var end = new Date(year, month + 1, 0);
                // ensure the startOfWeek value is between 0-6 to prevent any infinite loop
                /** @type {?} */
                var startOfWeek = Math.min(common.WeekDay.Saturday, Math.max(common.WeekDay.Sunday, this._datepicker.startOfWeek$.value));
                // we always want to show from the specified start of week - this may include showing some dates from the previous month
                while (start.getDay() !== startOfWeek) {
                    start.setDate(start.getDate() - 1);
                }
                // we also want to make sure that the range ends on a saturday
                end.setDate(end.getDate() + (6 - end.getDay()));
                // create an array of all the days to display
                /** @type {?} */
                var dates = dateRange(start, end).map(function (date) {
                    return ({
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        date: date,
                        isToday: _this.isToday(date),
                        isActive: _this.isActive(date),
                        isCurrentMonth: date.getMonth() === month
                    });
                });
                // turn the dates into a grid
                /** @type {?} */
                var items = gridify(dates, 7);
                this.grid$.next(items);
                // if no item has yet been focused then focus the first day of the month
                if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
                    // check if the selected item is visible
                    /** @type {?} */
                    var selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                    if (selectedDay) {
                        this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                    }
                    else {
                        // find the first day of the month
                        /** @type {?} */
                        var first = dates.find(function (date) { return date.day === 1; });
                        // focus the date
                        this.setFocus(first.day, first.month, first.year);
                    }
                }
            };
        /**
       * Determine whether or not a specific date is today
       * @param date The date to check
       */
        /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
        DayViewService.prototype.isToday = /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
            function (date) {
                return compareDays(new Date(), date);
            };
        /**
         * Determines whether or not a specific date is the selected one
         * @param date the date to check
         */
        /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
        DayViewService.prototype.isActive = /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
            function (date) {
                return this._datepicker.selected$.value ? compareDays(this._datepicker.selected$.value, date) : false;
            };
        DayViewService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DayViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return DayViewService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DayViewComponent = /** @class */ (function () {
        function DayViewComponent(datePicker, dayService, _changeDetector, _focusOrigin, _liveAnnouncer, _rangeService, _rangeOptions) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._changeDetector = _changeDetector;
            this._focusOrigin = _focusOrigin;
            this._liveAnnouncer = _liveAnnouncer;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            datePicker.headerEvent$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
            // if we are a range picker then we also want to subscribe to range changes
            if (_rangeService) {
                rxjs.merge(_rangeService.onRangeChange, _rangeService.onHoverChange).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _changeDetector.detectChanges(); });
                // subscribe to changes to the start date
                _rangeService.onStartChange
                    .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (date) { return !!date && _this._isRangeEnd && _this.datePicker.initialised; }), operators.delay(0))
                    .subscribe(function (date) { return _this.onRangeChange(date); });
                // subscribe to changes to the end date
                _rangeService.onEndChange
                    .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (date) { return !!date && _this._isRangeStart && _this.datePicker.initialised; }), operators.delay(0))
                    .subscribe(function (date) { return _this.onRangeChange(date); });
                // when the range is cleared reset the selected date so we can click on the same date again if we want to
                _rangeService.onClear.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.datePicker.selected$.next(null); });
            }
        }
        Object.defineProperty(DayViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_rangeStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_rangeEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update when there are changes to the min/max values
                rxjs.merge(this.datePicker.min$, this.datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._changeDetector.detectChanges(); });
                // if we open and the range start is already selected, ensure that we move the end picker to a month with options
                if (!this.datePicker.initialised && this._rangeStart && !this._rangeEnd && this._isRangeEnd) {
                    this.onRangeChange(this._rangeStart);
                }
                // if we open and the range end is already selected, ensure that we move the start picker to a month with options
                if (!this.datePicker.initialised && this._rangeEnd && !this._rangeStart && this._isRangeStart) {
                    this.onRangeChange(this._rangeEnd);
                }
            };
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Navigate to the previous page of dates
         */
        /**
         * Navigate to the previous page of dates
         * @return {?}
         */
        DayViewComponent.prototype.previous = /**
         * Navigate to the previous page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
            };
        /**
         * Navigate to the next page of dates
         */
        /**
         * Navigate to the next page of dates
         * @return {?}
         */
        DayViewComponent.prototype.next = /**
         * Navigate to the next page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
            };
        /**
         * Select a particular date
         * @param date the date to select
         */
        /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
        DayViewComponent.prototype.select = /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
            function (date) {
                // if we are range picking, and have no dates selected clear the range (if we select the current day initially it won't get selected)
                if (this._isRangeMode && !this._rangeStart && !this._rangeEnd) {
                    this._rangeService.clear();
                }
                // if we are the start range picker and we click the already selected day deselect it
                if (this._isRangeMode && this._isRangeStart && this._rangeStart && compareDays(this._rangeStart, date)) {
                    this._rangeService.setStartDate(null);
                    this.datePicker.selected$.next(null);
                    return;
                }
                // if we are the end range picker and we click the already selected day deselect it
                if (this._isRangeMode && this._isRangeEnd && this._rangeEnd && compareDays(this._rangeEnd, date)) {
                    this._rangeService.setEndDate(null);
                    this.datePicker.selected$.next(null);
                    return;
                }
                // if we are in range mode ensure we include the time from the time picker
                if (this._isRangeMode) {
                    // update the current date object
                    if (this._isRangeStart && !this._rangeService.showTime) {
                        this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 0, 0, 0);
                    }
                    else if (this._isRangeEnd && !this._rangeService.showTime) {
                        this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 23, 59, 59);
                    }
                    else {
                        this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), this.datePicker.hours, this.datePicker.minutes, this.datePicker.seconds);
                    }
                }
                else {
                    // update the current date object
                    this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
                }
                // focus the newly selected date
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
                // if we select a start date that is after the end date then clear the end date
                if (this._isRangeMode && this._isRangeStart && this._rangeStart && this._rangeEnd) {
                    if (this._rangeStart.getTime() > this._rangeEnd.getTime()) {
                        this._rangeService.setEndDate(null);
                    }
                }
                // if we select a end date that is before the start date then clear the start date
                if (this._isRangeMode && this._isRangeEnd && this._rangeStart && this._rangeEnd) {
                    if (this._rangeEnd.getTime() < this._rangeStart.getTime()) {
                        this._rangeService.setStartDate(null);
                    }
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        DayViewComponent.prototype.trackWeekByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.trackDayByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.day + " " + item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
        DayViewComponent.prototype.focusDate = /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
            function (item, dayOffset) {
                // determine the date of the day
                /** @type {?} */
                var target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
                // we should force the origin to be keyboard
                this._focusOrigin.setOrigin('keyboard');
                // identify which date should be focused
                this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var e_1, _a, e_2, _b;
                /** @type {?} */
                var focused = this.dayService.focused$.value;
                /** @type {?} */
                var grid = this.dayService.grid$.value;
                /** @type {?} */
                var month = this.datePicker.month$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused day is visible
                    /** @type {?} */
                    var isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year && _item.month === month; }); });
                    if (isFocusedDayVisible) {
                        return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable day then check if there is a selected day
                /** @type {?} */
                var isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
                if (isSelectedDayVisible) {
                    return item.isActive;
                }
                try {
                    // find the first non disabled day that is part of the current month
                    for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                        var row = grid_1_1.value;
                        try {
                            for (var row_1 = __values(row), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                var column = row_1_1.value;
                                if (column === item && column.month === month && !this.getDisabled(column.date)) {
                                    return true;
                                }
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                    _b.call(row_1);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (grid_1_1 && !grid_1_1.done && (_a = grid_1.return))
                            _a.call(grid_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return false;
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.getDisabled = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                // if we are not in range mode then it will always be enabled
                if (this._isRangeMode) {
                    // if we are range start and dates are after the range end then they should also be disabled
                    if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, this._rangeEnd)) {
                        return true;
                    }
                    // if we are range end and dates are before the range start then they should also be disabled
                    if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, this._rangeStart)) {
                        return true;
                    }
                }
                if (this.datePicker.min$.value && isDateBefore(date, this.datePicker.min$.value)) {
                    return true;
                }
                if (this.datePicker.max$.value && isDateAfter(date, this.datePicker.max$.value)) {
                    return true;
                }
                return false;
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.isRangeStartDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._isRangeMode && this._rangeStart && compareDays(date, this._rangeStart);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.isRangeEndDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._isRangeMode && this._rangeEnd && compareDays(date, this._rangeEnd);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.isWithinRange = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._isRangeMode && this._rangeStart && isDateAfter(date, this._rangeStart) && isDateBefore(date, this._rangeEnd);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.isDateHovered = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                // if we are not in range mode or both start and end dates are selected then dont show range hover
                if (!this._isRangeMode || !this._rangeService.hover || this._rangeStart && this._rangeEnd) {
                    return;
                }
                return this._rangeStart && isDateAfter(date, this._rangeStart) && isDateBefore(date, this._rangeService.hover, true) ||
                    this._rangeEnd && isDateBefore(date, this._rangeEnd) && isDateAfter(date, this._rangeService.hover, true);
            };
        /**
         * @param {?} date
         * @param {?} isActive
         * @return {?}
         */
        DayViewComponent.prototype.isItemActive = /**
         * @param {?} date
         * @param {?} isActive
         * @return {?}
         */
            function (date, isActive) {
                if (!this._isRangeMode) {
                    return isActive;
                }
                return this._isRangeStart && this._rangeStart && compareDays(this._rangeStart, date) ||
                    this._isRangeEnd && this._rangeEnd && compareDays(this._rangeEnd, date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.onRangeMouseEnter = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (this._isRangeMode) {
                    this._rangeService.setDateMouseEnter(date);
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.onRangeMouseLeave = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (this._isRangeMode) {
                    this._rangeService.setDateMouseLeave(date);
                }
            };
        /** Announce the date when we focus on a date */
        /**
         * Announce the date when we focus on a date
         * @return {?}
         */
        DayViewComponent.prototype.announceRangeMode = /**
         * Announce the date when we focus on a date
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
                }
            };
        /** Determine if we should focus a date */
        /**
         * Determine if we should focus a date
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.shouldFocus = /**
         * Determine if we should focus a date
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // if we are opening the popover initially we never want to focus a date in the range end picker
                if (!this.datePicker.initialised && this._isRangeEnd || this._rangeService && this._rangeService.isChangingTime) {
                    return false;
                }
                // extract the current focused dates
                var _a = this.dayService.focused$.value, day = _a.day, month = _a.month, year = _a.year;
                // check if the current date is the focused date and it is in the viewport date
                return day === item.day && month === item.month && year === item.year && item.isCurrentMonth;
            };
        /** Update the viewport when the range changes to ensure focus is present on a valid item */
        /**
         * Update the viewport when the range changes to ensure focus is present on a valid item
         * @param {?} date
         * @return {?}
         */
        DayViewComponent.prototype.onRangeChange = /**
         * Update the viewport when the range changes to ensure focus is present on a valid item
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (!(this._isRangeStart && !this._rangeStart || this._isRangeEnd && !this._rangeEnd)) {
                    return;
                }
                // get the month showing on the other date range picker
                /** @type {?} */
                var currentDate = new Date(this.datePicker.year$.value, this.datePicker.month$.value);
                // if we are the start date and we are after the end date - ONLY then should be change the visible month the match the end date
                /** @type {?} */
                var startShouldUpdate = this._isRangeStart && !this._rangeStart && (currentDate.getFullYear() > date.getFullYear() || currentDate.getFullYear() === date.getFullYear() && currentDate.getMonth() > date.getMonth());
                // if we are the end date and we are before the start date - ONLY then should be change the visible month the match the start date
                /** @type {?} */
                var endShouldUpdate = this._isRangeEnd && !this._rangeEnd && (currentDate.getFullYear() < date.getFullYear() || currentDate.getFullYear() === date.getFullYear() && currentDate.getMonth() < date.getMonth());
                if (startShouldUpdate || endShouldUpdate) {
                    this.datePicker.setViewportMonth(date.getMonth());
                    this.datePicker.setViewportYear(date.getFullYear());
                    this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
                    this._changeDetector.detectChanges();
                }
            };
        DayViewComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker-day-view',
                        template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async | weekDaySort: (datePicker.startOfWeek$ | async)\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button type=\"button\"\n                        uxFocusIndicator\n                        uxFocusIndicatorOrigin\n                        class=\"date-button\"\n                        [class.range-start]=\"isRangeStartDate(item.date)\"\n                        [class.range-between]=\"isWithinRange(item.date) || isDateHovered(item.date)\"\n                        [class.range-end]=\"isRangeEndDate(item.date)\"\n                        [focusIf]=\"shouldFocus(item)\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"isItemActive(item.date, item.isActive)\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"isItemActive(item.date, item.isActive) && !getDisabled(item.date)\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        [disabled]=\"getDisabled(item.date)\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (mouseenter)=\"onRangeMouseEnter(item.date)\"\n                        (mouseleave)=\"onRangeMouseLeave(item.date)\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\"\n                        (focus)=\"announceRangeMode()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                        providers: [DayViewService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DayViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: DayViewService },
                { type: i0.ChangeDetectorRef },
                { type: FocusIndicatorOriginService },
                { type: a11y.LiveAnnouncer },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        return DayViewComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HeaderComponent = /** @class */ (function () {
        function HeaderComponent(datepicker, _changeDetector, _rangeService, _rangeOptions) {
            this.datepicker = datepicker;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Day';
                    case DatePickerMode.Month:
                        return 'Month';
                    case DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Previous month';
                    case DatePickerMode.Month:
                        return 'Previous year';
                    case DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Next month';
                    case DatePickerMode.Month:
                        return 'Next year';
                    case DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
            /**
             * Unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
            if (this._rangeService) {
                // delay required to allow all ui to update elsewhere
                this._rangeService.onRangeChange.pipe(operators.takeUntil(this._onDestroy), operators.delay(100))
                    .subscribe(function () { return _changeDetector.detectChanges(); });
            }
        }
        Object.defineProperty(HeaderComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_rangeStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_rangeEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update on min/max changes
                rxjs.merge(this.datepicker.min$, this.datepicker.max$).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._changeDetector.detectChanges(); });
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Navigate to the previous day, month or year */
        /**
         * Navigate to the previous day, month or year
         * @return {?}
         */
        HeaderComponent.prototype.previous = /**
         * Navigate to the previous day, month or year
         * @return {?}
         */
            function () {
                this.datepicker.goToPrevious();
            };
        /** Navigate to the larger scale, eg. Days -> Months, Months -> Years */
        /**
         * Navigate to the larger scale, eg. Days -> Months, Months -> Years
         * @return {?}
         */
        HeaderComponent.prototype.ascend = /**
         * Navigate to the larger scale, eg. Days -> Months, Months -> Years
         * @return {?}
         */
            function () {
                this.datepicker.goToParentMode();
            };
        /** Navigate to the previous day, month or year */
        /**
         * Navigate to the previous day, month or year
         * @return {?}
         */
        HeaderComponent.prototype.next = /**
         * Navigate to the previous day, month or year
         * @return {?}
         */
            function () {
                this.datepicker.goToNext();
            };
        /** Determine if the previous button is enabled */
        /**
         * Determine if the previous button is enabled
         * @return {?}
         */
        HeaderComponent.prototype.isPreviousDisabled = /**
         * Determine if the previous button is enabled
         * @return {?}
         */
            function () {
                /** @type {?} */
                var min = this.datepicker.min$.value;
                if (min && this._isBeforeView(min)) {
                    return true;
                }
                // if we are not in range mode or there are no disabled items then we can navigate back
                if (!this._isRangeMode || this._rangeStart && this._rangeEnd ||
                    !this._rangeStart && !this._rangeEnd || this._isRangeStart
                    || this._isRangeEnd && this._rangeEnd) {
                    return false;
                }
                if (this._isBeforeView(this._rangeStart)) {
                    return true;
                }
                return false;
            };
        /** Determine if the previous button is enabled */
        /**
         * Determine if the previous button is enabled
         * @return {?}
         */
        HeaderComponent.prototype.isNextDisabled = /**
         * Determine if the previous button is enabled
         * @return {?}
         */
            function () {
                /** @type {?} */
                var max = this.datepicker.max$.value;
                if (max && this._isAfterView(max)) {
                    return true;
                }
                // if we are not in range mode or there are no disabled items then we can navigate back
                if (!this._isRangeMode || this._rangeStart && this._rangeEnd ||
                    !this._rangeStart && !this._rangeEnd || this._isRangeStart && this._rangeStart
                    || this._isRangeEnd) {
                    return false;
                }
                if (this._isAfterView(this._rangeEnd)) {
                    return true;
                }
                return false;
            };
        /**
         * @param {?} date
         * @return {?}
         */
        HeaderComponent.prototype._isBeforeView = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                /** @type {?} */
                var month = this.datepicker.month$.value;
                /** @type {?} */
                var year = this.datepicker.year$.value;
                /** @type {?} */
                var mode = this.datepicker.mode$.value;
                /** @type {?} */
                var yearRange = this.datepicker.yearRange;
                if (mode === DatePickerMode.Day) {
                    return year <= date.getFullYear() && month <= date.getMonth();
                }
                if (mode === DatePickerMode.Month) {
                    return year <= date.getFullYear();
                }
                if (mode === DatePickerMode.Year) {
                    return yearRange.start <= date.getFullYear();
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        HeaderComponent.prototype._isAfterView = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                /** @type {?} */
                var month = this.datepicker.month$.value;
                /** @type {?} */
                var year = this.datepicker.year$.value;
                /** @type {?} */
                var mode = this.datepicker.mode$.value;
                /** @type {?} */
                var yearRange = this.datepicker.yearRange;
                if (mode === DatePickerMode.Day) {
                    return year >= date.getFullYear() && month >= date.getMonth();
                }
                if (mode === DatePickerMode.Month) {
                    return year >= date.getFullYear();
                }
                if (mode === DatePickerMode.Year) {
                    return yearRange.end >= date.getFullYear();
                }
            };
        HeaderComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker-header',
                        template: "<header class=\"header\">\n\n  <button type=\"button\"\n          uxFocusIndicator\n          [disabled]=\"isPreviousDisabled()\"\n          class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <ux-icon name=\"previous\" class=\"header-navigation-previous-icon\"></ux-icon>\n  </button>\n\n  <button type=\"button\"\n          uxFocusIndicator\n          class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button type=\"button\"\n          uxFocusIndicator\n          [disabled]=\"isNextDisabled()\"\n          class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <ux-icon name=\"next\" class=\"header-navigation-next-icon\"></ux-icon>\n  </button>\n</header>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: i0.ChangeDetectorRef },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        return HeaderComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MonthViewService = /** @class */ (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        /**
         * @return {?}
         */
        MonthViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.setFocus = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                this.focused$.next({ month: month, year: year });
                // update the viewport to ensure focused month is visible
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.createMonthGrid = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(year.toString());
                // get the current year and month
                /** @type {?} */
                var currentMonth = new Date().getMonth();
                /** @type {?} */
                var currentYear = new Date().getFullYear();
                // get the currently selected month
                /** @type {?} */
                var activeMonth = this._datepicker.selected$.value ? this._datepicker.selected$.value.getMonth() : null;
                /** @type {?} */
                var activeYear = this._datepicker.selected$.value ? this._datepicker.selected$.value.getFullYear() : null;
                // create a 4x3 grid of month numbers
                /** @type {?} */
                var months$$1 = range(0, 11).map(function (month) {
                    return {
                        name: _this._datepicker.monthsShort[month],
                        month: month,
                        year: year,
                        isCurrentMonth: year === currentYear && month === currentMonth,
                        isActiveMonth: year === activeYear && month === activeMonth
                    };
                });
                // map these to the appropriate format
                /** @type {?} */
                var items = gridify(months$$1, 4);
                // update the grid
                this.grid$.next(items);
                // if there is no focused month select the first one
                if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
                    // check if the selected month is in view
                    /** @type {?} */
                    var selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
                    this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
                }
            };
        MonthViewService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        MonthViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return MonthViewService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MonthViewComponent = /** @class */ (function () {
        function MonthViewComponent(_datePicker, monthService, _liveAnnouncer, _changeDetector, _rangeService, _rangeOptions) {
            var _this = this;
            var e_1, _a, e_2, _b;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            _datePicker.headerEvent$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
            if (this._rangeService) {
                this._rangeService.onRangeChange.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _changeDetector.detectChanges(); });
            }
            // if the currently focused item is disabled then choose a month that isn't disabled
            if (this.monthService.focused$.value) {
                if (this.getDisabled(this.monthService.focused$.value)) {
                    try {
                        for (var _c = __values(this.monthService.grid$.value), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var row = _d.value;
                            try {
                                for (var row_1 = __values(row), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                    var column = row_1_1.value;
                                    if (!this.getDisabled(column)) {
                                        this.monthService.setFocus(column.month, column.year);
                                        return;
                                    }
                                }
                            }
                            catch (e_2_1) {
                                e_2 = { error: e_2_1 };
                            }
                            finally {
                                try {
                                    if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                        _b.call(row_1);
                                }
                                finally {
                                    if (e_2)
                                        throw e_2.error;
                                }
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return))
                                _a.call(_c);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                }
            }
        }
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_rangeStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_rangeEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_minMonth", {
            get: /**
             * @return {?}
             */ function () {
                return this._datePicker.min$.value ? new Date(this._datePicker.min$.value.getFullYear(), this._datePicker.min$.value.getMonth()) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_maxMonth", {
            get: /**
             * @return {?}
             */ function () {
                return this._datePicker.max$.value ? new Date(this._datePicker.max$.value.getFullYear(), this._datePicker.max$.value.getMonth()) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update on min/max changes
                rxjs.merge(this._datePicker.min$, this._datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._changeDetector.detectChanges(); });
            };
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Get the disabled state of a month */
        /**
         * Get the disabled state of a month
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getDisabled = /**
         * Get the disabled state of a month
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var date = new Date(item.year, item.month);
                // if we are not in range mode then it will always be enabled
                if (this._isRangeMode) {
                    // if we are range start and dates are after the range end then they should also be disabled
                    if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, new Date(this._rangeEnd.getFullYear(), this._rangeEnd.getMonth()))) {
                        return true;
                    }
                    // if we are range end and dates are before the range start then they should also be disabled
                    if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, new Date(this._rangeStart.getFullYear(), this._rangeStart.getMonth()))) {
                        return true;
                    }
                }
                if (this._minMonth && isDateBefore(date, this._minMonth)) {
                    return true;
                }
                if (this._maxMonth && isDateAfter(date, this._maxMonth)) {
                    return true;
                }
                return false;
            };
        /**
         * Go to the previous year
         */
        /**
         * Go to the previous year
         * @return {?}
         */
        MonthViewComponent.prototype.previous = /**
         * Go to the previous year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
            };
        /**
         * Go to the next year
         */
        /**
         * Go to the next year
         * @return {?}
         */
        MonthViewComponent.prototype.next = /**
         * Go to the next year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
            };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
        MonthViewComponent.prototype.select = /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
            function (month) {
                this._datePicker.setViewportMonth(month);
                // show the day picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
        MonthViewComponent.prototype.focusMonth = /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
            function (item, monthOffset) {
                /** @type {?} */
                var targetMonth = item.month + monthOffset;
                /** @type {?} */
                var targetYear = item.year;
                if (targetMonth < 0) {
                    targetMonth += 12;
                    targetYear -= 1;
                }
                if (targetMonth >= 12) {
                    targetMonth -= 12;
                    targetYear += 1;
                }
                this.monthService.setFocus(targetMonth, targetYear);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        MonthViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.trackMonthByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var e_3, _a, e_4, _b;
                /** @type {?} */
                var focused = this.monthService.focused$.value;
                /** @type {?} */
                var grid = this.monthService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused month is visible
                    /** @type {?} */
                    var isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedMonthVisible) {
                        return focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable month then check if there is a selected month
                /** @type {?} */
                var isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
                if (isSelectedMonthVisible) {
                    return item.isActiveMonth;
                }
                try {
                    // otherwise find the first non-disabled month
                    for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                        var row = grid_1_1.value;
                        try {
                            for (var row_2 = __values(row), row_2_1 = row_2.next(); !row_2_1.done; row_2_1 = row_2.next()) {
                                var column = row_2_1.value;
                                if (!this.getDisabled(column)) {
                                    return item === column;
                                }
                            }
                        }
                        catch (e_4_1) {
                            e_4 = { error: e_4_1 };
                        }
                        finally {
                            try {
                                if (row_2_1 && !row_2_1.done && (_b = row_2.return))
                                    _b.call(row_2);
                            }
                            finally {
                                if (e_4)
                                    throw e_4.error;
                            }
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (grid_1_1 && !grid_1_1.done && (_a = grid_1.return))
                            _a.call(grid_1);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                return false;
            };
        /** Announce the date when we focus on a date */
        /**
         * Announce the date when we focus on a date
         * @return {?}
         */
        MonthViewComponent.prototype.announceRangeMode = /**
         * Announce the date when we focus on a date
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.shouldFocus = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var focused = this.monthService.focused$.value;
                if (focused) {
                    return focused.month === item.month && focused.year === item.year;
                }
            };
        MonthViewComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker-month-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button type=\"button\"\n         uxFocusIndicator\n         uxFocusIndicatorOrigin\n         [programmaticFocusIndicator]=\"true\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"shouldFocus(item)\"\n         [disabled]=\"getDisabled(item)\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth && !getDisabled(item)\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (focus)=\"announceRangeMode()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                        providers: [MonthViewService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        MonthViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: MonthViewService },
                { type: a11y.LiveAnnouncer },
                { type: i0.ChangeDetectorRef },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        return MonthViewComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var WeekDaySortPipe = /** @class */ (function () {
        function WeekDaySortPipe() {
        }
        /**
         * @param {?} value
         * @param {?} startOfWeek
         * @return {?}
         */
        WeekDaySortPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} startOfWeek
         * @return {?}
         */
            function (value, startOfWeek) {
                // ensure start of week is in range
                startOfWeek = Math.max(common.WeekDay.Sunday, Math.min(common.WeekDay.Saturday, startOfWeek));
                // create a new array to avoid altering the original
                /** @type {?} */
                var weekdays = __spread(value);
                for (var idx = 0; idx < startOfWeek; idx++) {
                    weekdays.push(weekdays.shift());
                }
                return weekdays;
            };
        WeekDaySortPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'weekDaySort'
                    },] }
        ];
        return WeekDaySortPipe;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TimeViewComponent = /** @class */ (function () {
        function TimeViewComponent(datepicker, _changeDetector, _rangeService, _rangeOptions) {
            var _this = this;
            this.datepicker = datepicker;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            /**
             * Earliest time permitted on the time picker.
             */
            this.min = null;
            /**
             * Latest time permitted on the time picker.
             */
            this.max = null;
            this._onDestroy = new rxjs.Subject();
            // when the date changes we should update the value
            datepicker.date$.pipe(operators.filter(function (date) { return date && _this.value instanceof Date; }), operators.takeUntil(this._onDestroy)).subscribe(function (date) {
                _this.value.setFullYear(date.getFullYear());
                _this.value.setMonth(date.getMonth());
                _this.value.setDate(date.getDate());
                _changeDetector.detectChanges();
            });
            if (!this._isRangeMode) {
                datepicker.selected$.pipe(operators.filter(function (date) { return !!date; }), operators.takeUntil(this._onDestroy)).subscribe(function (date) { return _this.value = new Date(date); });
            }
            if (this._isRangeMode && this._isRangeStart) {
                this.value = new Date();
                if (!this._rangeStart) {
                    this.value.setHours(0, 0, 0, 0);
                }
                else {
                    this.value.setHours(this._rangeStart.getHours(), this._rangeStart.getMinutes(), this._rangeStart.getSeconds());
                }
            }
            if (this._isRangeMode && this._isRangeEnd) {
                this.value = new Date();
                if (!this._rangeEnd) {
                    this.value.setHours(23, 59, 59, 0);
                }
                else {
                    this.value.setHours(this._rangeEnd.getHours(), this._rangeEnd.getMinutes(), this._rangeEnd.getSeconds());
                }
            }
        }
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_rangeStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_rangeEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // min should only apply if it's on the same day as the selected date
                rxjs.combineLatest(this.datepicker.min$, this.datepicker.date$).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                    var _b = __read(_a, 2), min = _b[0], date = _b[1];
                    _this.min = (min && date && compareDays(date, min)) ? min : null;
                    _this._changeDetector.detectChanges();
                });
                // max should only apply if it's on the same day as the selected date
                rxjs.combineLatest(this.datepicker.max$, this.datepicker.date$).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                    var _b = __read(_a, 2), max = _b[0], date = _b[1];
                    _this.max = (max && date && compareDays(date, max)) ? max : null;
                    _this._changeDetector.detectChanges();
                });
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} time
         * @return {?}
         */
        TimeViewComponent.prototype.onTimeChange = /**
         * @param {?} time
         * @return {?}
         */
            function (time) {
                if (this._isRangeMode) {
                    this.datepicker.hours = time.getHours();
                    this.datepicker.minutes = time.getMinutes();
                    this.datepicker.seconds = time.getSeconds();
                    // update the time in the range picker service
                    if (this._isRangeStart) {
                        this._rangeService.startTime = { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() };
                    }
                    else {
                        this._rangeService.endTime = { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() };
                    }
                    // if a date is currently selected we should update it
                    if (this._isRangeStart && this._rangeStart) {
                        /** @type {?} */
                        var start = new Date(this._rangeStart);
                        start.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                        this._rangeService.setStartDate(start);
                    }
                    if (this._isRangeEnd && this._rangeEnd) {
                        /** @type {?} */
                        var end = new Date(this._rangeEnd);
                        end.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                        this._rangeService.setEndDate(end);
                    }
                    return;
                }
                // if the selected time is null then do nothing
                if (!this.datepicker.selected$.value) {
                    return;
                }
                // otherwise set the time
                /** @type {?} */
                var date = new Date(this.datepicker.selected$.value);
                // update the time
                date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                // emit the time
                this.datepicker.selected$.next(date);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        TimeViewComponent.prototype.selectTimezone = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                /** @type {?} */
                var timezones$$1 = this.datepicker.timezones$.value;
                // find matching timezone
                /** @type {?} */
                var timezone = timezones$$1.find(function (_timezone) { return _timezone.name === name; });
                if (timezone) {
                    this.datepicker.setTimezone(timezone);
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.incrementTimezone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var timezone = this.datepicker.timezone$.value;
                /** @type {?} */
                var timezones$$1 = this.datepicker.timezones$.value;
                /** @type {?} */
                var currentZone = timezones$$1.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones$$1[currentZone + 1] ? timezones$$1[currentZone + 1] : timezones$$1[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.decrementTimezone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var timezone = this.datepicker.timezone$.value;
                /** @type {?} */
                var timezones$$1 = this.datepicker.timezones$.value;
                /** @type {?} */
                var currentZone = timezones$$1.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones$$1[currentZone - 1] ? timezones$$1[currentZone - 1] : timezones$$1[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.onFocusWithin = /**
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    this._rangeService.isChangingTime = true;
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.onFocusOut = /**
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    this._rangeService.isChangingTime = false;
                }
            };
        TimeViewComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker-time-view',
                        template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"value\"\n    (valueChange)=\"onTimeChange($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\"\n    [meridians]=\"datepicker.meridians\"\n    [min]=\"min\"\n    [max]=\"max\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TimeViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: i0.ChangeDetectorRef },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        TimeViewComponent.propDecorators = {
            onFocusWithin: [{ type: i0.HostListener, args: ['focusin',] }],
            onFocusOut: [{ type: i0.HostListener, args: ['focusout',] }]
        };
        return TimeViewComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var YearViewService = /** @class */ (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new rxjs.Subscription();
            /** @type {?} */
            var year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            /** @type {?} */
            var event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        /**
         * @return {?}
         */
        YearViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.setFocus = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.focused$.next(year);
                this.createYearGrid(year);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToPreviousDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year - 10);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToNextDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year + 10);
            };
        /**
         * @param {?=} year
         * @return {?}
         */
        YearViewService.prototype.createYearGrid = /**
         * @param {?=} year
         * @return {?}
         */
            function (year) {
                var _this = this;
                if (year === void 0) {
                    year = this._year;
                }
                this._year = year;
                // get the years to display
                /** @type {?} */
                var decade = this.getDecade(year);
                /** @type {?} */
                var currentYear = new Date().getFullYear();
                // produce items in the correct format
                /** @type {?} */
                var items = decade.range.map(function (_year) {
                    return {
                        year: _year,
                        isCurrentYear: _year === currentYear,
                        isActiveYear: _year === _this._datepicker.year$.value
                    };
                });
                // update the header text
                this._datepicker.setHeader(decade.start + ' - ' + decade.end);
                // create the grid
                this.grid$.next(gridify(items, 4));
            };
        /**
         * Get the years in the current decade to display
         */
        /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.getDecade = /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
            function (year) {
                // figure the start and end points
                /** @type {?} */
                var start = (year - (year % 10));
                /** @type {?} */
                var end = start + 9;
                this._datepicker.yearRange = { start: start, end: end, range: range(start, end) };
                // create an array containing all the numbers between the start and end points
                return this._datepicker.yearRange;
            };
        YearViewService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        YearViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return YearViewService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var YearViewComponent = /** @class */ (function () {
        function YearViewComponent(_datePicker, yearService, _liveAnnouncer, _changeDetector, _rangeService, _rangeOptions) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            if (this._rangeService) {
                this._rangeService.onRangeChange.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _changeDetector.detectChanges(); });
            }
        }
        Object.defineProperty(YearViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: /**
             * Determine if we are in range selection mode
             * @return {?}
             */ function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: /**
             * Determine if this picker is the start picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: /**
             * Determine if this picker is the end picker
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeOptions.picker === DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_rangeStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_rangeEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_minYear", {
            get: /**
             * @return {?}
             */ function () {
                return this._datePicker.min$.value ? new Date(this._datePicker.min$.value.getFullYear(), 0) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_maxYear", {
            get: /**
             * @return {?}
             */ function () {
                return this._datePicker.max$.value ? new Date(this._datePicker.max$.value.getFullYear(), 0) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        YearViewComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update on min/max changes
                rxjs.merge(this._datePicker.min$, this._datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._changeDetector.detectChanges(); });
            };
        /**
         * @return {?}
         */
        YearViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewComponent.prototype.select = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this._datePicker.setViewportYear(year);
                // show the month picker
                this._datePicker.goToChildMode();
            };
        /** Get the disabled state of a month */
        /**
         * Get the disabled state of a month
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getDisabled = /**
         * Get the disabled state of a month
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var date = new Date(item.year, 0);
                // if we are not in range mode then it will always be enabled
                if (this._isRangeMode) {
                    // if we are range start and dates are after the range end then they should also be disabled
                    if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, new Date(this._rangeEnd.getFullYear(), 0))) {
                        return true;
                    }
                    // if we are range end and dates are before the range start then they should also be disabled
                    if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, new Date(this._rangeStart.getFullYear(), 0))) {
                        return true;
                    }
                }
                if (this._minYear && isDateBefore(date, this._minYear)) {
                    return true;
                }
                if (this._maxYear && isDateAfter(date, this._maxYear)) {
                    return true;
                }
                return false;
            };
        /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
        YearViewComponent.prototype.focusYear = /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
            function (item, yearOffset) {
                this.yearService.setFocus(item.year + yearOffset);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        YearViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.trackYearByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var e_1, _a, e_2, _b;
                /** @type {?} */
                var focused = this.yearService.focused$.value;
                /** @type {?} */
                var grid = this.yearService.grid$.value;
                // if there is a focused year check if this is it
                if (focused) {
                    // check if the focused year is visible
                    /** @type {?} */
                    var isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                    if (isFocusedYearVisible) {
                        return focused === item.year;
                    }
                }
                // if there is no focusable year then check if there is a selected year
                /** @type {?} */
                var isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
                if (isSelectedYearVisible) {
                    return item.isActiveYear;
                }
                try {
                    // otherwise find the first non-disabled month
                    for (var _c = __values(this.yearService.grid$.value), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var row = _d.value;
                        try {
                            for (var row_1 = __values(row), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                var column = row_1_1.value;
                                if (!this.getDisabled(column)) {
                                    return item === column;
                                }
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                    _b.call(row_1);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // otherwise make the first month tabbable
                return false;
            };
        /** Announce the date when we focus on a date */
        /**
         * Announce the date when we focus on a date
         * @return {?}
         */
        YearViewComponent.prototype.announceRangeMode = /**
         * Announce the date when we focus on a date
         * @return {?}
         */
            function () {
                if (this._isRangeMode) {
                    this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
                }
            };
        YearViewComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-date-time-picker-year-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         uxFocusIndicator\n         uxFocusIndicatorOrigin\n         [programmaticFocusIndicator]=\"true\"\n         type=\"button\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear && !getDisabled(item)\"\n         [disabled]=\"getDisabled(item)\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (focus)=\"announceRangeMode()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                        providers: [YearViewService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        YearViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: YearViewService },
                { type: a11y.LiveAnnouncer },
                { type: i0.ChangeDetectorRef },
                { type: DateRangeService, decorators: [{ type: i0.Optional }] },
                { type: DateRangeOptions, decorators: [{ type: i0.Optional }] }
            ];
        };
        return YearViewComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateTimePickerModule = /** @class */ (function () {
        function DateTimePickerModule() {
        }
        /**
         * @return {?}
         */
        DateTimePickerModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: DateTimePickerModule,
                    providers: [
                        DateTimePickerConfig
                    ]
                };
            };
        DateTimePickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            FocusIfModule,
                            forms.FormsModule,
                            IconModule,
                            SpinButtonModule,
                            TimePickerModule,
                        ],
                        exports: [DateTimePickerComponent],
                        declarations: [
                            DateTimePickerComponent,
                            HeaderComponent,
                            DayViewComponent,
                            MonthViewComponent,
                            YearViewComponent,
                            TimeViewComponent,
                            WeekDaySortPipe
                        ]
                    },] }
        ];
        return DateTimePickerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateFormatterPipe = /** @class */ (function () {
        function DateFormatterPipe() {
        }
        /**
         * @param {?} value
         * @param {?} formatter
         * @return {?}
         */
        DateFormatterPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} formatter
         * @return {?}
         */
            function (value, formatter) {
                // we may not initially have  a value
                if (!value) {
                    return '';
                }
                return typeof formatter === 'function' ? formatter(value) : common.formatDate(value, formatter, navigator.language);
            };
        DateFormatterPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'formatDate'
                    },] }
        ];
        return DateFormatterPipe;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateFormatterPipeModule = /** @class */ (function () {
        function DateFormatterPipeModule() {
        }
        DateFormatterPipeModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [DateFormatterPipe],
                        declarations: [DateFormatterPipe]
                    },] }
        ];
        return DateFormatterPipeModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DateRangePickerModule = /** @class */ (function () {
        function DateRangePickerModule() {
        }
        DateRangePickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            DateTimePickerModule,
                            IconModule,
                            DateFormatterPipeModule
                        ],
                        declarations: [
                            DateRangePickerComponent,
                            DateRangePickerDirective,
                        ],
                        exports: [
                            DateRangePickerComponent
                        ]
                    },] }
        ];
        return DateRangePickerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var EboxComponent = /** @class */ (function () {
        function EboxComponent() {
        }
        EboxComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-ebox',
                        template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return EboxComponent;
    }());
    var EboxHeaderDirective = /** @class */ (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-ebox-header'
                    },] }
        ];
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = /** @class */ (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-ebox-content'
                    },] }
        ];
        return EboxContentDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var EboxModule = /** @class */ (function () {
        function EboxModule() {
        }
        EboxModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                        declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                    },] }
        ];
        return EboxModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetHeaderComponent = /** @class */ (function () {
        function FacetHeaderComponent(focusIndicatorService, elementRef) {
            /**
             * Defines whether or not clicking on the header will toggle the expanded state.
             */
            this.canExpand = true;
            /**
             * Can be used to set the initial expanded state.
             */
            this.expanded = true;
            /**
             * If two-way binding is used it will be updated when the expanded state changes.
             */
            this.expandedChange = new i0.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusIndicator.destroy();
            };
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                // if not expandable then do nothing
                if (this.canExpand) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        FacetHeaderComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-header',
                        template: "<span class=\"facet-header-title\">{{ header }}</span>\n<ux-icon *ngIf=\"canExpand\" [name]=\"expanded ? 'down' : 'previous'\" class=\"facet-header-icon\"></ux-icon>\n",
                        host: {
                            'role': 'button',
                            'tabindex': '0',
                            '(click)': 'toggleExpand()',
                            '(keyup.enter)': 'toggleExpand()',
                            '[attr.aria-expanded]': 'expanded',
                            '[attr.aria-label]': 'header + \' Facet: Activate to \' + (expanded ? \'collapse\' : \'expand\')'
                        }
                    }] }
        ];
        /** @nocollapse */
        FacetHeaderComponent.ctorParameters = function () {
            return [
                { type: FocusIndicatorService },
                { type: i0.ElementRef }
            ];
        };
        FacetHeaderComponent.propDecorators = {
            header: [{ type: i0.Input }],
            canExpand: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.expanded',] }],
            expandedChange: [{ type: i0.Output }]
        };
        return FacetHeaderComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetSelect = /** @class */ (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = /** @class */ (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = /** @class */ (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetService = /** @class */ (function () {
        function FacetService() {
            /**
             * The list of active facets
             */
            this.facets$ = new rxjs.BehaviorSubject([]);
            /**
             * Emit all the events when they occur
             */
            this.events$ = new rxjs.Subject();
        }
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetService.prototype.select = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is already selected or disabled then do nothing
                if (this.isSelected(facet) || facet.disabled) {
                    return;
                }
                // update the list of active facets
                this.facets$.next(__spread(this.facets$.value, [facet]));
                // emit the event
                this.events$.next(new FacetSelect(facet));
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetService.prototype.deselect = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is not selected then do nothing
                if (!this.isSelected(facet)) {
                    return;
                }
                // update the list of active facets
                this.facets$.next(this.facets$.value.filter(function (_facet) { return _facet !== facet; }));
                // emit the event
                this.events$.next(new FacetDeselect(facet));
            };
        /**
         * @return {?}
         */
        FacetService.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                // empty the list of active facets
                this.facets$.next([]);
                // emit the event
                this.events$.next(new FacetDeselectAll());
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetService.prototype.toggle = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                this.isSelected(facet) ? this.deselect(facet) : this.select(facet);
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetService.prototype.isSelected = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                return this.facets$.value.indexOf(facet) > -1;
            };
        FacetService.decorators = [
            { type: i0.Injectable }
        ];
        return FacetService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetCheckListItemComponent = /** @class */ (function () {
        function FacetCheckListItemComponent() {
            this.facet = null;
            this.selected = false;
            this.tabbable = false;
            this.simplified = false;
            this.selectedChange = new i0.EventEmitter();
            this.itemFocus = new i0.EventEmitter();
            this.itemBlur = new i0.EventEmitter();
        }
        Object.defineProperty(FacetCheckListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : '';
            };
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetCheckListItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-check-list-item',
                        template: "<div #option\n    uxFocusIndicator\n    class=\"facet-check-list-item\"\n    [class.facet-active]=\"selected\"\n    [attr.aria-checked]=\"selected\"\n    role=\"option\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (blur)=\"itemBlur.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    [class.disabled]=\"facet?.disabled\">\n\n    <!-- Show check icon to indicate the state -->\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-check-list-item-title\">{{ facet?.title }}</span>\n        <span *ngIf=\"facet?.count !== undefined\" class=\"facet-check-list-item-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetCheckListItemComponent.propDecorators = {
            facet: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            tabbable: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            itemFocus: [{ type: i0.Output }],
            itemBlur: [{ type: i0.Output }],
            option: [{ type: i0.ViewChild, args: ['option', { static: true },] }]
        };
        return FacetCheckListItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetCheckListComponent = /** @class */ (function () {
        function FacetCheckListComponent(facetService) {
            var _this = this;
            this.facetService = facetService;
            /**
             * Defines the complete list of facets that can be selected.
             */
            this.facets = [];
            /**
             * If `false` the list will grow to display all possible facets. If `true` a scrollbar will appear to prevent the list from growing too large.
             */
            this.scrollbar = true;
            /**
             * Defines whether or not the checkboxes will appear in simplified form.
             */
            this.simplified = false;
            /**
             * Defines whether or not the Facet Check List should be initially expanded or not.
             */
            this.expanded = true;
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property (deselect all will not contain affected facets).
             */
            this.events = new rxjs.Subject();
            /**
             * If two-way binding is used this array will get updated any time the selected facets change.
             */
            this.selectedChange = new i0.EventEmitter();
            this.isFocused = false;
            this.activeIndex = 0;
            this._onDestroy = new rxjs.Subject();
            facetService.events$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // deselect all events should always be emitted
                if (event instanceof FacetDeselectAll) {
                    _this.events.next(event);
                    _this.selectedChange.next([]);
                }
                // selection and deselection events should only be emitted when the facet belongs to this component
                if ((event instanceof FacetSelect || event instanceof FacetDeselect) && _this.isOwnFacet(event.facet)) {
                    _this.events.next(event);
                    _this.selectedChange.next(_this.getSelectedFacets());
                }
            });
        }
        Object.defineProperty(FacetCheckListComponent.prototype, "selected", {
            /** This will allow you to define an initial set of selected facets. */
            set: /**
             * This will allow you to define an initial set of selected facets.
             * @param {?} selection
             * @return {?}
             */ function (selection) {
                var _this = this;
                if (Array.isArray(selection)) {
                    selection.forEach(function (facet) { return _this.facetService.select(facet); });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._focusKeyManager = new a11y.FocusKeyManager(this.options)
                    .withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetCheckListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetCheckListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetCheckListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                this.facetService.toggle(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.getSelectedFacets = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.facetService.facets$.value.filter(function (facet) { return _this.isOwnFacet(facet); });
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetCheckListComponent.prototype.isOwnFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                return this.facets.indexOf(facet) !== -1;
            };
        FacetCheckListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-check-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\"\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [class.facet-check-list-scrollbar]=\"scrollbar\"\n    [class.facet-check-list-scrollbar-focused]=\"isFocused\"\n    *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <ux-facet-check-list-item *ngFor=\"let facet of facets; let index = index\"\n        [facet]=\"facet\"\n        [simplified]=\"simplified\"\n        [tabbable]=\"activeIndex === index\"\n        [selected]=\"facetService.isSelected(facet)\"\n        (selectedChange)=\"toggleFacet(index, facet)\"\n        (keydown)=\"onKeydown($event)\"\n        (itemFocus)=\"isFocused = true; onFocus(index)\"\n        (itemBlur)=\"isFocused = false\">\n    </ux-facet-check-list-item>\n\n</div>"
                    }] }
        ];
        /** @nocollapse */
        FacetCheckListComponent.ctorParameters = function () {
            return [
                { type: FacetService }
            ];
        };
        FacetCheckListComponent.propDecorators = {
            selected: [{ type: i0.Input }],
            facets: [{ type: i0.Input }],
            header: [{ type: i0.Input }],
            scrollbar: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            events: [{ type: i0.Output }],
            selectedChange: [{ type: i0.Output }],
            options: [{ type: i0.ViewChildren, args: [FacetCheckListItemComponent,] }]
        };
        return FacetCheckListComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetClearButtonDirective = /** @class */ (function () {
        function FacetClearButtonDirective() {
        }
        FacetClearButtonDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFacetClearButton]'
                    },] }
        ];
        return FacetClearButtonDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetContainerComponent = /** @class */ (function () {
        function FacetContainerComponent(_announcer, facetService) {
            var _this = this;
            this._announcer = _announcer;
            this.facetService = facetService;
            /**
             * Defines the text displayed at the top of the Facet Container.
             */
            this.header = 'Selected';
            /**
             * Defines the text to display in the tooltip when hovering over the clear all button.
             */
            this.clearTooltip = 'Clear All';
            /**
             * Defines the text to display when there are no selected facets.
             */
            this.emptyText = 'No Items';
            /**
             * Determines if the facets can be reordered.
             */
            this.facetsReorderable = false;
            /**
             * Defines the aria-label for the clear all button.
             */
            this.clearAriaLabel = 'Clear All';
            /**
             * Defines the aria-label for the deselect facet button..
             */
            this.deselectFacetAriaLabel = 'Deselect Facet';
            /**
             * If using two-way binding this array will update when the selected facets change.
             */
            this.facetsChange = new i0.EventEmitter();
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property
             * (deselect all will not contain affected facets).
             */
            this.events = new i0.EventEmitter();
            this._onDestroy = new rxjs.Subject();
            facetService.facets$.subscribe(function (facets) { return _this.facetsChange.next(facets); });
            facetService.events$.subscribe(function (event) { return _this.triggerEvent(event); });
            // announce deselection
            facetService.events$.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }))
                .subscribe(function (event) { return _this._announcer.announce("Option " + event.facet.title + " deselected.", 'assertive'); });
        }
        Object.defineProperty(FacetContainerComponent.prototype, "facets", {
            get: /**
             * @return {?}
             */ function () {
                return this.facetService.facets$.value;
            },
            /** Allows a predefined set of Facets to be displayed. */
            set: /**
             * Allows a predefined set of Facets to be displayed.
             * @param {?} facets
             * @return {?}
             */ function (facets) {
                this.facetService.facets$.next(facets);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.selectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                this.facetService.select(facet);
            };
        /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectFacet = /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
            function (facet, tag) {
                // find the index of the item in the selected array
                /** @type {?} */
                var idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
                // if match there was no match then finish
                if (idx === -1) {
                    return;
                }
                // remove the last item
                this.facetService.deselect(facet);
                // announce the facet removal
                this._announcer.announce("Option " + facet.title + " deselected.", 'assertive');
                // focus another tag if there is one
                if (tag) {
                    /** @type {?} */
                    var sibling = tag.previousElementSibling || tag.nextElementSibling;
                    // if there is a sibling then focus it
                    if (sibling) {
                        (( /** @type {?} */(sibling))).focus();
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectAllFacets = /**
         * @return {?}
         */
            function () {
                // empty the selected array
                this.facetService.deselectAll();
                // announce the facet removal
                this._announcer.announce("All options deselected.", 'assertive');
            };
        /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.trackBy = /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
            function (_index, facet) {
                return facet.id || facet.title;
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftRight = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, 1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved down.");
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftLeft = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, -1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved up.");
            };
        /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftFacet = /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
            function (facet, distance) {
                /** @type {?} */
                var index = this.facets.indexOf(facet);
                /** @type {?} */
                var target = index + distance;
                // Ensure the move is valid
                if (target < 0 || target === this.facets.length) {
                    return;
                }
                // Perform the move
                this.facets.splice(index, 1);
                this.facets.splice(target, 0, facet);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetContainerComponent.prototype.triggerEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.events.next(event);
            };
        FacetContainerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-container',
                        template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <ng-container *ngIf=\"(facetService.facets$ | async).length > 0\" [ngTemplateOutlet]=\"clearButton || clearButtonDefault\"></ng-container>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\"\n        uxReorderable\n        role=\"list\"\n        [reorderingDisabled]=\"!facetsReorderable\"\n        [(reorderableModel)]=\"facets\"\n        (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div #tag\n            class=\"facet-selected-tag\"\n            role=\"listitem\"\n            tabindex=\"0\"\n            uxReorderableHandle\n            *ngFor=\"let facet of (facetService.facets$ | async); trackBy: trackBy\"\n            [attr.aria-label]=\"facet.title\"\n            [uxReorderableModel]=\"facet\"\n            (mousedown)=\"tag.focus()\"\n            (touchmove)=\"$event.preventDefault()\"\n            (keydown.ArrowRight)=\"shiftRight(facet, tag)\"\n            (keydown.ArrowLeft)=\"shiftLeft(facet, tag)\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\">{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <button type=\"button\"\n                uxFocusIndicator\n                class=\"facet-selected-remove-btn\"\n                [attr.aria-label]=\"deselectFacetAriaLabel\"\n                (click)=\"deselectFacet(facet, tag)\">\n\n                <ux-icon name=\"close\"></ux-icon>\n            </button>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && (facetService.facets$ | async).length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>\n\n<ng-template #clearButtonDefault>\n    <button type=\"button\"\n            class=\"btn btn-link btn-icon button-secondary\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"clearAriaLabel\"\n            [uxTooltip]=\"clearTooltip\"\n            placement=\"left\"\n            (click)=\"deselectAllFacets()\">\n\n            <svg class=\"facets-selected-clear-graphic\" focusable=\"false\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </button>\n</ng-template>",
                        providers: [FacetService]
                    }] }
        ];
        /** @nocollapse */
        FacetContainerComponent.ctorParameters = function () {
            return [
                { type: a11y.LiveAnnouncer },
                { type: FacetService }
            ];
        };
        FacetContainerComponent.propDecorators = {
            header: [{ type: i0.Input }],
            clearTooltip: [{ type: i0.Input }],
            emptyText: [{ type: i0.Input }],
            facetsReorderable: [{ type: i0.Input }],
            facets: [{ type: i0.Input }],
            clearAriaLabel: [{ type: i0.Input }],
            deselectFacetAriaLabel: [{ type: i0.Input }],
            facetsChange: [{ type: i0.Output }],
            events: [{ type: i0.Output }],
            clearButton: [{ type: i0.ContentChild, args: [FacetClearButtonDirective, { read: i0.TemplateRef, static: false },] }]
        };
        return FacetContainerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ TypeaheadOptionEvent = /** @class */ (function () {
        function TypeaheadOptionEvent(option, origin) {
            this.option = option;
            this.origin = origin;
        }
        return TypeaheadOptionEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var TypeaheadKeyService = /** @class */ (function () {
        function TypeaheadKeyService() {
        }
        /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
        TypeaheadKeyService.prototype.handleKey = /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
            function (event, typeahead) {
                if (!typeahead) {
                    return;
                }
                switch (event.keyCode) {
                    case keycodes.UP_ARROW:
                        if (!typeahead.open) {
                            typeahead.open = true;
                        }
                        else {
                            typeahead.moveHighlight(-1);
                        }
                        event.preventDefault();
                        break;
                    case keycodes.DOWN_ARROW:
                        if (!typeahead.open) {
                            typeahead.open = true;
                        }
                        else {
                            typeahead.moveHighlight(1);
                        }
                        event.preventDefault();
                        break;
                    case keycodes.ESCAPE:
                        typeahead.open = false;
                        break;
                    case keycodes.ENTER:
                        if (typeahead.selectOnEnter) {
                            typeahead.selectHighlighted();
                        }
                }
            };
        TypeaheadKeyService.decorators = [
            { type: i0.Injectable }
        ];
        return TypeaheadKeyService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TypeaheadService = /** @class */ (function () {
        function TypeaheadService() {
            this.open$ = new rxjs.BehaviorSubject(false);
            this.highlightedElement$ = new rxjs.BehaviorSubject(null);
        }
        TypeaheadService.decorators = [
            { type: i0.Injectable }
        ];
        return TypeaheadService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$3 = 0;
    /**
     * @template T
     */
    var TypeaheadComponent = /** @class */ (function () {
        function TypeaheadComponent(typeaheadElement, _changeDetector, _service) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._changeDetector = _changeDetector;
            this._service = _service;
            /**
             * Define a unique id for the typeahead
             */
            this.id = "ux-typeahead-" + ++uniqueId$3;
            /**
             * Specify the drop direction
             */
            this.dropDirection = 'down';
            /**
             * Specify the max height of the dropdown
             */
            this.maxHeight = '250px';
            /**
             * Specify the aria multi selectable attribute value
             */
            this.multiselectable = false;
            /**
             * Specify if the dropdown should appear when the filter appears
             */
            this.openOnFilterChange = true;
            /**
             * Specify the page size
             */
            this.pageSize = 20;
            /**
             * Specify if we should select the first item by default
             */
            this.selectFirst = true;
            /**
             * Specify if we should select an item on enter key press
             */
            this.selectOnEnter = false;
            /**
             * Specify the loading state
             */
            this.loading = false;
            /**
             * Emit when the open state changes
             */
            this.openChange = new i0.EventEmitter();
            /**
             * Emit when an option is selected
             */
            this.optionSelected = new i0.EventEmitter();
            /**
             * Emit whenever a highlighted item changes
             */
            this.highlightedChange = new i0.EventEmitter();
            /**
             * Emit the highlighted element when it changes
             */
            this.highlightedElementChange = new i0.EventEmitter();
            this.activeKey = null;
            this.clicking = false;
            this.hasBeenOpened = false;
            this.highlighted$ = new rxjs.BehaviorSubject(null);
            this.highlightedKey = null;
            this.visibleOptions$ = new rxjs.BehaviorSubject([]);
            this._onDestroy = new rxjs.Subject();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    /** @type {?} */
                    var arrayOrPromise = _this.options(pageNum, pageSize, filter);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return newOptions.map(function (option) {
                            return {
                                value: option,
                                key: _this.getKey(option)
                            };
                        });
                    });
                }
                return null;
            };
            this._service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isOpen) {
                _this.openChange.emit(isOpen);
                if (isOpen) {
                    _this.hasBeenOpened = true;
                    _this.initOptions();
                }
            });
            this.highlighted$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.highlightedKey = next ? next.key : null;
                _this.highlightedChange.emit(next ? next.value : null);
            });
            rxjs.combineLatest([this._service.open$, this._service.highlightedElement$, this.visibleOptions$])
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            });
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            /** Specify if the typeahead is open */
            get: /**
             * Specify if the typeahead is open
             * @return {?}
             */ function () {
                return this._service.open$.getValue();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "active", {
            /** Specify the currently active item */
            set: /**
             * Specify the currently active item
             * @param {?} item
             * @return {?}
             */ function (item) {
                this.activeKey = this.getKey(item);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // Open the dropdown if the filter value updates
                if (changes.filter) {
                    if (this.openOnFilterChange && changes.filter.currentValue && changes.filter.currentValue.length > 0) {
                        // if the dropdown item was just selected, and we set the filter value to match the
                        // selected value then open will have also just been set to `false`, in which case we do
                        // not want to set open to `true`
                        if (changes.open && changes.open.previousValue === true && changes.open.currentValue === false) {
                            return;
                        }
                        // show the dropdown
                        this.open = true;
                    }
                }
                // Re-filter visibleOptions
                this.updateOptions();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mousedownHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = true;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mouseupHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.optionMousedownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Workaround to prevent focus changing when an option is clicked
                event.preventDefault();
            };
        /**
         * @param {?} _event
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.optionClickHandler = /**
         * @param {?} _event
         * @param {?} option
         * @return {?}
         */
            function (_event, option) {
                this.select(option, 'mouse');
            };
        /**
         * Returns the unique key value of the given option.
         */
        /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getKey = /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.key === 'function') {
                    return this.key(option);
                }
                if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                    return option[( /** @type {?} */(this.key))];
                }
                return this.getDisplay(option);
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                    return option[( /** @type {?} */(this.display))];
                }
                if (typeof option === 'string') {
                    return option;
                }
            };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplayHtml = /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                /** @type {?} */
                var displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                /** @type {?} */
                var displayHtml = displayText;
                if (this.filter) {
                    /** @type {?} */
                    var length_1 = this.filter.length;
                    /** @type {?} */
                    var matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
                    if (matchIndex >= 0) {
                        /** @type {?} */
                        var highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                        displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
                    }
                }
                return displayHtml;
            };
        /**
         * Returns true if the infinite scroll component should load
         */
        /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
        TypeaheadComponent.prototype.isInfiniteScroll = /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
            function () {
                return typeof this.options === 'function';
            };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @param {?=} origin
         * @return {?}
         */
        TypeaheadComponent.prototype.select = /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @param {?=} origin
         * @return {?}
         */
            function (option, origin) {
                if (!this.isDisabled(option)) {
                    this.optionSelected.emit(new TypeaheadOptionEvent(option.value, origin));
                    this.highlighted$.next(null);
                    this.open = false;
                }
            };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.isDisabled = /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                var _this = this;
                if (this.disabledOptions && Array.isArray(this.disabledOptions)) {
                    /** @type {?} */
                    var result = this.disabledOptions.find(function (selectedOption) {
                        return _this.getKey(selectedOption) === option.key;
                    });
                    return result !== undefined;
                }
                return false;
            };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.highlight = /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (!this.isDisabled(option)) {
                    this.highlighted$.next(option);
                    this._changeDetector.detectChanges();
                }
            };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TypeaheadComponent.prototype.moveHighlight = /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (d) {
                /** @type {?} */
                var visibleOptions = this.visibleOptions$.getValue();
                /** @type {?} */
                var highlightIndex = this.indexOfVisibleOption(this.highlighted);
                /** @type {?} */
                var newIndex = highlightIndex;
                /** @type {?} */
                var disabled = true;
                /** @type {?} */
                var inBounds = true;
                do {
                    newIndex = newIndex + d;
                    inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
                    disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
                } while (inBounds && disabled);
                if (!disabled && inBounds) {
                    this.highlight(visibleOptions[newIndex]);
                }
                return this.highlighted;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.selectHighlighted = /**
         * @return {?}
         */
            function () {
                if (this.highlighted) {
                    this.select({ value: this.highlighted, key: this.getKey(this.highlighted) }, 'keyboard');
                }
            };
        /**
         * Set up the options before the dropdown is displayed.
         */
        /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
        TypeaheadComponent.prototype.initOptions = /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
            function () {
                // Clear previous highlight
                this.highlighted$.next(null);
                if (this.selectFirst) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Display the first item as highlighted when there are several pages
         */
        /**
         * Display the first item as highlighted when there are several pages
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.onLoadedHighlight = /**
         * Display the first item as highlighted when there are several pages
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.selectFirst && this.options && event.pageNumber === 0) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Update the visibleOptions array with the current filter.
         */
        /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
        TypeaheadComponent.prototype.updateOptions = /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
            function () {
                var _this = this;
                if (typeof this.options === 'object') {
                    /** @type {?} */
                    var normalisedInput_1 = (this.filter || '').toLowerCase();
                    /** @type {?} */
                    var visibleOptions = this.options
                        .filter(function (option) {
                        return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
                    })
                        .map(function (value) {
                        return {
                            value: value,
                            key: _this.getKey(value)
                        };
                    });
                    this.visibleOptions$.next(visibleOptions);
                }
                this.initOptions();
                this._changeDetector.detectChanges();
            };
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         */
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.indexOfVisibleOption = /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option) {
                    /** @type {?} */
                    var optionKey_1 = this.getKey(option);
                    return this.visibleOptions$.getValue().findIndex(function (el) {
                        return el.key === optionKey_1;
                    });
                }
                return -1;
            };
        TypeaheadComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-typeahead',
                        template: "<div class=\"ux-typeahead-options\"\n     [uxInfiniteScroll]=\"loadOptionsCallback\"\n     [collection]=\"visibleOptions$ | async\"\n     (collectionChange)=\"visibleOptions$.next($event)\"\n     [enabled]=\"hasBeenOpened && isInfiniteScroll()\"\n     [filter]=\"filter\"\n     [loadOnScroll]=\"true\"\n     [pageSize]=\"pageSize\"\n     [scrollElement]=\"typeaheadElement\"\n     (loading)=\"loading = true\"\n     (loaded)=\"loading = false; onLoadedHighlight($event)\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [class.active]=\"activeKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : (activeKey === option.key ? true : null)\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate || defaultOptionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n    <div *ngIf=\"isInfiniteScroll() === false && (visibleOptions$ | async).length === 0 && loading\">\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate || defaultNoOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                        providers: [TypeaheadService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'listbox',
                            '[class.open]': 'open',
                            '[class.drop-up]': 'dropDirection === "up"',
                            '[style.maxHeight]': 'maxHeight'
                        }
                    }] }
        ];
        /** @nocollapse */
        TypeaheadComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.ChangeDetectorRef },
                { type: TypeaheadService }
            ];
        };
        TypeaheadComponent.propDecorators = {
            id: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.id',] }],
            options: [{ type: i0.Input }],
            filter: [{ type: i0.Input }],
            open: [{ type: i0.Input }],
            display: [{ type: i0.Input }],
            key: [{ type: i0.Input }],
            disabledOptions: [{ type: i0.Input }],
            dropDirection: [{ type: i0.Input }],
            maxHeight: [{ type: i0.Input }],
            multiselectable: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-multiselectable',] }],
            openOnFilterChange: [{ type: i0.Input }],
            pageSize: [{ type: i0.Input }],
            selectFirst: [{ type: i0.Input }],
            selectOnEnter: [{ type: i0.Input }],
            loading: [{ type: i0.Input }],
            loadingTemplate: [{ type: i0.Input }],
            optionTemplate: [{ type: i0.Input }],
            noOptionsTemplate: [{ type: i0.Input }],
            active: [{ type: i0.Input }],
            openChange: [{ type: i0.Output }],
            optionSelected: [{ type: i0.Output }],
            highlightedChange: [{ type: i0.Output }],
            highlightedElementChange: [{ type: i0.Output }],
            mousedownHandler: [{ type: i0.HostListener, args: ['mousedown',] }],
            mouseupHandler: [{ type: i0.HostListener, args: ['mouseup',] }]
        };
        return TypeaheadComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var InfiniteScrollLoadButtonDirective = /** @class */ (function () {
        function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
            this._element = _element;
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new rxjs.Subject();
            this.loading = ( /** @type {?} */(this._load.asObservable()));
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._template);
                        // Template content follows the elementRef, which is a comment.
                        /** @type {?} */
                        var clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                        this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._load.next(event);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var next = element;
                while (next = next.nextSibling) {
                    if (next.nodeType === 1) {
                        return next;
                    }
                }
                return null;
            };
        InfiniteScrollLoadButtonDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxInfiniteScrollLoadButton]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadButtonDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef },
                { type: i0.Renderer2 }
            ];
        };
        InfiniteScrollLoadButtonDirective.propDecorators = {
            visible: [{ type: i0.Input, args: ['uxInfiniteScrollLoadButton',] }],
            loading: [{ type: i0.Output }]
        };
        return InfiniteScrollLoadButtonDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var InfiniteScrollLoadingDirective = /** @class */ (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxInfiniteScrollLoading]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadingDirective.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        InfiniteScrollLoadingDirective.propDecorators = {
            visible: [{ type: i0.Input, args: ['uxInfiniteScrollLoading',] }]
        };
        return InfiniteScrollLoadingDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var InfiniteScrollDirective = /** @class */ (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new i0.EventEmitter();
            this.loadingEvent = new i0.EventEmitter();
            this.loadedEvent = new i0.EventEmitter();
            this.loadErrorEvent = new i0.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new rxjs.Subject();
            this._isLoading = new rxjs.BehaviorSubject(false);
            this._isExhausted = new rxjs.BehaviorSubject(false);
            this._loadButtonEnabled = new rxjs.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new rxjs.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: /**
             * @return {?}
             */ function () {
                return this._collection;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._scrollElement = element instanceof i0.ElementRef ? element : new i0.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this._scrollElement) {
                    this._scrollElement = this._element;
                }
                this._loadButtonEnabled.next(!this.loadOnScroll);
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // There are two kinds of update requests: check and load.
                // Check requests are throttled and will only cause an update if more data is required
                // to fill the scrolling view, and it isn't already loading some.
                // Load requests are not throttled and always request a page of data.
                this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                if (this.enabled) {
                    // Subscribe to scroll events and DOM changes.
                    this.attachEventHandlers();
                }
                // Connect the Load More button visible state.
                this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                    _this._loadButtonQuery.forEach(function (loadButton) {
                        loadButton.visible = canLoad;
                    });
                });
                // Connect the loading indicator visible state.
                this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                    _this._loadingIndicatorQuery.forEach(function (loading) {
                        loading.visible = isLoading;
                    });
                });
                // Link the Load More button click event to trigger an update.
                this.attachLoadButtonEvents();
                this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.attachLoadButtonEvents();
                });
                // Initial update.
                if (this.loadOnInit) {
                    this.loadNextPage();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                /** @type {?} */
                var check = true;
                if (changes.enabled && changes.enabled.currentValue !== changes.enabled.previousValue) {
                    if (changes.enabled.currentValue) {
                        this.attachEventHandlers();
                        this.reset();
                        check = false;
                    }
                    else {
                        this.detachEventHandlers();
                    }
                }
                if (this.enabled) {
                    if (changes.filter && changes.filter.currentValue !== changes.filter.previousValue) {
                        this.reset();
                        check = false;
                    }
                    if (changes.loadOnScroll) {
                        this._loadButtonEnabled.next(!changes.loadOnScroll.currentValue);
                    }
                    if (changes.pageSize && changes.pageSize.currentValue !== changes.pageSize.previousValue) {
                        this.reset();
                        check = false;
                    }
                    this._updateRequests.next({
                        check: check,
                        pageNumber: this._nextPageNum,
                        pageSize: this.pageSize,
                        filter: this.filter
                    });
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.detachEventHandlers();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Request an additional page of data.
         */
        /**
         * Request an additional page of data.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.loadNextPage = /**
         * Request an additional page of data.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.check = /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: true,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reset = /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                // Reset the page counter.
                this._nextPageNum = 0;
                this._pages = [];
                // Clear the collection (without changing the reference).
                if (this.collection) {
                    this.collection.length = 0;
                }
                // Reset the exhausted flag, allowing the Load More button to appear.
                this._isExhausted.next(false);
                // Cancel any pending requests
                if (this._subscriptions) {
                    this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
                }
            };
        /**
         * Reload the data without clearing the view.
         */
        /**
         * Reload the data without clearing the view.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reload = /**
         * Reload the data without clearing the view.
         * @return {?}
         */
            function () {
                var _this = this;
                this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
            };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reloadPage = /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
            function (pageNum) {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: pageNum,
                    pageSize: this.pageSize,
                    filter: this.filter,
                    reload: true
                });
            };
        /**
         * Attach scroll event handler and DOM observer.
         */
        /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachEventHandlers = /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                // if the scrollElement is documentElement we must watch for a scroll event on the document
                /** @type {?} */
                var target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
                // Subscribe to the scroll event on the target element.
                this._scrollEventSub = rxjs.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
                // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
                // required after the initial load.
                this._domObserver = new MutationObserver(this.check.bind(this));
                this._domObserver.observe(this._scrollElement.nativeElement, {
                    childList: true,
                    subtree: true
                });
            };
        /**
         * Detach scroll event handler and DOM observer.
         */
        /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.detachEventHandlers = /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                if (this._scrollEventSub) {
                    this._scrollEventSub.unsubscribe();
                    this._scrollEventSub = null;
                }
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            };
        /**
         * Remove any existing event subscriptions for the load button `loading` event, then attach
         * subscriptions
         * for any in the query.
         */
        /**
         * Remove any existing event subscriptions for the load button `loading` event, then attach
         * subscriptions
         * for any in the query.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents = /**
         * Remove any existing event subscriptions for the load button `loading` event, then attach
         * subscriptions
         * for any in the query.
         * @return {?}
         */
            function () {
                var _this = this;
                this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.loading.subscribe(_this.loadNextPage.bind(_this)); });
            };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         */
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.doRequest = /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                var _this = this;
                // Load a new page if the scroll position is beyond the threshhold and if the client code did not
                // cancel.
                if (this.needsData(request) && this.beginLoading(request)) {
                    // Invoke the callback load function, which returns a promose or plain data.
                    /** @type {?} */
                    var loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                    /** @type {?} */
                    var observable = Array.isArray(loadResult) ? rxjs.of(loadResult) : rxjs.from(loadResult);
                    /** @type {?} */
                    var subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                        // Make sure that the parameters have not changed since the load started;
                        // otherwise discard the results.
                        if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                            if (items && items.length) {
                                _this.setPageItems(request.pageNumber, items);
                            }
                            // Emit the loaded event
                            _this.endLoading(request, items);
                        }
                    }, function (reason) {
                        // Emit the loadError event
                        _this.endLoadingWithError(request, reason);
                    }, function () {
                        // remove this request from the list
                        _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    });
                    // add the subscription to the list of requests
                    this._subscriptions.push(subscription_1);
                }
            };
        /**
         * Returns true if the request should be fulfilled.
         */
        /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.needsData = /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                if (!this.enabled) {
                    return false;
                }
                // Always load for a load request
                if (!request.check) {
                    return true;
                }
                // Ignore a check request when the end of data has been detected, or if data is currently loading.
                if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                    return false;
                }
                // Load if the remaining scroll area is <= the element height.
                if (this._scrollElement && this.loadOnScroll) {
                    /** @type {?} */
                    var element = ( /** @type {?} */(this._scrollElement.nativeElement));
                    /** @type {?} */
                    var remainingScroll = element.scrollHeight -
                        (element.scrollTop + element.clientHeight);
                    return remainingScroll <= element.clientHeight;
                }
                return false;
            };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         */
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.beginLoading = /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                /** @type {?} */
                var event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
                this.loadingEvent.emit(event);
                this._isLoading.next(!event.defaultPrevented());
                return !event.defaultPrevented();
            };
        /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
        InfiniteScrollDirective.prototype.setPageItems = /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
            function (pageNum, items) {
                this._pages[pageNum] = items;
                this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
            };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         */
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoading = /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
            function (request, data) {
                this._isLoading.next(false);
                /** @type {?} */
                var isExhausted = !!(data && data.length < this.pageSize);
                this._isExhausted.next(isExhausted);
                this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
                if (!request.reload) {
                    this._nextPageNum += 1;
                }
            };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         */
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoadingWithError = /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
            function (request, error) {
                this._isLoading.next(false);
                this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
            };
        InfiniteScrollDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxInfiniteScroll]',
                        exportAs: 'uxInfiniteScroll'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        InfiniteScrollDirective.propDecorators = {
            load: [{ type: i0.Input, args: ['uxInfiniteScroll',] }],
            _collection: [{ type: i0.Input, args: ['collection',] }],
            scrollElement: [{ type: i0.Input }],
            enabled: [{ type: i0.Input }],
            filter: [{ type: i0.Input }],
            loadOnInit: [{ type: i0.Input }],
            loadOnScroll: [{ type: i0.Input }],
            pageSize: [{ type: i0.Input }],
            collectionChange: [{ type: i0.Output }],
            loadingEvent: [{ type: i0.Output, args: ['loading',] }],
            loadedEvent: [{ type: i0.Output, args: ['loaded',] }],
            loadErrorEvent: [{ type: i0.Output, args: ['loadError',] }],
            _loadButtonQuery: [{ type: i0.ContentChildren, args: [InfiniteScrollLoadButtonDirective,] }],
            _loadingIndicatorQuery: [{ type: i0.ContentChildren, args: [InfiniteScrollLoadingDirective,] }]
        };
        return InfiniteScrollDirective;
    }());
    /**
     * Event raised before the `loading` function is called.
     * @template S
     */
    var /**
     * Event raised before the `loading` function is called.
     * @template S
     */ InfiniteScrollLoadingEvent = /** @class */ (function () {
        function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault = /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     * @template T, S
     */
    var /**
     * Event raised when the loading function result has been resolved and added to the collection.
     * @template T, S
     */ InfiniteScrollLoadedEvent = /** @class */ (function () {
        function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter, data, exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     * @template S
     */
    var /**
     * Event raised if the loading function returns a rejected promise.
     * @template S
     */ InfiniteScrollLoadErrorEvent = /** @class */ (function () {
        function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter, error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var InfiniteScrollModule = /** @class */ (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        declarations: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        providers: [],
                    },] }
        ];
        return InfiniteScrollModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ScrollIntoViewService = /** @class */ (function () {
        function ScrollIntoViewService() {
        }
        /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
        ScrollIntoViewService.prototype.scrollIntoView = /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
            function (elem, scrollParent) {
                /** @type {?} */
                var offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
                if (offsetTop < scrollParent.scrollTop) {
                    scrollParent.scrollTop = offsetTop;
                }
                else {
                    /** @type {?} */
                    var offsetBottom = offsetTop + elem.offsetHeight;
                    if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                        scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                    }
                }
            };
        ScrollIntoViewService.decorators = [
            { type: i0.Injectable }
        ];
        return ScrollIntoViewService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ScrollIntoViewIfDirective = /** @class */ (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewIfDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.condition) {
                    setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
                }
            };
        ScrollIntoViewIfDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxScrollIntoViewIf]',
                        providers: [ScrollIntoViewService]
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewIfDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ScrollIntoViewService }
            ];
        };
        ScrollIntoViewIfDirective.propDecorators = {
            condition: [{ type: i0.Input, args: ['uxScrollIntoViewIf',] }],
            scrollParent: [{ type: i0.Input }]
        };
        return ScrollIntoViewIfDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ScrollIntoViewDirective = /** @class */ (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow a condition around whether or not this should scroll into view
             */
            this.uxScrollIntoView = true;
            /**
             * Allow user to provide the browser supported options
             */
            this.scrollIntoViewOptions = true;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.uxScrollIntoView) {
                    this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
                }
            };
        ScrollIntoViewDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxScrollIntoView]'
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        ScrollIntoViewDirective.propDecorators = {
            uxScrollIntoView: [{ type: i0.Input }],
            scrollIntoViewOptions: [{ type: i0.Input }]
        };
        return ScrollIntoViewDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ScrollModule = /** @class */ (function () {
        function ScrollModule() {
        }
        ScrollModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                        declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                    },] }
        ];
        return ScrollModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TypeaheadHighlightDirective = /** @class */ (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadHighlightDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTypeaheadHighlight]'
                    },] }
        ];
        /** @nocollapse */
        TypeaheadHighlightDirective.ctorParameters = function () {
            return [
                { type: TypeaheadService },
                { type: i0.ElementRef }
            ];
        };
        TypeaheadHighlightDirective.propDecorators = {
            highlight: [{ type: i0.Input, args: ['uxTypeaheadHighlight',] }]
        };
        return TypeaheadHighlightDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TypeaheadModule = /** @class */ (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            InfiniteScrollModule,
                            ScrollModule
                        ],
                        exports: [TypeaheadComponent],
                        declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                        providers: [TypeaheadKeyService],
                    },] }
        ];
        return TypeaheadModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FacetTypeaheadListItemComponent = /** @class */ (function () {
        function FacetTypeaheadListItemComponent() {
            this.selected = false;
            this.simplified = false;
            this.tabbable = false;
            this.itemFocus = new i0.EventEmitter();
            this.selectedChange = new i0.EventEmitter();
        }
        Object.defineProperty(FacetTypeaheadListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : null;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetTypeaheadListItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-typeahead-list-item',
                        template: "<div #option\n    uxFocusIndicator\n    role=\"option\"\n    class=\"facet-typeahead-list-selected-option\"\n    [attr.aria-checked]=\"selected\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\">\n\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-typeahead-list-selected-option-title\">{{ facet?.title }}</span>\n        <span *ngIf=\"facet?.count !== undefined\" class=\"facet-typeahead-list-selected-option-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetTypeaheadListItemComponent.propDecorators = {
            facet: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            tabbable: [{ type: i0.Input }],
            itemFocus: [{ type: i0.Output }],
            selectedChange: [{ type: i0.Output }],
            option: [{ type: i0.ViewChild, args: ['option', { static: true },] }]
        };
        return FacetTypeaheadListItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$4 = 1;
    var FacetTypeaheadListComponent = /** @class */ (function () {
        function FacetTypeaheadListComponent(typeaheadKeyService, facetService, _announcer) {
            this.typeaheadKeyService = typeaheadKeyService;
            this.facetService = facetService;
            this._announcer = _announcer;
            /**
             * Defines whether or not the Facet Typeahead List should be initially expanded or not.
             */
            this.expanded = true;
            /**
             * Defines a list of facets which will be displayed above the typeahead to allow the user to quickly select some facets.
             */
            this.suggestions = [];
            /**
             * Defines whether or not the checkboxes displayed alongside suggestions will appear in simplified form.
             */
            this.simplified = true;
            /**
             * Emits the current query when the value of the input field changes.
             */
            this.queryChange = new i0.EventEmitter();
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property (deselect all will not contain affected facets).
             */
            this.events = new rxjs.Subject();
            /**
             * If two-way binding is used this array will get updated any time the selected facets change.
             */
            this.selectedChange = new i0.EventEmitter();
            this.query$ = new rxjs.BehaviorSubject('');
            this.loading = false;
            this.activeIndex = 0;
            this.typeaheadId = "ux-facet-typeahead-" + uniqueId$4++;
            this.typeaheadOpen = false;
            this.typeaheadOptions = [];
            this._facets = [];
            this._selected = [];
            this._onDestroy = new rxjs.Subject();
            this._config = { placeholder: '', maxResults: 50, minCharacters: 1 };
        }
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "selected", {
            /** This will allow you to define an initial set of selected facets. */
            set: /**
             * This will allow you to define an initial set of selected facets.
             * @param {?} selection
             * @return {?}
             */ function (selection) {
                var _this = this;
                if (Array.isArray(selection)) {
                    selection.forEach(function (facet) { return _this.facetService.select(facet); });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "query", {
            /** Defines the query displayed in the input field. */
            set: /**
             * Defines the query displayed in the input field.
             * @param {?} query
             * @return {?}
             */ function (query) {
                if (query !== this.query$.value) {
                    this.query$.next(query);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "typeaheadConfig", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            /**
             * Allows configuration of the typeahead control. The possible values are:
             * - `placeholder` - **string** - Sets the placeholder of the typeahead.
             * - `minCharacters` - **number** - Defines the minimum number of characters that are required before results will be shown. **Default**: `1`.
             * - `maxResults` - **number** - Sets the maximum number of results to display. **Default**: `50`.
             * - `delay` - **number** - Defines the number of milliseconds to wait before the results are filtered. **Default**: `0`.
             */
            set: /**
             * Allows configuration of the typeahead control. The possible values are:
             * - `placeholder` - **string** - Sets the placeholder of the typeahead.
             * - `minCharacters` - **number** - Defines the minimum number of characters that are required before results will be shown. **Default**: `1`.
             * - `maxResults` - **number** - Sets the maximum number of results to display. **Default**: `50`.
             * - `delay` - **number** - Defines the number of milliseconds to wait before the results are filtered. **Default**: `0`.
             * @param {?} config
             * @return {?}
             */ function (config) {
                this._config = __assign({ placeholder: '', maxResults: 50, minCharacters: 1 }, config);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.facetService.events$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                    // deselect all events should always be emitted
                    if (event instanceof FacetDeselectAll) {
                        _this.events.next(event);
                        _this._selected = [];
                        _this.selectedChange.next(_this._selected);
                    }
                    // if deselected remove the facet from our internal list of selected facets
                    if (event instanceof FacetDeselect && _this.isOwnFacet(event.facet)) {
                        if (_this._selected.indexOf(event.facet) !== -1) {
                            _this.events.next(event);
                            _this._selected = _this._selected.filter(function (_facet) { return _facet !== event.facet; });
                            _this.selectedChange.next(_this._selected);
                        }
                    }
                    // selection and deselection events should only be emitted when the facet belongs to this component
                    if (event instanceof FacetSelect && _this.isOwnFacet(event.facet)) {
                        if (_this._selected.indexOf(event.facet) === -1) {
                            _this.events.next(event);
                            _this._selected = __spread(_this._selected, [event.facet]);
                            _this.selectedChange.next(_this._selected);
                        }
                    }
                });
                // store the original list of all possible facets
                this.getFacetObservable().pipe(operators.first()).subscribe(function (facets) { return _this._facets = facets; });
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // emit the latest query whenever it changes
                this.query$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged())
                    .subscribe(function (query) { return _this.queryChange.emit(query); });
                // set up search query subscription
                this.query$.pipe(operators.takeUntil(this._onDestroy), tick(), operators.tap(function () {
                    _this.loading = true;
                    _this.typeaheadOptions = [];
                }), operators.mergeMap(function () {
                    return _this.getFacetObservable().pipe(operators.map(function (facets) {
                        return facets.filter(function (facet) { return !facet.disabled && !_this.facetService.facets$.value.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .slice(0, _this._config.maxResults);
                    }));
                })).subscribe(function (facets) {
                    _this.loading = false;
                    _this.typeaheadOptions = facets;
                });
                this._focusKeyManager = new a11y.FocusKeyManager(this.options).withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                // toggle selection
                this.facetService.isSelected(facet) ? this.facetService.deselect(facet) : this.facetService.select(facet);
                // focus the correct item
                this._focusKeyManager.setActiveItem(index);
            };
        /** Only show typeahead if we have enough characters */
        /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.updateTypeahead = /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
            function (query) {
                if (query === void 0) {
                    query = '';
                }
                this.typeaheadOpen = query.length >= this._config.minCharacters;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.getFacetObservable = /**
         * @return {?}
         */
            function () {
                return rxjs.isObservable(this.facets) ? this.facets : rxjs.of(this.facets);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.select = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // check to make sure that the item is not currently selected
                if (this.facetService.isSelected(event.option)) {
                    return;
                }
                // select the facet
                this.facetService.select(event.option);
                // clear the typeahead
                this.query$.next('');
                // announce the selected facet
                this._announcer.announce((( /** @type {?} */(event.option))).title + " selected.");
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.isOwnFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                return this._facets ? this._facets.indexOf(facet) !== -1 : false;
            };
        FacetTypeaheadListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-facet-typeahead-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" role=\"listbox\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" tabindex=\"-1\" *ngIf=\"suggestions?.length > 0\">\n\n        <ux-facet-typeahead-list-item\n            *ngFor=\"let facet of suggestions; let index = index\"\n            [facet]=\"facet\"\n            [tabbable]=\"activeIndex === index\"\n            [selected]=\"facetService.isSelected(facet)\"\n            (selectedChange)=\"toggleFacet(index, facet)\"\n            (keydown)=\"onKeydown($event)\"\n            (itemFocus)=\"onFocus(index)\">\n        </ux-facet-typeahead-list-item>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\"\n            class=\"form-control\"\n            [placeholder]=\"typeaheadConfig?.placeholder\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            aria-autocomplete=\"list\"\n            aria-multiline=\"false\"\n            [attr.aria-controls]=\"typeaheadId\"\n            [ngModel]=\"query$ | async\"\n            (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n            (keydown)=\"typeaheadKeyService.handleKey($event, typeahead)\"\n            (blur)=\"typeaheadOpen = false\">\n\n        <ux-typeahead #typeahead\n            [id]=\"typeaheadId\"\n            [(open)]=\"typeaheadOpen\"\n            [loading]=\"loading\"\n            display=\"title\"\n            [options]=\"typeaheadOptions\"\n            [optionTemplate]=\"facetOptionTemplate\"\n            [selectOnEnter]=\"true\"\n            (optionSelected)=\"select($event)\"\n            (highlightedElementChange)=\"highlightedElement = $event\">\n        </ux-typeahead>\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-option=\"option\" let-api=\"api\">\n    <p class=\"facet-typeahead-list-option\" [attr.aria-label]=\"option.title\">\n        <span [innerHTML]=\"option.title | facetTypeaheadHighlight: (query$ | async)\"></span>\n        <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"option.count\">\n            ({{ option.count }})\n        </span>\n    </p>\n</ng-template>"
                    }] }
        ];
        /** @nocollapse */
        FacetTypeaheadListComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FacetService },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FacetTypeaheadListComponent.propDecorators = {
            selected: [{ type: i0.Input }],
            facets: [{ type: i0.Input }],
            header: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            suggestions: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            query: [{ type: i0.Input }],
            queryChange: [{ type: i0.Output }],
            events: [{ type: i0.Output }],
            selectedChange: [{ type: i0.Output }],
            typeaheadConfig: [{ type: i0.Input }],
            options: [{ type: i0.ViewChildren, args: [FacetTypeaheadListItemComponent,] }]
        };
        return FacetTypeaheadListComponent;
    }());
    var FacetTypeaheadHighlight = /** @class */ (function () {
        function FacetTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FacetTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                /** @type {?} */
                var regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FacetTypeaheadHighlight.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'facetTypeaheadHighlight'
                    },] }
        ];
        return FacetTypeaheadHighlight;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ReorderableHandleDirective = /** @class */ (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxReorderableHandle]'
                    },] }
        ];
        return ReorderableHandleDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ReorderableModelDirective = /** @class */ (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        ReorderableModelDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxReorderableModel]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableModelDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        ReorderableModelDirective.propDecorators = {
            uxReorderableModel: [{ type: i0.Input }]
        };
        return ReorderableModelDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var dragula = dragulaNamespace__default || dragulaNamespace;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ReorderableService = /** @class */ (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
        ReorderableService.prototype.getUniqueGroupName = /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
            function () {
                return '_uxReorderable_' + this._uniqueGroupId++;
            };
        /**
         * Adds the container to the named group.
         */
        /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.register = /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                if (!this._groups[groupName]) {
                    this._groups[groupName] = new ReorderableGroup();
                }
                this._groups[groupName].register(container);
                return this._groups[groupName];
            };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.unregister = /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                /** @type {?} */
                var group = this._groups[groupName];
                if (group) {
                    group.unregister(container);
                    if (group.isEmpty()) {
                        group.destroy();
                        delete this._groups[groupName];
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
        ReorderableService.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
            function (groupName) {
                /** @type {?} */
                var group = this._groups[groupName];
                if (group) {
                    group.initialize();
                }
                return group;
            };
        /**
         * Returns the group object for the given name.
         */
        /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
        ReorderableService.prototype.getGroup = /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
            function (group) {
                return this._groups[group];
            };
        ReorderableService.decorators = [
            { type: i0.Injectable }
        ];
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */ ReorderableGroup = /** @class */ (function () {
        function ReorderableGroup() {
            this.drag = new i0.EventEmitter();
            this.dragEnd = new i0.EventEmitter();
            this.drop = new i0.EventEmitter();
            this.cancel = new i0.EventEmitter();
            this.cloned = new i0.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
        ReorderableGroup.prototype.isEmpty = /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
            function () {
                return this._containers.length === 0;
            };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
        ReorderableGroup.prototype.getModelForElement = /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var e_1, _a;
                try {
                    for (var _b = __values(this._containers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var container = _c.value;
                        /** @type {?} */
                        var model = container.getModelFromElement(element);
                        if (model) {
                            return model;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return null;
            };
        /**
         * Adds the container to the group.
         */
        /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.register = /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                this._containers.push(container);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
                if (!this._config.mirrorContainer) {
                    this._config.mirrorContainer = container.element;
                }
            };
        /**
         * Removes the container from the group.
         */
        /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.unregister = /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                /** @type {?} */
                var index = this._containers.indexOf(container);
                if (index >= 0) {
                    this._containers.splice(index, 1);
                    if (this._instance) {
                        this._instance.containers = this._containers.map(function (c) { return c.element; });
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
        ReorderableGroup.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._instance) {
                    return;
                }
                this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
                this._instance.on('drag', function (element, source) {
                    _this.drag.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        source: source
                    });
                });
                this._instance.on('dragend', function (element) {
                    _this.dragEnd.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('drop', function (element, target, source, sibling) {
                    _this.drop.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        target: target,
                        source: source,
                        sibling: sibling
                    });
                });
                this._instance.on('cancel', function (element) {
                    _this.cancel.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('cloned', function (clone, element, type) {
                    _this.cloned.emit({
                        clone: clone,
                        element: element,
                        type: type
                    });
                });
            };
        /**
         * Destroys the dragula instance.
         */
        /**
         * Destroys the dragula instance.
         * @return {?}
         */
        ReorderableGroup.prototype.destroy = /**
         * Destroys the dragula instance.
         * @return {?}
         */
            function () {
                if (this._instance) {
                    this._instance.destroy();
                    this._instance = null;
                }
            };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         */
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
        ReorderableGroup.prototype.canMove = /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
            function (element, containerElement, handle) {
                var e_2, _a;
                try {
                    for (var _b = __values(this._containers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var container = _c.value;
                        if (container.element.isSameNode(containerElement)) {
                            return container.canMove(element, containerElement, handle);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            };
        return ReorderableGroup;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ReorderableDirective = /** @class */ (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            /**
             * Determines if reordering is disabled.
             */
            this.reorderingDisabled = false;
            /**
             * This event will be triggered when the order changes and will contain an updated dataset containing the items
             * in their current order. This should be used when the list of items is generated using ngFor to ensure the
             * data remains in the same order for both the `uxReorderable` and `ngFor` directives.
             */
            this.reorderableModelChange = new i0.EventEmitter();
            /**
             * This event is triggered when a user begins dragging an item. The event will contain the element being moved.
             */
            this.reorderStart = new i0.EventEmitter();
            /**
             * This event is triggered when the item being dragged is returned to the same location as it began. The event will contain the element that was being moved.
             */
            this.reorderCancel = new i0.EventEmitter();
            /**
             * This event is triggered when a user has relocated an item. The event will contain the element that was moved.
             */
            this.reorderEnd = new i0.EventEmitter();
            this.dragging = false;
            this._subscriptions = new rxjs.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnInit = /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
            function () {
                var _this = this;
                // If no group name then generate a unique one for this instance only
                if (!this.reorderableGroup) {
                    this.reorderableGroup = this._service.getUniqueGroupName();
                }
                this._container = {
                    element: this._elementRef.nativeElement,
                    getModelFromElement: this.getModelFromElement.bind(this),
                    canMove: this.canMove.bind(this)
                };
                // Register for drag events on this element
                /** @type {?} */
                var group = this._service.register(this.reorderableGroup, this._container);
                this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
                this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
                this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
                this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
                this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
            };
        /**
         * @return {?}
         */
        ReorderableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._service.initialize(this.reorderableGroup);
            };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnDestroy = /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
            function () {
                this._service.unregister(this.reorderableGroup, this._container);
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrag = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = true;
                this.reorderStart.emit({ element: event.element, model: event.model });
            };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrop = /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if there is no provided module we can skip this
                if (!this.reorderableModel) {
                    return;
                }
                /** @type {?} */
                var changed = false;
                if (event.source.isSameNode(this._elementRef.nativeElement)) {
                    // remove this model from the list of models
                    /** @type {?} */
                    var index = this.reorderableModel.indexOf(event.model);
                    if (index >= 0) {
                        this.reorderableModel.splice(index, 1);
                        changed = true;
                    }
                }
                if (event.target.isSameNode(this._elementRef.nativeElement)) {
                    // get the position of sibling element
                    /** @type {?} */
                    var index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                        this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                        this.reorderableModel.length;
                    // insert the model at its new location
                    this.reorderableModel.splice(index, 0, event.model);
                    changed = true;
                }
                // Emit event if any changes were made
                if (changed) {
                    this.reorderableModelChange.emit(this.reorderableModel);
                }
            };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
        ReorderableDirective.prototype.getModelFromElement = /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
                if (!model) {
                    return null;
                }
                return model.uxReorderableModel;
            };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDragEnd = /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = false;
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                    this.reorderEnd.emit({
                        element: event.element,
                        model: event.model
                    });
                }
            };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onClone = /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this.setTableCellWidths(event.element, event.clone);
                    this.captureCanvases(event.element, event.clone);
                    this._renderer.addClass(event.element, 'ux-reorderable-moving');
                }
            };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
        ReorderableDirective.prototype.canMove = /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
            function (element, container, handle) {
                if (this.reorderingDisabled) {
                    return false;
                }
                return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.setTableCellWidths = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // if it is not a table row then skip this
                if (source.tagName !== 'TR') {
                    return;
                }
                // find any immediate td children and fix their width
                /** @type {?} */
                var sourceCells = ( /** @type {?} */(Array.from(source.children)));
                /** @type {?} */
                var targetCells = ( /** @type {?} */(Array.from(target.children)));
                // fix the width of these cells
                sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.captureCanvases = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // find all child canvas elements
                /** @type {?} */
                var sourceCanvases = Array.from(source.querySelectorAll('canvas'));
                /** @type {?} */
                var targetCanvases = Array.from(target.querySelectorAll('canvas'));
                // replicate the canvas content
                targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                    .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
            };
        ReorderableDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxReorderable]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: ReorderableService }
            ];
        };
        ReorderableDirective.propDecorators = {
            reorderableModel: [{ type: i0.Input }],
            reorderableGroup: [{ type: i0.Input }],
            reorderingDisabled: [{ type: i0.Input }],
            reorderableModelChange: [{ type: i0.Output }],
            reorderStart: [{ type: i0.Output }],
            reorderCancel: [{ type: i0.Output }],
            reorderEnd: [{ type: i0.Output }],
            handles: [{ type: i0.ContentChildren, args: [ReorderableHandleDirective, { read: i0.ElementRef, descendants: true },] }],
            models: [{ type: i0.ContentChildren, args: [ReorderableModelDirective,] }],
            dragging: [{ type: i0.HostBinding, args: ['class.ux-reorderable-container-moving',] }]
        };
        return ReorderableDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ReorderableModule = /** @class */ (function () {
        function ReorderableModule() {
        }
        ReorderableModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        exports: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        providers: [
                            ReorderableService
                        ]
                    },] }
        ];
        return ReorderableModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetCheckListComponent,
        FacetCheckListItemComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadListItemComponent,
        FacetTypeaheadHighlight,
        FacetClearButtonDirective
    ];
    var FacetsModule = /** @class */ (function () {
        function FacetsModule() {
        }
        FacetsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            CheckboxModule,
                            common.CommonModule,
                            forms.FormsModule,
                            IconModule,
                            ReorderableModule,
                            TooltipModule,
                            TypeaheadModule,
                        ],
                        exports: DECLARATIONS$1,
                        declarations: DECLARATIONS$1
                    },] }
        ];
        return FacetsModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var Facet = /** @class */ (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterAddEvent = /** @class */ (function () {
        function FilterAddEvent(filter) {
            this.filter = filter;
        }
        return FilterAddEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterRemoveAllEvent = /** @class */ (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterRemoveEvent = /** @class */ (function () {
        function FilterRemoveEvent(filter) {
            this.filter = filter;
        }
        return FilterRemoveEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterService = /** @class */ (function () {
        function FilterService() {
            /**
             * The list of active filters
             */
            this.filters$ = new rxjs.BehaviorSubject([]);
            /**
             * Emit all the events when they occur
             */
            this.events$ = new rxjs.Subject();
        }
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.add = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                // if the filter is already selected or it is the intial filter then do nothing
                if (this.isSelected(filter) || filter.initial) {
                    return;
                }
                // update the list of active filters
                this.filters$.next(__spread(this.filters$.value, [filter]));
                // emit the event
                this.events$.next(new FilterAddEvent(filter));
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.remove = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                // if the filter is not selected then do nothing
                if (!this.isSelected(filter)) {
                    return;
                }
                // update the list of active filters
                this.filters$.next(this.filters$.value.filter(function (_filter) { return _filter !== filter; }));
                // emit the event
                this.events$.next(new FilterRemoveEvent(filter));
            };
        /**
         * @return {?}
         */
        FilterService.prototype.removeAll = /**
         * @return {?}
         */
            function () {
                // empty the list of active filters
                this.filters$.next([]);
                // emit the event
                this.events$.next(new FilterRemoveAllEvent());
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterService.prototype.isSelected = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                return this.filters$.value.indexOf(filter) > -1;
            };
        FilterService.decorators = [
            { type: i0.Injectable }
        ];
        return FilterService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterContainerComponent = /** @class */ (function () {
        function FilterContainerComponent(filterService) {
            var _this = this;
            this.filterService = filterService;
            /**
             * Defines the aria-label for the clear all button
             */
            this.clearAriaLabel = 'Clear All Filters';
            /**
             * Emit when the active filters chance
             */
            this.filtersChange = new i0.EventEmitter();
            /**
             * Emit when a specific event occurs
             */
            this.events = new i0.EventEmitter();
            /**
             * Unsubscribe from the subscriptions on destroy
             */
            this._onDestroy = new rxjs.Subject();
            // subscribe to changes to the active filters
            filterService.filters$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged())
                .subscribe(function (filters) { return _this.filtersChange.emit(filters); });
            // relay any events to the event emitter
            this.filterService.events$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this.events.emit(event); });
        }
        Object.defineProperty(FilterContainerComponent.prototype, "filters", {
            /** Allow filters to set from outside the component */
            set: /**
             * Allow filters to set from outside the component
             * @param {?} filters
             * @return {?}
             */ function (filters) { this.filterService.filters$.next(filters); },
            enumerable: true,
            configurable: true
        });
        /** Destroy all subscriptions */
        /**
         * Destroy all subscriptions
         * @return {?}
         */
        FilterContainerComponent.prototype.ngOnDestroy = /**
         * Destroy all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        FilterContainerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-filter-container',
                        template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<button type=\"button\"\n    class=\"btn btn-link btn-icon btn-secondary m-l-xs\"\n    tabindex=\"0\"\n    [attr.aria-label]=\"clearAriaLabel\"\n    *ngIf=\"(filterService.filters$ | async).length > 0\"\n    [uxTooltip]=\"clearTooltip || 'Clear All'\"\n    (click)=\"filterService.removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"100%\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</button>",
                        providers: [FilterService]
                    }] }
        ];
        /** @nocollapse */
        FilterContainerComponent.ctorParameters = function () {
            return [
                { type: FilterService }
            ];
        };
        FilterContainerComponent.propDecorators = {
            filters: [{ type: i0.Input }],
            clearTooltip: [{ type: i0.Input }],
            clearAriaLabel: [{ type: i0.Input }],
            filtersChange: [{ type: i0.Output }],
            events: [{ type: i0.Output }]
        };
        return FilterContainerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterDropdownComponent = /** @class */ (function () {
        function FilterDropdownComponent(_filterService) {
            var _this = this;
            this._filterService = _filterService;
            /**
             * The list of items to display in the dropdown
             */
            this.filters = [];
            this._onDestroy = new rxjs.Subject();
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.selected = this.initial;
                // check to see if any of the filters have been preselected or changes to selected filters
                this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                    filters.forEach(function (filter) {
                        if (_this.filters.indexOf(filter) !== -1) {
                            _this.selected = filter;
                        }
                    });
                });
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
        FilterDropdownComponent.prototype.selectFilter = /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
            function (filter, event) {
                this.removeFilter();
                this.selected = filter;
                this._filterService.add(this.selected);
                event.stopPropagation();
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.removeFilter = /**
         * @return {?}
         */
            function () {
                this._filterService.remove(this.selected);
                this.selected = this.initial;
            };
        FilterDropdownComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-filter-dropdown',
                        template: "<div class=\"btn-group\">\n    <button\n        type=\"button\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [class.active]=\"selected !== initial\"\n        [uxMenuTriggerFor]=\"menu\">\n\n        {{ selected?.title }} <ux-icon name=\"down\"></ux-icon>\n    </button>\n\n    <ux-menu #menu menuClass=\"ux-filter-menu\">\n        <button\n            type=\"button\"\n            *ngFor=\"let filter of filters\"\n            uxMenuItem\n            [attr.aria-selected]=\"filter === selected\"\n            (click)=\"selectFilter(filter, $event)\"\n            (keydown.enter)=\"selectFilter(filter, $event)\">\n\n            <ux-icon\n                name=\"checkmark\"\n                [style.visibility]=\"filter === selected ? 'visible' : 'hidden'\">\n            </ux-icon>\n\n            <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n        </button>\n    </ux-menu>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        FilterDropdownComponent.ctorParameters = function () {
            return [
                { type: FilterService }
            ];
        };
        FilterDropdownComponent.propDecorators = {
            filters: [{ type: i0.Input }],
            initial: [{ type: i0.Input }]
        };
        return FilterDropdownComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$5 = 1;
    var FilterDynamicComponent = /** @class */ (function () {
        function FilterDynamicComponent(typeaheadKeyService, _filterService) {
            var _this = this;
            this.typeaheadKeyService = typeaheadKeyService;
            this._filterService = _filterService;
            /**
             * The list of possible filter options
             */
            this.filters = [];
            /**
             * Generate a unique id for the typeahead
             */
            this.typeaheadId = "ux-filter-dynamic-typeahead-" + uniqueId$5++;
            /**
             * Store the current search query
             */
            this.query$ = new rxjs.BehaviorSubject('');
            /**
             * Indicate whether or not the typeahead should be shown
             */
            this.showTypeahead = true;
            /**
             * Store the items that should be displayed in the typeahead
             */
            this.typeaheadItems = [];
            /**
             * Store the open state of the typeahead
             */
            this.typeaheadOpen = false;
            /**
             * The default options
             */
            this._defaultOptions = { placeholder: '', minCharacters: 3, maxResults: Infinity };
            /**
             * Store the user specified typeahead options
             */
            this._options = __assign({}, this._defaultOptions);
            /**
             * Unsubscribe from all subscriptions
             */
            this._onDestroy = new rxjs.Subject();
            // listen for remove all events in which case we should deselect event initial filters
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        Object.defineProperty(FilterDynamicComponent.prototype, "options", {
            /** Get the options with the defaults for any missing options */
            get: /**
             * Get the options with the defaults for any missing options
             * @return {?}
             */ function () {
                return __assign({}, this._defaultOptions, this._options);
            },
            /** Specify the typeahead options */
            set: /**
             * Specify the typeahead options
             * @param {?} options
             * @return {?}
             */ function (options) { this._options = options; },
            enumerable: true,
            configurable: true
        });
        /** Set up the initial conditions */
        /**
         * Set up the initial conditions
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnInit = /**
         * Set up the initial conditions
         * @return {?}
         */
            function () {
                var _this = this;
                // The initially selected item should be set the the specified initial item
                this.selected = this.initial;
                // watch for changes to the selected filters
                this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                    filters.forEach(function (filter) {
                        if (_this.filters.indexOf(filter) !== -1) {
                            _this.selected = filter;
                        }
                    });
                });
                // get the items to be displayed in the typeahead
                this.typeaheadItems = this.getItems();
                // determine if we should show the typeahead control
                if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                    this.showTypeahead = false;
                }
            };
        /** Cleanup all subscriptions */
        /**
         * Cleanup all subscriptions
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnDestroy = /**
         * Cleanup all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Get the items to display in the typeahead based on the search query */
        /**
         * Get the items to display in the typeahead based on the search query
         * @return {?}
         */
        FilterDynamicComponent.prototype.getItems = /**
         * Get the items to display in the typeahead based on the search query
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var query = this.query$.value.toLowerCase();
                return this.filters.filter(function (item) { return item !== _this.initial && item.name.toLowerCase().indexOf(query) !== -1; })
                    .map(function (item) { return item.name; })
                    .slice(0, this._options.maxResults);
            };
        /** When the dropdown is closed clear the query */
        /**
         * When the dropdown is closed clear the query
         * @return {?}
         */
        FilterDynamicComponent.prototype.onClose = /**
         * When the dropdown is closed clear the query
         * @return {?}
         */
            function () {
                this.query$.next('');
            };
        /** If a filter needs removed, and is not the initial filter then remove it */
        /**
         * If a filter needs removed, and is not the initial filter then remove it
         * @return {?}
         */
        FilterDynamicComponent.prototype.removeFilter = /**
         * If a filter needs removed, and is not the initial filter then remove it
         * @return {?}
         */
            function () {
                // check if the filter we want to remove is the initial filter
                if (this.selected !== this.initial) {
                    this._filterService.remove(this.selected);
                    this.selected = this.initial;
                }
                // clear the search query
                this.query$.next('');
            };
        /** Select a specific filter */
        /**
         * Select a specific filter
         * @param {?} filter
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectFilter = /**
         * Select a specific filter
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                // clear any current filters
                this.removeFilter();
                // store the newly selected filter
                this.selected = filter;
                // store the filter in the service
                this._filterService.add(this.selected);
            };
        /** Update typeahead items and visibility */
        /**
         * Update typeahead items and visibility
         * @param {?} query
         * @return {?}
         */
        FilterDynamicComponent.prototype.updateTypeahead = /**
         * Update typeahead items and visibility
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.typeaheadOpen = query.length >= this._options.minCharacters;
                this.typeaheadItems = this.getItems();
            };
        /** Select a filter from a typeahead item */
        /**
         * Select a filter from a typeahead item
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.select = /**
         * Select a filter from a typeahead item
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // find the filter with the matching name
                /** @type {?} */
                var filter = this.filters.find(function (_filter) { return _filter.name === event.option; });
                if (filter) {
                    this.selectFilter(filter);
                }
            };
        FilterDynamicComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-filter-dynamic',
                        template: "<div class=\"btn-group ux-dynamic-filter\">\n\n    <button\n        type=\"button\"\n        [class.active]=\"selected !== initial\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [uxMenuTriggerFor]=\"menu\"\n        #trigger=\"ux-menu-trigger\">\n        {{ selected?.title }}\n        <ux-icon name=\"down\"></ux-icon>\n    </button>\n\n    <ux-menu #menu menuClass=\"ux-dynamic-filter-menu\" (closed)=\"onClose()\">\n        <!-- Initial Option -->\n        <button\n            uxMenuItem\n            *ngIf=\"showTypeahead\"\n            (click)=\"removeFilter()\"\n            (keydown.enter)=\"removeFilter()\">\n            <ux-icon\n                name=\"checkmark\"\n                [style.visibility]=\"initial === selected ? 'visible' : 'hidden'\">\n            </ux-icon>\n            <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n        </button>\n\n        <!-- Selected Options -->\n        <button uxMenuItem *ngIf=\"selected !== initial && showTypeahead\">\n            <ux-icon name=\"checkmark\"></ux-icon>\n            <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n        </button>\n\n        <ux-menu-divider *ngIf=\"showTypeahead\"></ux-menu-divider>\n\n        <div *ngIf=\"showTypeahead\" class=\"typeahead-box\" role=\"none\">\n\n            <input type=\"text\"\n                class=\"form-control\"\n                [placeholder]=\"options?.placeholder\"\n                [attr.aria-activedescendant]=\"highlightedElement?.id\"\n                [attr.aria-controls]=\"typeaheadId\"\n                aria-autocomplete=\"list\"\n                aria-multiline=\"false\"\n                [ngModel]=\"query$ | async\"\n                (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n                (keydown)=\"typeaheadKeyService.handleKey($event, typeahead); $event.stopPropagation();\"\n                (keydown.enter)=\"$event.preventDefault()\"\n                (blur)=\"typeaheadOpen = false\"\n                (click)=\"$event.stopPropagation()\">\n\n            <ux-typeahead #typeahead\n                [id]=\"typeaheadId\"\n                [(open)]=\"typeaheadOpen\"\n                display=\"title\"\n                [selectOnEnter]=\"true\"\n                [options]=\"typeaheadItems\"\n                [optionTemplate]=\"filterOptionTemplate\"\n                (optionSelected)=\"select($event); trigger.closeMenu($event.origin)\"\n                (highlightedElementChange)=\"highlightedElement = $event\">\n            </ux-typeahead>\n        </div>\n\n        <ng-container *ngIf=\"!showTypeahead\">\n\n            <button\n                *ngFor=\"let filter of filters\"\n                type=\"button\"\n                uxMenuItem\n                (click)=\"selectFilter(filter); trigger.closeMenu('mouse')\"\n                (keydown.enter)=\"selectFilter(filter); trigger.closeMenu('keyboard')\">\n\n                <ux-icon\n                    name=\"checkmark\"\n                    [style.visibility]=\"filter === selected ? 'visible' : 'hidden'\">\n                </ux-icon>\n\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </button>\n\n        </ng-container>\n\n    </ux-menu>\n</div>\n\n<ng-template #filterOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span [attr.aria-label]=\"option\" [innerHTML]=\"option | filterTypeaheadHighlight: (query$ | async)\"></span>\n</ng-template>"
                    }] }
        ];
        /** @nocollapse */
        FilterDynamicComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FilterService }
            ];
        };
        FilterDynamicComponent.propDecorators = {
            filters: [{ type: i0.Input }],
            initial: [{ type: i0.Input }],
            options: [{ type: i0.Input }]
        };
        return FilterDynamicComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FilterTypeaheadHighlight = /** @class */ (function () {
        function FilterTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FilterTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                /** @type {?} */
                var regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"filter-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FilterTypeaheadHighlight.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'filterTypeaheadHighlight'
                    },] }
        ];
        return FilterTypeaheadHighlight;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuDividerComponent = /** @class */ (function () {
        function MenuDividerComponent() {
        }
        MenuDividerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-menu-divider',
                        template: "",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            role: 'separator'
                        }
                    }] }
        ];
        return MenuDividerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MenuItemType = {
        Default: 0,
        Custom: 1,
    };
    MenuItemType[MenuItemType.Default] = 'Default';
    MenuItemType[MenuItemType.Custom] = 'Custom';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MENU_OPTIONS_TOKEN = new i0.InjectionToken('MENU_OPTIONS_TOKEN');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuComponent = /** @class */ (function () {
        function MenuComponent(_changeDetector, _options) {
            this._changeDetector = _changeDetector;
            this._options = _options;
            /**
             * Define the position of the menu
             */
            this.placement = 'bottom';
            /**
             * Define the alignment of the menu
             */
            this.alignment = 'start';
            /**
             * Define if we should animate the menu
             */
            this.animate = this._options && this._options.hasOwnProperty('animate') ? this._options.animate : true;
            /**
             * Emit when the opening has begun (the opened EventEmitter waits until the animation has finished)
             */
            this.opening = new i0.EventEmitter();
            /**
             * Emit when the menu is opened
             */
            this.opened = new i0.EventEmitter();
            /**
             * Emit whenever closing has begun (the closed EventEmitter waits until animation has finished)
             */
            this.closing = new i0.EventEmitter();
            /**
             * Emit when the menu is closed
             */
            this.closed = new i0.EventEmitter();
            /**
             * Store the menu open state
             */
            this.isMenuOpen = false;
            /**
             * Store the animation state
             */
            this._isAnimating = false;
            /**
             * Determine if this is a submenu
             */
            this._isSubMenu = false;
            /**
             * Emit when the focused item changes (we use this as the key manager is not instantiated until a late lifecycle hook)
             */
            this._activeItem$ = new rxjs.BehaviorSubject(null);
            /**
             * Access allow a close event to propagate all the way up the submenus
             */
            this._closeAll$ = new rxjs.Subject();
            /**
             * Emit keyboard events
             */
            this._onKeydown$ = new rxjs.Subject();
            /**
             * Emit hover events
             */
            this._isHovering$ = new rxjs.BehaviorSubject(false);
            /**
             * Emit focus events
             */
            this._isFocused$ = new rxjs.BehaviorSubject(false);
            /**
             * Access all child menu items for accessibility purposes
             */
            this._items$ = new rxjs.BehaviorSubject([]);
            /**
             * Automatically unsubscribe when the component is destroyed
             */
            this._onDestroy$ = new rxjs.Subject();
            /**
             * Create an internal querylist to store the menu items
             */
            this._itemsList = new i0.QueryList();
        }
        Object.defineProperty(MenuComponent.prototype, "_isExpanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuItems.pipe(operators.switchMap(function (items) { return rxjs.merge.apply(void 0, __spread(items.map(function (item) { return item.isExpanded$; }))); }), operators.takeUntil(this._onDestroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuComponent.prototype, "_menuItemClick", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuItems.pipe(operators.switchMap(function (items) { return rxjs.merge.apply(void 0, __spread(items.map(function (item) { return item.onClick$; }))); }), operators.takeUntil(this._onDestroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuComponent.prototype, "_menuItems", {
            /** Return only menu items an not custom tabbable items */
            get: /**
             * Return only menu items an not custom tabbable items
             * @return {?}
             */ function () {
                return this._items$.pipe(operators.map(function (items) { return ( /** @type {?} */(items.filter(function (item) { return item.type === MenuItemType.Default; }))); }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // initialise the query list with the items
                this._items$.pipe(operators.takeUntil(this._onDestroy$)).subscribe(function (items) {
                    // if no items has been marked as tabbable then this should be
                    if (!_this._activeItem$.value && items.length > 0) {
                        _this._activeItem$.next(items[0]);
                    }
                    _this._itemsList.reset(items);
                    _this._itemsList.notifyOnChanges();
                });
                // setup keyboard functionality
                this._keyManager = new a11y.FocusKeyManager(this._itemsList)
                    .withVerticalOrientation()
                    .withTypeAhead()
                    .withWrap();
                // emit the tabbable item on change
                this._keyManager.change.pipe(operators.map(function () { return _this._keyManager.activeItem; }), operators.takeUntil(this._onDestroy$))
                    .subscribe(function (item) { return _this._activeItem$.next(item); });
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy$.next();
                this._onDestroy$.complete();
                this._closeAll$.complete();
                this._isHovering$.complete();
                this._isFocused$.complete();
                this._activeItem$.complete();
                this._items$.complete();
            };
        /** Register a menu item - we do this do avoid `@ContentChildren` detecting submenu items */
        /**
         * Register a menu item - we do this do avoid `\@ContentChildren` detecting submenu items
         * @param {?} item
         * @return {?}
         */
        MenuComponent.prototype._addItem = /**
         * Register a menu item - we do this do avoid `\@ContentChildren` detecting submenu items
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!this.hasItem(item)) {
                    this._items$.next(__spread(this._items$.value, [item]));
                }
            };
        /** Remove an item */
        /**
         * Remove an item
         * @param {?} item
         * @return {?}
         */
        MenuComponent.prototype._removeItem = /**
         * Remove an item
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.hasItem(item)) {
                    this._items$.next(this._items$.value.filter(function (_item) { return _item !== item; }));
                }
            };
        /** Determine if an item exists */
        /**
         * Determine if an item exists
         * @param {?} item
         * @return {?}
         */
        MenuComponent.prototype.hasItem = /**
         * Determine if an item exists
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return !!this._items$.value.find(function (_item) { return _item === item; });
            };
        /** Internal function to set the open state and run change detection */
        /**
         * Internal function to set the open state and run change detection
         * @param {?} menuOpen
         * @return {?}
         */
        MenuComponent.prototype._setMenuOpen = /**
         * Internal function to set the open state and run change detection
         * @param {?} menuOpen
         * @return {?}
         */
            function (menuOpen) {
                // store the open state
                this.isMenuOpen = menuOpen;
                // if we are closing the menu reset some values
                if (!menuOpen) {
                    this._isHovering$.next(false);
                    this._isFocused$.next(false);
                }
                // check for changes - required to show the menu as we are using `*ngIf`
                this._changeDetector.detectChanges();
                // emit the closing event
                menuOpen ? this.opening.emit() : this.closing.emit();
            };
        /** Track the animation state */
        /**
         * Track the animation state
         * @return {?}
         */
        MenuComponent.prototype._onAnimationStart = /**
         * Track the animation state
         * @return {?}
         */
            function () {
                this._isAnimating = true;
            };
        /** Track animation state and emit event when opening or closing */
        /**
         * Track animation state and emit event when opening or closing
         * @return {?}
         */
        MenuComponent.prototype._onAnimationDone = /**
         * Track animation state and emit event when opening or closing
         * @return {?}
         */
            function () {
                this._isAnimating = false;
                if (this.isMenuOpen) {
                    this.opened.emit();
                }
                else {
                    this.closed.emit();
                }
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype._closeMenu = /**
         * @return {?}
         */
            function () {
                this._setMenuOpen(false);
            };
        /** Forward any keyboard events to the key manage for accessibility */
        /**
         * Forward any keyboard events to the key manage for accessibility
         * @param {?} event
         * @return {?}
         */
        MenuComponent.prototype._onKeydown = /**
         * Forward any keyboard events to the key manage for accessibility
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._keyManager.setFocusOrigin('keyboard').onKeydown(event);
                // emit the keydown event
                this._onKeydown$.next(event);
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype._onHoverStart = /**
         * @return {?}
         */
            function () {
                this._isHovering$.next(true);
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype._onHoverEnd = /**
         * @return {?}
         */
            function () {
                this._isHovering$.next(false);
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype._onFocus = /**
         * @return {?}
         */
            function () {
                this._isFocused$.next(true);
            };
        /**
         * @return {?}
         */
        MenuComponent.prototype._onBlur = /**
         * @return {?}
         */
            function () {
                this._isFocused$.next(false);
            };
        MenuComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-menu',
                        template: "<ng-template>\n    <div\n        *ngIf=\"isMenuOpen\"\n        class=\"ux-menu\"\n        [class.ux-sub-menu]=\"_isSubMenu\"\n        [class.ux-menu-placement-top]=\"placement === 'top'\"\n        [ngClass]=\"menuClass\"\n        @menuAnimation\n        [@.disabled]=\"!animate\"\n        (@menuAnimation.start)=\"_onAnimationStart()\"\n        (@menuAnimation.done)=\"_onAnimationDone()\"\n        (mouseenter)=\"_onHoverStart()\"\n        (mouseover)=\"_onHoverStart()\"\n        (mouseleave)=\"_onHoverEnd()\"\n        (focusin)=\"_onFocus()\"\n        (focusout)=\"_onBlur()\">\n        <ng-content></ng-content>\n    </div>\n</ng-template>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'menu'
                        },
                        animations: [
                            animations.trigger('menuAnimation', [
                                animations.transition(':enter', [
                                    animations.style({ opacity: 0, transform: 'scaleY(0)' }),
                                    animations.animate('200ms ease-out', animations.style({ opacity: 1, transform: 'none' })),
                                ]),
                                animations.transition(':leave', [
                                    animations.animate('200ms ease-out', animations.style({ opacity: 0, transform: 'scaleY(0)' }))
                                ])
                            ]),
                        ]
                    }] }
        ];
        /** @nocollapse */
        MenuComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MENU_OPTIONS_TOKEN,] }] }
            ];
        };
        MenuComponent.propDecorators = {
            placement: [{ type: i0.Input }],
            alignment: [{ type: i0.Input }],
            animate: [{ type: i0.Input }],
            menuClass: [{ type: i0.Input }],
            opening: [{ type: i0.Output }],
            opened: [{ type: i0.Output }],
            closing: [{ type: i0.Output }],
            closed: [{ type: i0.Output }],
            templateRef: [{ type: i0.ViewChild, args: [i0.TemplateRef, { static: false },] }]
        };
        return MenuComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuItemComponent = /** @class */ (function () {
        function MenuItemComponent(_menu, _elementRef, _focusIndicatorService, _renderer) {
            this._menu = _menu;
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this._renderer = _renderer;
            /**
             * Define if this item is disabled or not
             */
            this.disabled = false;
            /**
             * Define the role of the element
             */
            this.role = 'menuitem';
            /**
             * Indicate the type of the menu item
             */
            this.type = MenuItemType.Default;
            /**
             * Store the current hover state
             */
            this.isHovered$ = new rxjs.BehaviorSubject(false);
            /**
             * Store the current focus state
             */
            this.isFocused$ = new rxjs.BehaviorSubject(false);
            /**
             * Store the current expanded state
             */
            this.isExpanded$ = new rxjs.BehaviorSubject(false);
            /**
             * Emit when an item is clicked
             */
            this.onClick$ = new rxjs.Subject();
            /**
             * Automatically unsubscribe from observables on destroy
             */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(MenuItemComponent.prototype, "isOpen", {
            /** Access the open state */
            get: /**
             * Access the open state
             * @return {?}
             */ function () {
                return this._menu.isMenuOpen;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // register this item in the MenuComponent
                this._menu._addItem(this);
                // we only want to show the focus indicator whenever the keyboard is used
                this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
                // subscribe to active item changes
                this._menu._activeItem$.pipe(operators.takeUntil(this._onDestroy$))
                    .subscribe(function (item) { return _this.setTabIndex(item === _this); });
            };
        /**
         * @return {?}
         */
        MenuItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._menu._removeItem(this);
                this.isHovered$.complete();
                this.isExpanded$.complete();
                this.isFocused$.complete();
                this.onClick$.complete();
                this._focusIndicator.destroy();
                this._onDestroy$.next();
                this._onDestroy$.complete();
            };
        /**
         * @param {?} origin
         * @return {?}
         */
        MenuItemComponent.prototype.focus = /**
         * @param {?} origin
         * @return {?}
         */
            function (origin) {
                this._focusIndicator.focus(origin);
            };
        /** This function is built into the CDK manager to allow jumping to items based on text content */
        /**
         * This function is built into the CDK manager to allow jumping to items based on text content
         * @return {?}
         */
        MenuItemComponent.prototype.getLabel = /**
         * This function is built into the CDK manager to allow jumping to items based on text content
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement.textContent.trim();
            };
        /**
         * @return {?}
         */
        MenuItemComponent.prototype._onMouseEnter = /**
         * @return {?}
         */
            function () {
                this.isHovered$.next(true);
            };
        /**
         * @return {?}
         */
        MenuItemComponent.prototype._onMouseLeave = /**
         * @return {?}
         */
            function () {
                this.isHovered$.next(false);
            };
        /**
         * @return {?}
         */
        MenuItemComponent.prototype._onFocus = /**
         * @return {?}
         */
            function () {
                this.isFocused$.next(true);
            };
        /**
         * @return {?}
         */
        MenuItemComponent.prototype._onBlur = /**
         * @return {?}
         */
            function () {
                this.isFocused$.next(false);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuItemComponent.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.disabled) {
                    this.onClick$.next(isKeyboardTrigger(event) ? 'keyboard' : 'mouse');
                }
            };
        /** Forward any keyboard events to the MenuComponent for accessibility */
        /**
         * Forward any keyboard events to the MenuComponent for accessibility
         * @param {?} event
         * @return {?}
         */
        MenuItemComponent.prototype._onKeydown = /**
         * Forward any keyboard events to the MenuComponent for accessibility
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._menu._onKeydown(event);
            };
        /** Update the tab index on this item */
        /**
         * Update the tab index on this item
         * @param {?} isTabbable
         * @return {?}
         */
        MenuItemComponent.prototype.setTabIndex = /**
         * Update the tab index on this item
         * @param {?} isTabbable
         * @return {?}
         */
            function (isTabbable) {
                this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', isTabbable ? '0' : '-1');
            };
        MenuItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: '[uxMenuItem]',
                        template: "<ng-content></ng-content>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[attr.role]': 'role',
                            '[class.disabled]': 'disabled',
                            '[class.ux-menu-item]': 'true',
                            '[class.open]': 'isOpen'
                        }
                    }] }
        ];
        /** @nocollapse */
        MenuItemComponent.ctorParameters = function () {
            return [
                { type: MenuComponent },
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: i0.Renderer2 }
            ];
        };
        MenuItemComponent.propDecorators = {
            disabled: [{ type: i0.Input }],
            role: [{ type: i0.Input }],
            _onMouseEnter: [{ type: i0.HostListener, args: ['mouseenter',] }],
            _onMouseLeave: [{ type: i0.HostListener, args: ['mouseleave',] }],
            _onFocus: [{ type: i0.HostListener, args: ['focus',] }],
            _onBlur: [{ type: i0.HostListener, args: ['blur',] }],
            _onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }, { type: i0.HostListener, args: ['keydown.enter', ['$event'],] }],
            _onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuTabbableItemDirective = /** @class */ (function () {
        function MenuTabbableItemDirective(_menu, _elementRef, _focusIndicatorService, _renderer) {
            this._menu = _menu;
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this._renderer = _renderer;
            /**
             * Define if this item is disabled or not
             */
            this.disabled = false;
            /**
             * Indicate the type of the menu item
             */
            this.type = MenuItemType.Default;
            /**
             * Automatically unsubscribe when directive is destroyed
             */
            this._onDestroy$ = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        MenuTabbableItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // register this item in the MenuComponent
                this._menu._addItem(this);
                // we only want to show the focus indicator whenever the keyboard is used
                this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
                // subscribe to active item changes
                this._menu._activeItem$.pipe(operators.takeUntil(this._onDestroy$))
                    .subscribe(function (item) { return _this.setTabIndex(item === _this); });
            };
        /**
         * @return {?}
         */
        MenuTabbableItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy$.next();
                this._onDestroy$.complete();
                this._focusIndicator.destroy();
            };
        /** Focus this item with a given origin */
        /**
         * Focus this item with a given origin
         * @param {?} origin
         * @return {?}
         */
        MenuTabbableItemDirective.prototype.focus = /**
         * Focus this item with a given origin
         * @param {?} origin
         * @return {?}
         */
            function (origin) {
                this._focusIndicator.focus(origin);
            };
        /** This function is built into the CDK manager to allow jumping to items based on text content */
        /**
         * This function is built into the CDK manager to allow jumping to items based on text content
         * @return {?}
         */
        MenuTabbableItemDirective.prototype.getLabel = /**
         * This function is built into the CDK manager to allow jumping to items based on text content
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement.textContent.trim();
            };
        /** Forward any keyboard events to the MenuComponent for accessibility */
        /**
         * Forward any keyboard events to the MenuComponent for accessibility
         * @param {?} event
         * @return {?}
         */
        MenuTabbableItemDirective.prototype._onKeydown = /**
         * Forward any keyboard events to the MenuComponent for accessibility
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._menu._onKeydown(event);
            };
        /** Update the tab index on this item */
        /**
         * Update the tab index on this item
         * @param {?} isTabbable
         * @return {?}
         */
        MenuTabbableItemDirective.prototype.setTabIndex = /**
         * Update the tab index on this item
         * @param {?} isTabbable
         * @return {?}
         */
            function (isTabbable) {
                this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', isTabbable ? '0' : '-1');
            };
        MenuTabbableItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMenuTabbableItem]',
                    },] }
        ];
        /** @nocollapse */
        MenuTabbableItemDirective.ctorParameters = function () {
            return [
                { type: MenuComponent },
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: i0.Renderer2 }
            ];
        };
        MenuTabbableItemDirective.propDecorators = {
            disabled: [{ type: i0.Input }],
            _onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuTabbableItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuTriggerDirective = /** @class */ (function () {
        function MenuTriggerDirective(_overlay, _elementRef, _viewContainerRef, _focusOrigin, _focusIndicatorService, _parentMenu, _menuItem) {
            this._overlay = _overlay;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._focusOrigin = _focusOrigin;
            this._focusIndicatorService = _focusIndicatorService;
            this._parentMenu = _parentMenu;
            this._menuItem = _menuItem;
            /**
             * Determine if we should disable the trigger
             */
            this.disabled = false;
            /**
             * Automatically unsubscribe on directive destroy
             */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(MenuTriggerDirective.prototype, "_isSubmenuTrigger", {
            /** Determine if this triggers a submenu */
            get: /**
             * Determine if this triggers a submenu
             * @return {?}
             */ function () {
                return !!this._parentMenu;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuTriggerDirective.prototype, "_isRootTrigger", {
            /** Determine if this is the root trigger */
            get: /**
             * Determine if this is the root trigger
             * @return {?}
             */ function () {
                return !this._isSubmenuTrigger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuTriggerDirective.prototype, "_menuShouldClose", {
            /** If this is a submenu we want to know when the mouse leaves the items or parent item */
            get: /**
             * If this is a submenu we want to know when the mouse leaves the items or parent item
             * @return {?}
             */ function () {
                if (!this._isSubmenuTrigger) {
                    return rxjs.of();
                }
                // This combined observable will essentially check for all of the combinations of events that can cause a menu
                // to remain open, for example:
                //
                // 1. Hovering over any item in the menu should keep the menu open
                // 2. Having any item in the menu focused should keep the menu open
                // 3. Having the parent menu item hovered should keep a submenu open
                // 4. Having the parent menu item focused should keep a submenu open
                // 5. Having a submenu open should keep the parent open (if the submenu meets one of the above conditions)
                //
                // We also debounce this because there is often a delay between a blur and a focus event or moving the mouse
                // from a menu item to a sub menu item, so we add this buffer time to prevent the menu from closing unexpectedly
                return rxjs.combineLatest(this.menu._isHovering$, this.menu._isFocused$, this._menuItem.isHovered$, this.menu._isExpanded, this._menuItem.isFocused$)
                    .pipe(operators.debounceTime(50), operators.filter(function (_a) {
                    var _b = __read(_a, 5), isHovered = _b[0], isFocused = _b[1], isItemHovered = _b[2], isExpanded = _b[3], isItemFocused = _b[4];
                    return !isHovered && !isFocused && !isItemHovered && !isExpanded && !isItemFocused;
                }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuTriggerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // set up focus indicator handling
                this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
                // if there is a parent menu then we should override the default initial
                // position to be to the right rather than beneath. Note this gets called
                // before ngOnInit in the MenuComponent so if the user specifies an explicit
                // position then it will still take precendence
                if (this._isSubmenuTrigger) {
                    this.menu._isSubMenu = true;
                    this.menu.placement = 'right';
                }
                // listen for the menu to open (after animation so we can focus the first item)
                this.menu.opened.pipe(operators.takeUntil(this._onDestroy$))
                    .subscribe(function () { return _this.menuDidOpen(); });
                // propagate the close event if it is triggered
                this.menu._closeAll$.pipe(operators.takeUntil(this._onDestroy$))
                    .subscribe(function (origin) { return _this.closeMenu(origin, true); });
                // handle keyboard events in the menu
                this.menu._onKeydown$.pipe(operators.takeUntil(this._onDestroy$))
                    .subscribe(function (event) { return _this.onMenuKeydown(event); });
            };
        /**
         * @return {?}
         */
        MenuTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy$.next();
                this._onDestroy$.complete();
            };
        /** Open the menu */
        /**
         * Open the menu
         * @return {?}
         */
        MenuTriggerDirective.prototype.openMenu = /**
         * Open the menu
         * @return {?}
         */
            function () {
                var _this = this;
                // if the menu is already open then do nothing
                if (this.menu.isMenuOpen || this.disabled) {
                    return;
                }
                // get or create an overlayRef
                /** @type {?} */
                var overlayRef = this.getOverlay();
                /** @type {?} */
                var portal$$1 = this.getPortal();
                // if the overlay is already attached do nothing
                if (overlayRef.hasAttached()) {
                    return;
                }
                // attach the menu to the DOM
                overlayRef.attach(portal$$1);
                // mark the menu as open
                this.menu._setMenuOpen(true);
                if (this._menuItem) {
                    this._menuItem.isExpanded$.next(true);
                }
                // listen for a menu item to be selected
                this.menu._menuItemClick.pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                    .subscribe(function (origin) { return _this.closeMenu(origin, true); });
                // subscribe to any close events
                this.didMenuClose().pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                    .subscribe(function () { return _this.closeMenu(); });
                // listen for the menu to animate closed then destroy it
                this.menu.closed.pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                    .subscribe(function () { return _this.destroyMenu(); });
            };
        /** Close a menu or submenu */
        /**
         * Close a menu or submenu
         * @param {?=} origin
         * @param {?=} closeParents
         * @return {?}
         */
        MenuTriggerDirective.prototype.closeMenu = /**
         * Close a menu or submenu
         * @param {?=} origin
         * @param {?=} closeParents
         * @return {?}
         */
            function (origin, closeParents) {
                if (closeParents === void 0) {
                    closeParents = false;
                }
                // update the menu state
                this.menu._setMenuOpen(false);
                if (this._menuItem) {
                    this._menuItem.isExpanded$.next(false);
                }
                // if we should close parents then propagate the event
                if (closeParents && this._parentMenu) {
                    this._parentMenu._closeAll$.next(origin);
                }
                // we should focus the trigger element if this is the root trigger
                if (this._isRootTrigger) {
                    this._focusIndicator.focus(origin);
                }
                return this.menu.closed;
            };
        /** Toggle the open state of a menu */
        /**
         * Toggle the open state of a menu
         * @param {?=} event
         * @return {?}
         */
        MenuTriggerDirective.prototype.toggleMenu = /**
         * Toggle the open state of a menu
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                // if this occurs on a submenu trigger then we can skip
                if (this._isSubmenuTrigger) {
                    return;
                }
                if (!this.menu._isAnimating) {
                    // determine the focus origin based on whether or not a keyboard was used
                    /** @type {?} */
                    var origin_1 = event instanceof KeyboardEvent ? 'keyboard' : 'mouse';
                    // set the correct focus origin - if triggered by an event then use the source otherwise it was programmatic
                    this._focusOrigin.setOrigin(event ? origin_1 : 'program');
                    // toggle the menu open state
                    this.menu.isMenuOpen ? this.closeMenu(origin_1, true) : this.openMenu();
                }
                // the enter key will trigger the click event and therefore set the wrong focus origin
                // so we nee to ensure this doesn't happen
                if (event) {
                    event.preventDefault();
                }
            };
        /** Submenus should be opened by hovering on the menu item */
        /**
         * Submenus should be opened by hovering on the menu item
         * @return {?}
         */
        MenuTriggerDirective.prototype._onMouseEnter = /**
         * Submenus should be opened by hovering on the menu item
         * @return {?}
         */
            function () {
                if (this._isSubmenuTrigger && !this._parentMenu._isAnimating) {
                    this.openMenu();
                }
            };
        /** Pressing the escape key should close all menus */
        /**
         * Pressing the escape key should close all menus
         * @return {?}
         */
        MenuTriggerDirective.prototype._onEscape = /**
         * Pressing the escape key should close all menus
         * @return {?}
         */
            function () {
                if (this.menu.isMenuOpen) {
                    this.closeMenu();
                    // refocus the root trigger and show the focus ring
                    if (this._isRootTrigger) {
                        this._focusIndicator.focus('keyboard');
                    }
                }
            };
        /** Handle keyboard events for opening submenus */
        /**
         * Handle keyboard events for opening submenus
         * @param {?} event
         * @return {?}
         */
        MenuTriggerDirective.prototype._onKeydown = /**
         * Handle keyboard events for opening submenus
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // arrow key in the correct direction should open the menu
                if (this.menu.placement === 'right' && event.keyCode === keycodes.RIGHT_ARROW ||
                    this.menu.placement === 'left' && event.keyCode === keycodes.LEFT_ARROW ||
                    this.menu.placement === 'top' && event.keyCode === keycodes.UP_ARROW ||
                    this.menu.placement === 'bottom' && event.keyCode === keycodes.DOWN_ARROW) {
                    this._focusOrigin.setOrigin('keyboard');
                    // if the menu was opened by a click but we subsequently use the arrow keys focus the first item
                    if (this.menu.isMenuOpen) {
                        this.menu._keyManager.setFocusOrigin('keyboard').setFirstItemActive();
                    }
                    else {
                        // otherwise open the menu
                        this.openMenu();
                    }
                    // prevent the browser from scrolling
                    event.preventDefault();
                }
            };
        /** Remove the menu from the DOM */
        /**
         * Remove the menu from the DOM
         * @return {?}
         */
        MenuTriggerDirective.prototype.destroyMenu = /**
         * Remove the menu from the DOM
         * @return {?}
         */
            function () {
                // if the menu has been destroyed already then do nothing
                if (!this._overlayRef) {
                    return;
                }
                // remove the overlay
                this._overlayRef.detach();
            };
        /** Create an overlay or return an existing instance */
        /**
         * Create an overlay or return an existing instance
         * @return {?}
         */
        MenuTriggerDirective.prototype.getOverlay = /**
         * Create an overlay or return an existing instance
         * @return {?}
         */
            function () {
                // if we have already created the overlay then reuse it
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                var _a = this.getOrigin(), originX = _a.originX, originY = _a.originY;
                var _b = this.getOverlayPosition(), overlayX = _b.overlayX, overlayY = _b.overlayY;
                // otherwise create a new one
                this._overlayRef = this._overlay.create({
                    hasBackdrop: !this._isSubmenuTrigger,
                    backdropClass: 'cdk-overlay-transparent-backdrop',
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    positionStrategy: this._overlay.position()
                        .flexibleConnectedTo(this._elementRef)
                        .withLockedPosition()
                        .withPositions([
                        { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY },
                        { originX: this.menu.alignment === 'start' ? 'end' : 'start', originY: originY, overlayX: overlayX, overlayY: overlayY },
                        { originX: originX, originY: this.menu.placement === 'bottom' ? 'top' : 'bottom', overlayX: overlayX, overlayY: overlayY },
                        { originX: this.menu.alignment === 'start' ? 'end' : 'start', originY: this.menu.placement === 'bottom' ? 'top' : 'bottom', overlayX: overlayX, overlayY: overlayY },
                    ])
                });
                return this._overlayRef;
            };
        /** Create a Template portal if one does not already exist (or the template has changed) */
        /**
         * Create a Template portal if one does not already exist (or the template has changed)
         * @return {?}
         */
        MenuTriggerDirective.prototype.getPortal = /**
         * Create a Template portal if one does not already exist (or the template has changed)
         * @return {?}
         */
            function () {
                // if there is no portal or the templateRef has changed then create a new one
                if (!this._portal || this.menu.templateRef !== this._portal.templateRef) {
                    this._portal = new portal.TemplatePortal(this.menu.templateRef, this._viewContainerRef);
                }
                return this._portal;
            };
        /** Get the origin position based on the specified tooltip placement */
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        MenuTriggerDirective.prototype.getOrigin = /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.menu.placement = this.menu.placement || 'bottom';
                if (this.menu.placement === 'top' || this.menu.placement === 'bottom') {
                    return { originX: ( /** @type {?} */(this.menu.alignment)), originY: this.menu.placement };
                }
                if (this.menu.placement === 'left') {
                    return { originX: 'start', originY: this.getVerticalAlignment() };
                }
                if (this.menu.placement === 'right') {
                    return { originX: 'end', originY: this.getVerticalAlignment() };
                }
            };
        /** Calculate the overlay position based on the specified tooltip placement */
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        MenuTriggerDirective.prototype.getOverlayPosition = /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.menu.placement = this.menu.placement || 'top';
                if (this.menu.placement === 'top') {
                    return { overlayX: ( /** @type {?} */(this.menu.alignment)), overlayY: 'bottom' };
                }
                if (this.menu.placement === 'bottom') {
                    return { overlayX: ( /** @type {?} */(this.menu.alignment)), overlayY: 'top' };
                }
                if (this.menu.placement === 'left') {
                    return { overlayX: 'end', overlayY: this.getVerticalAlignment() };
                }
                if (this.menu.placement === 'right') {
                    return { overlayX: 'start', overlayY: this.getVerticalAlignment() };
                }
            };
        /** Convert the alignment property to a valid CDK alignment value */
        /**
         * Convert the alignment property to a valid CDK alignment value
         * @return {?}
         */
        MenuTriggerDirective.prototype.getVerticalAlignment = /**
         * Convert the alignment property to a valid CDK alignment value
         * @return {?}
         */
            function () {
                switch (this.menu.alignment) {
                    case 'start':
                        return 'top';
                    case 'end':
                        return 'bottom';
                    default:
                        return this.menu.alignment;
                }
            };
        /** Get an observable that emits on any of the triggers that close a menu */
        /**
         * Get an observable that emits on any of the triggers that close a menu
         * @return {?}
         */
        MenuTriggerDirective.prototype.didMenuClose = /**
         * Get an observable that emits on any of the triggers that close a menu
         * @return {?}
         */
            function () {
                return rxjs.merge(this._overlayRef.backdropClick(), this._overlayRef.detachments(), this._parentMenu ? this._parentMenu.closing : rxjs.of(), this._menuShouldClose);
            };
        /** When the menu opens we want to focus the first item in the list */
        /**
         * When the menu opens we want to focus the first item in the list
         * @return {?}
         */
        MenuTriggerDirective.prototype.menuDidOpen = /**
         * When the menu opens we want to focus the first item in the list
         * @return {?}
         */
            function () {
                // if the keyboard is used we should always focus and show the indicator
                // regardless of it this is the root menu or not
                if (this._focusOrigin.getOrigin() === 'keyboard') {
                    this.menu._keyManager.setFocusOrigin('keyboard').setFirstItemActive();
                }
            };
        /** Handle keypresses in submenus where we may want to close them */
        /**
         * Handle keypresses in submenus where we may want to close them
         * @param {?} event
         * @return {?}
         */
        MenuTriggerDirective.prototype.onMenuKeydown = /**
         * Handle keypresses in submenus where we may want to close them
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if we are a submenu and the user presses an arrow key in the opposite
                // direction than it is positioned from its parents then we should close the menu
                if (this._parentMenu) {
                    if (this.menu.placement === 'right' && event.keyCode === keycodes.LEFT_ARROW ||
                        this.menu.placement === 'left' && event.keyCode === keycodes.RIGHT_ARROW ||
                        this.menu.placement === 'top' && event.keyCode === keycodes.DOWN_ARROW ||
                        this.menu.placement === 'bottom' && event.keyCode === keycodes.UP_ARROW) {
                        this.closeMenu();
                        // refocus the parent menu item
                        this._menuItem.focus('keyboard');
                    }
                }
            };
        MenuTriggerDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMenuTriggerFor]',
                        exportAs: 'ux-menu-trigger',
                        host: {
                            '[attr.aria-haspopup]': '!!menu',
                            '[attr.aria-expanded]': 'menu?.isMenuOpen'
                        }
                    },] }
        ];
        /** @nocollapse */
        MenuTriggerDirective.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: i0.ElementRef },
                { type: i0.ViewContainerRef },
                { type: FocusIndicatorOriginService },
                { type: FocusIndicatorService },
                { type: MenuComponent, decorators: [{ type: i0.Optional }] },
                { type: MenuItemComponent, decorators: [{ type: i0.Optional }, { type: i0.Self }] }
            ];
        };
        MenuTriggerDirective.propDecorators = {
            menu: [{ type: i0.Input, args: ['uxMenuTriggerFor',] }],
            disabled: [{ type: i0.Input }],
            menuTriggers: [{ type: i0.ContentChildren, args: [MenuTriggerDirective,] }],
            toggleMenu: [{ type: i0.HostListener, args: ['click', ['$event'],] }, { type: i0.HostListener, args: ['keydown.enter', ['$event'],] }],
            _onMouseEnter: [{ type: i0.HostListener, args: ['mouseenter',] }],
            _onEscape: [{ type: i0.HostListener, args: ['document:keydown.escape',] }],
            _onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuTriggerDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuModule = /** @class */ (function () {
        function MenuModule() {
        }
        /**
         * @param {?} options
         * @return {?}
         */
        MenuModule.forRoot = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return {
                    ngModule: MenuModule,
                    providers: [
                        { provide: MENU_OPTIONS_TOKEN, useValue: options }
                    ]
                };
            };
        /** Support options at a child module level (implementation is the same as `forRoot`) */
        /**
         * Support options at a child module level (implementation is the same as `forRoot`)
         * @param {?} options
         * @return {?}
         */
        MenuModule.forChild = /**
         * Support options at a child module level (implementation is the same as `forRoot`)
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return MenuModule.forRoot(options);
            };
        MenuModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            MenuComponent,
                            MenuTriggerDirective,
                            MenuItemComponent,
                            MenuDividerComponent,
                            MenuTabbableItemDirective
                        ],
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            overlay.OverlayModule
                        ],
                        exports: [
                            MenuComponent,
                            MenuTriggerDirective,
                            MenuItemComponent,
                            MenuDividerComponent,
                            MenuTabbableItemDirective
                        ]
                    },] }
        ];
        return MenuModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$2 = [
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent,
        FilterTypeaheadHighlight
    ];
    var FilterModule = /** @class */ (function () {
        function FilterModule() {
        }
        FilterModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            IconModule,
                            MenuModule,
                            TooltipModule,
                            TypeaheadModule,
                        ],
                        exports: DECLARATIONS$2,
                        declarations: DECLARATIONS$2
                    },] }
        ];
        return FilterModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FlippableCardComponent = /** @class */ (function () {
        function FlippableCardComponent(focusIndicatorService, elementRef) {
            /**
             * Determines whether the card should flip horizontally or vertically.
             */
            this.direction = 'horizontal';
            /**
             * Determines when the card should flip. Possible options are `click`, `hover` and `manual`.
             * The manual option should be used if you want complete control over when the card should flip.
             */
            this.trigger = 'hover';
            /**
             * Sets the width (in pixels) of the card.
             */
            this.width = 280;
            /**
             * Sets the height (in pixels) of the card.
             */
            this.height = 200;
            /**
             * Determines whether or not the card is flipped.
             */
            this.flipped = false;
            /**
             * If two way binding is used this value will be updated when the state of the card changes.
             */
            this.flippedChange = new i0.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusIndicator.destroy();
            };
        /**
         * @param {?} state
         * @return {?}
         */
        FlippableCardComponent.prototype.setFlipped = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                this.flipped = state;
                this.flippedChange.emit(this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.toggleFlipped = /**
         * @return {?}
         */
            function () {
                this.setFlipped(!this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.clickTrigger = /**
         * @return {?}
         */
            function () {
                // add or remove the class depending on whether or not the card has been flipped
                if (this.trigger === 'click') {
                    this.toggleFlipped();
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverEnter = /**
         * @return {?}
         */
            function () {
                // if the trigger is hover then begin to flip
                if (this.trigger === 'hover') {
                    this.setFlipped(true);
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverExit = /**
         * @return {?}
         */
            function () {
                if (this.trigger === 'hover') {
                    this.setFlipped(false);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FlippableCardComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.trigger !== 'manual') {
                    this.toggleFlipped();
                    event.preventDefault();
                }
            };
        FlippableCardComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-flippable-card',
                        template: "<div class=\"ux-flipper\"\n     [class.ux-flip-card]=\"flipped\"\n     [style.width.px]=\"width\"\n     [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"flipped\">\n\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"!flipped\">\n\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                        host: {
                            'tabindex': '0',
                            '[class.horizontal]': 'direction === "horizontal"',
                            '[class.vertical]': 'direction === "vertical"'
                        },
                        exportAs: 'ux-flippable-card',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        FlippableCardComponent.ctorParameters = function () {
            return [
                { type: FocusIndicatorService },
                { type: i0.ElementRef }
            ];
        };
        FlippableCardComponent.propDecorators = {
            direction: [{ type: i0.Input }],
            trigger: [{ type: i0.Input }],
            width: [{ type: i0.Input }],
            height: [{ type: i0.Input }],
            flipped: [{ type: i0.Input }],
            flippedChange: [{ type: i0.Output }],
            clickTrigger: [{ type: i0.HostListener, args: ['click',] }],
            hoverEnter: [{ type: i0.HostListener, args: ['mouseenter',] }],
            hoverExit: [{ type: i0.HostListener, args: ['mouseleave',] }],
            onKeyDown: [{ type: i0.HostListener, args: ['keydown.enter', ['$event'],] }, { type: i0.HostListener, args: ['keydown.space', ['$event'],] }, { type: i0.HostListener, args: ['keydown.spacebar', ['$event'],] }]
        };
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = /** @class */ (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-flippable-card-front'
                    },] }
        ];
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = /** @class */ (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-flippable-card-back'
                    },] }
        ];
        return FlippableCardBackDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FlippableCardModule = /** @class */ (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule
                        ],
                        exports: [
                            FlippableCardComponent,
                            FlippableCardBackDirective,
                            FlippableCardFrontDirective
                        ],
                        declarations: [
                            FlippableCardComponent,
                            FlippableCardBackDirective,
                            FlippableCardFrontDirective
                        ]
                    },] }
        ];
        return FlippableCardModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FloatingActionButtonsService = /** @class */ (function () {
        function FloatingActionButtonsService() {
            this.open$ = new rxjs.BehaviorSubject(false);
            this.direction$ = new rxjs.BehaviorSubject('top');
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.open$.next(!this.open$.getValue());
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
                // make the first button tabbable again
                this.setPrimaryButtonFocusable();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.isHorizontal = /**
         * @return {?}
         */
            function () {
                return this.direction$.value === 'left' || this.direction$.value === 'right';
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.isVertical = /**
         * @return {?}
         */
            function () {
                return this.direction$.value === 'top' || this.direction$.value === 'bottom';
            };
        /**
         * @param {?} buttons
         * @return {?}
         */
        FloatingActionButtonsService.prototype.setButtons = /**
         * @param {?} buttons
         * @return {?}
         */
            function (buttons) {
                var _this = this;
                this._buttons = buttons;
                // make the first button tabbable (after a delay to prevent expression changed error)
                requestAnimationFrame(function () { return _this.setPrimaryButtonFocusable(); });
            };
        /** Make only the first button tabbable */
        /**
         * Make only the first button tabbable
         * @return {?}
         */
        FloatingActionButtonsService.prototype.setPrimaryButtonFocusable = /**
         * Make only the first button tabbable
         * @return {?}
         */
            function () {
                this._buttons.forEach(function (btn) { return btn.tabindex$.next(btn.primary ? 0 : -1); });
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focusPrimaryButton = /**
         * @return {?}
         */
            function () {
                this.focus(this._buttons.find(function (btn) { return btn.primary; }));
            };
        /**
         * @param {?} button
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focus = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                // if the button is not defined then do nothing
                if (!button) {
                    return;
                }
                // set the button tab index
                this._buttons.forEach(function (btn) { return btn.tabindex$.next(button === btn ? 0 : -1); });
                // apply the focus
                button.focus();
            };
        /**
         * @param {?} next
         * @return {?}
         */
        FloatingActionButtonsService.prototype.focusSibling = /**
         * @param {?} next
         * @return {?}
         */
            function (next) {
                // if the buttons are not visible then do nothing
                if (this.open$.value === false) {
                    return;
                }
                // get the current focused item
                /** @type {?} */
                var button = this.getFocusedButton();
                if (next && button === this._buttons.last) {
                    return this.focus(this._buttons.first);
                }
                else if (!next && button === this._buttons.first) {
                    return this.focus(this._buttons.last);
                }
                // find the sibling button
                /** @type {?} */
                var sibling = this._buttons.toArray()[this.getButtonIndex(button) + (next ? 1 : -1)];
                // focus the next button
                this.focus(sibling);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.getFocusedButton = /**
         * @return {?}
         */
            function () {
                return this._buttons.find(function (btn) { return btn.tabindex$.value === 0; });
            };
        /**
         * @param {?} button
         * @return {?}
         */
        FloatingActionButtonsService.prototype.getButtonIndex = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                return this._buttons.toArray().findIndex(function (btn) { return btn === button; });
            };
        FloatingActionButtonsService.decorators = [
            { type: i0.Injectable }
        ];
        return FloatingActionButtonsService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FloatingActionButtonComponent = /** @class */ (function () {
        function FloatingActionButtonComponent(primary, fab, _tooltip) {
            this.fab = fab;
            this._tooltip = _tooltip;
            /**
             * Determine if this is the primary button in the set
             */
            this.primary = false;
            /**
             * Store the tabindex
             */
            this.tabindex$ = new rxjs.BehaviorSubject(-1);
            /**
             * Unsubscribe from all observables on component destroy
             */
            this._onDestroy = new rxjs.Subject();
            this.primary = primary !== null;
        }
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._tooltip) {
                    // ensure the tooltip gets hidden when the button is hidden
                    this.fab.open$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (isOpen) { return !isOpen && !_this.primary; }))
                        .subscribe(function () { return _this._tooltip.hide(); });
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                // ensure the tooltip gets shown
                if (this._tooltip) {
                    this._tooltip.show();
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                // ensure the tooltip gets hidden
                if (this._tooltip) {
                    this._tooltip.hide();
                }
            };
        /**
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.fab.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FloatingActionButtonComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        if (this.fab.isVertical()) {
                            this.fab.focusSibling(this.fab.direction$.value !== 'bottom');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.DOWN_ARROW:
                        if (this.fab.isVertical()) {
                            this.fab.focusSibling(this.fab.direction$.value === 'bottom');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.LEFT_ARROW:
                        if (this.fab.isHorizontal()) {
                            this.fab.focusSibling(this.fab.direction$.value !== 'right');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (this.fab.isHorizontal()) {
                            this.fab.focusSibling(this.fab.direction$.value === 'right');
                            event.preventDefault();
                        }
                        break;
                    case keycodes.ENTER:
                        this.fab.focusPrimaryButton();
                        break;
                    case keycodes.ESCAPE:
                        this.fab.focusPrimaryButton();
                        this.fab.close();
                        break;
                }
            };
        FloatingActionButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-floating-action-button',
                        template: "<button #button\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        type=\"button\"\n        class=\"btn floating-action-button\"\n        [class.button-primary]=\"primary\"\n        [class.button-secondary]=\"!primary\"\n        [attr.aria-label]=\"ariaLabel\"\n        [tabIndex]=\"tabindex$ | async\"\n        (focus)=\"onFocus()\"\n        (blur)=\"onBlur()\"\n        (click)=\"primary ? fab.toggle() : close()\">\n\n    <ng-content></ng-content>\n\n</button>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonComponent.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Attribute, args: ['fab-primary',] }] },
                { type: FloatingActionButtonsService },
                { type: TooltipDirective, decorators: [{ type: i0.Optional }] }
            ];
        };
        FloatingActionButtonComponent.propDecorators = {
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            button: [{ type: i0.ViewChild, args: ['button', { static: true },] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return FloatingActionButtonComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FloatingActionButtonsComponent = /** @class */ (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            var _this = this;
            this.fab = fab;
            this._elementRef = _elementRef;
            /**
             * Emit whenever the open state changes
             */
            this.openChange = new i0.EventEmitter();
            this._subscription = new rxjs.Subscription();
            this._subscription.add(this.fab.open$.subscribe(function (value) { return _this.openChange.emit(value); }));
        }
        Object.defineProperty(FloatingActionButtonsComponent.prototype, "direction", {
            /** Specify the direction that the FAB should display */
            set: /**
             * Specify the direction that the FAB should display
             * @param {?} direction
             * @return {?}
             */ function (direction) { this.fab.direction$.next(direction); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.fab.setButtons(this.buttons);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /*
         * Detect any clicks to trigger close of the menu
         */
        /*
             * Detect any clicks to trigger close of the menu
             */
        /**
         * @param {?} target
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.close = /*
             * Detect any clicks to trigger close of the menu
             */
            /**
             * @param {?} target
             * @return {?}
             */
            function (target) {
                if (!this._elementRef.nativeElement.contains(target)) {
                    this.fab.close();
                }
            };
        FloatingActionButtonsComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-floating-action-buttons',
                        template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"fab.direction$ | async\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                        providers: [FloatingActionButtonsService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        animations: [
                            animations.trigger('fabAnimation', [
                                animations.transition('void => true', [
                                    animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                                    animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                                ]),
                                animations.transition('true => void', [
                                    animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonsComponent.ctorParameters = function () {
            return [
                { type: FloatingActionButtonsService },
                { type: i0.ElementRef }
            ];
        };
        FloatingActionButtonsComponent.propDecorators = {
            direction: [{ type: i0.Input }],
            openChange: [{ type: i0.Output }],
            buttons: [{ type: i0.ContentChildren, args: [FloatingActionButtonComponent,] }],
            close: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return FloatingActionButtonsComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FloatingActionButtonsModule = /** @class */ (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule
                        ],
                        exports: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ],
                        declarations: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ]
                    },] }
        ];
        return FloatingActionButtonsModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarNodeIconDirective = /** @class */ (function () {
        function HierarchyBarNodeIconDirective() {
        }
        HierarchyBarNodeIconDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxHierarchyBarNodeIcon]',
                    },] }
        ];
        return HierarchyBarNodeIconDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarService = /** @class */ (function () {
        function HierarchyBarService() {
            /**
             * Define the list of selected nodes
             */
            this.nodes$ = new rxjs.BehaviorSubject([]);
            /**
             * Define the events that show the popover when interacting with the arrows
             */
            this.popoverShowTriggers = ['click'];
            /**
             * Define the events that hide the popover when interacting with the arrows
             */
            this.popoverHideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Emit the selected node when it changes
             */
            this.selection$ = new rxjs.Subject();
            /**
             * Define the aria label for the show siblings popover button
             */
            this.showSiblingsAriaLabel = 'Show Siblings';
            /**
             * Store nodes as a flattened list
             */
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
        HierarchyBarService.prototype.setRootNode = /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
            function (root) {
                // if the node is null or undefined then do nothing
                if (!root) {
                    return;
                }
                // store the root node
                this._root = root;
                // create a flat structure of nodes
                this._nodes = this.getNodeList(root);
                // flatten the array - based on the selected node
                this.nodes$.next(this.getSelectedChildren(root));
            };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.selectNode = /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // deselect all nodes
                this.deselectAll();
                // if the node is undefined then do nothing
                if (!node) {
                    return;
                }
                // ensure the current node is selected and its parents
                this.select(node);
                // emit a new node list to trigger change detection
                this.nodes$.next(this.getSelectedChildren(this._root));
                // emit the new selection
                this.selection$.next(node);
            };
        /**
         * Handles getting children with support for both arrays and observables
         */
        /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getChildren = /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                if (Array.isArray(node.children)) {
                    return rxjs.of({ loading: false, children: node.children });
                }
                /** @type {?} */
                var children$ = node.children;
                // if it is an observable then handle loading
                return rxjs.Observable.create(function (observer) {
                    // emit initial value
                    observer.next({ loading: true, children: [] });
                    // now wait until the children observable completes
                    children$.pipe(operators.first()).subscribe(function (children) {
                        // replace the observable with an array for future loading
                        node.children = children;
                        // rebuild the node tree
                        _this.setRootNode(_this._root);
                        // emit the latest value
                        observer.next({ loading: false, children: children });
                        // close the observable stream
                        observer.complete();
                    });
                });
            };
        /**
         * Utility function to get the sibling nodes, taking into account that
         * a node may be a root node and may not have a parent.
         */
        /**
         * Utility function to get the sibling nodes, taking into account that
         * a node may be a root node and may not have a parent.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSiblings = /**
         * Utility function to get the sibling nodes, taking into account that
         * a node may be a root node and may not have a parent.
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return node.parent ? this.getChildren(node.parent) : rxjs.of({ loading: false, children: [] });
            };
        /**
         * Traverses all the parents to ensure they are selected
         */
        /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.select = /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                node.selected = true;
                if (node.parent) {
                    this.select(node.parent);
                }
            };
        /**
         * Deselects all nodes
         */
        /**
         * Deselects all nodes
         * @return {?}
         */
        HierarchyBarService.prototype.deselectAll = /**
         * Deselects all nodes
         * @return {?}
         */
            function () {
                this._nodes.forEach(function (node) { return node.selected = false; });
            };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         */
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getNodeList = /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                // if there are no children then return only itself
                if (!node.children || rxjs.isObservable(node.children) || node.children.length === 0) {
                    return [node];
                }
                // store the parent property
                node.children.forEach(function (child) { return child.parent = node; });
                // get all descendants of this node
                /** @type {?} */
                var descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
                return __spread([node], descendants);
            };
        /**
         * Gets all selected nodes from the parent node.
         */
        /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSelectedChildren = /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (rxjs.isObservable(node.children)) {
                    return [node];
                }
                // get the children - and account for when there is none
                /** @type {?} */
                var children = node.children || [];
                // check if any child is selected
                /** @type {?} */
                var child = children.find(function (_child) { return _child.selected; });
                // return the remaining chain of selected items
                return child ? __spread([node], this.getSelectedChildren(child)) : [node];
            };
        HierarchyBarService.decorators = [
            { type: i0.Injectable }
        ];
        return HierarchyBarService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarComponent = /** @class */ (function () {
        function HierarchyBarComponent(_hierarchyBar) {
            var _this = this;
            this._hierarchyBar = _hierarchyBar;
            /**
             * Define which presentational mode we should display
             */
            this.mode = 'standard';
            /**
             * hierarchy bar as being readonly - default false
             */
            this.readonly = false;
            /**
             * Emit when the selected node changes
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Unsubscribe from all subscriptions when component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
            // emit the latest selection value
            _hierarchyBar.selection$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (selection) { return _this.selectedChange.next(selection); });
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            /** Define the root node of the hierarchy bar */
            set: /**
             * Define the root node of the hierarchy bar
             * @param {?} node
             * @return {?}
             */ function (node) {
                this._hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            /** Define the selected node in the hierarchy bar */
            set: /**
             * Define the selected node in the hierarchy bar
             * @param {?} node
             * @return {?}
             */ function (node) {
                this._hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "loadingIndicator", {
            /** Provide a custom loading indicator */
            set: /**
             * Provide a custom loading indicator
             * @param {?} loadingIndicator
             * @return {?}
             */ function (loadingIndicator) {
                this._hierarchyBar.loadingIndicator = loadingIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "overflowTemplate", {
            /** Provide a custom overflow template */
            set: /**
             * Provide a custom overflow template
             * @param {?} overflowTemplate
             * @return {?}
             */ function (overflowTemplate) {
                this._hierarchyBar.overflowTemplate = overflowTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "popoverShowTriggers", {
            /** Define the events that show the popover when interacting with the arrows */
            set: /**
             * Define the events that show the popover when interacting with the arrows
             * @param {?} popoverShowTriggers
             * @return {?}
             */ function (popoverShowTriggers) {
                this._hierarchyBar.popoverShowTriggers = popoverShowTriggers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "popoverHideTriggers", {
            /** Define the events that hide the popover when interacting with the arrows */
            set: /**
             * Define the events that hide the popover when interacting with the arrows
             * @param {?} popoverHideTriggers
             * @return {?}
             */ function (popoverHideTriggers) {
                this._hierarchyBar.popoverHideTriggers = popoverHideTriggers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "showSiblingsAriaLabel", {
            /** Define the aria label for the show siblings popover button */
            set: /**
             * Define the aria label for the show siblings popover button
             * @param {?} label
             * @return {?}
             */ function (label) {
                this._hierarchyBar.showSiblingsAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "icon", {
            /** Allow a custom icon to be specified */
            set: /**
             * Allow a custom icon to be specified
             * @param {?} icon
             * @return {?}
             */ function (icon) {
                this._hierarchyBar.icon = icon;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        HierarchyBarComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar',
                        template: "<!-- Hierarchy Bar - Standard Layout -->\n<ux-hierarchy-bar-standard [readonly]=\"readonly\" [mode]=\"mode\" *ngIf=\"mode !== 'collapsed'\">\n\n    <!-- Forward the content to the correct layout -->\n    <ng-container ngProjectAs=\"left-addons\" [ngTemplateOutlet]=\"leftAddons\"></ng-container>\n    <ng-container ngProjectAs=\"trailing-addons\" [ngTemplateOutlet]=\"trailingAddons\"></ng-container>\n    <ng-container ngProjectAs=\"right-addons\" [ngTemplateOutlet]=\"rightAddons\"></ng-container>\n\n</ux-hierarchy-bar-standard>\n\n<!-- Hierarchy Bar - Collapsed Layout -->\n<ux-hierarchy-bar-collapsed [readonly]=\"readonly\" *ngIf=\"mode === 'collapsed'\">\n\n    <!-- Forward the content to the correct layout -->\n    <ng-container ngProjectAs=\"left-addons\" [ngTemplateOutlet]=\"leftAddons\"></ng-container>\n    <ng-container ngProjectAs=\"trailing-addons\" [ngTemplateOutlet]=\"trailingAddons\"></ng-container>\n    <ng-container ngProjectAs=\"right-addons\" [ngTemplateOutlet]=\"rightAddons\"></ng-container>\n\n</ux-hierarchy-bar-collapsed>\n\n<!-- We can only have one ng-content so this allows us to use it more than once -->\n<ng-template #leftAddons>\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</ng-template>\n\n<ng-template #trailingAddons>\n    <ng-content select=\"[uxHierarchyBarTrailingAddon]\"></ng-content>\n</ng-template>\n\n<ng-template #rightAddons>\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        viewProviders: [HierarchyBarService]
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarComponent.propDecorators = {
            mode: [{ type: i0.Input }],
            readonly: [{ type: i0.Input }],
            root: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            loadingIndicator: [{ type: i0.Input }],
            overflowTemplate: [{ type: i0.Input }],
            popoverShowTriggers: [{ type: i0.Input }],
            popoverHideTriggers: [{ type: i0.Input }],
            showSiblingsAriaLabel: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            icon: [{ type: i0.ContentChild, args: [HierarchyBarNodeIconDirective, { read: i0.TemplateRef, static: false },] }]
        };
        return HierarchyBarComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ClickOutsideDirective = /** @class */ (function () {
        function ClickOutsideDirective(_elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.uxClickOutside = new i0.EventEmitter();
            /**
             * Often a click event makes the element appear - if so we can end up closing it immediately
             */
            this._initialised = false;
            setTimeout(function () { return _this._initialised = true; });
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClickOutsideDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._initialised && this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                    this.uxClickOutside.emit(event);
                }
            };
        ClickOutsideDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxClickOutside]'
                    },] }
        ];
        /** @nocollapse */
        ClickOutsideDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        ClickOutsideDirective.propDecorators = {
            uxClickOutside: [{ type: i0.Output }],
            click: [{ type: i0.HostListener, args: ['document:click', ['$event'],] }]
        };
        return ClickOutsideDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ClickOutsideModule = /** @class */ (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [ClickOutsideDirective],
                        declarations: [ClickOutsideDirective]
                    },] }
        ];
        return ClickOutsideModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniquePopoverId = 0;
    var PopoverComponent = /** @class */ (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent(changeDetectorRef) {
            var _this = _super.call(this, changeDetectorRef) || this;
            /**
             * Define a unique id for each popover
             */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /**
             * This will emit an event any time the user clicks outside the popover
             */
            _this.clickOutside$ = new rxjs.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
        PopoverComponent.prototype.setTitle = /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
            function (title) {
                this.title = title;
                this._changeDetectorRef.markForCheck();
            };
        PopoverComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div class=\"popover show\" [ngClass]=\"[placement, 'popover-align-' + alignment, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        PopoverComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        return PopoverComponent;
    }(TooltipComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PopoverDirective = /** @class */ (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective(elementRef, viewContainerRef, overlay$$1, scrollDispatcher, changeDetectorRef, renderer, tooltipService) {
            var _this = _super.call(this, elementRef, viewContainerRef, overlay$$1, scrollDispatcher, changeDetectorRef, renderer, tooltipService) || this;
            /**
             * All the user to add a custom class to the popover
             */
            _this.customClass = '';
            /**
             * All the user to add a role to the popover - default is tooltip
             */
            _this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            _this.context = {};
            /**
             * Delay the showing of the popover by a number of miliseconds
             */
            _this.delay = 0;
            /**
             * Specify which events should show the popover
             */
            _this.showTriggers = ['click'];
            /**
             * Specify which events should hide the popover
             */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Keep track of the tooltip visibility and update aria-expanded attribute
             */
            _this.isVisible = false;
            /**
             * Define the overlay class
             */
            _this._overlayClass = 'ux-overlay-pane';
            /**
             * Internally store the type of this component - usual for distinctions when extending the tooltip class
             */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        PopoverDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                // set up the event triggers
                rxjs.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
                // check if there is an aria-described by attribute
                this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
                // set up the default event triggers
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        PopoverDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (this._instance && changes.title) {
                    this._instance.setTitle(changes.title.currentValue);
                }
            };
        /**
         * @param {?} overlayRef
         * @return {?}
         */
        PopoverDirective.prototype.createInstance = /**
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                /** @type {?} */
                var instance = ( /** @type {?} */(overlayRef.attach(this._portal).instance));
                // supply the tooltip with the correct properties
                instance.setTitle(this.title);
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setAlignment(this.alignment);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                // subscribe to the outside click event
                instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
                return instance;
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.createPortal = /**
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PopoverDirective.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if visible and the escape key is pressed and it is one of the hide triggers
                if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                    this.hide();
                }
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.onClickOutside = /**
         * @return {?}
         */
            function () {
                // if visible and it is one of the hide triggers
                if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                    this.hide();
                }
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        PopoverDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
                if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                    _super.prototype.setAriaDescribedBy.call(this, id);
                }
            };
        PopoverDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxPopover]',
                        exportAs: 'ux-popover'
                    },] }
        ];
        /** @nocollapse */
        PopoverDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.ViewContainerRef },
                { type: overlay.Overlay },
                { type: overlay.ScrollDispatcher },
                { type: i0.ChangeDetectorRef },
                { type: i0.Renderer2 },
                { type: TooltipService }
            ];
        };
        PopoverDirective.propDecorators = {
            content: [{ type: i0.Input, args: ['uxPopover',] }],
            title: [{ type: i0.Input, args: ['popoverTitle',] }],
            disabled: [{ type: i0.Input, args: ['popoverDisabled',] }],
            customClass: [{ type: i0.Input, args: ['popoverClass',] }],
            role: [{ type: i0.Input, args: ['popoverRole',] }],
            context: [{ type: i0.Input, args: ['popoverContext',] }],
            delay: [{ type: i0.Input, args: ['popoverDelay',] }],
            showTriggers: [{ type: i0.Input }],
            hideTriggers: [{ type: i0.Input }],
            isVisible: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }]
        };
        return PopoverDirective;
    }(TooltipDirective));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PopoverModule = /** @class */ (function () {
        function PopoverModule() {
        }
        PopoverModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule,
                            ClickOutsideModule,
                            TooltipModule
                        ],
                        exports: [PopoverDirective],
                        declarations: [PopoverComponent, PopoverDirective],
                        entryComponents: [PopoverComponent]
                    },] }
        ];
        return PopoverModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarCollapsedComponent = /** @class */ (function () {
        function HierarchyBarCollapsedComponent(hierarchyBar, _renderer, _resizeService, _elementRef) {
            this.hierarchyBar = hierarchyBar;
            this._renderer = _renderer;
            this._resizeService = _resizeService;
            this._elementRef = _elementRef;
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_first", {
            /** Get the first node to display */
            get: /**
             * Get the first node to display
             * @return {?}
             */ function () {
                return this._nodes[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_last", {
            /** Get the last node to display */
            get: /**
             * Get the last node to display
             * @return {?}
             */ function () {
                return this._nodes[this._nodes.length - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_siblings", {
            /** Get all the sibling nodes */
            get: /**
             * Get all the sibling nodes
             * @return {?}
             */ function () {
                return this.hierarchyBar.getSiblings(this._last);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_parents", {
            /** Get all the nodes between the first and last nodes */
            get: /**
             * Get all the nodes between the first and last nodes
             * @return {?}
             */ function () {
                var _this = this;
                return this._nodes.filter(function (node) { return node !== _this._first && node !== _this._last; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_nodes", {
            /** Get the nodes as an array */
            get: /**
             * Get the nodes as an array
             * @return {?}
             */ function () {
                return this.hierarchyBar.nodes$.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarCollapsedComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // check for overflow when the selected nodes change
                this.hierarchyBar.nodes$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.updateOverflow(); });
                // watch for the host element size changing
                this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.updateOverflow(); });
            };
        /**
         * @return {?}
         */
        HierarchyBarCollapsedComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                // remove the resize event listener
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
            };
        /**
         * @return {?}
         */
        HierarchyBarCollapsedComponent.prototype.updateOverflow = /**
         * @return {?}
         */
            function () {
                // remove the class if it is present
                this._renderer.removeClass(this.nodeContainer.nativeElement, 'hierarchy-bar-nodes-overflow');
                // check if there is overflow
                if (this.nodeContainer.nativeElement.scrollWidth > this.nodeContainer.nativeElement.offsetWidth) {
                    this._renderer.addClass(this.nodeContainer.nativeElement, 'hierarchy-bar-nodes-overflow');
                }
            };
        HierarchyBarCollapsedComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar-collapsed',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"left-addons\"></ng-content>\n</div>\n\n<div #nodes class=\"hierarchy-bar-nodes\">\n\n    <ux-hierarchy-bar-node\n        [readonly]=\"readonly\"\n        [popoverTemplate]=\"content\"\n        [node]=\"_first\"\n        (selected)=\"hierarchyBar.selectNode($event)\">\n    </ux-hierarchy-bar-node>\n\n    <div class=\"hierarchy-bar-overflow\" *ngIf=\"_parents.length > 0\">\n        <div class=\"hierarchy-bar-overflow-container\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.overflowTemplate || defaultOverflowTemplate\"\n                          [ngTemplateOutletContext]=\"{ $implicit: _parents }\">\n            </ng-container>\n        </div>\n\n        <button [attr.aria-label]=\"hierarchyBar.showSiblingsAriaLabel\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            class=\"hierarchy-bar-node-arrow\"\n            placement=\"bottom\"\n            [uxPopover]=\"siblingsTemplate\"\n            popoverClass=\"hierarchy-bar-popover\"\n            role=\"button\"\n            tabindex=\"0\"\n            [disabled]=\"readonly\"\n            #popover=\"ux-popover\"\n            [popoverContext]=\"{ popover: popover }\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            type=\"button\">\n\n            <ux-icon name=\"next\" class=\"hierarchy-bar-node-arrow-icon\"></ux-icon>\n        </button>\n    </div>\n\n\n    <ux-hierarchy-bar-node\n        *ngIf=\"_last !== _first\"\n        [readonly]=\"readonly\"\n        [popoverTemplate]=\"content\"\n        [node]=\"_last\"\n        (selected)=\"hierarchyBar.selectNode($event)\">\n    </ux-hierarchy-bar-node>\n\n    <!-- Allow content to be placed after the last node -->\n    <div class=\"hierarchy-bar-addons\">\n        <ng-content select=\"trailing-addons\"></ng-content>\n    </div>\n\n</div>\n\n<!-- Allow content to be placed on the right of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"right-addons\"></ng-content>\n</div>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [loading]=\"(hierarchyBar.getChildren(node) | async)?.loading\"\n        [nodes]=\"(hierarchyBar.getChildren(node) | async)?.children\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the siblings popover list -->\n<ng-template #siblingsTemplate let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [nodes]=\"(_siblings | async)?.children\"\n        [loading]=\"(_siblings | async)?.loading\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the parents popover list -->\n<ng-template #parentsTemplate let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [nodes]=\"_parents\"\n        [separator]=\"true\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Default Overflow Template -->\n<ng-template #defaultOverflowTemplate>\n    <button uxFocusIndicator\n            uxFocusIndicatorOrigin\n            [disabled]=\"readonly\"\n            class=\"overflow-button\"\n            aria-label=\"Show parents\"\n            [uxPopover]=\"parentsTemplate\"\n            popoverClass=\"hierarchy-bar-popover\"\n            role=\"button\"\n            tabindex=\"0\"\n            #popover=\"ux-popover\"\n            [popoverContext]=\"{ popover: popover }\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            placement=\"bottom\"\n            type=\"button\">\n            <ux-icon name=\"more\"></ux-icon>\n    </button>\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarCollapsedComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService },
                { type: i0.Renderer2 },
                { type: ResizeService },
                { type: i0.ElementRef }
            ];
        };
        HierarchyBarCollapsedComponent.propDecorators = {
            readonly: [{ type: i0.Input }],
            nodeContainer: [{ type: i0.ViewChild, args: ['nodes', { static: true },] }]
        };
        return HierarchyBarCollapsedComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarNodeComponent = /** @class */ (function () {
        function HierarchyBarNodeComponent(hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /**
             * Emit when the node is selected
             */
            this.selected = new i0.EventEmitter();
        }
        HierarchyBarNodeComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar-node',
                        template: "<div class=\"hierarchy-bar-node\"\n     [class.hierarchy-bar-node-readonly]=\"readonly\"\n     [class.hierarchy-bar-node-child-indicator]=\"node.children\">\n\n    <ng-container\n        *ngIf=\"mode === 'dropdown'; then dropdownMode; else standardClickMode\">\n    </ng-container>\n\n</div>\n\n<ng-template #standardClickMode>\n    <button type=\"button\"\n            uxFocusIndicator\n            class=\"hierarchy-bar-node-content\"\n            [disabled]=\"readonly\"\n            [attr.aria-label]=\"node.title\"\n            (click)=\"selected.emit(node)\">\n\n        <!-- Show a custom icon if specified -->\n        <div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.icon\" [ngTemplateOutletContext]=\"{ node: node, $implicit: node }\"></ng-container>\n        </div>\n\n        <!-- Show an icon if specified -->\n        <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon && !hierarchyBar.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n        <!-- Show the name of the current node -->\n        <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n    </button>\n\n    <!-- Show a dropdown arrow if there are children -->\n    <button type=\"button\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            *ngIf=\"node.children\"\n            #popover=\"ux-popover\"\n            aria-label=\"Show children\"\n            role=\"button\"\n            class=\"hierarchy-bar-node-arrow\"\n            [disabled]=\"readonly\"\n            [uxPopover]=\"popoverTemplate\"\n            [popoverContext]=\"{ node: node, popover: popover }\"\n            placement=\"bottom\"\n            popoverClass=\"hierarchy-bar-popover\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            tabindex=\"0\">\n        <ux-icon name=\"next\"\n                 class=\"hierarchy-bar-node-arrow-icon\">\n        </ux-icon>\n    </button>\n</ng-template>\n\n<ng-template #dropdownMode>\n    <button type=\"button\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            #popover=\"ux-popover\"\n            aria-label=\"Show children\"\n            class=\"hierarchy-bar-node-content\"\n            [disabled]=\"readonly\"\n            [uxPopover]=\"popoverTemplate\"\n            [popoverContext]=\"{ node: node, popover: popover }\"\n            placement=\"bottom\"\n            popoverClass=\"hierarchy-bar-popover\"\n            [showTriggers]=\"node.children ? hierarchyBar.popoverShowTriggers : []\"\n            [hideTriggers]=\"node.children ? hierarchyBar.popoverHideTriggers : []\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"node.title\">\n\n        <!-- Show a custom icon if specified -->\n        <div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.icon\" [ngTemplateOutletContext]=\"{ node: node, $implicit: node }\"></ng-container>\n        </div>\n\n        <!-- Show an icon if specified -->\n        <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon && !hierarchyBar.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n        <!-- Show the name of the current node -->\n        <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <div [class.readonly-arrow]=\"readonly\" class=\"hierarchy-bar-node-arrow-icon-dropdown\">\n            <ux-icon *ngIf=\"node.children\" name=\"next\"\n                     class=\"hierarchy-bar-node-arrow-icon\">\n            </ux-icon>\n        </div>\n\n    </button>\n\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarNodeComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarNodeComponent.propDecorators = {
            node: [{ type: i0.Input }],
            popoverTemplate: [{ type: i0.Input }],
            mode: [{ type: i0.Input }],
            readonly: [{ type: i0.Input }],
            selected: [{ type: i0.Output }]
        };
        return HierarchyBarNodeComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarPopoverItemComponent = /** @class */ (function () {
        function HierarchyBarPopoverItemComponent(focusOriginService, elementRef, renderer, hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /**
             * Emit when a click or enter key press occurs.
             * Note this is an `async` EventEmitter to ensure that
             * the event handlers in the `FocusIndicatorOrigin` set
             * the origin before we emit the select event, otherwise
             * the item may not get a focus ring when the keyboard is used.
             */
            this.selected = new i0.EventEmitter(true);
            this._focusOrigin = new FocusIndicatorOrigin(focusOriginService, elementRef, renderer);
        }
        /**
         * @return {?}
         */
        HierarchyBarPopoverItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusOrigin.destroy();
            };
        /**
         * @return {?}
         */
        HierarchyBarPopoverItemComponent.prototype.onSelect = /**
         * @return {?}
         */
            function () {
                this.selected.emit(this.node);
            };
        HierarchyBarPopoverItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar-popover-item',
                        template: "<!-- Show an icon if specified -->\n<img class=\"hierarchy-bar-node-icon\" *ngIf=\"!hierarchyBar.icon && node?.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n<!-- Show a custom icon if specified -->\n<div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n    <ng-container\n        [ngTemplateOutlet]=\"hierarchyBar.icon\"\n        [ngTemplateOutlet]=\"{ node: node, $implicit: node }\">\n    </ng-container>\n</div>\n\n<!-- Show the name of the current node -->\n<span class=\"hierarchy-bar-node-title\">{{ node?.title }}</span>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarPopoverItemComponent.ctorParameters = function () {
            return [
                { type: FocusIndicatorOriginService },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarPopoverItemComponent.propDecorators = {
            node: [{ type: i0.Input }],
            selected: [{ type: i0.Output }],
            onSelect: [{ type: i0.HostListener, args: ['click',] }, { type: i0.HostListener, args: ['keydown.enter',] }]
        };
        return HierarchyBarPopoverItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarPopoverComponent = /** @class */ (function () {
        function HierarchyBarPopoverComponent(hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /**
             * Define the nodes to display
             */
            this.nodes = [];
            /**
             * Defines if dropdown items should have separators between them to distinguish if nodes are siblings or ancestors
             */
            this.separator = false;
            /**
             * Emit a select event when an item ahs been clicked or enter key pressed
             */
            this.selected = new i0.EventEmitter();
        }
        HierarchyBarPopoverComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar-popover',
                        template: "<!-- Loading Indicator -->\n<ul class=\"hierarchy-bar-node-list\" *ngIf=\"loading\">\n\n    <li class=\"hierarchy-bar-loading-indicator\">\n        <ng-container [ngTemplateOutlet]=\"hierarchyBar.loadingIndicator || defaultLoadingIndicator\"></ng-container>\n    </li>\n</ul>\n\n<!-- List of children -->\n<div class=\"hierarchy-bar-node-list\"\n    [class.hierarchy-bar-node-list-separator]=\"separator\"\n    *ngIf=\"!loading\"\n    uxTabbableList\n    [returnFocus]=\"true\">\n\n    <ux-hierarchy-bar-popover-item *ngFor=\"let node of nodes; let first = first\"\n        uxFocusIndicator\n        [node]=\"node\"\n        [focusIf]=\"first\"\n        uxTabbableListItem\n        (selected)=\"selected.emit($event)\">\n    </ux-hierarchy-bar-popover-item>\n\n</div>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-loading-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-loading-title\">Loading...</span>\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarPopoverComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarPopoverComponent.propDecorators = {
            nodes: [{ type: i0.Input }],
            loading: [{ type: i0.Input }],
            separator: [{ type: i0.Input }],
            selected: [{ type: i0.Output }]
        };
        return HierarchyBarPopoverComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarStandardComponent = /** @class */ (function () {
        function HierarchyBarStandardComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            /**
             * Identify which nodes are overflowing
             */
            this.overflow$ = new rxjs.BehaviorSubject([]);
            /**
             * Determine if there is any overflow
             */
            this.isOverflowing$ = new rxjs.BehaviorSubject(false);
            /**
             * Unsubscribe from all subscriptions when component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
            // subscribe to changes in the selected node - update the UI after the render
            hierarchyBar.nodes$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return requestAnimationFrame(_this.scrollIntoView.bind(_this)); });
        }
        /**
         * @return {?}
         */
        HierarchyBarStandardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
        HierarchyBarStandardComponent.prototype.scrollIntoView = /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.nodelist) {
                    return;
                }
                // get the native element
                var nativeElement = this.nodelist.nativeElement;
                /** @type {?} */
                var isOverflowing = nativeElement.scrollWidth > nativeElement.offsetWidth;
                // emit whether we are overflowing or not
                this.isOverflowing$.next(isOverflowing);
                // if the hierarchy bar contents do not overflow then do nothing
                if (isOverflowing) {
                    // determine the amount of overflow
                    /** @type {?} */
                    var amount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                    // determine which nodes are not fully visible
                    this.overflow$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < amount_1; })
                        .map(function (_node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                    // move the scroll position to always show the last item
                    this.nodelist.nativeElement.scrollLeft = amount_1;
                }
            };
        HierarchyBarStandardComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-hierarchy-bar-standard',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"left-addons\"></ng-content>\n</div>\n\n<div #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"isOverflowing$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n         [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        <ng-container [ngTemplateOutlet]=\"hierarchyBar.overflowTemplate || defaultOverflowTemplate\"\n                      [ngTemplateOutletContext]=\"{ $implicit: overflow$ | async }\">\n        </ng-container>\n    </div>\n\n    <ux-hierarchy-bar-node\n        [mode]=\"mode\"\n        [readonly]=\"readonly\"\n        *ngFor=\"let node of hierarchyBar.nodes$ | async\"\n        [node]=\"node\"\n        [popoverTemplate]=\"content\"\n        (selected)=\"hierarchyBar.selectNode(node)\">\n    </ux-hierarchy-bar-node>\n\n    <!-- Allow content to be placed after the last node -->\n    <div class=\"hierarchy-bar-addons\">\n        <ng-content select=\"trailing-addons\"></ng-content>\n    </div>\n\n</div>\n\n<!-- Allow content to be placed on the right of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"right-addons\"></ng-content>\n</div>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [loading]=\"(hierarchyBar.getChildren(node) | async)?.loading\"\n        [nodes]=\"(hierarchyBar.getChildren(node) | async)?.children\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <div uxTabbableList [returnFocus]=\"true\">\n\n        <ux-hierarchy-bar-popover-item\n            *ngFor=\"let child of overflow$ | async; let first = first\"\n            uxFocusIndicator\n            [node]=\"child\"\n            [focusIf]=\"first\"\n            uxTabbableListItem\n            (selected)=\"hierarchyBar.selectNode(child); popover.hide()\">\n        </ux-hierarchy-bar-popover-item>\n    </div>\n</ng-template>\n\n<!-- Default Overflow Template -->\n<ng-template #defaultOverflowTemplate>\n    . . .\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarStandardComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarStandardComponent.propDecorators = {
            mode: [{ type: i0.Input }],
            readonly: [{ type: i0.Input }],
            nodelist: [{ type: i0.ViewChild, args: ['nodelist', { static: true },] }],
            nodes: [{ type: i0.ViewChildren, args: [HierarchyBarNodeComponent, { read: i0.ElementRef },] }]
        };
        return HierarchyBarStandardComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HierarchyBarModule = /** @class */ (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            FocusIfModule,
                            IconModule,
                            PopoverModule,
                            ResizeModule,
                        ],
                        exports: [
                            HierarchyBarComponent,
                            HierarchyBarStandardComponent,
                            HierarchyBarCollapsedComponent,
                            HierarchyBarNodeIconDirective
                        ],
                        declarations: [
                            HierarchyBarComponent,
                            HierarchyBarStandardComponent,
                            HierarchyBarCollapsedComponent,
                            HierarchyBarNodeComponent,
                            HierarchyBarPopoverComponent,
                            HierarchyBarPopoverItemComponent,
                            HierarchyBarNodeIconDirective
                        ],
                    },] }
        ];
        return HierarchyBarModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var SidePanelAnimationState = {
        Closed: 'closed',
        Open: 'open',
        OpenImmediate: 'openImmediate',
    };
    /** @type {?} */
    var sidePanelStateAnimation = animations.trigger('panelState', [
        animations.state(SidePanelAnimationState.Closed, animations.style({ visibility: 'hidden' })),
        animations.state(SidePanelAnimationState.Open + ", " + SidePanelAnimationState.OpenImmediate, animations.style({ visibility: 'visible', transform: 'none' })),
        animations.transition("void <=> " + SidePanelAnimationState.Open, animations.animate('0.2s cubic-bezier(0.49, 1, 0.38, 0.98)')),
        animations.transition("void <=> " + SidePanelAnimationState.OpenImmediate, animations.animate('0s'))
    ]);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SidePanelService = /** @class */ (function () {
        function SidePanelService() {
            /**
             * Emit the open state when it changes
             */
            this.open$ = new rxjs.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        SidePanelService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        SidePanelService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
            };
        SidePanelService.decorators = [
            { type: i0.Injectable }
        ];
        return SidePanelService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SidePanelComponent = /** @class */ (function () {
        function SidePanelComponent(service, _elementRef, _focusOrigin) {
            this.service = service;
            this._elementRef = _elementRef;
            this._focusOrigin = _focusOrigin;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.focusOnShow = false;
            this.openChange = new i0.EventEmitter();
            this.animationPanelState = SidePanelAnimationState.Closed;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this.service.open$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.service.open$.pipe(operators.skip(1), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy))
                    .subscribe(function (isOpen) { return _this.openChange.emit(isOpen); });
                this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isOpen) {
                    _this.animationPanelState = isOpen
                        ? _this.animate
                            ? SidePanelAnimationState.Open
                            : SidePanelAnimationState.OpenImmediate
                        : SidePanelAnimationState.Closed;
                });
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.openPanel = /**
         * @return {?}
         */
            function () {
                this.service.open();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.closePanel = /**
         * @return {?}
         */
            function () {
                this.service.close();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype._onDocumentEscape = /**
         * @return {?}
         */
            function () {
                if (this.open) {
                    this._focusOrigin.setOrigin('keyboard');
                    this.closePanel();
                }
            };
        /**
         * @param {?} target
         * @return {?}
         */
        SidePanelComponent.prototype._onDocumentClick = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (!this.open || !this.closeOnExternalClick) {
                    return;
                }
                if (!this._elementRef.nativeElement.contains(target) || (target && target.classList.contains('modal-backdrop'))) {
                    this.closePanel();
                }
            };
        SidePanelComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-side-panel',
                        exportAs: 'ux-side-panel',
                        template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [@panelState]=\"animationPanelState\"\n    [focusIf]=\"open && focusOnShow\"\n    [focusIfScroll]=\"false\"\n    [cdkTrapFocus]=\"open && modal\"\n    *ngIf=\"open\">\n    <ng-content></ng-content>\n</div>\n",
                        providers: [SidePanelService],
                        animations: [sidePanelStateAnimation],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            class: 'ux-side-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        SidePanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: i0.ElementRef },
                { type: FocusIndicatorOriginService }
            ];
        };
        SidePanelComponent.propDecorators = {
            open: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.open',] }],
            inline: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.inline',] }],
            attachTo: [{ type: i0.Input }],
            width: [{ type: i0.Input }],
            top: [{ type: i0.Input }],
            modal: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-modal',] }],
            animate: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.animate',] }],
            closeOnExternalClick: [{ type: i0.Input }],
            focusOnShow: [{ type: i0.Input }],
            openChange: [{ type: i0.Output }],
            componentWidth: [{ type: i0.HostBinding, args: ['style.width',] }],
            _onDocumentEscape: [{ type: i0.HostListener, args: ['document:keyup.escape',] }],
            _onDocumentClick: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return SidePanelComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ItemDisplayPanelContentDirective = /** @class */ (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxItemDisplayPanelContent]'
                    },] }
        ];
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = /** @class */ (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxItemDisplayPanelFooter]'
                    },] }
        ];
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = /** @class */ (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef, focusOrigin) {
            var _this = _super.call(this, service, elementRef, focusOrigin) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            /**
             * Defines the aria-label for the close button
             */
            _this.closeAriaLabel = 'Close';
            _this.shadow = false;
            _this.visibleChange = new i0.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: /**
             * @return {?}
             */ function () {
                return !this.closeOnExternalClick;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.open;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */ function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isVisible) { return _this.visibleChange.emit(isVisible); });
            };
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this.panel) {
                    this.panel.nativeElement.focus();
                }
            };
        ItemDisplayPanelComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-item-display-panel',
                        template: "<div class=\"ux-side-panel-host ux-item-display-panel\" #panel\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [@panelState]=\"animationPanelState\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\"\n    *ngIf=\"open\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n\n        <button *ngIf=\"closeVisible\"\n                uxFocusIndicator\n                [attr.aria-label]=\"closeAriaLabel\"\n                type=\"button\"\n                class=\"btn btn-lg btn-link btn-icon button-secondary\"\n                (click)=\"visible = false\">\n\n            <ux-icon name=\"close\"></ux-icon>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                        providers: [SidePanelService],
                        animations: [sidePanelStateAnimation],
                        host: {
                            'class': 'ux-side-panel ux-item-display-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        ItemDisplayPanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: i0.ElementRef },
                { type: FocusIndicatorOriginService }
            ];
        };
        ItemDisplayPanelComponent.propDecorators = {
            header: [{ type: i0.Input }],
            boxShadow: [{ type: i0.Input }],
            closeVisible: [{ type: i0.Input }],
            preventClose: [{ type: i0.Input }],
            closeAriaLabel: [{ type: i0.Input }],
            shadow: [{ type: i0.Input }],
            visibleChange: [{ type: i0.Output }],
            footer: [{ type: i0.ContentChild, args: [ItemDisplayPanelFooterDirective, { static: false },] }],
            panel: [{ type: i0.ViewChild, args: ['panel', { static: true },] }],
            visible: [{ type: i0.Input }]
        };
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = /** @class */ (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            FocusIfModule,
                            IconModule
                        ],
                        exports: DECLARATIONS$3,
                        declarations: DECLARATIONS$3
                    },] }
        ];
        return ItemDisplayPanelModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MarqueeWizardStepIconDirective = /** @class */ (function () {
        function MarqueeWizardStepIconDirective() {
        }
        MarqueeWizardStepIconDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMarqueeWizardStepIcon]',
                    },] }
        ];
        return MarqueeWizardStepIconDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var WizardStepComponent = /** @class */ (function () {
        function WizardStepComponent(_changeDetector) {
            this._changeDetector = _changeDetector;
            /**
             * Allows you to define whether or not a step is valid. The user will not be able to proceed to the next step if this property has a value of false.
             */
            this.valid = true;
            /**
             * Emits when visited changes.
             */
            this.visitedChange = new i0.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            /**
             * Defines whether or not this step has previously been visited.
             * A visited step can be clicked on and jumped to at any time.
             * By default, steps will become 'visited' when the user navigates to a step for the first time.
             */
            get: /**
             * Defines whether or not this step has previously been visited.
             * A visited step can be clicked on and jumped to at any time.
             * By default, steps will become 'visited' when the user navigates to a step for the first time.
             * @return {?}
             */ function () {
                return this._visited;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
                // mark for change detection
                this._changeDetector.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'tabpanel',
                            '[attr.aria-labelledby]': 'id + "-label"'
                        }
                    }] }
        ];
        /** @nocollapse */
        WizardStepComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        WizardStepComponent.propDecorators = {
            header: [{ type: i0.Input }],
            disableNextWhenInvalid: [{ type: i0.Input }],
            valid: [{ type: i0.Input }],
            visitedChange: [{ type: i0.Input }],
            visited: [{ type: i0.Input }],
            active: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }],
            id: [{ type: i0.HostBinding, args: ['id',] }]
        };
        return WizardStepComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$6 = 0;
    var WizardComponent = /** @class */ (function () {
        function WizardComponent() {
            /**
             * Defines whether or not the wizard should be displayed in a `horizontal` or `vertical` layout.
             */
            this.orientation = 'horizontal';
            /**
             * Defines the text displayed in the 'Next' button.
             */
            this.nextText = 'Next';
            /**
             * Defines the text displayed in the 'Previous' button.
             */
            this.previousText = 'Previous';
            /**
             * Defines the text displayed in the 'Cancel' button.
             */
            this.cancelText = 'Cancel';
            /**
             * Defines the text displayed in the 'Finish' button.
             */
            this.finishText = 'Finish';
            /**
             * Defines the text displayed in the tooltip when the 'Next' button is hovered.
             */
            this.nextTooltip = 'Go to the next step';
            /**
             * Defines the text displayed in the tooltip when the 'Previous' button is hovered.
             */
            this.previousTooltip = 'Go to the previous step';
            /**
             * Defines the text displayed in the tooltip when the 'Cancel' button is hovered.
             */
            this.cancelTooltip = 'Cancel the wizard';
            /**
             * Defines the text displayed in the tooltip when the 'Finish' button is hovered.
             */
            this.finishTooltip = 'Finish the wizard';
            /**
             * Defines the text for the aria label on the 'Next' button.
             */
            this.nextAriaLabel = 'Go to the next step';
            /**
             * Defines the text for the aria label on the 'Previous' button.
             */
            this.previousAriaLabel = 'Go to the previous step';
            /**
             * Defines the text for the aria label on the 'Cancel' button.
             */
            this.cancelAriaLabel = 'Cancel the wizard';
            /**
             * Defines the text for the aria label on the 'Finish' button.
             */
            this.finishAriaLabel = 'Finish the wizard';
            /**
             * If set to `true` the 'Next' button will appear disabled and will not respond to clicks.
             */
            this.nextDisabled = false;
            /**
             * If set to `true` the 'Previous' button will appear disabled and will not respond to clicks.
             */
            this.previousDisabled = false;
            /**
             * If set to `true` the 'Cancel' button will appear disabled and will not respond to clicks.
             */
            this.cancelDisabled = false;
            /**
             * If set to `true` the 'Finish' button will appear disabled and will not respond to clicks.
             */
            this.finishDisabled = false;
            /**
             * If set to `false` the 'Next' button will be hidden.
             */
            this.nextVisible = true;
            /**
             * If set to `false` the 'Previous' button will be hidden.
             */
            this.previousVisible = true;
            /**
             * If set to `false` the 'Cancel' button will be hidden.
             */
            this.cancelVisible = true;
            /**
             * If set to false the 'Finish' button will be hidden.
             */
            this.finishVisible = true;
            /**
             * If set to `true` the 'Cancel' button will be visible even on the last step. By default it will be hidden on the final step.
             */
            this.cancelAlwaysVisible = false;
            /**
             * If set to `true` the 'Finish' button will be visible on all steps of the wizard. By default this button will only be visible on the final step of the wizard.
             */
            this.finishAlwaysVisible = false;
            /**
             * If set to `true` the 'Next' or 'Finish' button will become disabled when the current step is invalid.
             */
            this.disableNextWhenInvalid = false;
            /**
             * Emits when the wizard has moved to the next step. It will receive the current step index as a parameter.
             */
            this.onNext = new i0.EventEmitter();
            /**
             * Emits when the wizard has moved to the previous step. It will receive the current step index as a parameter.
             */
            this.onPrevious = new i0.EventEmitter();
            /**
             * Emits when the 'Cancel' button has been pressed.
             */
            this.onCancel = new i0.EventEmitter();
            /**
             * Emits when the 'Finish' button is clicked, but before the finish event fires. This fires regardless of the validity of the final step.
             */
            this.onFinishing = new i0.EventEmitter();
            /**
             * Emits when the 'Finish' button has been pressed and the final step is valid.
             */
            this.onFinish = new i0.EventEmitter();
            /**
             * Emits before the current step changes. The event contains the current step index in the `from` property, and the requested step index in the `to` property.
             */
            this.stepChanging = new i0.EventEmitter();
            /**
             * Emits when the current step has changed.
             */
            this.stepChange = new i0.EventEmitter();
            /**
             * Emits when the user tries to continue but the current step is invalid.
             */
            this.stepError = new i0.EventEmitter();
            this.steps = new i0.QueryList();
            this.id = "ux-wizard-" + uniqueId$6++;
            this.invalidIndicator = false;
            this._step = 0;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            /**
             * The current active step. When the step changes an event will be emitted containing the index of the newly active step.
             * If this is not specifed the wizard will start on the first step.
             */
            get: /**
             * The current active step. When the step changes an event will be emitted containing the index of the newly active step.
             * If this is not specifed the wizard will start on the first step.
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // initially set the correct visibility of the steps
                setTimeout(this.update.bind(this));
                // initially set the ids for each step
                this.setWizardStepIds();
                // if the steps change then update the ids
                this.steps.changes.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.setWizardStepIds();
                    _this.update();
                });
            };
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set ids for each of the wizard steps */
        /**
         * Set ids for each of the wizard steps
         * @return {?}
         */
        WizardComponent.prototype.setWizardStepIds = /**
         * Set ids for each of the wizard steps
         * @return {?}
         */
            function () {
                var _this = this;
                this.steps.forEach(function (step, idx) { return step.id = _this.id + "-step-" + idx; });
            };
        /**
         * Navigate to the next step
         */
        /**
         * Navigate to the next step
         * @return {?}
         */
        WizardComponent.prototype.next = /**
         * Navigate to the next step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                // check if current step is invalid
                if (!this.getCurrentStep().valid) {
                    this.invalidIndicator = true;
                    this.stepError.next(this.step);
                    return;
                }
                // check if we are currently on the last step
                if ((this.step + 1) < this.steps.length) {
                    this.step++;
                    // emit the current step
                    this.onNext.next(this.step);
                }
            };
        /**
         * Whether the Next or Finish button should be disabled.
         */
        /**
         * Whether the Next or Finish button should be disabled.
         * @return {?}
         */
        WizardComponent.prototype.isNextDisabled = /**
         * Whether the Next or Finish button should be disabled.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var step = this.getCurrentStep();
                // Use the `disableNextWhenInvalid` setting to determine whether to disable the Next/Finish button
                // based on validation.
                // If not defined on the WizardStepComponent, use the value from WizardComponent.
                return (step.disableNextWhenInvalid === undefined ? this.disableNextWhenInvalid : step.disableNextWhenInvalid) && !step.valid;
            };
        /**
         * Navigate to the previous step
         */
        /**
         * Navigate to the previous step
         * @return {?}
         */
        WizardComponent.prototype.previous = /**
         * Navigate to the previous step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
                // check if we are currently on the last step
                if (this.step > 0) {
                    this.step--;
                    // emit the current step
                    this.onPrevious.next(this.step);
                }
            };
        /**
         * Perform actions when the finish button is clicked
         */
        /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
        WizardComponent.prototype.finish = /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
            function () {
                var _this = this;
                // fires when the finish button is clicked always
                this.onFinishing.next();
                /**
                 * This is required because we need to ensure change detection has run
                 * to determine whether or not we have the latest value for the 'valid' input
                 * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                 * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                 */
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        // only fires when the finish button is clicked and the step is valid
                        if (_this.getCurrentStep().valid) {
                            _this.onFinish.next();
                        }
                        else {
                            _this.stepError.next(_this.step);
                        }
                        resolve();
                    });
                });
            };
        /**
         * Perform actions when the cancel button is clicked
         */
        /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
        WizardComponent.prototype.cancel = /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
            function () {
                this.onCancel.next();
            };
        /**
         * Update the active state of each step
         */
        /**
         * Update the active state of each step
         * @return {?}
         */
        WizardComponent.prototype.update = /**
         * Update the active state of each step
         * @return {?}
         */
            function () {
                var _this = this;
                // update which steps should be active
                this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
            };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
        WizardComponent.prototype.gotoStep = /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
            function (step) {
                if (step.visited) {
                    /** @type {?} */
                    var stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                    this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                    this.step = stepIndex;
                }
            };
        /**
         * Determine if the current step is the last step
         */
        /**
         * Determine if the current step is the last step
         * @return {?}
         */
        WizardComponent.prototype.isLastStep = /**
         * Determine if the current step is the last step
         * @return {?}
         */
            function () {
                return this.step === (this.steps.length - 1);
            };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
        WizardComponent.prototype.reset = /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
            function () {
                // mark all steps as not visited
                this.steps.forEach(function (step) { return step.visited = false; });
                // go to the first step
                this.step = 0;
            };
        /**
         * Get the step at the current index
         */
        /**
         * Get the step at the current index
         * @return {?}
         */
        WizardComponent.prototype.getCurrentStep = /**
         * Get the step at the current index
         * @return {?}
         */
            function () {
                return this.getStepAtIndex(this.step);
            };
        /**
         * Return a step at a specific index
         */
        /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
        WizardComponent.prototype.getStepAtIndex = /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.steps.toArray()[index];
            };
        WizardComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-wizard',
                        template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\"\n        uxTabbableList\n        [direction]=\"orientation\"\n        role=\"tablist\"\n        [attr.aria-orientation]=\"orientation\">\n\n        <div *ngFor=\"let stp of steps; let index = index\"\n            role=\"tab\"\n            class=\"wizard-step\"\n            [class.active]=\"stp.active\"\n            [class.visited]=\"stp.visited\"\n            [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\"\n            [attr.aria-posinset]=\"index + 1\"\n            [attr.aria-setsize]=\"steps.length\"\n            [attr.aria-selected]=\"stp.active\"\n            [attr.aria-controls]=\"stp.id\"\n            [id]=\"stp.id + '-label'\"\n            uxFocusIndicator\n            uxTabbableListItem\n            [programmaticFocusIndicator]=\"true\"\n            [disabled]=\"index !== 0 && !stp.visited\"\n            (click)=\"gotoStep(stp)\"\n            (keydown.enter)=\"gotoStep(stp)\">\n            <span class=\"wizard-step-text\">{{ stp.header }}</span>\n            <ux-icon *ngIf=\"stp.visited && !stp.active\" class=\"wizard-step-icon\" name=\"checkmark\"></ux-icon>\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n\n    <ng-container *ngIf=\"footerTemplate\"\n                  [ngTemplateOutlet]=\"footerTemplate\"\n                  [ngTemplateOutletContext]=\"{ step: step }\">\n    </ng-container>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-secondary\"\n            *ngIf=\"previousVisible\"\n            [uxTooltip]=\"previousTooltip\"\n            [disabled]=\"previousDisabled || step === 0\"\n            [attr.aria-label]=\"previousAriaLabel\"\n            (click)=\"previous(); tip.hide()\">\n        {{ previousText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-primary\"\n            *ngIf=\"nextVisible && !isLastStep()\"\n            [uxTooltip]=\"nextTooltip\"\n            [disabled]=\"nextDisabled || isNextDisabled()\"\n            [attr.aria-label]=\"nextAriaLabel\"\n            (click)=\"next(); tip.hide()\">\n        {{ nextText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-primary\"\n            *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n            [uxTooltip]=\"finishTooltip\"\n            [disabled]=\"finishDisabled || isNextDisabled()\"\n            [attr.aria-label]=\"finishAriaLabel\"\n            (click)=\"finish(); tip.hide()\">\n        {{ finishText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-secondary\"\n            *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n            [uxTooltip]=\"cancelTooltip\"\n            [disabled]=\"cancelDisabled\"\n            [attr.aria-label]=\"cancelAriaLabel\"\n            (click)=\"cancel(); tip.hide()\">\n        {{ cancelText }}\n    </button>\n\n</div>\n",
                        host: {
                            '[class]': 'orientation'
                        }
                    }] }
        ];
        WizardComponent.propDecorators = {
            orientation: [{ type: i0.Input }],
            nextText: [{ type: i0.Input }],
            previousText: [{ type: i0.Input }],
            cancelText: [{ type: i0.Input }],
            finishText: [{ type: i0.Input }],
            nextTooltip: [{ type: i0.Input }],
            previousTooltip: [{ type: i0.Input }],
            cancelTooltip: [{ type: i0.Input }],
            finishTooltip: [{ type: i0.Input }],
            nextAriaLabel: [{ type: i0.Input }],
            previousAriaLabel: [{ type: i0.Input }],
            cancelAriaLabel: [{ type: i0.Input }],
            finishAriaLabel: [{ type: i0.Input }],
            nextDisabled: [{ type: i0.Input }],
            previousDisabled: [{ type: i0.Input }],
            cancelDisabled: [{ type: i0.Input }],
            finishDisabled: [{ type: i0.Input }],
            nextVisible: [{ type: i0.Input }],
            previousVisible: [{ type: i0.Input }],
            cancelVisible: [{ type: i0.Input }],
            finishVisible: [{ type: i0.Input }],
            cancelAlwaysVisible: [{ type: i0.Input }],
            finishAlwaysVisible: [{ type: i0.Input }],
            disableNextWhenInvalid: [{ type: i0.Input }],
            onNext: [{ type: i0.Output }],
            onPrevious: [{ type: i0.Output }],
            onCancel: [{ type: i0.Output }],
            onFinishing: [{ type: i0.Output }],
            onFinish: [{ type: i0.Output }],
            stepChanging: [{ type: i0.Output }],
            stepChange: [{ type: i0.Output }],
            stepError: [{ type: i0.Output }],
            steps: [{ type: i0.ContentChildren, args: [WizardStepComponent,] }],
            footerTemplate: [{ type: i0.ContentChild, args: ['footerTemplate', { static: false },] }],
            step: [{ type: i0.Input }]
        };
        return WizardComponent;
    }());
    var StepChangingEvent = /** @class */ (function () {
        function StepChangingEvent(from, to) {
            this.from = from;
            this.to = to;
        }
        return StepChangingEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = /** @class */ (function () {
        function WizardModule() {
        }
        WizardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule,
                            TooltipModule,
                        ],
                        exports: DECLARATIONS$4,
                        declarations: DECLARATIONS$4
                    },] }
        ];
        return WizardModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = /** @class */ (function () {
        function MarqueeWizardService() {
            this.valid$ = new rxjs.Subject();
        }
        MarqueeWizardService.decorators = [
            { type: i0.Injectable }
        ];
        return MarqueeWizardService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MarqueeWizardStepComponent = /** @class */ (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(changeDetector, _marqueeWizardService) {
            var _this = _super.call(this, changeDetector) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            /**
             * Determine the completed state of this step
             */
            _this.completed = false;
            /**
             * Emit when the completed step changes
             */
            _this.completedChange = new i0.EventEmitter();
            /**
             * Store the validity of the current step
             */
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
        MarqueeWizardStepComponent.prototype.setCompleted = /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
            function (completed) {
                this.completed = completed;
                this.completedChange.emit(completed);
            };
        MarqueeWizardStepComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-marquee-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardStepComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: MarqueeWizardService }
            ];
        };
        MarqueeWizardStepComponent.propDecorators = {
            completed: [{ type: i0.Input }],
            completedChange: [{ type: i0.Output }],
            _iconTemplate: [{ type: i0.ContentChild, args: [MarqueeWizardStepIconDirective, { read: i0.TemplateRef, static: false },] }]
        };
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MarqueeWizardComponent = /** @class */ (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService, _resizeService, _elementRef) {
            var _this = _super.call(this) || this;
            _this._resizeService = _resizeService;
            _this._elementRef = _elementRef;
            /**
             * Initial set to default width to match 240px on left but can be changed with a perecentage value
             */
            _this.sidePanelWidth = 25;
            /**
             * Width of the splitter - default is 10
             */
            _this.gutterSize = 10;
            /**
             * If set to true the resizable splitter will be enabled and set to the default width *
             */
            _this.resizable = false;
            /**
             * Emit the current width of the splitter
             */
            _this.sidePanelWidthChange = new i0.EventEmitter();
            /**
             * Access each step content component
             */
            _this.steps = new i0.QueryList();
            /**
             * If the wizard is in a modal it may initially have a size of 0 until the modal displays
             * in which case if we are using the splitter it will not render correctly. We use this
             * variable to only initialise the splitter when the content has a width.
             */
            _this._isInitialised = false;
            /**
             * Unsubscribe from all subscriptions when component is destroyed
             */
            _this._onDestroyed = new rxjs.Subject();
            // watch for changes to the size
            _resizeService.addResizeListener(_elementRef.nativeElement)
                .pipe(operators.takeUntil(_this._onDestroyed))
                .subscribe(_this.onResize.bind(_this));
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; }))
                .subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: /**
             * @return {?}
             */ function () {
                return this.description && this.description instanceof i0.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MarqueeWizardComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                this._onDestroyed.next();
                this._onDestroyed.complete();
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
            };
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
        MarqueeWizardComponent.prototype.next = /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
            function () {
                // get the current step
                /** @type {?} */
                var step = ( /** @type {?} */(this.getCurrentStep()));
                if (step.valid) {
                    _super.prototype.next.call(this);
                    // mark this step as completed
                    step.setCompleted(true);
                }
                else {
                    this.stepError.next(this.step);
                }
            };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
        MarqueeWizardComponent.prototype.finish = /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
            function () {
                var _this = this;
                // get the current step
                /** @type {?} */
                var step = ( /** @type {?} */(this.getCurrentStep()));
                // call the original finish function
                return _super.prototype.finish.call(this).then(function () {
                    // if the step is valid indicate that it is now complete
                    if (step.valid) {
                        step.setCompleted(true);
                    }
                    else {
                        _this.stepError.next(_this.step);
                    }
                });
            };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
        MarqueeWizardComponent.prototype.validChange = /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
            function (state) {
                /** @type {?} */
                var steps = this.steps.toArray();
                /** @type {?} */
                var current = steps.findIndex(function (step) { return step === state.step; });
                /** @type {?} */
                var affected = steps.slice(current);
                affected.forEach(function (step) {
                    // the step should no longer be completed
                    step.completed = false;
                    // if the step is not the current step then also mark it as unvisited
                    if (step !== state.step) {
                        step.visited = false;
                    }
                });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MarqueeWizardComponent.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.width !== 0 && event.height !== 0) {
                    this._isInitialised = true;
                }
            };
        /** Whenever the drag event ends, update the internal value and emit the new size */
        /**
         * Whenever the drag event ends, update the internal value and emit the new size
         * @param {?} __0
         * @return {?}
         */
        MarqueeWizardComponent.prototype.onDragEnd = /**
         * Whenever the drag event ends, update the internal value and emit the new size
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var sizes = _a.sizes;
                // we need to only get the size of the first panel which will be the side panel
                this.sidePanelWidth = sizes[0];
                this.sidePanelWidthChange.emit(this.sidePanelWidth);
            };
        MarqueeWizardComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-marquee-wizard',
                        template: "<ng-container *ngIf=\"resizable && _isInitialised\">\n    <as-split direction=\"horizontal\"\n           [gutterSize]=\"gutterSize\"\n           (dragEnd)=\"onDragEnd($event)\">\n        <as-split-area [size]=\"sidePanelWidth\">\n            <ng-container [ngTemplateOutlet]=\"sidePanel\"></ng-container>\n        </as-split-area>\n        <as-split-area [size]=\"100 - sidePanelWidth\">\n            <ng-container [ngTemplateOutlet]=\"mainContentPanel\"></ng-container>\n        </as-split-area>\n    </as-split>\n</ng-container>\n\n<ng-container *ngIf=\"!resizable\">\n    <ng-container [ngTemplateOutlet]=\"sidePanel\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"mainContentPanel\"></ng-container>\n</ng-container>\n\n<ng-template #sidePanel>\n    <div class=\"marquee-wizard-side-panel\" [class.marquee-wizard-side-panel-resize]=\"resizable\">\n\n        <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n            <!-- If a template was provided display it -->\n            <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n            <!-- Otherwise wimply display the string -->\n            <ng-container *ngIf=\"!isTemplate\">\n                <p>{{ description }}</p>\n            </ng-container>\n        </div>\n\n        <ul class=\"marquee-wizard-steps\"\n            uxTabbableList\n            direction=\"vertical\"\n            role=\"tablist\"\n            aria-orientation=\"vertical\">\n\n            <li *ngFor=\"let step of steps; let index = index\"\n                role=\"tab\"\n                uxTabbableListItem\n                [disabled]=\"!step.visited\"\n                class=\"marquee-wizard-step\"\n                [class.active]=\"step.active\"\n                [class.visited]=\"step.visited\"\n                [class.invalid]=\"!step.valid\"\n                [attr.aria-posinset]=\"index + 1\"\n                [attr.aria-setsize]=\"steps.length\"\n                [attr.aria-selected]=\"step.active\"\n                [attr.aria-controls]=\"step.id\"\n                [id]=\"step.id + '-label'\"\n                (click)=\"gotoStep(step)\"\n                (keydown.enter)=\"gotoStep(step)\">\n\n                <ng-container [ngTemplateOutlet]=\"stepTemplate || defaultStepTemplate\" [ngTemplateOutletContext]=\"{ $implicit: step }\"></ng-container>\n            </li>\n\n        </ul>\n    </div>\n</ng-template>\n\n\n<ng-template #mainContentPanel>\n    <div class=\"marquee-wizard-content-panel\" [class.marquee-wizard-content-panel-resize]=\"resizable\">\n        <div class=\"marquee-wizard-content\">\n            <ng-content></ng-content>\n        </div>\n\n        <div class=\"modal-footer\">\n\n            <ng-container *ngIf=\"footerTemplate\"\n                          [ngTemplateOutlet]=\"footerTemplate\"\n                          [ngTemplateOutletContext]=\"{ step: step }\">\n            </ng-container>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-secondary\"\n                    *ngIf=\"previousVisible\"\n                    [uxTooltip]=\"previousTooltip\"\n                    [attr.aria-label]=\"previousAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"previousDisabled || step === 0\"\n                    (click)=\"previous(); tip.hide()\">\n                {{ previousText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-primary\"\n                    *ngIf=\"nextVisible && !isLastStep()\"\n                    [uxTooltip]=\"nextTooltip\"\n                    [attr.aria-label]=\"nextAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"nextDisabled || isNextDisabled()\"\n                    (click)=\"next(); tip.hide()\">\n                {{ nextText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-primary\"\n                    *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n                    [uxTooltip]=\"finishTooltip\"\n                    [attr.aria-label]=\"finishAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"finishDisabled || isNextDisabled()\"\n                    (click)=\"finish(); tip.hide()\">\n                {{ finishText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-secondary\"\n                    *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n                    [uxTooltip]=\"cancelTooltip\"\n                    [attr.aria-label]=\"cancelAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"cancelDisabled\"\n                    (click)=\"cancel(); tip.hide()\">\n                {{ cancelText }}\n            </button>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #defaultStepTemplate let-step>\n\n    <!-- Insert the icon -->\n    <div *ngIf=\"step._iconTemplate\" class=\"marquee-wizard-step-icon\">\n        <ng-container [ngTemplateOutlet]=\"step._iconTemplate\"></ng-container>\n    </div>\n\n    <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n    <ux-icon *ngIf=\"step.completed\" class=\"marquee-wizard-step-status\" name=\"checkmark\"></ux-icon>\n</ng-template>",
                        providers: [MarqueeWizardService]
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService },
                { type: ResizeService },
                { type: i0.ElementRef }
            ];
        };
        MarqueeWizardComponent.propDecorators = {
            description: [{ type: i0.Input }],
            stepTemplate: [{ type: i0.Input }],
            sidePanelWidth: [{ type: i0.Input }],
            gutterSize: [{ type: i0.Input }],
            resizable: [{ type: i0.Input }],
            sidePanelWidthChange: [{ type: i0.Output }],
            steps: [{ type: i0.ContentChildren, args: [MarqueeWizardStepComponent,] }]
        };
        return MarqueeWizardComponent;
    }(WizardComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MarqueeWizardModule = /** @class */ (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule,
                            TooltipModule,
                            WizardModule,
                            angularSplit.AngularSplitModule,
                            ResizeModule
                        ],
                        exports: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent,
                            MarqueeWizardStepIconDirective
                        ],
                        declarations: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent,
                            MarqueeWizardStepIconDirective
                        ]
                    },] }
        ];
        return MarqueeWizardModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FrameExtractionService = /** @class */ (function () {
        function FrameExtractionService() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        FrameExtractionService.prototype.createVideoPlayer = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                /** @type {?} */
                var videoPlayer = document.createElement('video');
                videoPlayer.preload = 'auto';
                videoPlayer.src = source;
                return videoPlayer;
            };
        /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        FrameExtractionService.prototype.createCanvas = /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (width, height) {
                /** @type {?} */
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            };
        /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.goToFrame = /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
            function (videoPlayer, time) {
                videoPlayer.currentTime = time;
                return rxjs.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
            };
        /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
        FrameExtractionService.prototype.getThumbnail = /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
            function (videoPlayer, canvas, time, width, height) {
                var _this = this;
                if (width === void 0) {
                    width = 160;
                }
                if (height === void 0) {
                    height = 90;
                }
                return rxjs.Observable.create(function (observer) {
                    // go to specified frame
                    /** @type {?} */
                    var subscription = _this.goToFrame(videoPlayer, time).subscribe(function () {
                        // create image from current frame
                        canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                        observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                        observer.complete();
                        subscription.unsubscribe();
                    });
                });
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnail = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
            function (source, width, height, time) {
                // create required elements
                /** @type {?} */
                var videoPlayer = this.createVideoPlayer(source);
                /** @type {?} */
                var canvas = this.createCanvas(width, height);
                /** @type {?} */
                var frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
                // ensure we release memory after we are finished
                frameSubscription.subscribe(null, null, function () {
                    videoPlayer = null;
                    canvas = null;
                });
                return frameSubscription;
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnails = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
            function (source, width, height, start, end, skip) {
                var _this = this;
                if (skip === void 0) {
                    skip = 5;
                }
                // create required elements
                /** @type {?} */
                var videoPlayer = this.createVideoPlayer(source);
                /** @type {?} */
                var canvas = this.createCanvas(width, height);
                return rxjs.Observable.create(function (observer) {
                    rxjs.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                        // calculate the frames required
                        /** @type {?} */
                        var frames = [];
                        for (var idx = start; idx < end; idx += skip) {
                            frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                        }
                        rxjs.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                            videoPlayer = null;
                            canvas = null;
                            observer.complete();
                        });
                    });
                });
            };
        FrameExtractionService.decorators = [
            { type: i0.Injectable }
        ];
        return FrameExtractionService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FrameExtractionModule = /** @class */ (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule.decorators = [
            { type: i0.NgModule, args: [{
                        providers: [FrameExtractionService],
                    },] }
        ];
        return FrameExtractionModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MediaPlayerService = /** @class */ (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /**
             * Aria Labels
             */
            this.muteAriaLabel = this.getMuteAriaLabel;
            this.playAriaLabel = this.getPlayAriaLabel;
            this.fullscreenAriaLabel = this.getFullscreenAriaLabel;
            this.selectSubtitlesAriaLabel = this.getSubtitlesAriaLabel;
            this.goToStartAriaLabel = 'Go to start';
            this.goToEndAriaLabel = 'Go to end';
            this.subtitlesTitleAriaLabel = 'Subtitles';
            this.subtitlesOffAriaLabel = 'Subtitles Off';
            this.noSubtitlesAriaLabel = 'No subtitles';
            this.mediaPlayerAriaLabel = 'Media Player';
            this.seekAriaLabel = 'Seek Slider';
            /*
                    Create observables for media player events
                */
            this.playing = new rxjs.BehaviorSubject(false);
            this.initEvent = new rxjs.ReplaySubject();
            this.abortEvent = new rxjs.Subject();
            this.canPlayEvent = new rxjs.BehaviorSubject(false);
            this.canPlayThroughEvent = new rxjs.BehaviorSubject(false);
            this.durationChangeEvent = new rxjs.Subject();
            this.endedEvent = new rxjs.Subject();
            this.errorEvent = new rxjs.Subject();
            this.loadedDataEvent = new rxjs.Subject();
            this.loadedMetadataEvent = new rxjs.Subject();
            this.loadStartEvent = new rxjs.Subject();
            this.pauseEvent = new rxjs.Subject();
            this.playEvent = new rxjs.Subject();
            this.playingEvent = new rxjs.Subject();
            this.rateChangeEvent = new rxjs.Subject();
            this.seekedEvent = new rxjs.Subject();
            this.seekingEvent = new rxjs.Subject();
            this.stalledEvent = new rxjs.Subject();
            this.suspendEvent = new rxjs.Subject();
            this.timeUpdateEvent = new rxjs.Subject();
            this.volumeChangeEvent = new rxjs.Subject();
            this.waitingEvent = new rxjs.Subject();
            this.mediaClickEvent = new rxjs.Subject();
            this.fullscreenEvent = new rxjs.BehaviorSubject(false);
            this.quietModeEvent = new rxjs.BehaviorSubject(false);
            this.progressEvent = rxjs.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                /** @type {?} */
                var interval = setInterval(function () {
                    /** @type {?} */
                    var buffered = ( /** @type {?} */(_this._mediaPlayer.buffered));
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: /*
                    Create all the getters and setters the can be used by media player extensions
                */ 
            /**
             * @return {?}
             */
            function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this._quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer && !isNaN(this.mediaPlayer.duration) ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.textTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.videoTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._mediaPlayer) {
                    this._mediaPlayer.volume = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
        MediaPlayerService.prototype.setMediaPlayer = /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
            function (hostElement, mediaPlayer) {
                this._hostElement = hostElement;
                this._mediaPlayer = mediaPlayer;
                this.initEvent.next(true);
            };
        /**
         * Toggle playing state
         */
        /**
         * Toggle playing state
         * @return {?}
         */
        MediaPlayerService.prototype.togglePlay = /**
         * Toggle playing state
         * @return {?}
         */
            function () {
                // prevent any action is not loaded
                if (this.loaded === false) {
                    return;
                }
                if (this.paused) {
                    this.play();
                }
                else {
                    this.pause();
                }
            };
        /**
         * Starts playing the audio/video
         */
        /**
         * Starts playing the audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.play = /**
         * Starts playing the audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.play();
            };
        /**
         * Pauses the currently playing audio/video
         */
        /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.pause = /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.pause();
            };
        /**
         * Re-loads the audio/video element
         */
        /**
         * Re-loads the audio/video element
         * @return {?}
         */
        MediaPlayerService.prototype.load = /**
         * Re-loads the audio/video element
         * @return {?}
         */
            function () {
                this._mediaPlayer.load();
            };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
        MediaPlayerService.prototype.canPlayType = /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
            function (type) {
                return this._mediaPlayer.canPlayType(type);
            };
        /**
         * Adds a new text track to the audio/video
         */
        /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
        MediaPlayerService.prototype.addTextTrack = /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
            function (kind, label, language) {
                return this._mediaPlayer.addTextTrack(kind, label, language);
            };
        /**
         * Attempt to display media in fullscreen mode
         */
        /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
        MediaPlayerService.prototype.requestFullscreen = /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
            function () {
                // get the host element (we need to do some browser specific checks and typescript complains)
                /** @type {?} */
                var host = ( /** @type {?} */(this._hostElement));
                /** @type {?} */
                var requestFullscreen = host.requestFullscreen || host.webkitRequestFullscreen || host.msRequestFullscreen || host.mozRequestFullScreen;
                // if we can perform the action then perform it and update the state
                if (requestFullscreen) {
                    requestFullscreen.call(host);
                    // update the internal state
                    this.fullscreen = true;
                }
            };
        /**
         * Exit full screen mode
         */
        /**
         * Exit full screen mode
         * @return {?}
         */
        MediaPlayerService.prototype.exitFullscreen = /**
         * Exit full screen mode
         * @return {?}
         */
            function () {
                // get the document element (we need to do some browser specific checks and typescript complains)
                /** @type {?} */
                var host = ( /** @type {?} */(document));
                /** @type {?} */
                var exitFullscreen = host.exitFullscreen || host.webkitExitFullscreen || host.msExitFullscreen || host.mozCancelFullScreen;
                // if we can perform the action then perform it and update the state
                if (exitFullscreen) {
                    exitFullscreen.call(host);
                    // update the internal state
                    this.fullscreen = false;
                }
            };
        /**
         * Toggle Fullscreen State
         */
        /**
         * Toggle Fullscreen State
         * @return {?}
         */
        MediaPlayerService.prototype.toggleFullscreen = /**
         * Toggle Fullscreen State
         * @return {?}
         */
            function () {
                if (this.fullscreen) {
                    this.exitFullscreen();
                }
                else {
                    this.requestFullscreen();
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.fullscreenChange = /**
         * @return {?}
         */
            function () {
                // get the document element (we need to do some browser specific checks and typescript complains)
                /** @type {?} */
                var host = ( /** @type {?} */(document));
                // set the fullscreen state (this also emits the event)
                this.fullscreen = host.fullscreen || host.webkitIsFullScreen || host.mozFullScreen || host.msFullscreenElement !== null && host.msFullscreenElement !== undefined;
            };
        /**
         * Extract the frames from the video
         */
        /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
        MediaPlayerService.prototype.getFrames = /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
            function (width, height, skip) {
                if (this.type === 'video') {
                    return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
                }
                return rxjs.from([]);
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.hideSubtitleTracks = /**
         * @return {?}
         */
            function () {
                for (var index = 0; index < this.textTracks.length; index++) {
                    this.textTracks[index].mode = 'hidden';
                }
            };
        /**
         * @param {?} volume
         * @return {?}
         */
        MediaPlayerService.prototype.getMuteAriaLabel = /**
         * @param {?} volume
         * @return {?}
         */
            function (volume) {
                return volume === 0 ? 'Unmute' : 'Mute';
            };
        /**
         * @param {?} isPlaying
         * @return {?}
         */
        MediaPlayerService.prototype.getPlayAriaLabel = /**
         * @param {?} isPlaying
         * @return {?}
         */
            function (isPlaying) {
                return isPlaying ? 'Pause' : 'Play';
            };
        /**
         * @param {?} isFullscreen
         * @return {?}
         */
        MediaPlayerService.prototype.getFullscreenAriaLabel = /**
         * @param {?} isFullscreen
         * @return {?}
         */
            function (isFullscreen) {
                return isFullscreen ? 'Exit full screen' : 'Full screen';
            };
        /**
         * @param {?} track
         * @return {?}
         */
        MediaPlayerService.prototype.getSubtitlesAriaLabel = /**
         * @param {?} track
         * @return {?}
         */
            function (track) {
                return "Select subtitles, " + track + " currently selected.";
            };
        MediaPlayerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        MediaPlayerService.ctorParameters = function () {
            return [
                { type: FrameExtractionService }
            ];
        };
        return MediaPlayerService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MediaPlayerBaseExtensionDirective = /** @class */ (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[mediaPlayerBaseExtension]'
                    },] }
        ];
        /** @nocollapse */
        MediaPlayerBaseExtensionDirective.ctorParameters = function () {
            return [
                { type: MediaPlayerService }
            ];
        };
        return MediaPlayerBaseExtensionDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SliderComponent = /** @class */ (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * This should reference either a single number or a SliderValue object, depending on the slider type specified.
             */
            this.value = 0;
            /**
             * Emits when the `value` changes.
             */
            this.valueChange = new i0.EventEmitter();
            // expose enums to Angular view
            this.sliderType = SliderType;
            this.sliderStyle = SliderStyle;
            this.sliderSize = SliderSize;
            this.sliderSnap = SliderSnap;
            this.sliderThumb = SliderThumb;
            this.sliderTickType = SliderTickType;
            this.sliderThumbEvent = SliderThumbEvent;
            this.sliderCalloutTrigger = SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: ( /** @type {?} */(null))
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: ( /** @type {?} */(null))
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: SliderType.Value,
                handles: {
                    style: SliderStyle.Button,
                    callout: {
                        trigger: SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {}
                }
            };
        }
        Object.defineProperty(SliderComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this._options;
            },
            /** A wide range of options can used to customize the appearance and behavior of the component. */
            set: /**
             * A wide range of options can used to customize the appearance and behavior of the component.
             * @param {?} options
             * @return {?}
             */ function (options) {
                this._options = options;
                this.updateOptions();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.updateValues();
                this.setThumbState(SliderThumb.Lower, false, false);
                this.setThumbState(SliderThumb.Upper, false, false);
                // emit the initial value
                this.valueChange.next(this.clone(this.value));
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this.detectValueChange(this.value, this._value)) {
                    this.updateValues();
                    this._value = this.clone(this.value);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // persistent tooltips will need positioned correctly at this stage
                setTimeout(function () {
                    _this.updateTooltipPosition(SliderThumb.Lower);
                    _this.updateTooltipPosition(SliderThumb.Upper);
                    // mark as dirty
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToNearestTick = /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, snapTarget, forwards) {
                // get the value for the thumb
                var value = this.getThumbState(thumb).value;
                // get the closest ticks - remove any tick if we are currently on it
                /** @type {?} */
                var closest = this.getTickDistances(value, thumb, snapTarget)
                    .filter(function (tick) { return tick.value !== value; })
                    .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
                // If we have no ticks then move by a predefined amount
                if (closest) {
                    return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
                }
                /** @type {?} */
                var step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
                this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
            };
        /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToEnd = /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, forwards) {
                this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.getThumbState(thumb).value;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getFormattedValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbState = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
            };
        /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
        SliderComponent.prototype.setThumbState = /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
            function (thumb, hover, drag) {
                if (thumb === SliderThumb.Lower) {
                    this.thumbs.lower.hover = hover;
                    this.thumbs.lower.drag = drag;
                }
                else {
                    this.thumbs.upper.hover = hover;
                    this.thumbs.upper.drag = drag;
                }
                // update the visibility of the tooltips
                this.updateTooltips(thumb);
            };
        /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.thumbEvent = /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
            function (thumb, event) {
                // get the current thumb state
                /** @type {?} */
                var state = this.getThumbState(thumb);
                // update based upon event
                switch (event) {
                    case SliderThumbEvent.DragStart:
                        state.drag = true;
                        break;
                    case SliderThumbEvent.DragEnd:
                        state.drag = false;
                        break;
                    case SliderThumbEvent.MouseOver:
                        state.hover = true;
                        break;
                    case SliderThumbEvent.MouseLeave:
                        state.hover = false;
                        break;
                    case SliderThumbEvent.None:
                        state.drag = false;
                        state.hover = false;
                        break;
                }
                // update the thumb state
                this.setThumbState(thumb, state.hover, state.drag);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getAriaValueText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the current thumb value
                /** @type {?} */
                var value = this.getThumbValue(thumb);
                // get all the ticks
                /** @type {?} */
                var tick = this.ticks.find(function (_tick) { return _tick.value === value; });
                if (tick && tick.label) {
                    return tick.label;
                }
                // otherwise simply display the formatted value
                return this.getFormattedValue(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltips = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                /** @type {?} */
                var visible = false;
                /** @type {?} */
                var state = this.getThumbState(thumb);
                switch (this.options.handles.callout.trigger) {
                    case SliderCalloutTrigger.Persistent:
                        visible = true;
                        break;
                    case SliderCalloutTrigger.Drag:
                        visible = state.drag;
                        break;
                    case SliderCalloutTrigger.Hover:
                        visible = state.hover || state.drag;
                        break;
                    case SliderCalloutTrigger.Dynamic:
                        visible = true;
                        break;
                }
                // update the state for the corresponding thumb
                this.getTooltip(thumb).visible = visible;
                // update the tooltip text
                this.updateTooltipText(thumb);
                // update the tooltip positions
                this.updateTooltipPosition(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the thumb value
                /** @type {?} */
                var state = this.getThumbState(thumb);
                /** @type {?} */
                var tooltip = this.getTooltip(thumb);
                // store the formatted label
                tooltip.label = this.getFormattedValue(thumb).toString();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltipElement = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltip = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipPosition = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                /** @type {?} */
                var tooltip = this.getTooltip(thumb);
                // if tooltip is not visible then stop here
                if (tooltip.visible === false) {
                    return;
                }
                /** @type {?} */
                var tooltipElement = this.getTooltipElement(thumb);
                // get the element widths
                /** @type {?} */
                var thumbWidth;
                if (this._options.handles.style === SliderStyle.Button) {
                    thumbWidth = this._options.track.height === SliderSize.Narrow ? 16 : 24;
                }
                else {
                    thumbWidth = 2;
                }
                /** @type {?} */
                var tooltipWidth = tooltipElement.nativeElement.offsetWidth;
                // calculate the tooltips new position
                /** @type {?} */
                var tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
                // update tooltip position
                tooltip.position = -tooltipPosition;
                if (this._options.type === SliderType.Range && this._options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
                    this.preventTooltipOverlap(tooltip);
                }
            };
        /**
         * @param {?} tooltip
         * @return {?}
         */
        SliderComponent.prototype.preventTooltipOverlap = /**
         * @param {?} tooltip
         * @return {?}
         */
            function (tooltip) {
                /** @type {?} */
                var trackWidth = this.track.nativeElement.offsetWidth;
                /** @type {?} */
                var lower = (trackWidth / 100) * this.thumbs.lower.position;
                /** @type {?} */
                var upper = (trackWidth / 100) * this.thumbs.upper.position;
                /** @type {?} */
                var lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
                /** @type {?} */
                var upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
                /** @type {?} */
                var diff = (lower + lowerWidth) - (upper - upperWidth);
                // if the tooltips are closer than 16px then adjust so the dont move any close
                if (diff > 0) {
                    if (tooltip === this.tooltips.lower && this.thumbs.lower.drag === false) {
                        tooltip.position -= (diff / 2);
                    }
                    else if (tooltip === this.tooltips.upper && this.thumbs.upper.drag === false) {
                        tooltip.position += (diff / 2);
                    }
                }
            };
        /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
        SliderComponent.prototype.clamp = /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
            function (value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateThumbPosition = /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
            function (event, thumb) {
                // get event position - either mouse or touch
                /** @type {?} */
                var eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
                // if event position is null do nothing
                if (eventPosition === null) {
                    return;
                }
                // get mouse position
                /** @type {?} */
                var mouseX = window.pageXOffset + eventPosition;
                // get track size and position
                /** @type {?} */
                var trackBounds = this.track.nativeElement.getBoundingClientRect();
                // restrict the value within the range size
                /** @type {?} */
                var position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
                // get fraction representation of location within the track
                /** @type {?} */
                var fraction = (position / trackBounds.width);
                // convert to value within the range
                /** @type {?} */
                var value = ((this._options.track.max - this._options.track.min) * fraction) + this._options.track.min;
                // ensure value is valid
                value = this.validateValue(thumb, value);
                // snap to a tick if required
                value = this.snapToTick(value, thumb);
                // update the value accordingly
                this.setThumbValue(thumb, value);
                this.updateOrder(thumb);
                this.updateValues();
                // update tooltip text & position
                this.updateTooltipText(thumb);
                // update the position of all visible tooltips
                this.updateTooltipPosition(SliderThumb.Lower);
                this.updateTooltipPosition(SliderThumb.Upper);
                // mark as dirty for change detection
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateOrder = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                /** @type {?} */
                var lower = thumb === SliderThumb.Lower ? 101 : 100;
                /** @type {?} */
                var upper = thumb === SliderThumb.Lower ? 100 : 101;
                // The most recently used thumb should be above
                this.thumbs.lower.order = lower;
                this.thumbs.upper.order = upper;
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
        SliderComponent.prototype.getTickDistances = /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
            function (value, thumb, snapTarget) {
                // if snap target is none then return original value
                if (snapTarget === SliderSnap.None) {
                    return [];
                }
                // get filtered ticks
                /** @type {?} */
                var ticks;
                switch (snapTarget) {
                    case SliderSnap.Minor:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                        break;
                    case SliderSnap.Major:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                        break;
                    default:
                        ticks = this.ticks.slice(0);
                }
                // get the track limit
                /** @type {?} */
                var lowerLimit = this._options.track.min;
                /** @type {?} */
                var upperLimit = this._options.track.max;
                if (this._options.type === SliderType.Range && thumb === SliderThumb.Lower) {
                    upperLimit = this.thumbs.upper.value;
                }
                if (this._options.type === SliderType.Range && thumb === SliderThumb.Upper) {
                    lowerLimit = this.thumbs.lower.value;
                }
                // Find the closest tick to the current position
                /** @type {?} */
                var range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
                // If there are no close ticks in the valid range then dont snap
                if (range.length === 0) {
                    return [];
                }
                return range.sort(function (tickOne, tickTwo) {
                    /** @type {?} */
                    var tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                    /** @type {?} */
                    var tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                    return tickOneDelta - tickTwoDelta;
                });
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.snapToTick = /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
            function (value, thumb) {
                /** @type {?} */
                var tickDistances = this.getTickDistances(value, thumb, this._options.track.ticks.snap);
                // if there are no ticks return the current value
                if (tickDistances.length === 0) {
                    return value;
                }
                // get the closest tick
                return tickDistances[0].value;
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.validateValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // if slider is not a range value is always valid providing it is within the chart min and max values
                if (this._options.type === SliderType.Value) {
                    return Math.max(Math.min(value, this._options.track.max), this._options.track.min);
                }
                // check if value is with chart ranges
                if (value > this._options.track.max) {
                    return thumb === SliderThumb.Lower ? Math.min(this._options.track.max, this.thumbs.upper.value) : this._options.track.max;
                }
                if (value < this._options.track.min) {
                    return thumb === SliderThumb.Upper ? Math.max(this._options.track.min, this.thumbs.lower.value) : this._options.track.min;
                }
                // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                if (thumb === SliderThumb.Lower) {
                    if (this.thumbs.upper.value === null) {
                        return value;
                    }
                    return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
                }
                if (thumb === SliderThumb.Upper) {
                    if (this.thumbs.lower.value === null) {
                        return value;
                    }
                    return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateOptions = /**
         * @return {?}
         */
            function () {
                // add in the default options that user hasn't specified
                this._options = this.deepMerge(this._options || {}, this.defaultOptions);
                this.updateTrackColors();
                this.updateTicks();
                this.updateValues();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateValues = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined || this.value === null) {
                    this.value = 0;
                }
                /** @type {?} */
                var lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
                /** @type {?} */
                var upperValue = typeof this.value === 'number' ? this.value : this.value.high;
                // validate values
                lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
                upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
                // calculate the positions as percentages
                /** @type {?} */
                var lowerPosition = (((lowerValue - this._options.track.min) / (this._options.track.max - this._options.track.min)) * 100);
                /** @type {?} */
                var upperPosition = (((upperValue - this._options.track.min) / (this._options.track.max - this._options.track.min)) * 100);
                // update thumb positions
                this.thumbs.lower.position = lowerPosition;
                this.thumbs.upper.position = upperPosition;
                // calculate the track sizes
                this.tracks.lower.size = lowerPosition;
                this.tracks.middle.size = upperPosition - lowerPosition;
                this.tracks.upper.size = this._options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
                // update the value input
                this.setValue(lowerValue, upperValue);
            };
        /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
        SliderComponent.prototype.setValue = /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
            function (low, high) {
                this.thumbs.lower.value = low;
                this.thumbs.upper.value = high;
                /** @type {?} */
                var previousValue = this.clone(this._value);
                this.value = this._options.type === SliderType.Value ? low : { low: low, high: high };
                // call the event emitter if changes occured
                if (this.detectValueChange(this.value, previousValue)) {
                    this.valueChange.emit(this.clone(this.value));
                    this.updateTooltipText(SliderThumb.Lower);
                    this.updateTooltipText(SliderThumb.Upper);
                }
                else {
                    this.valueChange.emit(this.clone(this.value));
                }
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.setThumbValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // update the thumb value
                this.getThumbState(thumb).value = value;
                // forward these changes to the value
                this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicks = /**
         * @return {?}
         */
            function () {
                // get tick options
                /** @type {?} */
                var majorOptions = this._options.track.ticks.major;
                /** @type {?} */
                var minorOptions = this._options.track.ticks.minor;
                // check if we should show ticks
                if (majorOptions.show === false && minorOptions.show === false) {
                    this.ticks = [];
                }
                // create ticks for both major and minor - only get the ones to be shown
                /** @type {?} */
                var majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
                /** @type {?} */
                var minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
                // remove any minor ticks that are on a major interval
                this.ticks = this.unionTicks(majorTicks, minorTicks);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTrackColors = /**
         * @return {?}
         */
            function () {
                // get colors for each part of the track
                var _a = this._options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
                // update the controller value
                this.tracks.lower.color = this.getTrackColorStyle(lower);
                this.tracks.middle.color = this.getTrackColorStyle(range);
                this.tracks.upper.color = this.getTrackColorStyle(higher);
            };
        /** Map the color value to the correct CSS color value */
        /**
         * Map the color value to the correct CSS color value
         * @param {?} color
         * @return {?}
         */
        SliderComponent.prototype.getTrackColorStyle = /**
         * Map the color value to the correct CSS color value
         * @param {?} color
         * @return {?}
         */
            function (color) {
                return Array.isArray(color) ? "linear-gradient(to right, " + color.join(', ') + ")" : color;
            };
        /**
         * @param {?} steps
         * @return {?}
         */
        SliderComponent.prototype.getSteps = /**
         * @param {?} steps
         * @return {?}
         */
            function (steps) {
                // if they are already an array just return it
                if (steps instanceof Array) {
                    return steps;
                }
                /** @type {?} */
                var output = [];
                // otherwise calculate the steps
                for (var idx = this._options.track.min; idx <= this._options.track.max; idx += steps) {
                    output.push(idx);
                }
                return output;
            };
        /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
        SliderComponent.prototype.getTicks = /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
            function (options, type) {
                // create an array to store the ticks and step points
                /** @type {?} */
                var steps = this.getSteps(options.steps);
                // get some chart options
                /** @type {?} */
                var min = this._options.track.min;
                /** @type {?} */
                var max = this._options.track.max;
                // convert each step to a slider tick and remove invalid ticks
                return steps.map(function (step) {
                    return {
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: ((step - min) / (max - min)) * 100,
                        value: step,
                        label: options.formatter(step)
                    };
                }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
            };
        /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
        SliderComponent.prototype.unionTicks = /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
            function (majorTicks, minorTicks) {
                // get all ticks combined removing any minor ticks with the same value as major ticks
                return majorTicks.concat(minorTicks)
                    .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
                    .sort(function (t1, t2) { return t1.value - t2.value; });
            };
        /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
        SliderComponent.prototype.deepMerge = /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
            function (destination, source) {
                // loop though all of the properties in the source object
                for (var prop in source) {
                    // check if the destination object has the property
                    if (!destination.hasOwnProperty(prop)) {
                        // copy the property across
                        destination[prop] = source[prop];
                        continue;
                    }
                    // if the property exists and is not an object then skip
                    if (typeof destination[prop] !== 'object') {
                        continue;
                    }
                    // check if property is an array
                    if (destination[prop] instanceof Array) {
                        continue;
                    }
                    // if it is an object then perform a recursive check
                    destination[prop] = this.deepMerge(destination[prop], source[prop]);
                }
                return destination;
            };
        /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        SliderComponent.prototype.detectValueChange = /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
            function (value1, value2) {
                // compare two slider values
                if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                    // references to the objects in the correct types
                    /** @type {?} */
                    var obj1 = ( /** @type {?} */(value1));
                    /** @type {?} */
                    var obj2 = ( /** @type {?} */(value2));
                    return obj1.low !== obj2.low || obj1.high !== obj2.high;
                }
                // if not a slider value - should be number of nullable type - compare normally
                return value1 !== value2;
            };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param value - The object to check - this must be type any
         */
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
        SliderComponent.prototype.isSliderValue = /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
            function (value) {
                // check if is an object
                if (typeof value !== 'object') {
                    return false;
                }
                // next check if it contains the necessary properties
                return 'low' in value && 'high' in value;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.clone = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // if it is not an object simply return the value
                if (typeof value !== 'object') {
                    return value;
                }
                // create a new object from the existing one
                /** @type {?} */
                var instance = __assign({}, value);
                // delete remove the value from the old object
                value = undefined;
                // return the new instance of the object
                return instance;
            };
        SliderComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-slider',
                        template: "<div class=\"track\"\n     #track\n     [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n     [class.wide]=\"_options.track.height === sliderSize.Wide\"\n     [class.range]=\"_options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        uxFocusIndicator\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"_options.type === sliderType.Range ? _options.handles.aria.lowerThumb :\n        _options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"_options?.track?.min\"\n        [attr.aria-valuemax]=\"_options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) :\n        _options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"_options.handles.style === sliderStyle.Button\"\n        [class.line]=\"_options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"_options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"_options.handles.callout.trigger === sliderCalloutTrigger.Dynamic &&\n             thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"_options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"_options.handles.callout.background\"\n                [style.color]=\"_options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"_options.type === sliderType.Range\"\n         [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        uxFocusIndicator\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"_options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || _options?.track?.min\"\n        [attr.aria-valuemax]=\"_options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"_options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"_options.handles.style === sliderStyle.Button\"\n        [class.line]=\"_options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"_options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"_options.handles.callout.trigger === sliderCalloutTrigger.Dynamic &&\n             thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"_options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"_options.type === sliderType.Range\"\n                [style.background-color]=\"_options.handles.callout.background\"\n                [style.color]=\"_options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(_options.track.ticks.major.show || _options.track.ticks.minor.show) &&\n    _options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"_options.track.ticks.major.labels || _options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        SliderComponent.propDecorators = {
            value: [{ type: i0.Input }],
            options: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            lowerTooltip: [{ type: i0.ViewChild, args: ['lowerTooltip', { static: true },] }],
            upperTooltip: [{ type: i0.ViewChild, args: ['upperTooltip', { static: true },] }],
            track: [{ type: i0.ViewChild, args: ['track', { static: true },] }]
        };
        return SliderComponent;
    }());
    /** @enum {number} */
    var SliderType = {
        Value: 0,
        Range: 1,
    };
    SliderType[SliderType.Value] = 'Value';
    SliderType[SliderType.Range] = 'Range';
    /** @enum {number} */
    var SliderStyle = {
        Button: 0,
        Line: 1,
    };
    SliderStyle[SliderStyle.Button] = 'Button';
    SliderStyle[SliderStyle.Line] = 'Line';
    /** @enum {number} */
    var SliderSize = {
        Narrow: 0,
        Wide: 1,
    };
    SliderSize[SliderSize.Narrow] = 'Narrow';
    SliderSize[SliderSize.Wide] = 'Wide';
    /** @enum {number} */
    var SliderCalloutTrigger = {
        None: 0,
        Hover: 1,
        Drag: 2,
        Persistent: 3,
        Dynamic: 4,
    };
    SliderCalloutTrigger[SliderCalloutTrigger.None] = 'None';
    SliderCalloutTrigger[SliderCalloutTrigger.Hover] = 'Hover';
    SliderCalloutTrigger[SliderCalloutTrigger.Drag] = 'Drag';
    SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = 'Persistent';
    SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = 'Dynamic';
    /** @enum {number} */
    var SliderSnap = {
        None: 0,
        Minor: 1,
        Major: 2,
        All: 3,
    };
    SliderSnap[SliderSnap.None] = 'None';
    SliderSnap[SliderSnap.Minor] = 'Minor';
    SliderSnap[SliderSnap.Major] = 'Major';
    SliderSnap[SliderSnap.All] = 'All';
    /** @enum {number} */
    var SliderTickType = {
        Minor: 0,
        Major: 1,
    };
    SliderTickType[SliderTickType.Minor] = 'Minor';
    SliderTickType[SliderTickType.Major] = 'Major';
    /** @enum {number} */
    var SliderThumbEvent = {
        None: 0,
        MouseOver: 1,
        MouseLeave: 2,
        DragStart: 3,
        DragEnd: 4,
    };
    SliderThumbEvent[SliderThumbEvent.None] = 'None';
    SliderThumbEvent[SliderThumbEvent.MouseOver] = 'MouseOver';
    SliderThumbEvent[SliderThumbEvent.MouseLeave] = 'MouseLeave';
    SliderThumbEvent[SliderThumbEvent.DragStart] = 'DragStart';
    SliderThumbEvent[SliderThumbEvent.DragEnd] = 'DragEnd';
    /** @enum {number} */
    var SliderThumb = {
        Lower: 0,
        Upper: 1,
    };
    SliderThumb[SliderThumb.Lower] = 'Lower';
    SliderThumb[SliderThumb.Upper] = 'Upper';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SliderModule = /** @class */ (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            ColorServiceModule,
                            DragModule
                        ],
                        exports: [
                            SliderComponent
                        ],
                        declarations: [
                            SliderComponent
                        ]
                    },] }
        ];
        return SliderModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$7 = 1;
    var MediaPlayerControlsExtensionComponent = /** @class */ (function () {
        function MediaPlayerControlsExtensionComponent(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
            this.volumeActive = false;
            this.volumeFocus = false;
            this.returnFocus = true;
            this.subtitlesId = "ux-media-player-subtitle-popover-" + uniqueId$7++;
            this.subtitlesOpen = false;
            this.mouseEnterVolume = new rxjs.Subject();
            this.mouseLeaveVolume = new rxjs.Subject();
            this.options = {
                handles: {
                    aria: {
                        thumb: 'Volume'
                    }
                },
                track: {
                    colors: {
                        lower: '#666'
                    },
                    height: SliderSize.Narrow,
                    ticks: {
                        major: {
                            show: false
                        },
                        minor: {
                            show: false
                        }
                    }
                }
            };
            this._volume = 100;
            this._previousVolume = 100;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._volume;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
                this.mediaPlayerService.initEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
                this.mouseEnterVolume.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
                this.mouseLeaveVolume.pipe(operators.switchMap(function () { return rxjs.timer(1500).pipe(operators.takeUntil(_this.mouseEnterVolume)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.toggleMute = /**
         * @return {?}
         */
            function () {
                this.volume = this.volume === 0 ? this._previousVolume : 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToStart = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToEnd = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.isSubtitleActive = /**
         * @return {?}
         */
            function () {
                for (var idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return true;
                    }
                }
                return false;
            };
        /**
         * @param {?} track
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.setSubtitleTrack = /**
         * @param {?} track
         * @return {?}
         */
            function (track) {
                // hide all tracks
                this.mediaPlayerService.hideSubtitleTracks();
                // set the position of the subtitle track
                for (var idx = 0; idx < track.cues.length; idx++) {
                    /** @type {?} */
                    var cue = track.cues[idx];
                    cue.line = -3;
                }
                // activate the selected one
                track.mode = 'showing';
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.getSubtitleTrack = /**
         * @return {?}
         */
            function () {
                for (var idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return this.mediaPlayerService.textTracks[idx].label;
                    }
                }
                return this.mediaPlayerService.noSubtitlesAriaLabel;
            };
        MediaPlayerControlsExtensionComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-media-player-controls',
                        template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\"\n        #volumeContainer\n        [class.active]=\"volumeActive || volumeFocus\"\n        (mouseenter)=\"mouseEnterVolume.next()\"\n        (mouseleave)=\"mouseLeaveVolume.next()\"\n        (uxFocusWithin)=\"volumeFocus = true\"\n        (uxBlurWithin)=\"volumeFocus = false\">\n\n        <button #volumeIcon\n                uxFocusIndicator\n                type=\"button\"\n                class=\"volume-slider-icon\"\n                [attr.aria-label]=\"mediaPlayerService.muteAriaLabel(volume)\"\n                [uxTooltip]=\"muteTooltip\"\n                [showTriggers]=\"['mouseenter']\"\n                [hideTriggers]=\"['mouseleave']\"\n                (click)=\"toggleMute()\"\n                (mouseup)=\"volumeIcon.blur()\">\n\n            <ux-icon *ngIf=\"volume === 0\" name=\"volume-mute\"></ux-icon>\n            <ux-icon *ngIf=\"volume > 0 && volume <= 70\" name=\"volume-low\"></ux-icon>\n            <ux-icon *ngIf=\"volume > 70\" name=\"volume\"></ux-icon>\n        </button>\n\n        <div class=\"volume-slider-node\">\n            <ux-slider [(value)]=\"volume\" [options]=\"options\"></ux-slider>\n        </div>\n    </div>\n</div>\n\n<button #startButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    (click)=\"goToStart()\"\n    (mouseup)=\"startButton.blur()\"\n    [attr.aria-label]=\"mediaPlayerService.goToStartAriaLabel\">\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n    </svg>\n</button>\n\n<button #playButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    [attr.aria-label]=\"mediaPlayerService.playAriaLabel(mediaPlayerService.playing | async)\"\n    (click)=\"mediaPlayerService.togglePlay()\"\n    (mouseup)=\"playButton.blur()\">\n\n    <svg *ngIf=\"!(mediaPlayerService.playing | async)\" viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" focusable=\"false\">\n        <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n    </svg>\n    <svg *ngIf=\"mediaPlayerService.playing | async\" viewBox=\"0 0 43 56.9\" width=\"20\" height=\"29\" focusable=\"false\">\n        <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n        <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    </svg>\n</button>\n\n<button #endButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    (click)=\"goToEnd()\"\n    (mouseup)=\"endButton.blur()\"\n    [attr.aria-label]=\"mediaPlayerService.goToEndAriaLabel\">\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"0,64 0,0 44.1,32\" />\n    </svg>\n</button>\n\n<div class=\"actions-list\">\n\n    <ng-content></ng-content>\n\n    <div class=\"action-button-container\" *ngIf=\"mediaPlayerService.textTracks.length > 0 && mediaPlayerService.type === 'video'\">\n        <button #subtitlesButton\n            uxFocusIndicator\n            type=\"button\"\n            class=\"action-button\"\n            (keydown)=\"returnFocus = true\"\n            (click)=\"subtitlesOpen = !subtitlesOpen\"\n            (mouseup)=\"subtitlesButton.blur(); returnFocus = false\"\n            [attr.aria-label]=\"mediaPlayerService.selectSubtitlesAriaLabel(getSubtitleTrack())\"\n            [attr.aria-expanded]=\"subtitlesOpen\"\n            [attr.aria-describedby]=\"subtitlesId\"\n            aria-haspopup=\"true\">\n\n            <ux-icon name=\"subtitles\"></ux-icon>\n        </button>\n\n        <div #subtitles\n            [style.top.px]=\"-subtitles.offsetHeight\"\n            class=\"popover top media-player-subtitles-popover show\"\n            [id]=\"subtitlesId\"\n            (keydown.escape)=\"subtitlesOpen = false\"\n            (uxClickOutside)=\"subtitlesOpen = false\"\n            *ngIf=\"subtitlesOpen\">\n            <div class=\"arrow\"></div>\n            <h3 class=\"popover-title\">{{ mediaPlayerService.subtitlesTitleAriaLabel }}</h3>\n            <div class=\"popover-content\">\n                <ul class=\"subtitles-list\" uxTabbableList [focusOnShow]=\"returnFocus\" [returnFocus]=\"returnFocus\">\n                    <li uxTabbableListItem\n                        tabindex=\"0\"\n                        class=\"subtitles-list-item\"\n                        [class.active]=\"!isSubtitleActive()\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false\"\n                        (keydown.enter)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false; returnFocus = true\">\n\n                        <ux-icon name=\"checkmark\" class=\"subtitles-list-item-checkmark\"></ux-icon>\n                        <span>{{ mediaPlayerService.subtitlesOffAriaLabel }}</span>\n                    </li>\n                    <li uxTabbableListItem\n                        class=\"subtitles-list-item\"\n                        *ngFor=\"let track of mediaPlayerService.textTracks\"\n                        [class.active]=\"track.mode === 'showing'\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"setSubtitleTrack(track); subtitlesOpen = false\"\n                        (keydown.enter)=\"setSubtitleTrack(track); subtitlesOpen = false; returnFocus = true\">\n\n                        <ux-icon name=\"checkmark\" class=\"subtitles-list-item-checkmark\"></ux-icon>\n                        <span>{{ track.label }}</span>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"action-button-container\">\n        <button #fullscreenButton\n            uxFocusIndicator\n            *ngIf=\"mediaPlayerService.type !== 'audio'\"\n            type=\"button\"\n            class=\"action-button\"\n            [attr.aria-label]=\"mediaPlayerService.fullscreenAriaLabel(mediaPlayerService.fullscreen)\"\n            (click)=\"mediaPlayerService.toggleFullscreen()\"\n            (mouseup)=\"fullscreenButton.blur()\">\n\n            <ux-icon [name]=\"mediaPlayerService.fullscreen ? 'contract' : 'expand'\"></ux-icon>\n        </button>\n    </div>\n</div>\n\n\n\n<ng-template #muteTooltip>\n    <span aria-hidden=\"true\">{{ volume === 0 ? 'Unmute' : 'Mute' }}</span>\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        /** @nocollapse */
        MediaPlayerControlsExtensionComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService }
            ];
        };
        return MediaPlayerControlsExtensionComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MediaPlayerCustomControlDirective = /** @class */ (function () {
        function MediaPlayerCustomControlDirective() {
        }
        MediaPlayerCustomControlDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMediaPlayerCustomControl]',
                    },] }
        ];
        return MediaPlayerCustomControlDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MediaPlayerTimelineExtensionComponent = /** @class */ (function () {
        function MediaPlayerTimelineExtensionComponent(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
            this.current = 0;
            this.position = 0;
            this.buffered = [];
            this.mouseDown = false;
            this.scrub = { visible: false, position: 0, time: 0 };
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // watch for changes to the current time
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                    _this.scrub.position = 0;
                });
                this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                    _this.current = current;
                    _this.position = (_this.current / _this.mediaPlayerService.duration) * 100;
                });
                this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                    _this.buffered = [];
                    for (var idx = 0; idx < buffered.length; idx++) {
                        _this.buffered.push({
                            start: (buffered.start(idx) / _this.mediaPlayerService.duration) * 100,
                            end: (buffered.end(idx) / _this.mediaPlayerService.duration) * 100
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var mousedown$ = rxjs.fromEvent(this.thumb.nativeElement, 'mousedown');
                /** @type {?} */
                var mousemove$ = rxjs.fromEvent(document, 'mousemove');
                /** @type {?} */
                var mouseup$ = rxjs.fromEvent(document, 'mouseup');
                mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var target = ( /** @type {?} */(event.target));
                if (target.classList.contains('media-progress-bar-thumb')) {
                    return;
                }
                /** @type {?} */
                var timeline = ( /** @type {?} */(this.timelineRef.nativeElement));
                /** @type {?} */
                var bounds = timeline.getBoundingClientRect();
                this.scrub.position = event.offsetX;
                this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
                if (this.mouseDown) {
                    this.mediaPlayerService.pause();
                    this.mediaPlayerService.currentTime = this.scrub.time;
                }
            };
        /** Skip a number of seconds in any direction */
        /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.skip = /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                /** @type {?} */
                var target = this.current + seconds;
                // ensure that the target position is within the bounds of the clip
                if (target < 0) {
                    target = 0;
                }
                if (target > this.mediaPlayerService.duration) {
                    target = this.mediaPlayerService.duration;
                }
                this.mediaPlayerService.currentTime = target;
            };
        MediaPlayerTimelineExtensionComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-media-player-timeline',
                        template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline\n     class=\"timeline-bar\"\n     tabindex=\"0\"\n     role=\"slider\"\n     [attr.aria-label]=\"mediaPlayerService.seekAriaLabel\"\n     aria-valuemin=\"0\"\n     [attr.aria-valuemax]=\"mediaPlayerService.duration | number: '0.0-0'\"\n     [attr.aria-valuenow]=\"mediaPlayerService.currentTime | number: '0.0-0'\"\n     attr.aria-valuetext=\"{{ mediaPlayerService.currentTime | duration }} of {{ mediaPlayerService.duration | duration }}\"\n     (keydown.ArrowLeft)=\"skip(-5)\"\n     (keydown.ArrowRight)=\"skip(5)\"\n     (mouseenter)=\"scrub.visible = true; tooltip.show()\"\n     (mouseleave)=\"scrub.visible = false; tooltip.hide()\"\n     (mousemove)=\"updateScrub($event); tooltip.reposition()\"\n     (mouseup)=\"updateScrub($event)\"\n     (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\"\n         *ngFor=\"let buffer of buffered\"\n         [style.left.%]=\"buffer.start\"\n         [style.width.%]=\"buffer.end - buffer.start\">\n    </div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb\n             class=\"media-progress-bar-thumb\"\n             (mouseenter)=\"scrub.visible = false; tooltip.hide(); $event.stopPropagation()\"\n             (mouseleave)=\"scrub.visible = true; tooltip.show(); $event.stopPropagation()\">\n        </div>\n    </div>\n\n    <div #tooltip=\"ux-tooltip\"\n         class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         tooltipClass=\"ux-media-player-timeline-tooltip\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"mediaPlayerService.duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ mediaPlayerService.duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                        host: {
                            '(document:mouseup)': 'mouseDown = false',
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        /** @nocollapse */
        MediaPlayerTimelineExtensionComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService }
            ];
        };
        MediaPlayerTimelineExtensionComponent.propDecorators = {
            thumb: [{ type: i0.ViewChild, args: ['progressThumb', { static: true },] }],
            timelineRef: [{ type: i0.ViewChild, args: ['timeline', { static: true },] }]
        };
        return MediaPlayerTimelineExtensionComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AudioService = /** @class */ (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        /**
         * @param {?} mediaElement
         * @return {?}
         */
        AudioService.prototype.getAudioFileMetadata = /**
         * @param {?} mediaElement
         * @return {?}
         */
            function (mediaElement) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._http.get(mediaElement.src, { responseType: 'blob' }).subscribe(function (response) {
                        /** @type {?} */
                        var description;
                        /** @type {?} */
                        var extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                        /** @type {?} */
                        var filename = mediaElement.src.indexOf('base64') !== -1 ? '' : mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                        switch (extension) {
                            case 'mp3':
                                description = 'MPEG audio layer 3 file';
                                break;
                            case 'wma':
                                description = 'Windows media audio file';
                                break;
                            case 'wav':
                                description = 'WAVE audio file';
                                break;
                            case 'ogg':
                                description = 'Ogg Vorbis file';
                                break;
                            case 'aac':
                                description = 'Advanced audio coding file';
                                break;
                            case 'midi':
                                description = 'Musical instrument digital interface file';
                                break;
                            default:
                                description = 'Audio file';
                                break;
                        }
                        observer.next({
                            filename: filename,
                            extension: extension,
                            description: description,
                            size: response.size
                        });
                    });
                });
            };
        /**
         * @param {?} url
         * @return {?}
         */
        AudioService.prototype.getWaveformFromUrl = /**
         * @param {?} url
         * @return {?}
         */
            function (url) {
                var _this = this;
                // if audio context is not support return a stream of empty data
                if (!(( /** @type {?} */(window))).AudioContext) {
                    return rxjs.of([new Float32Array(0)]);
                }
                this._audioContext = new AudioContext();
                this.createVolumeNode();
                this.createAnalyserNode();
                return rxjs.Observable.create(function (observer) {
                    // load the media from the URL provided
                    _this._http.get(url, { responseType: 'arraybuffer' }).subscribe(function (response) {
                        _this.getAudioBuffer(response).subscribe(function (audioBuffer) {
                            // create the buffer source
                            _this.createBufferSource(audioBuffer);
                            /** @type {?} */
                            var dataPoints = [];
                            /** @type {?} */
                            var channels = _this._audioBuffer.numberOfChannels;
                            // extract the data from each channel
                            for (var channelIdx = 0; channelIdx < channels; channelIdx++) {
                                dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                            }
                            observer.next(dataPoints);
                            observer.complete();
                            // cleanup after ourselves
                            dataPoints = null;
                        }, function (error) { return observer.error(error); });
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
        AudioService.prototype.getWaveformPoints = /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
            function (channels, skip) {
                if (channels === void 0) {
                    channels = [];
                }
                if (skip === void 0) {
                    skip = 1000;
                }
                /** @type {?} */
                var waveform = [];
                /** @type {?} */
                var duration = channels.length > 0 ? channels[0].length : 0;
                var _loop_1 = function (idx) {
                    // get all the channel data for a specific point
                    /** @type {?} */
                    var points = channels.map(function (channel) { return channel[idx]; });
                    // find the minimum point and maximum points at each position across all channels
                    waveform.push({
                        min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                        max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                    });
                };
                // convert each channel data to a series of waveform points
                for (var idx = 0; idx < duration; idx += skip) {
                    _loop_1(idx);
                }
                return waveform;
            };
        /**
         * @param {?} arrayBuffer
         * @return {?}
         */
        AudioService.prototype.getAudioBuffer = /**
         * @param {?} arrayBuffer
         * @return {?}
         */
            function (arrayBuffer) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                        observer.next(audioBuffer);
                        observer.complete();
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @return {?}
         */
        AudioService.prototype.getOfflineAudioContext = /**
         * @return {?}
         */
            function () {
                return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
            };
        /**
         * @param {?} audioBuffer
         * @return {?}
         */
        AudioService.prototype.createBufferSource = /**
         * @param {?} audioBuffer
         * @return {?}
         */
            function (audioBuffer) {
                this.disconnectSource();
                this._audioBuffer = audioBuffer;
                this._audioBufferSource = this._audioContext.createBufferSource();
                this._audioBufferSource.buffer = this._audioBuffer;
                this._audioBufferSource.connect(this._analyserNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createVolumeNode = /**
         * @return {?}
         */
            function () {
                this._gainNode = this._audioContext.createGain();
                this._gainNode.connect(this._audioContext.destination);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createAnalyserNode = /**
         * @return {?}
         */
            function () {
                this._analyserNode = this._audioContext.createAnalyser();
                this._analyserNode.connect(this._gainNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.disconnectSource = /**
         * @return {?}
         */
            function () {
                if (this._audioBufferSource) {
                    this._audioBufferSource.disconnect();
                }
            };
        AudioService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AudioService.ctorParameters = function () {
            return [
                { type: http.HttpClient }
            ];
        };
        return AudioService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AudioServiceModule = /** @class */ (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [http.HttpClientModule],
                        providers: [AudioService]
                    },] }
        ];
        return AudioServiceModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MediaPlayerComponent = /** @class */ (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this.focused = false;
            /**
             * The `anonymous` keyword means that there will be no exchange of user credentials when the media source is fetched.
             */
            this.crossorigin = 'use-credentials';
            this._onDestroy = new rxjs.Subject();
            // show controls when hovering and in quiet mode
            rxjs.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.tap(function () { return _this.hovering = true; }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.source;
            },
            /** The url to the media file to be loaded by the media player. */
            set: /**
             * The url to the media file to be loaded by the media player.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.type;
            },
            /**
             * Defines the appearance of the media player. The two possible values are `video` and `audio`.
             * The media player will adapt it's appearance to best suit the type specified.
             */
            set: /**
             * Defines the appearance of the media player. The two possible values are `video` and `audio`.
             * The media player will adapt it's appearance to best suit the type specified.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.quietMode;
            },
            /**
             * If enabled, the controls in the media player will be hidden unless the mouse is over the player and will appear in a darker style.
             * Dark mode is automatically enabled in full screen mode. Quiet mode is only available for videos.
             */
            set: /**
             * If enabled, the controls in the media player will be hidden unless the mouse is over the player and will appear in a darker style.
             * Dark mode is automatically enabled in full screen mode. Quiet mode is only available for videos.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "muteAriaLabel", {
            /**
             * If specified the function will be called passing the current volume as an argument.
             * It should return an appropriate aria-label for the mute/unmute button.
             */
            set: /**
             * If specified the function will be called passing the current volume as an argument.
             * It should return an appropriate aria-label for the mute/unmute button.
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                this.mediaPlayerService.muteAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "playAriaLabel", {
            /**
             * If specified the function will be called passing the current playing state as an argument.
             * It should return an appropriate aria-label for the play/pause button.
             */
            set: /**
             * If specified the function will be called passing the current playing state as an argument.
             * It should return an appropriate aria-label for the play/pause button.
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                this.mediaPlayerService.playAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "fullscreenAriaLabel", {
            /**
             * If specified the function will be called passing the current fullscreen state as an argument.
             * It should return an appropriate aria-label for the fullscreen toggle button.
             */
            set: /**
             * If specified the function will be called passing the current fullscreen state as an argument.
             * It should return an appropriate aria-label for the fullscreen toggle button.
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                this.mediaPlayerService.fullscreenAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "selectSubtitlesAriaLabel", {
            /**
             * If specified the function will be called passing the current track as an argument.
             * It should return an appropriate aria-label for the subtitle selection button.
             */
            set: /**
             * If specified the function will be called passing the current track as an argument.
             * It should return an appropriate aria-label for the subtitle selection button.
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                this.mediaPlayerService.selectSubtitlesAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "goToStartAriaLabel", {
            /** Defines an aria-label for the go to start button. */
            set: /**
             * Defines an aria-label for the go to start button.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.goToStartAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "goToEndAriaLabel", {
            /** Defines an aria-label for the go to end button. */
            set: /**
             * Defines an aria-label for the go to end button.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.goToEndAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "subtitlesTitleAriaLabel", {
            /** Defines an aria-label for the title displayed in the subtitle selection popover. */
            set: /**
             * Defines an aria-label for the title displayed in the subtitle selection popover.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.subtitlesTitleAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "subtitlesOffAriaLabel", {
            /** Defines an aria-label to indicate subtitle are not currently enabled. */
            set: /**
             * Defines an aria-label to indicate subtitle are not currently enabled.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.subtitlesOffAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "noSubtitlesAriaLabel", {
            /** Define an aria-label to indicate there are no subtitles available. */
            set: /**
             * Define an aria-label to indicate there are no subtitles available.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.noSubtitlesAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "mediaPlayerAriaLabel", {
            /** Define an aria-label for the media player. */
            set: /**
             * Define an aria-label for the media player.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.mediaPlayerAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "seekAriaLabel", {
            /** Define an aria-label for the the seek element. */
            set: /**
             * Define an aria-label for the the seek element.
             * @param {?} ariaLabel
             * @return {?}
             */ function (ariaLabel) {
                this.mediaPlayerService.seekAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
                this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
                this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
                this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
                this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
                // initially hide all text tracks
                this.mediaPlayerService.hideSubtitleTracks();
            };
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        MediaPlayerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-media-player',
                        template: "<div class=\"player-container\"\n     uxFocusIndicator\n     tabindex=\"0\"\n     [attr.aria-label]=\"mediaPlayerService.mediaPlayerAriaLabel\"\n     [cdkTrapFocus]=\"mediaPlayerService.fullscreen\">\n\n    <div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n        <video class=\"video-player\"\n            #player\n            tabindex=\"-1\"\n            [src]=\"source\"\n            [crossOrigin]=\"crossorigin\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n\n            <ng-content select=\"track\"></ng-content>\n        </video>\n\n        <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n            <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n                <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n                <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n            </svg>\n        </div>\n\n    </div>\n\n    <div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n        <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n            <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n                <g transform=\"translate(-98.000000, -458.000000)\">\n                    <g transform=\"translate(98.000000, 458.000000)\">\n                        <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                        <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                            stroke=\"#60798D\"></path>\n                        <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                        <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    </g>\n                </g>\n            </g>\n        </svg>\n\n        <p class=\"audio-file-name\">{{ this.filename ? this.filename :  (audioMetadata | async)?.filename }}</p>\n        <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n        <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n        <audio #player\n            [src]=\"source\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n        </audio>\n    </div>\n\n    <div class=\"control-bar\"\n        (uxFocusWithin)=\"focused = true\"\n        (uxBlurWithin)=\"focused = false\">\n\n        <ux-media-player-timeline></ux-media-player-timeline>\n        <ux-media-player-controls>\n            <ng-content select=\"[uxMediaPlayerCustomControl]\"></ng-content>\n        </ux-media-player-controls>\n    </div>\n</div>",
                        providers: [MediaPlayerService],
                        host: {
                            '(keydown.Space)': 'mediaPlayerService.togglePlay(); $event.preventDefault()',
                            '[class.standard]': '!mediaPlayerService.fullscreen',
                            '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                            '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                            '[class.hover]': 'hovering || focused',
                            '[class.video]': 'type === "video"',
                            '[class.audio]': 'type === "audio"',
                            '(mouseenter)': 'hovering = true',
                            '(mouseleave)': 'hovering = false',
                            '(document:fullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange()'
                        }
                    }] }
        ];
        /** @nocollapse */
        MediaPlayerComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService },
                { type: AudioService },
                { type: i0.ElementRef }
            ];
        };
        MediaPlayerComponent.propDecorators = {
            _playerRef: [{ type: i0.ViewChild, args: ['player', { static: false },] }],
            crossorigin: [{ type: i0.Input }],
            filename: [{ type: i0.Input }],
            source: [{ type: i0.Input }],
            type: [{ type: i0.Input }],
            quietMode: [{ type: i0.Input }],
            muteAriaLabel: [{ type: i0.Input }],
            playAriaLabel: [{ type: i0.Input }],
            fullscreenAriaLabel: [{ type: i0.Input }],
            selectSubtitlesAriaLabel: [{ type: i0.Input }],
            goToStartAriaLabel: [{ type: i0.Input }],
            goToEndAriaLabel: [{ type: i0.Input }],
            subtitlesTitleAriaLabel: [{ type: i0.Input }],
            subtitlesOffAriaLabel: [{ type: i0.Input }],
            noSubtitlesAriaLabel: [{ type: i0.Input }],
            mediaPlayerAriaLabel: [{ type: i0.Input }],
            seekAriaLabel: [{ type: i0.Input }]
        };
        return MediaPlayerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DurationPipe = /** @class */ (function () {
        function DurationPipe() {
        }
        /**
         * @param {?} seconds
         * @return {?}
         */
        DurationPipe.prototype.transform = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                /** @type {?} */
                var minutes = Math.floor(seconds / 60);
                /** @type {?} */
                var hours = Math.floor(minutes / 60);
                /** @type {?} */
                var days = Math.floor(hours / 24);
                hours = hours - (days * 24);
                minutes = minutes - (days * 24 * 60) - (hours * 60);
                seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
                if (hours > 0) {
                    return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
                }
                else {
                    return this.pad(minutes) + ":" + this.pad(seconds);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DurationPipe.prototype.pad = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value < 10) {
                    return "0" + value;
                }
                return value.toString();
            };
        DurationPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'duration'
                    },] }
        ];
        return DurationPipe;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DurationPipeModule = /** @class */ (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [DurationPipe],
                        declarations: [DurationPipe]
                    },] }
        ];
        return DurationPipeModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FileSizePipe = /** @class */ (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        FileSizePipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // allow for async values
                if (!value) {
                    return value;
                }
                /** @type {?} */
                var units = ['B', 'KB', 'MB', 'GB', 'TB'];
                // calculate the which unit bracket the values should be a part of
                /** @type {?} */
                var idx = Math.floor(Math.log(value) / Math.log(1024));
                /** @type {?} */
                var formattedValue = value / Math.pow(1024, idx);
                return formattedValue.toFixed(2) + " " + units[idx];
            };
        FileSizePipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'fileSize'
                    },] }
        ];
        return FileSizePipe;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FileSizePipeModule = /** @class */ (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [FileSizePipe],
                        declarations: [FileSizePipe]
                    },] }
        ];
        return FileSizePipeModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent,
        MediaPlayerCustomControlDirective
    ];
    var MediaPlayerModule = /** @class */ (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            AudioServiceModule,
                            ClickOutsideModule,
                            common.CommonModule,
                            DurationPipeModule,
                            FileSizePipeModule,
                            FrameExtractionModule,
                            IconModule,
                            SliderModule,
                            TooltipModule,
                        ],
                        exports: DECLARATIONS$5,
                        declarations: DECLARATIONS$5
                    },] }
        ];
        return MediaPlayerModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NavigationItemComponent = /** @class */ (function () {
        function NavigationItemComponent(_elementRef, _renderer, _router, _parent) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._router = _router;
            this._parent = _parent;
            /**
             * Whether the navigation item is expanded, displaying the items from the `children` array.
             */
            this.expanded = false;
            /**
             * Indicate the depth of the item
             */
            this._level = this._parent ? this._parent._level + 1 : 1;
            /**
             * Indicate whether the indentation should include the arrow
             */
            this._indentWithoutArrow = true;
            /**
             * Automatically unsubscribe when the component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
            // Expand this component if it or a descendant is active.
            _router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.expanded = _this.hasActiveLink(_this.link);
            });
        }
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            /** Get the active state of this item from the router */
            get: /**
             * Get the active state of this item from the router
             * @return {?}
             */ function () {
                return this.link ? this._router.isActive(this.link, true) : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // Add classes to parent for styling
                /** @type {?} */
                var parentListElement = this._elementRef.nativeElement.parentElement;
                if (parentListElement) {
                    /** @type {?} */
                    var levelClass = this.getLevelClass();
                    if (levelClass.length > 0) {
                        this._renderer.addClass(parentListElement, 'nav');
                        this._renderer.addClass(parentListElement, levelClass);
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Set 'indentWithoutArrow'
                this.setIndentWithoutArrow();
                // Update 'indentWithoutArrow' in response to changes to children
                this._children.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.setIndentWithoutArrow(); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Check if this item or any children are active */
        /**
         * Check if this item or any children are active
         * @param {?} link
         * @return {?}
         */
        NavigationItemComponent.prototype.hasActiveLink = /**
         * Check if this item or any children are active
         * @param {?} link
         * @return {?}
         */
            function (link) {
                // If this component has a link, check if it is active.
                if (link && this._router.isActive(link, true)) {
                    return true;
                }
                // If this component has children, check if any of them, or their descendants, are active.
                return this.children.some(function (item) { return item.hasActiveLink(item.link); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.getLevelClass = /**
         * @return {?}
         */
            function () {
                switch (this._level) {
                    case 2:
                        return 'nav-second-level';
                    case 3:
                        return 'nav-third-level';
                    case 4:
                        return 'nav-fourth-level';
                    case 5:
                        return 'nav-fifth-level';
                }
                return '';
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.setIndentWithoutArrow = /**
         * @return {?}
         */
            function () {
                if (this.children.length > 0) {
                    // If this element has children it will be indented and will have an arrow
                    this._indentWithoutArrow = false;
                }
                else if (this._parent) {
                    // If this element has a parent, indent it if any of its siblings have children
                    this._indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
                }
                else {
                    // Top-level elements should be indented
                    this._indentWithoutArrow = true;
                }
            };
        NavigationItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: '[ux-navigation-item]',
                        template: "<a *ngIf=\"link\"\n   [class.has-arrow]=\"children.length > 0\"\n   [class.no-arrow]=\"_indentWithoutArrow\"\n   [routerLink]=\"link\">\n    <span>{{ header }}</span>\n</a>\n\n<a *ngIf=\"!link\"\n   (click)=\"expanded = !expanded\"\n   [class.has-arrow]=\"children.length > 0\"\n   [class.no-arrow]=\"_indentWithoutArrow\">\n    <span>{{ header }}</span>\n</a>\n\n<ng-content></ng-content>\n",
                        host: {
                            '[class.active]': 'active',
                            '[class.selected]': 'expanded',
                        }
                    }] }
        ];
        /** @nocollapse */
        NavigationItemComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: router.Router },
                { type: NavigationItemComponent, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
            ];
        };
        NavigationItemComponent.propDecorators = {
            header: [{ type: i0.Input }],
            icon: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            link: [{ type: i0.Input }],
            _children: [{ type: i0.ContentChildren, args: [NavigationItemComponent, { descendants: true },] }]
        };
        return NavigationItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NAVIGATION_MODULE_OPTIONS = new i0.InjectionToken('NAVIGATION_MODULE_OPTIONS');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NavigationService = /** @class */ (function () {
        function NavigationService() {
            /**
             * Whether to collapse other menu items when expanding a menu item.
             */
            this.autoCollapse = true;
            /**
             * Emit when the expanded state has changed
             */
            this.expanded$ = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        NavigationService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.expanded$.complete();
            };
        /** Set the expanded state of an item */
        /**
         * Set the expanded state of an item
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
        NavigationService.prototype.setExpanded = /**
         * Set the expanded state of an item
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
            function (source, expanded) {
                if (expanded && this.autoCollapse) {
                    this.collapseSiblings(source);
                    this.expanded$.next();
                }
            };
        /** Collapse all siblings nodes */
        /**
         * Collapse all siblings nodes
         * @param {?} source
         * @return {?}
         */
        NavigationService.prototype.collapseSiblings = /**
         * Collapse all siblings nodes
         * @param {?} source
         * @return {?}
         */
            function (source) {
                var _this = this;
                var e_1, _a;
                /** @type {?} */
                var siblings = this.items;
                try {
                    for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var item = _c.value;
                        /** @type {?} */
                        var parent_1 = this.getParent(source, item);
                        if (parent_1) {
                            siblings = parent_1.children;
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // collapse every sibling
                siblings.filter(function (item) { return item !== source; }).forEach(function (item) { return _this.collapseAll(item); });
            };
        /** Collapse an item and all its children */
        /**
         * Collapse an item and all its children
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.collapseAll = /**
         * Collapse an item and all its children
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                item.expanded = false;
                if (item.children) {
                    item.children.forEach(function (child) { return _this.collapseAll(child); });
                }
            };
        /** Get a nodes parent if it has one */
        /**
         * Get a nodes parent if it has one
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.getParent = /**
         * Get a nodes parent if it has one
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
            function (target, item) {
                return (item.children || []).find(function (child) { return child === target; }) ? item : null;
            };
        NavigationService.decorators = [
            { type: i0.Injectable }
        ];
        return NavigationService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NavigationLinkDirective = /** @class */ (function () {
        function NavigationLinkDirective(_router, _locationStrategy, _navigationService, _changeDetector, _route, _options) {
            this._router = _router;
            this._locationStrategy = _locationStrategy;
            this._navigationService = _navigationService;
            this._changeDetector = _changeDetector;
            this._route = _route;
            this._options = _options;
            /**
             * Emit with the current expaned state
             */
            this._expanded$ = new rxjs.Subject();
            /**
             * Unsubscribe from all observables when this directive is destroyed
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NavigationLinkDirective.prototype, "expanded", {
            /** The expaned state of this item */
            set: /**
             * The expaned state of this item
             * @param {?} value
             * @return {?}
             */ function (value) { this._expanded$.next(value); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // any time expanded state anywhere change we should run change detection in case we should collapse
                this._navigationService.expanded$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._changeDetector.markForCheck(); });
                this._expanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                    if (_this.navigationItem.children && _this.navigationItem.children.length > 0) {
                        _this.ariaExpanded = expanded;
                        _this._navigationService.setExpanded(_this.navigationItem, expanded);
                    }
                });
                this._router.events
                    .pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy))
                    .subscribe(this.updateNavigationState.bind(this));
                this.updateNavigationState();
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NavigationLinkDirective.prototype.activated = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.navigationItem.routerLink) {
                    /** @type {?} */
                    var commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    this._router.navigate(commands, this.navigationItem.routerExtras);
                }
                // Toggle expanded state (relevant only if it has children)
                this.navigationItem.expanded = !this.navigationItem.expanded;
                // Invoke the custom click handler if specified
                if (this.navigationItem.click) {
                    this.navigationItem.click(event, this.navigationItem);
                }
                return false;
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateNavigationState = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.isActive = this.isActiveItem(this.navigationItem);
                if (this.navigationItem.children) {
                    /** @type {?} */
                    var activeChild = this.navigationItem.children.find(function (child) { return _this.isActiveItem(child); });
                    if (activeChild) {
                        this.navigationItem.expanded = true;
                    }
                }
                this._changeDetector.markForCheck();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateAttributes = /**
         * @return {?}
         */
            function () {
                this.href = this.getHref();
                this.role = (this.navigationItem.children && this.navigationItem.children.length > 0) ? 'button' : 'treeitem';
                this.indentChildren = this.navigationItem.children && this.navigationItem.children.some(function (item) { return item.children && item.children.length > 0; });
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.getHref = /**
         * @return {?}
         */
            function () {
                if (this.navigationItem.routerLink) {
                    /** @type {?} */
                    var commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    /** @type {?} */
                    var urlTree = this._router.createUrlTree(commands, this.navigationItem.routerExtras);
                    return this._locationStrategy.prepareExternalUrl(this._router.serializeUrl(urlTree));
                }
                return null;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        NavigationLinkDirective.prototype.isActiveItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _a = this.getRouterOptions(item), exact = _a.exact, ignoreQueryParams = _a.ignoreQueryParams;
                if (item.routerLink) {
                    /** @type {?} */
                    var routerExtras = item.routerExtras;
                    // if we are to ignore the query params we must remove them
                    if (ignoreQueryParams) {
                        // get the current actual query params
                        var queryParams = this._route.snapshot.queryParams;
                        // override the provided query params with the actual query params so they will alway match
                        routerExtras = __assign({}, routerExtras, { queryParams: queryParams });
                    }
                    /** @type {?} */
                    var commands = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    /** @type {?} */
                    var urlTree = this._router.createUrlTree(commands, routerExtras);
                    return this._router.isActive(urlTree, exact);
                }
                return false;
            };
        /** Get the router options with defaults for missing properties */
        /**
         * Get the router options with defaults for missing properties
         * @param {?} item
         * @return {?}
         */
        NavigationLinkDirective.prototype.getRouterOptions = /**
         * Get the router options with defaults for missing properties
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the default options based on the ones provided in `forRoot`
                /** @type {?} */
                var defaultOptions = __assign({ exact: true, ignoreQueryParams: false }, (this._options ? this._options.routerOptions : {}));
                // if there are item specific router options they should take precendence
                return __assign({}, defaultOptions, item.routerOptions);
            };
        NavigationLinkDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxNavigationLink]',
                        exportAs: 'uxNavigationLink'
                    },] }
        ];
        /** @nocollapse */
        NavigationLinkDirective.ctorParameters = function () {
            return [
                { type: router.Router },
                { type: common.LocationStrategy },
                { type: NavigationService },
                { type: i0.ChangeDetectorRef },
                { type: router.ActivatedRoute },
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [NAVIGATION_MODULE_OPTIONS,] }] }
            ];
        };
        NavigationLinkDirective.propDecorators = {
            navigationItem: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            canExpand: [{ type: i0.Input }],
            indent: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.indent',] }],
            href: [{ type: i0.HostBinding, args: ['attr.href',] }],
            role: [{ type: i0.HostBinding, args: ['attr.role',] }],
            ariaExpanded: [{ type: i0.HostBinding, args: ['attr.aria-expanded',] }],
            activated: [{ type: i0.HostListener, args: ['click', ['$event'],] }, { type: i0.HostListener, args: ['keydown.enter', ['$event'],] }]
        };
        return NavigationLinkDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NavigationComponent = /** @class */ (function () {
        function NavigationComponent(_navigationService) {
            this._navigationService = _navigationService;
            /**
             * Whether to present the menu as a hierarchical tree.
             */
            this.tree = true;
            /**
             * The classes to be added to each different level
             */
            this._hierarchyClasses = [
                '',
                'nav-second-level',
                'nav-third-level',
                'nav-fourth-level',
                'nav-fifth-level',
            ];
        }
        Object.defineProperty(NavigationComponent.prototype, "items", {
            get: /**
             * @return {?}
             */ function () {
                return this._navigationService.items;
            },
            /** The navigation items to populate the menu with. */
            set: /**
             * The navigation items to populate the menu with.
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._navigationService.items = items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "autoCollapse", {
            /** Whether to collapse other menu items when expanding a menu item. */
            set: /**
             * Whether to collapse other menu items when expanding a menu item.
             * @param {?} autoCollapse
             * @return {?}
             */ function (autoCollapse) {
                this._navigationService.autoCollapse = autoCollapse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "_depthLimit", {
            get: /**
             * @return {?}
             */ function () {
                return this.tree ? this._hierarchyClasses.length : 2;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         */
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
        NavigationComponent.prototype._needsIndent = /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
            function (items) {
                return items && items.some(function (item) { return item.children && item.children.length > 0; });
            };
        /** Determine the type of icon to display. We support `hpe-icon`, `ux-icon` or `component` */
        /**
         * Determine the type of icon to display. We support `hpe-icon`, `ux-icon` or `component`
         * @param {?} item
         * @return {?}
         */
        NavigationComponent.prototype._getIconType = /**
         * Determine the type of icon to display. We support `hpe-icon`, `ux-icon` or `component`
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return getIconType(item.icon);
            };
        NavigationComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-navigation',
                        template: "<nav class=\"ux-side-nav\" [class.tree]=\"tree\" role=\"navigation\">\n\n    <ol *ngIf=\"items\" role=\"tree\" class=\"nav\" uxTabbableList [hierarchy]=\"true\">\n\n        <ng-container *ngFor=\"let item of items; let rank = index\"\n            [ngTemplateOutlet]=\"navigationNode\"\n            [ngTemplateOutletContext]=\"{ item: item, level: 1, rank: rank, indent: _needsIndent(items) }\">\n        </ng-container>\n\n        <ng-template #navigationNode let-item=\"item\" let-parent=\"parent\" let-level=\"level\" let-rank=\"rank\" let-indent=\"indent\">\n\n            <li [attr.role]=\"(item.children && item.children.length > 0) ? 'treeitem' : 'none'\"\n                [attr.aria-expanded]=\"item.expanded\"\n                [class.selected]=\"item.expanded\"\n                [class.active]=\"navigationLink.isActive\">\n\n                <a uxNavigationLink\n                    #navigationLink=\"uxNavigationLink\"\n                    #tli=\"ux-tabbable-list-item\"\n                    [navigationItem]=\"item\"\n                    [expanded]=\"item.expanded\"\n                    [canExpand]=\"level < _depthLimit\"\n                    [indent]=\"indent\"\n                    uxTabbableListItem\n                    [parent]=\"parent\"\n                    [rank]=\"rank\"\n                    [(expanded)]=\"item.expanded\">\n\n                    <span *ngIf=\"!navigationItemTemplate && item.children && item.children.length > 0 && level < _depthLimit\"\n                          aria-hidden=\"true\"\n                          class=\"nav-expander\"\n                          (click)=\"item.expanded = !item.expanded; $event.stopPropagation(); $event.preventDefault()\">\n                    </span>\n\n                    <!-- Support HPE Icons, UX Icons and Icon Component -->\n                    <ng-container *ngIf=\"!navigationItemTemplate && item.icon && !tree\">\n\n                        <span *ngIf=\"_getIconType(item) !== 'component'\"\n                              class=\"nav-icon\"\n                              [ngClass]=\"[_getIconType(item), item.icon]\">\n                        </span>\n\n                        <ux-icon *ngIf=\"_getIconType(item) === 'component'\"\n                                 class=\"nav-icon\"\n                                 [name]=\"item.icon\">\n                        </ux-icon>\n\n                    </ng-container>\n\n                    <img *ngIf=\"!navigationItemTemplate && item.iconUrl && !tree\" class=\"nav-icon\" [src]=\"item.iconUrl\" alt=\"item.iconLabel\">\n                    <span *ngIf=\"!navigationItemTemplate\" class=\"nav-title\">{{ item.title }}</span>\n\n                    <ng-container\n                        [ngTemplateOutlet]=\"navigationItemTemplate\"\n                        [ngTemplateOutletContext]=\"{ item: item, level: level }\">\n                    </ng-container>\n\n                </a>\n\n                <ol *ngIf=\"item.children && item.expanded && level < _depthLimit\"\n                    role=\"group\"\n                    class=\"nav\"\n                    [ngClass]=\"_hierarchyClasses[level]\">\n\n                    <ng-container *ngFor=\"let child of item.children; let rank = index\"\n                        [ngTemplateOutlet]=\"navigationNode\"\n                        [ngTemplateOutletContext]=\"{ item: child, parent: tli, level: level + 1, rank: rank, indent: navigationLink.indentChildren }\">\n                    </ng-container>\n\n                </ol>\n\n            </li>\n\n        </ng-template>\n\n    </ol>\n\n    <!-- Backward compatibility with the original ux-navigation -->\n    <ol *ngIf=\"!items\" role=\"tree\" class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n\n</nav>\n",
                        providers: [NavigationService],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NavigationComponent.ctorParameters = function () {
            return [
                { type: NavigationService }
            ];
        };
        NavigationComponent.propDecorators = {
            items: [{ type: i0.Input }],
            tree: [{ type: i0.Input }],
            autoCollapse: [{ type: i0.Input }],
            navigationItemTemplate: [{ type: i0.ContentChild, args: ['uxNavigationItem', { static: false },] }]
        };
        return NavigationComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NavigationModule = /** @class */ (function () {
        function NavigationModule() {
        }
        // allow options to be specified globally
        // allow options to be specified globally
        /**
         * @param {?} options
         * @return {?}
         */
        NavigationModule.forRoot =
            // allow options to be specified globally
            /**
             * @param {?} options
             * @return {?}
             */
            function (options) {
                return {
                    ngModule: NavigationModule,
                    providers: [
                        { provide: NAVIGATION_MODULE_OPTIONS, useValue: options }
                    ]
                };
            };
        NavigationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule,
                            router.RouterModule
                        ],
                        exports: [
                            NavigationComponent,
                            NavigationItemComponent
                        ],
                        declarations: [
                            NavigationComponent,
                            NavigationItemComponent,
                            NavigationLinkDirective
                        ]
                    },] }
        ];
        return NavigationModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NestedDonutChartComponent = /** @class */ (function () {
        function NestedDonutChartComponent(_colorService, _changeDetector, _elementRef, _resizeService) {
            this._colorService = _colorService;
            this._changeDetector = _changeDetector;
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            /**
             * Define the maximum range of the arcs
             */
            this.max = 100;
            /**
             * Define the thickness of each arc
             */
            this.thickness = 8;
            /**
             * Define the spacing of each arc
             */
            this.spacing = 8;
            /**
             * Determine if we should show the hover effect
             */
            this.disableHover = false;
            /**
             * Determine if we should show a tooltip on arc hover
             */
            this.disableTooltip = false;
            /**
             * Determine the position of the tooltip
             */
            this.tooltipPlacement = 'top';
            /**
             * Set the duration of the animation
             */
            this.animationDuration = 750;
            /**
             * Emit whenever an arc is clicked
             */
            this.itemClick = new i0.EventEmitter();
            /**
             * Indicate if the tooltip should be visible
             */
            this._tooltipVisible = false;
            /**
             * Store the previously processed data
             */
            this._arcData = [];
            /**
             * Determine if the intial render has taken place
             */
            this._isInitialized = false;
            /**
             * Unsubscribe from all observables automatically
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NestedDonutChartComponent.prototype, "_radius", {
            /** Determine the radius of the chart based on the specified size */
            get: /**
             * Determine the radius of the chart based on the specified size
             * @return {?}
             */ function () {
                return this._size / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NestedDonutChartComponent.prototype, "_size", {
            /**
             * Get the size of the chart. The chart will always be square to
             * the size will be the smaller of the width/height properties
             */
            get: /**
             * Get the size of the chart. The chart will always be square to
             * the size will be the smaller of the width/height properties
             * @return {?}
             */ function () {
                return Math.min(this._elementRef.nativeElement.offsetWidth, this._elementRef.nativeElement.offsetHeight);
            },
            enumerable: true,
            configurable: true
        });
        /** Perform the initial render */
        /**
         * Perform the initial render
         * @return {?}
         */
        NestedDonutChartComponent.prototype.ngOnInit = /**
         * Perform the initial render
         * @return {?}
         */
            function () {
                var _this = this;
                // create the selection where we will draw the tracks
                this._trackLayer = d3Selection.select(this._chartElement.nativeElement)
                    .append('g');
                // create the selection where we will draw the arcs
                this._arcLayer = d3Selection.select(this._chartElement.nativeElement)
                    .append('g');
                // create the arcs representing the data
                this.render();
                // mark the component as initialized
                this._isInitialized = true;
                // listen for any resizing - skip the first emission as it always emits on first subscribe
                this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.render();
                    _this._changeDetector.markForCheck();
                });
            };
        /** Any time an input changes we must re-render the chart */
        /**
         * Any time an input changes we must re-render the chart
         * @return {?}
         */
        NestedDonutChartComponent.prototype.ngOnChanges = /**
         * Any time an input changes we must re-render the chart
         * @return {?}
         */
            function () {
                if (this._isInitialized) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        NestedDonutChartComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Inset the content so it never overlaps the arcs */
        /**
         * Inset the content so it never overlaps the arcs
         * @return {?}
         */
        NestedDonutChartComponent.prototype._getContentInset = /**
         * Inset the content so it never overlaps the arcs
         * @return {?}
         */
            function () {
                return this.dataset.length * (this.spacing + this.thickness);
            };
        /** Get the dimensions of the content area */
        /**
         * Get the dimensions of the content area
         * @return {?}
         */
        NestedDonutChartComponent.prototype._getContentSize = /**
         * Get the dimensions of the content area
         * @return {?}
         */
            function () {
                return this._size - (this._getContentInset() * 2);
            };
        /** Get the dataset formated in an accessible manner */
        /**
         * Get the dataset formated in an accessible manner
         * @return {?}
         */
        NestedDonutChartComponent.prototype._getAriaLabel = /**
         * Get the dataset formated in an accessible manner
         * @return {?}
         */
            function () {
                return this.dataset.map(function (data) { return data.value + " " + data.name; }).join('. ');
            };
        /**
         * Display the tracks and arcs defined by the dataset.
         * We also provide the transition configuration so anytime the dataset
         * changes we will animate the update.
         */
        /**
         * Display the tracks and arcs defined by the dataset.
         * We also provide the transition configuration so anytime the dataset
         * changes we will animate the update.
         * @return {?}
         */
        NestedDonutChartComponent.prototype.render = /**
         * Display the tracks and arcs defined by the dataset.
         * We also provide the transition configuration so anytime the dataset
         * changes we will animate the update.
         * @return {?}
         */
            function () {
                var _this = this;
                // update the transform of the layers
                this._trackLayer.attr('transform', "translate(" + this._radius + ", " + this._radius + ")");
                this._arcLayer.attr('transform', "translate(" + this._radius + ", " + this._radius + ")");
                // create the arcs based on the dataset
                this._arcs = this._arcLayer.selectAll('path')
                    .data(this.getChartData());
                // create the default transition based on the specified duration
                /** @type {?} */
                var arcTransition = d3Transition.transition().ease(d3Ease.easeCubic).duration(this.animationDuration);
                // create the tracks based on the dataset
                this._tracks = this._trackLayer.selectAll('path')
                    .data(this.getChartData())
                    .enter()
                    .append('path')
                    .attr('class', 'ux-nested-donut-chart-track');
                // set the track color on each render in case the input has changed
                this._trackLayer.selectAll('path')
                    .attr('d', this.getTrackArc())
                    .style('fill', function () { return _this.getTrackColor(); });
                // if an arc is removed then also remove the track
                this._tracks.exit().remove();
                // When a new arc is added we should create the element
                // size it and provide the background color and begin the
                // animation until it reaches its final angle
                this._arcs.enter()
                    .append('path')
                    .attr('class', 'ux-nested-donut-chart-arc')
                    .style('fill', function (data) { return _this.getColor(data.color); })
                    .attr('opacity', 1)
                    .on('click', function (data) { return _this.itemClick.emit(data); })
                    .on('mouseenter', function (data, index, nodes) { return _this.onArcMouseEnter(nodes[index], data); })
                    .on('mousemove', function () { return _this.onArcMouseMove(d3Selection.mouse(_this._chartElement.nativeElement)); })
                    .on('mouseleave', function (_data, index, nodes) { return _this.onArcMouseLeave(nodes[index]); })
                    .transition(arcTransition)
                    .attrTween('d', this.getArcTween.bind(this));
                // any time an existing dataset value changes
                // we should update the angle with an animation
                // we also animate any color changes also.
                this._arcs.transition(arcTransition)
                    .style('fill', function (data) { return _this.getColor(data.color); })
                    .attrTween('d', this.getArcTween.bind(this));
                // when a dataset it removed animate the arc out
                // and then remove the associated DOM element
                this._arcs.exit().transition(arcTransition)
                    .attrTween('d', this.getArcTween.bind(this))
                    .remove();
            };
        /** Get the interpolation function based on the new and previous angle */
        /**
         * Get the interpolation function based on the new and previous angle
         * @param {?} data
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getArcTween = /**
         * Get the interpolation function based on the new and previous angle
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var _this = this;
                // create a new interpolation function with a new endAngle
                /** @type {?} */
                var interpolation = d3Interpolate.interpolate(__assign({}, data, { endAngle: data.previousEndAngle }), data);
                // return the function that will produce the interpolation
                return function (delta) { return _this.getArc()(interpolation(delta)); };
            };
        /** Get the arc layout for a specific item in the dataset */
        /**
         * Get the arc layout for a specific item in the dataset
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getArc = /**
         * Get the arc layout for a specific item in the dataset
         * @return {?}
         */
            function () {
                var _this = this;
                return d3Shape.arc()
                    .innerRadius(function (data) { return _this.getArcRadius(data.index); })
                    .outerRadius(function (data) { return _this.getArcRadius(data.index) + _this.thickness; })
                    .startAngle(function (data) { return data.startAngle; })
                    .endAngle(function (data) { return data.endAngle; });
            };
        /**
         * Get the track arc layout for a specific item in the dataset.
         * This will match the arc of that represents the actual data
         * however the endAngle will always be a complete circle
         */
        /**
         * Get the track arc layout for a specific item in the dataset.
         * This will match the arc of that represents the actual data
         * however the endAngle will always be a complete circle
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getTrackArc = /**
         * Get the track arc layout for a specific item in the dataset.
         * This will match the arc of that represents the actual data
         * however the endAngle will always be a complete circle
         * @return {?}
         */
            function () {
                return this.getArc().endAngle(function () { return Math.PI * 2; });
            };
        /**
         * Get the radius of an arc. This is calculated
         * based on the chart radius that has been defined,
         * minus the thickness defined, then taking into account
         * the depth of the arc and the spacing between each arc.
         */
        /**
         * Get the radius of an arc. This is calculated
         * based on the chart radius that has been defined,
         * minus the thickness defined, then taking into account
         * the depth of the arc and the spacing between each arc.
         * @param {?} index
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getArcRadius = /**
         * Get the radius of an arc. This is calculated
         * based on the chart radius that has been defined,
         * minus the thickness defined, then taking into account
         * the depth of the arc and the spacing between each arc.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return (this._radius - this.thickness) - (index * (this.thickness + this.spacing));
            };
        /**
         * Map the dataset to the NestedDonutChartArc interface
         */
        /**
         * Map the dataset to the NestedDonutChartArc interface
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getChartData = /**
         * Map the dataset to the NestedDonutChartArc interface
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var dataset = this.dataset.map(function (data, index) {
                    /** @type {?} */
                    var previousEndAngle = 0;
                    // check if there was a previous dataset at this index
                    if (_this._arcData && _this._arcData[index]) {
                        previousEndAngle = _this._arcData[index].endAngle;
                    }
                    return __assign({}, data, { index: index, startAngle: 0, endAngle: _this.getAngle(data), previousEndAngle: previousEndAngle });
                });
                // store the latest processed arc data
                this._arcData = dataset;
                return dataset;
            };
        /** Convert the data value to radians */
        /**
         * Convert the data value to radians
         * @param {?} data
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getAngle = /**
         * Convert the data value to radians
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var fraction = data.value / this.max;
                /** @type {?} */
                var degrees = fraction * 360.0;
                return degrees * (Math.PI / 180);
            };
        /**
         * Get the color of the arc, this may be a CSS color value, the name of a color
         * from the color set or a ThemeColor object. We return this as a rgba color to
         * support the alpha channel
         */
        /**
         * Get the color of the arc, this may be a CSS color value, the name of a color
         * from the color set or a ThemeColor object. We return this as a rgba color to
         * support the alpha channel
         * @param {?} color
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getColor = /**
         * Get the color of the arc, this may be a CSS color value, the name of a color
         * from the color set or a ThemeColor object. We return this as a rgba color to
         * support the alpha channel
         * @param {?} color
         * @return {?}
         */
            function (color) {
                return ThemeColor.isInstanceOf(color) ? (( /** @type {?} */(color))).toRgba() : this._colorService.resolve(( /** @type {?} */(color)));
            };
        /** If no track color is specified then default to a specific color based on the active colorset */
        /**
         * If no track color is specified then default to a specific color based on the active colorset
         * @return {?}
         */
        NestedDonutChartComponent.prototype.getTrackColor = /**
         * If no track color is specified then default to a specific color based on the active colorset
         * @return {?}
         */
            function () {
                if (this.trackColor) {
                    return this.getColor(this.trackColor);
                }
                // otherwise default to a color based on the colorset (note we can't use the Color enum from MF package)
                if (this._colorService.colorExists(Color.Grey6)) {
                    return this.getColor(Color.Grey6);
                }
                if (this._colorService.colorExists('bright-gray')) {
                    return this.getColor('bright-gray');
                }
            };
        /** Define the on hover event */
        /**
         * Define the on hover event
         * @param {?} target
         * @param {?} data
         * @return {?}
         */
        NestedDonutChartComponent.prototype.onArcMouseEnter = /**
         * Define the on hover event
         * @param {?} target
         * @param {?} data
         * @return {?}
         */
            function (target, data) {
                // update the hover effect if it is enabled
                if (this.disableHover === false) {
                    d3Selection.select(target).transition().duration(250).attr('opacity', 0.5);
                }
                // update the tooltip context
                this._tooltipContext = __assign({}, data, { color: this.getColor(data.color) });
                // update the tooltip visibility
                this._tooltipVisible = true;
                // run change detection to ensure the visibility is updated
                this._changeDetector.detectChanges();
            };
        /** Update the tooltip position on mouse move */
        /**
         * Update the tooltip position on mouse move
         * @param {?} __0
         * @return {?}
         */
        NestedDonutChartComponent.prototype.onArcMouseMove = /**
         * Update the tooltip position on mouse move
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var _b = __read(_a, 2), x = _b[0], y = _b[1];
                this._tooltipX = x;
                this._tooltipY = y - 2; // subtract 2 so that it appears slightly above the cursor
                // run change detection to update the element position
                this._changeDetector.detectChanges();
            };
        /** Define the on hover out event */
        /**
         * Define the on hover out event
         * @param {?} target
         * @return {?}
         */
        NestedDonutChartComponent.prototype.onArcMouseLeave = /**
         * Define the on hover out event
         * @param {?} target
         * @return {?}
         */
            function (target) {
                // update the hover effect if it is enabled
                if (this.disableHover === false) {
                    d3Selection.select(target).transition().duration(250).attr('opacity', 1);
                }
                // clear the tooltip context
                this._tooltipContext = null;
                // update the tooltip visibility
                this._tooltipVisible = false;
                // run change detection to ensure the visibility is updated
                this._changeDetector.detectChanges();
            };
        NestedDonutChartComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-nested-donut-chart',
                        template: "<svg #chart\n    class=\"ux-nested-donut-chart\"\n    [attr.focusable]=\"false\"\n    [attr.width]=\"_size\"\n    [attr.height]=\"_size\"\n    [attr.aria-label]=\"_getAriaLabel()\">\n</svg>\n\n<!-- Custom content in center of the chart -->\n<div class=\"ux-nested-donut-chart-content\"\n    [style.top.px]=\"_getContentInset()\"\n    [style.right.px]=\"_getContentInset()\"\n    [style.bottom.px]=\"_getContentInset()\"\n    [style.left.px]=\"_getContentInset()\"\n    [style.width.px]=\"_getContentSize()\"\n    [style.height.px]=\"_getContentSize()\">\n  <ng-content></ng-content>\n</div>\n\n<!-- Tooltip to appear on arc hover -->\n<div class=\"ux-nested-donut-chart-tooltip\" *ngIf=\"_tooltipVisible && !disableTooltip\">\n  <ux-tooltip\n    [placement]=\"tooltipPlacement\"\n    [content]=\"_customTooltip || tooltip\"\n    [context]=\"_tooltipContext\"\n    [style.top.px]=\"_tooltipY\"\n    [style.left.px]=\"_tooltipX\">\n  </ux-tooltip>\n</div>\n\n<!-- Default tooltip template -->\n<ng-template #tooltip let-name=\"name\" let-value=\"value\">\n  <span class=\"ux-nested-donut-chart-tooltip-content\">\n    {{ name }}: {{ value }}\n  </span>\n</ng-template>\n\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NestedDonutChartComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: i0.ChangeDetectorRef },
                { type: i0.ElementRef },
                { type: ResizeService }
            ];
        };
        NestedDonutChartComponent.propDecorators = {
            dataset: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            thickness: [{ type: i0.Input }],
            spacing: [{ type: i0.Input }],
            trackColor: [{ type: i0.Input }],
            disableHover: [{ type: i0.Input }],
            disableTooltip: [{ type: i0.Input }],
            tooltipPlacement: [{ type: i0.Input }],
            animationDuration: [{ type: i0.Input }],
            itemClick: [{ type: i0.Output }],
            _chartElement: [{ type: i0.ViewChild, args: ['chart', { static: true },] }],
            _customTooltip: [{ type: i0.ContentChild, args: ['tooltip', { static: false },] }]
        };
        return NestedDonutChartComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NestedDonutChartModule = /** @class */ (function () {
        function NestedDonutChartModule() {
        }
        NestedDonutChartModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule,
                            ResizeModule
                        ],
                        declarations: [
                            NestedDonutChartComponent
                        ],
                        exports: [
                            NestedDonutChartComponent
                        ]
                    },] }
        ];
        return NestedDonutChartModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NotificationService = /** @class */ (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            /**
             *  Sets the order in which notifications are displayed:
             * `above` - newer notifications will appear above older ones.
             * `below` - newer notifications will appear below older ones.
             */
            this.direction = 'above';
            /**
             * The list of notifications including notifications that have been dismissed
             */
            this.notifications$ = new rxjs.BehaviorSubject([]);
            /**
             * Define the default set of notification options
             */
            this.options = {
                duration: 4,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
        }
        Object.defineProperty(NotificationService.prototype, "notifications", {
            /**
             * Access the list of notifications as an array
             */
            get: /**
             * Access the list of notifications as an array
             * @return {?}
             */ function () {
                return this.notifications$.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This function should be called to show a notification.
         * It should be given a TemplateRef containing the content to be displayed.
         * @param templateRef - A TemplateRef containing the content to be displayed
         * @param options - The properties to configure the notification.
         * @param context - The context passed to the notification TemplateRef. This can be accessed by adding a let-data="data" to the ng-template element.
         */
        /**
         * This function should be called to show a notification.
         * It should be given a TemplateRef containing the content to be displayed.
         * @param {?} templateRef - A TemplateRef containing the content to be displayed
         * @param {?=} options - The properties to configure the notification.
         * @param {?=} context - The context passed to the notification TemplateRef. This can be accessed by adding a let-data="data" to the ng-template element.
         * @return {?}
         */
        NotificationService.prototype.show = /**
         * This function should be called to show a notification.
         * It should be given a TemplateRef containing the content to be displayed.
         * @param {?} templateRef - A TemplateRef containing the content to be displayed
         * @param {?=} options - The properties to configure the notification.
         * @param {?=} context - The context passed to the notification TemplateRef. This can be accessed by adding a let-data="data" to the ng-template element.
         * @return {?}
         */
            function (templateRef, options, context) {
                var _this = this;
                if (options === void 0) {
                    options = this.options;
                }
                if (context === void 0) {
                    context = {};
                }
                // populate the specified options with the default values for any missing properties
                options = __assign({}, this.options, options);
                // create the notificationRef based on the options and context specified
                /** @type {?} */
                var notificationRef = {
                    templateRef: templateRef,
                    duration: options.duration,
                    date: new Date(),
                    visible: true,
                    height: options.height,
                    spacing: options.spacing,
                    backgroundColor: options.backgroundColor,
                    iconColor: options.iconColor,
                    data: context
                };
                // add the new notification to the list (either above or below based on direction)
                this.direction === 'above' ? this.notifications.unshift(notificationRef) : this.notifications.push(notificationRef);
                // update the notifications list
                this.notifications$.next(this.notifications);
                // remove notification after delay
                if (options.duration !== 0) {
                    setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
                }
                return notificationRef;
            };
        /**
         * This function will return a list of all the notifications that have been shown.
         */
        /**
         * This function will return a list of all the notifications that have been shown.
         * @return {?}
         */
        NotificationService.prototype.getHistory = /**
         * This function will return a list of all the notifications that have been shown.
         * @return {?}
         */
            function () {
                return this.notifications;
            };
        /**
         * This function can be called to dismiss a notification. It should be passed the object to dismiss.
         * @param notificationRef - The notification that should be dismissed
         */
        /**
         * This function can be called to dismiss a notification. It should be passed the object to dismiss.
         * @param {?} notificationRef - The notification that should be dismissed
         * @return {?}
         */
        NotificationService.prototype.dismiss = /**
         * This function can be called to dismiss a notification. It should be passed the object to dismiss.
         * @param {?} notificationRef - The notification that should be dismissed
         * @return {?}
         */
            function (notificationRef) {
                notificationRef.visible = false;
                this.notifications$.next(this.notifications);
            };
        /**
         * This function will dismiss any currently visible notifications.
         */
        /**
         * This function will dismiss any currently visible notifications.
         * @return {?}
         */
        NotificationService.prototype.dismissAll = /**
         * This function will dismiss any currently visible notifications.
         * @return {?}
         */
            function () {
                this.notifications.forEach(function (notificationRef) { return notificationRef.visible = false; });
                this.notifications$.next(this.notifications);
            };
        NotificationService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        /** @nocollapse */ NotificationService.ngInjectableDef = i0.defineInjectable({ factory: function NotificationService_Factory() { return new NotificationService(i0.inject(ColorService)); }, token: NotificationService, providedIn: "root" });
        return NotificationService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NotificationListComponent = /** @class */ (function () {
        function NotificationListComponent(_notificationService, _changeDetectorRef) {
            var _this = this;
            this._notificationService = _notificationService;
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Sets the position of the list of notifications within the browser window.
             */
            this.position = 'bottom-right';
            /**
             * The list of notifications that have not been dismissed
             */
            this.notifications$ = this._notificationService.notifications$.pipe(operators.map(function () { return _this._notifications; }));
            /**
             * Unsubscribe from all subscriptions on component destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            /**
             *  Sets the order in which notifications are displayed:
                `above` - newer notifications will appear above older ones.
                `below` - newer notifications will appear below older ones.
             */
            set: /**
             *  Sets the order in which notifications are displayed:
             * `above` - newer notifications will appear above older ones.
             * `below` - newer notifications will appear below older ones.
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotificationListComponent.prototype, "_notifications", {
            /** Filter out any hidden notifications */
            get: /**
             * Filter out any hidden notifications
             * @return {?}
             */ function () {
                return this._notificationService.notifications.filter(function (notification) { return notification.visible; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NotificationListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // whenever the notifications change we want to recalculate the height
                this._elements.changes.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this.position === 'bottom-left' || _this.position === 'bottom-right'; }), tick(), operators.map(function (changes) { return changes.toArray(); }), operators.withLatestFrom(this.notifications$)).subscribe(function (_a) {
                    var _b = __read(_a, 2), elements = _b[0], notifications = _b[1];
                    // calculate the total height of all notifications including spacing
                    _this._height = notifications.reduce(function (total, notification, index) {
                        return total + _this._getNotificationHeight(elements[index], notification) + notification.spacing;
                    }, 0);
                    // we are running in OnPush mode, so we will need to manually trigger CD here
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @return {?}
         */
        NotificationListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Get the height of a notification based on its content height or specified height
         */
        /**
         * Get the height of a notification based on its content height or specified height
         * @param {?} notification
         * @param {?} notificationRef
         * @return {?}
         */
        NotificationListComponent.prototype._getNotificationHeight = /**
         * Get the height of a notification based on its content height or specified height
         * @param {?} notification
         * @param {?} notificationRef
         * @return {?}
         */
            function (notification, notificationRef) {
                // if no fixed height is specified calculate the height based on content size
                notificationRef.height = notificationRef.height || notification.scrollHeight;
                return notificationRef.height;
            };
        /**
         * Get the notification position based on the notifications before it and the spacing
         */
        /**
         * Get the notification position based on the notifications before it and the spacing
         * @param {?} index
         * @return {?}
         */
        NotificationListComponent.prototype._getNotificationPosition = /**
         * Get the notification position based on the notifications before it and the spacing
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._notifications.slice(0, index).reduce(function (accumulator, notificationRef) {
                    return accumulator + notificationRef.height + notificationRef.spacing;
                }, 0);
            };
        NotificationListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-notification-list',
                        template: "<div #notification\n    class=\"notification\"\n    *ngFor=\"let notificationRef of notifications$ | async; let index = index\"\n    [style.height.px]=\"_getNotificationHeight(notification, notificationRef)\"\n    [style.top.px]=\"_getNotificationPosition(index)\"\n    [style.background-color]=\"notificationRef.backgroundColor\"\n    [@notificationState]>\n\n    <!-- Notification Content -->\n    <ng-container\n        [ngTemplateOutlet]=\"notificationRef.templateRef\"\n        [ngTemplateOutletContext]=\"{ $implicit: notificationRef, data: notificationRef.data }\">\n    </ng-container>\n</div>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('notificationState', [
                                animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                                animations.transition(':enter', [
                                    animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                                    animations.animate(500)
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                                ])
                            ])
                        ],
                        host: {
                            '[style.bottom.px]': '_height'
                        }
                    }] }
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () {
            return [
                { type: NotificationService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        NotificationListComponent.propDecorators = {
            direction: [{ type: i0.Input }],
            position: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class',] }],
            _elements: [{ type: i0.ViewChildren, args: ['notification',] }]
        };
        return NotificationListComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var NotificationModule = /** @class */ (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule
                        ],
                        exports: [
                            NotificationListComponent
                        ],
                        declarations: [
                            NotificationListComponent
                        ]
                    },] }
        ];
        return NotificationModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var OrganizationChartComponent = /** @class */ (function () {
        function OrganizationChartComponent(_elementRef, _resizeService, _componentFactoryResolver, _injector, _appRef, _viewContainerRef, _renderer, _focusIndicator, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._injector = _injector;
            this._appRef = _appRef;
            this._viewContainerRef = _viewContainerRef;
            this._renderer = _renderer;
            this._focusIndicator = _focusIndicator;
            this._ngZone = _ngZone;
            /**
             * Define the presentation of the connectors
             */
            this.connector = 'elbow';
            /**
             * Define the duration of the transition animations
             */
            this.duration = 750;
            /**
             * Define whether or not we can reveal additional parents
             */
            this.showReveal = false;
            /**
             * Define the aria label for the reveal button
             */
            this.revealAriaLabel = 'Reveal More';
            /**
             * Emit whenever a node is selected
             */
            this.selectedChange = new i0.EventEmitter(true);
            /**
             * Emit whenever the reveal button is pressed
             */
            this.reveal = new i0.EventEmitter();
            /**
             * Emit when the transition ends
             */
            this.transitionEnd = new i0.EventEmitter();
            /**
             * Store a flattened array of nodes
             */
            this._nodeLayout = [];
            /**
             * Store a flattened array of links
             */
            this._linkLayout = [];
            /**
             * Store the portal/outlets associated with some data
             */
            this._portals = new Map();
            /**
             * Store the focus indicators associated with nodes
             */
            this._indicators = new Map();
            /**
             * Store whether or not a transition is in progress
             */
            this._isTransitioning = false;
            /**
             * Store whether or not a camera pan is in progress
             */
            this._isPanning = false;
            /**
             * Determine if the component is initialised
             */
            this._isInitialised = false;
            /**
             * Determine if the connector type has changed since the last render
             */
            this._hasConnectorChanged = false;
            /**
             * Automatically unsubscribe from all subscriptions on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(OrganizationChartComponent.prototype, "selected", {
            /** Programmatically select an item */
            set: /**
             * Programmatically select an item
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                if (this.selected === selected || !selected) {
                    return;
                }
                if (this._isInitialised) {
                    this.select(selected);
                    this.centerNode(selected);
                }
                else {
                    this._pendingSelection = selected;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OrganizationChartComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // before we do anything ensure they have provided a template
                if (!this.nodeTemplate) {
                    throw new Error('Organization Chart - You must provide a node template!');
                }
                if (!this.nodeWidth || !this.nodeHeight) {
                    throw new Error('Organization Chart - You must specify a nodeWidth and nodeHeight');
                }
                // create the zoom drag listener
                this._zoom = d3Zoom.zoom()
                    .scaleExtent([1, 1])
                    .interpolate(d3Interpolate.interpolate)
                    .on('zoom', this.applyCameraPosition.bind(this))
                    .on('end', function () {
                    if (!_this._isPanning) {
                        _this.ensureNodesAreVisible();
                    }
                });
                // set up the selections
                this._linksContainer = d3Selection.select(this.linksContainer.nativeElement);
                this._nodesContainer = d3Selection.select(this.nodesContainer.nativeElement);
                // setup the zoom on the node layer
                this._ngZone.runOutsideAngular(function () { return _this._nodesContainer.call(_this._zoom); });
                // perform the initial render
                this.render();
                // ensure we set the initial chart size
                this._width = this._elementRef.nativeElement.offsetWidth;
                this._height = this._elementRef.nativeElement.offsetHeight;
                // watch for any resizing of the chart
                /** @type {?} */
                var resize$ = this._resizeService.addResizeListener(this._elementRef.nativeElement);
                // on size change immediate update the width and height measurements
                resize$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(this.onResize.bind(this));
                // after a debounce ensure nodes are visible
                resize$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(this.duration))
                    .subscribe(this.ensureNodesAreVisible.bind(this));
                // initially horizontally center the root node
                this.centerNode(this.dataset, OrganizationChartAxis.Horizontal, false);
                // initally move the camera down slightly so the root node does not appear at the very top of the chart
                this.moveCamera(0, 150, false);
                // mark this component as initialised
                this._isInitialised = true;
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        OrganizationChartComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.connector && !changes.connector.firstChange) {
                    this._hasConnectorChanged = true;
                }
                // if only the selected property has changed then don't re-render as this is handled by the setter
                if (Object.keys(changes).length === 1 && changes.selected) {
                    return;
                }
                if (this._isInitialised) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        OrganizationChartComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                // correctly dispose all portals and outlets
                this._portals.forEach(function (node) {
                    node.portal.detach();
                    node.outlet.dispose();
                });
            };
        /** Perform the actual rendering of the chart */
        /**
         * Perform the actual rendering of the chart
         * @return {?}
         */
        OrganizationChartComponent.prototype.render = /**
         * Perform the actual rendering of the chart
         * @return {?}
         */
            function () {
                var _this = this;
                // perform the layout algorithm on the current dataset
                this.updateLayout();
                // select all the existing links and nodes
                this.updateSelections();
                // create a d3 transition based in the specified transition time
                /** @type {?} */
                var defaultTransition = d3Transition.transition()
                    .duration(this.duration)
                    .on('start', function () { return _this._isTransitioning = true; })
                    .on('end', function () {
                    _this._isTransitioning = false;
                    _this.transitionEnd.emit();
                });
                // render the links when they are first added to the DOM
                this._links.enter()
                    .insert('path')
                    .attr('class', 'ux-organization-chart-link')
                    .attr('d', function (link) { return _this.getLinkPath(link); })
                    .attr('opacity', -2)
                    .transition(defaultTransition)
                    .attr('d', function (link) { return _this.getLinkPath(link); })
                    .attr('opacity', 1);
                // define the standard transition while the link is 'alive'
                this._links.transition()
                    .duration(this._hasConnectorChanged ? 0 : this.duration)
                    .attr('d', function (link) { return _this.getLinkPath(link); });
                // apply transitions when removing nodes
                this._links.exit()
                    .transition(defaultTransition)
                    .attr('d', function (link) { return _this.getCollapsedLinkPath(link); })
                    .attr('opacity', 0)
                    .remove();
                // when a node is first added to the DOM position it
                this._nodes.enter()
                    .append('div')
                    .attr('class', 'ux-organization-chart-node')
                    .style('width', this.nodeWidth + 'px')
                    .style('height', this.nodeHeight + 'px')
                    .style('left', function (node) { return (node.parent ? node.parent.x : node.x) + 'px'; })
                    .style('top', function (node) { return (node.parent ? node.parent.y : node.y) + 'px'; })
                    .style('opacity', 0)
                    .on('keydown', this.onKeydown.bind(this))
                    .on('focus', this.onFocus.bind(this))
                    .on('mousedown', function () { return d3Selection.event.stopPropagation(); })
                    .on('click', this.toggle.bind(this))
                    .each(this.renderNodeTemplate.bind(this))
                    .each(function (node, index, group) { return _this.monitorFocus(group[index], node); })
                    .transition(defaultTransition)
                    .style('left', function (node) { return node.x + 'px'; })
                    .style('top', function (node) { return node.y + 'px'; })
                    .style('opacity', 1);
                // apply any movements while nodes are 'alive'
                this._nodes.transition(defaultTransition)
                    .style('left', function (node) { return node.x + 'px'; })
                    .style('top', function (node) { return node.y + 'px'; });
                // apply transitions when removing nodes
                this._nodes.exit()
                    .transition(defaultTransition)
                    .style('left', function (node) { return (node.parent ? node.parent.x : node.x) + 'px'; })
                    .style('opacity', 0)
                    .remove()
                    .on('end', function (node) { return _this.destroyNode(node); });
                // update the position of the reveal button
                d3Selection.select(this.revealElement.nativeElement)
                    .style('left', ((this.nodeWidth / 2) - (this.revealElement.nativeElement.offsetWidth / 2)) + 'px')
                    .style('top', -((this.nodeHeight / 2) + (this.revealElement.nativeElement.offsetHeight / 2)) + 'px');
                // after any new links and nodes have been created or removed we should update the selections
                this.updateSelections();
                // update the selected classes - ensure there is always a selected node
                if (!this._selected) {
                    this.select(this._pendingSelection || this.dataset);
                    this._pendingSelection = null;
                }
                // set the tab indexes and aria labels for any newly added items
                this.setNodeAttributes();
                // apply the current camera position to any new nodes/links
                this.applyCameraPosition();
                // reset the connector changed status
                this._hasConnectorChanged = false;
            };
        /** Select a specified node */
        /**
         * Select a specified node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.select = /**
         * Select a specified node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // get the node in the desired format
                node = ( /** @type {?} */(this.coerceDataNode(node)));
                // check if the node is already selected
                if (this._selected === node) {
                    return;
                }
                // ensure all parents are expanded
                this.expandParents(node);
                // deselect any current node
                this.deselect(false);
                // if the selected item has changed then store the latest selection
                this._selected = node;
                // emit the latest selection
                this.selectedChange.next(this._selected);
                // show reveal any nodes that may previously have been hidden but are now visible due to selection
                if (this._isInitialised) {
                    this.render();
                }
                // add the styling to the selected node
                this._renderer.addClass(this.getNodeElement(this._selected), 'ux-organization-chart-node-selected');
                // update the styling and tabindexes
                this.setNodeAttributes();
            };
        /** Deselect the currently selected node */
        /**
         * Deselect the currently selected node
         * @param {?=} emit
         * @return {?}
         */
        OrganizationChartComponent.prototype.deselect = /**
         * Deselect the currently selected node
         * @param {?=} emit
         * @return {?}
         */
            function (emit) {
                var _this = this;
                if (emit === void 0) {
                    emit = true;
                }
                if (this._nodes) {
                    this._nodes.nodes().forEach(function (element) { return _this._renderer.removeClass(element, 'ux-organization-chart-node-selected'); });
                }
                if (emit && !!this._selected) {
                    this._selected = null;
                    this.selectedChange.next(null);
                    // update the tab indexes and aria labels
                    this.setNodeAttributes();
                }
            };
        /** Toggle the collapsed state of a node */
        /**
         * Toggle the collapsed state of a node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.toggle = /**
         * Toggle the collapsed state of a node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // do nothing if a transition is currently in progress
                if (this._isTransitioning) {
                    return;
                }
                // get the node in the desired format
                node = ( /** @type {?} */(this.coercePointNode(node)));
                // ensure the clicked node is selected
                this.select(node);
                // apply the appropriate action
                this.isExpanded(node) ? this.collapse(node) : this.expand(node);
            };
        /** Expand a node */
        /**
         * Expand a node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.expand = /**
         * Expand a node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // do nothing if a transition is currently in progress
                if (this._isTransitioning) {
                    return;
                }
                // get the node in the desired format
                node = ( /** @type {?} */(this.coercePointNode(node)));
                // ensure this node and all parent nodes are expanded
                node.ancestors().forEach(function (_node) { return _node.data.expanded = true; });
                // re-render the nodes
                this.render();
                // if the node has children then we want to move the camera to a child node
                if (Array.isArray(node.data.children) && node.data.children.length > 0) {
                    // center on the middle child
                    this.centerNode(node.data.children[Math.floor(node.data.children.length / 2)]);
                }
                else {
                    this.centerNode(node);
                }
            };
        /** Collapse a node */
        /**
         * Collapse a node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.collapse = /**
         * Collapse a node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // do nothing if a transition is currently in progress
                if (this._isTransitioning) {
                    return;
                }
                // get the node in the desired format
                node = ( /** @type {?} */(this.coercePointNode(node)));
                // ensure this node and all child nodes are collapse
                node.descendants().forEach(function (_node) { return _node.data.expanded = false; });
                // re-render the nodes
                this.render();
                // center the node that has just been collapsed
                this.centerNode(node);
            };
        /** Move a specific node to the center of the screen */
        /**
         * Move a specific node to the center of the screen
         * @param {?} node
         * @param {?=} axis
         * @param {?=} animate
         * @return {?}
         */
        OrganizationChartComponent.prototype.centerNode = /**
         * Move a specific node to the center of the screen
         * @param {?} node
         * @param {?=} axis
         * @param {?=} animate
         * @return {?}
         */
            function (node, axis, animate) {
                if (axis === void 0) {
                    axis = OrganizationChartAxis.Both;
                }
                if (animate === void 0) {
                    animate = true;
                }
                // get the node in the desired format
                node = ( /** @type {?} */(this.coercePointNode(node)));
                // get the current camera position
                /** @type {?} */
                var camera = this.getCameraPosition();
                /** @type {?} */
                var x = axis === OrganizationChartAxis.Vertical ? camera.x : (this._width / 2) - (node.x + (this.nodeWidth / 2));
                /** @type {?} */
                var y = axis === OrganizationChartAxis.Horizontal ? camera.y : (this._height / 2) - (node.y + (this.nodeHeight / 2));
                // update the camera position
                this.setCameraPosition(x, y, animate);
            };
        /** Explicity set the position of the camera */
        /**
         * Explicity set the position of the camera
         * @param {?} x
         * @param {?} y
         * @param {?=} animate
         * @return {?}
         */
        OrganizationChartComponent.prototype.setCameraPosition = /**
         * Explicity set the position of the camera
         * @param {?} x
         * @param {?} y
         * @param {?=} animate
         * @return {?}
         */
            function (x, y, animate) {
                var _this = this;
                if (animate === void 0) {
                    animate = true;
                }
                // get the current transform
                /** @type {?} */
                var camera = d3Zoom.zoomTransform(this._nodesContainer.node());
                // do nothing if the co-orindates have not changed
                if (camera.x === x && camera.y === y) {
                    return;
                }
                // update the camera position
                camera = camera.translate(x - camera.x, y - camera.y);
                // indicate that the camera is panning programmatically
                this._isPanning = true;
                if (animate) {
                    this._nodesContainer.transition()
                        .duration(this.duration)
                        .call(this._zoom.transform, camera)
                        .on('end interrupt cancel', function () { return _this._isPanning = false; });
                }
                else {
                    this._nodesContainer.call(this._zoom.transform, camera);
                    this._isPanning = false;
                }
            };
        /** Move the camera an amount from its current position */
        /**
         * Move the camera an amount from its current position
         * @param {?} x
         * @param {?} y
         * @param {?=} animate
         * @return {?}
         */
        OrganizationChartComponent.prototype.moveCamera = /**
         * Move the camera an amount from its current position
         * @param {?} x
         * @param {?} y
         * @param {?=} animate
         * @return {?}
         */
            function (x, y, animate) {
                if (animate === void 0) {
                    animate = true;
                }
                // get the current camera position
                /** @type {?} */
                var camera = this.getCameraPosition();
                this.setCameraPosition(camera.x + x, camera.y + y, animate);
            };
        /** Focus a given node */
        /**
         * Focus a given node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focus = /**
         * Focus a given node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                this.focusNode(this.coercePointNode(node));
            };
        /** Focus the root node */
        /**
         * Focus the root node
         * @return {?}
         */
        OrganizationChartComponent.prototype._focusRootNode = /**
         * Focus the root node
         * @return {?}
         */
            function () {
                this.focusNode(this.coercePointNode(this.dataset));
            };
        /** Destroy the outlet and portal associated with a node */
        /**
         * Destroy the outlet and portal associated with a node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.destroyNode = /**
         * Destroy the outlet and portal associated with a node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // get the node in a consistent format
                node = this.coercePointNode(node);
                // remove focus monitoring
                if (this._indicators.has(node.data)) {
                    // remove the focus monitoring
                    this._indicators.get(node.data).destroy();
                    // remove the indicator from the list of indicators
                    this._indicators.delete(node.data);
                }
                // if there is not portal/outlets associated with this node then do nothing
                if (!this._portals.has(node.data)) {
                    return;
                }
                // get the portal and outlet from the map
                /** @type {?} */
                var portalRef = this._portals.get(node.data);
                // perform the cleanup
                portalRef.portal.detach();
                portalRef.outlet.dispose();
                // remove this entry from the map
                this._portals.delete(node.data);
            };
        // update the data structure for the node and link layouts
        // update the data structure for the node and link layouts
        /**
         * @return {?}
         */
        OrganizationChartComponent.prototype.updateLayout =
            // update the data structure for the node and link layouts
            /**
             * @return {?}
             */
            function () {
                this._layout = this.getLayout();
                this._nodeLayout = this._layout.descendants();
                this._linkLayout = this._layout.links();
            };
        /** Ensure the selections stay in sync with the view */
        /**
         * Ensure the selections stay in sync with the view
         * @return {?}
         */
        OrganizationChartComponent.prototype.updateSelections = /**
         * Ensure the selections stay in sync with the view
         * @return {?}
         */
            function () {
                // select all the newly added dom nodes and associate the dataset
                this._nodes = ( /** @type {?} */(this._nodesContainer.selectAll('.ux-organization-chart-node')
                    .data(this._nodeLayout, function (node) { return node.data.id.toString(); })));
                // select all the newly added path nodes
                this._links = ( /** @type {?} */(this._linksContainer.selectAll('.ux-organization-chart-link')
                    .data(this._linkLayout, function (link) {
                    return link.source.data.id + "-" + link.target.data.id;
                })));
            };
        /** Render the content of the node based on the template provided */
        /**
         * Render the content of the node based on the template provided
         * @param {?} node
         * @param {?} index
         * @param {?} group
         * @return {?}
         */
        OrganizationChartComponent.prototype.renderNodeTemplate = /**
         * Render the content of the node based on the template provided
         * @param {?} node
         * @param {?} index
         * @param {?} group
         * @return {?}
         */
            function (node, index, group) {
                var _this = this;
                // create the context for the node
                /** @type {?} */
                var context = {
                    data: node.data.data,
                    node: node.data,
                    focused: false
                };
                // the focused state should be a getter
                Object.defineProperty(context, 'focused', {
                    get: function () { return _this._focused === node.data; }
                });
                // create the outlet to insert the Template and the portal from the TemplateRef
                /** @type {?} */
                var outlet = this.createPortalOutlet(group[index]);
                /** @type {?} */
                var portal$$1 = new portal.TemplatePortal(this.nodeTemplate, this._viewContainerRef, context);
                // insert the TemplateRef into the specified region
                portal$$1.attach(outlet);
                // store the portal and outlet so we can correctly dispose of the nodes
                this._portals.set(node.data, { portal: portal$$1, outlet: outlet });
            };
        /** Handle any zoom events (we use zoom for panning behaviour) */
        /**
         * Handle any zoom events (we use zoom for panning behaviour)
         * @return {?}
         */
        OrganizationChartComponent.prototype.applyCameraPosition = /**
         * Handle any zoom events (we use zoom for panning behaviour)
         * @return {?}
         */
            function () {
                // get the new x and y position
                var _a = d3Zoom.zoomTransform(this._nodesContainer.node()), x = _a.x, y = _a.y;
                // round the precision to integers to prevent any anti-aliasing
                x = Math.round(x);
                y = Math.round(y);
                // transform the position of the reveal button
                this._renderer.setStyle(this.revealElement.nativeElement, 'transform', "translate(" + x + "px, " + y + "px)");
                // transform the position of the nodes
                this._nodesContainer.selectAll('.ux-organization-chart-node').style('transform', "translate(" + x + "px, " + y + "px)");
                // transform the position of the links
                this._linksContainer.selectAll('.ux-organization-chart-link').attr('transform', "translate(" + x + " " + y + ")");
            };
        /** Get the data in with the required layout information */
        /**
         * Get the data in with the required layout information
         * @return {?}
         */
        OrganizationChartComponent.prototype.getLayout = /**
         * Get the data in with the required layout information
         * @return {?}
         */
            function () {
                var _this = this;
                // create a hierarchical representation of the data - don't include collapsed nodes
                /** @type {?} */
                var treeHierarchy = d3Hierarchy.hierarchy(this.dataset, function (node) { return Array.isArray(node.children) && node.expanded ? node.children : []; });
                // create our layout
                /** @type {?} */
                var layout = d3Hierarchy.tree()
                    .nodeSize([this.nodeWidth, this.nodeHeight])
                    .separation(this.getNodeSpacing.bind(this));
                // process the data with the layout
                /** @type {?} */
                var treeLayout = layout(treeHierarchy);
                // calculate the vertical spacing
                /** @type {?} */
                var verticalSpacing = this.verticalSpacing === undefined ? this.nodeHeight : this.verticalSpacing;
                // set the vertical spacing
                treeLayout.each(function (data) { return data.y = data.depth * (_this.nodeHeight + verticalSpacing); });
                return treeLayout;
            };
        /** Determine how much horizontal spacing should be between nodes */
        /**
         * Determine how much horizontal spacing should be between nodes
         * @param {?} nodeOne
         * @param {?} nodeTwo
         * @return {?}
         */
        OrganizationChartComponent.prototype.getNodeSpacing = /**
         * Determine how much horizontal spacing should be between nodes
         * @param {?} nodeOne
         * @param {?} nodeTwo
         * @return {?}
         */
            function (nodeOne, nodeTwo) {
                // if the nodes are not siblings then space further apart
                if (nodeOne.parent !== nodeTwo.parent) {
                    return 2;
                }
                // if they are siblings they should be closer together
                return 1.5;
            };
        /** Ensure we consistently use the HierarchyPoint data structure */
        /**
         * Ensure we consistently use the HierarchyPoint data structure
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.coercePointNode = /**
         * Ensure we consistently use the HierarchyPoint data structure
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // determine if this is a raw data node or a hierarchy point
                if (node.hasOwnProperty('depth') && node.hasOwnProperty('x') && node.hasOwnProperty('y')) {
                    return ( /** @type {?} */(node));
                }
                // otherwise find the matching node
                /** @type {?} */
                var match = this._nodeLayout.find(function (_node) { return _node.data === node; });
                // if the data does not exist in the hierarchy throw an exception
                if (!match) {
                    throw new Error("The node does not exist in the hierarchy");
                }
                return match;
            };
        /**
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.coerceDataNode = /**
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.hasOwnProperty('depth') && node.hasOwnProperty('x') && node.hasOwnProperty('y')) {
                    return (( /** @type {?} */(node))).data;
                }
                return ( /** @type {?} */(node));
            };
        /** Handle chart resize events */
        /**
         * Handle chart resize events
         * @param {?} __0
         * @return {?}
         */
        OrganizationChartComponent.prototype.onResize = /**
         * Handle chart resize events
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var width = _a.width, height = _a.height;
                this._width = width;
                this._height = height;
            };
        /** Deteremine if a node is expanded or collapsed */
        /**
         * Deteremine if a node is expanded or collapsed
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.isExpanded = /**
         * Deteremine if a node is expanded or collapsed
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return !!node.data.expanded;
            };
        /** Get the current position of the camera */
        /**
         * Get the current position of the camera
         * @return {?}
         */
        OrganizationChartComponent.prototype.getCameraPosition = /**
         * Get the current position of the camera
         * @return {?}
         */
            function () {
                return d3Zoom.zoomTransform(this._nodesContainer.node());
            };
        /** Get the SVG line definition for each link */
        /**
         * Get the SVG line definition for each link
         * @param {?} pointLink
         * @return {?}
         */
        OrganizationChartComponent.prototype.getLinkPath = /**
         * Get the SVG line definition for each link
         * @param {?} pointLink
         * @return {?}
         */
            function (pointLink) {
                if (this.connector === 'elbow') {
                    /** @type {?} */
                    var source = { x: pointLink.source.x + (this.nodeWidth / 2), y: pointLink.source.y + this.nodeHeight };
                    /** @type {?} */
                    var target = { x: pointLink.target.x + (this.nodeWidth / 2), y: pointLink.target.y };
                    return 'M' + source.x + ',' + (source.y) +
                        'v' + ((target.y - source.y) / 2) +
                        'h' + (target.x - source.x) +
                        'v' + ((target.y - source.y) / 2);
                }
                else {
                    /** @type {?} */
                    var source = { x: pointLink.source.x + (this.nodeWidth / 2), y: pointLink.source.y + (this.nodeHeight / 2) };
                    /** @type {?} */
                    var target = { x: pointLink.target.x + (this.nodeWidth / 2), y: pointLink.target.y + (this.nodeHeight / 2) };
                    return d3Shape.linkVertical()({ source: [source.x, source.y], target: [target.x, target.y] });
                }
            };
        /** Get the link path line defintion when the link is collapsing */
        /**
         * Get the link path line defintion when the link is collapsing
         * @param {?} pointLink
         * @return {?}
         */
        OrganizationChartComponent.prototype.getCollapsedLinkPath = /**
         * Get the link path line defintion when the link is collapsing
         * @param {?} pointLink
         * @return {?}
         */
            function (pointLink) {
                return this.getLinkPath({ source: pointLink.source, target: pointLink.source });
            };
        /** Create a dynamic region that Angular can insert into */
        /**
         * Create a dynamic region that Angular can insert into
         * @param {?} element
         * @return {?}
         */
        OrganizationChartComponent.prototype.createPortalOutlet = /**
         * Create a dynamic region that Angular can insert into
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return new portal.DomPortalOutlet(element, this._componentFactoryResolver, this._appRef, this._injector);
            };
        /** Make the appropriate node tabbable and update aria attributes */
        /**
         * Make the appropriate node tabbable and update aria attributes
         * @return {?}
         */
        OrganizationChartComponent.prototype.setNodeAttributes = /**
         * Make the appropriate node tabbable and update aria attributes
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    for (var _b = __values(this._nodes.nodes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var element = _c.value;
                        // intially the tab index of all items to -1
                        this._renderer.setAttribute(element, 'tabindex', '-1');
                        // set the expanded aria attribute
                        this._renderer.setAttribute(element, 'aria-expanded', !!this.getNodeData(element).data.expanded ? 'true' : 'false');
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // if there is a selected item then it should be tabbable otherwise make the root tabbable
                if (this._selected) {
                    this._renderer.setAttribute(this.getNodeElement(this._selected), 'tabindex', '0');
                }
            };
        /** Get the element that represents a given node */
        /**
         * Get the element that represents a given node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.getNodeElement = /**
         * Get the element that represents a given node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                node = this.coercePointNode(node);
                // find the element that matches the node data
                /** @type {?} */
                var index = this._nodes.data().indexOf(node);
                return this._nodes.nodes()[index];
            };
        /** Get the element that represents a given node */
        /**
         * Get the element that represents a given node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.getNodeData = /**
         * Get the element that represents a given node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // find the element that matches the node element
                /** @type {?} */
                var index = this._nodes.nodes().indexOf(node);
                return this._nodes.data()[index];
            };
        /** Handle keyboard events */
        /**
         * Handle keyboard events
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.onKeydown = /**
         * Handle keyboard events
         * @param {?} node
         * @return {?}
         */
            function (node) {
                switch (d3Selection.event.keyCode) {
                    case keycodes.DOWN_ARROW:
                        d3Selection.event.preventDefault();
                        // if the node is collapsed and has children expand
                        if (!node.data.expanded && Array.isArray(node.data.children) && node.data.children.length > 0) {
                            return this.expand(node);
                        }
                        return this.focusChild(node);
                    case keycodes.RIGHT_ARROW:
                        d3Selection.event.preventDefault();
                        return this.focusNextSibling(node);
                    case keycodes.UP_ARROW:
                        d3Selection.event.preventDefault();
                        return this.focusParent(node);
                    case keycodes.LEFT_ARROW:
                        d3Selection.event.preventDefault();
                        return this.focusPreviousSibling(node);
                    case keycodes.ENTER:
                        return this.toggle(node);
                }
            };
        /** When a node receives focus */
        /**
         * When a node receives focus
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.onFocus = /**
         * When a node receives focus
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (!this.isNodeInViewport(node, this._width * 0.1, this._height * 0.1)) {
                    this.centerNode(node);
                }
            };
        /** Move focus to the parent node */
        /**
         * Move focus to the parent node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focusParent = /**
         * Move focus to the parent node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.parent) {
                    this.focusNode(node.parent);
                }
                else if (this.revealElement) {
                    this.revealElement.nativeElement.focus();
                    // center the root node to ensure the reveal button is in view
                    this.centerNode(this.dataset);
                }
            };
        /** Move focus to the child node */
        /**
         * Move focus to the child node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focusChild = /**
         * Move focus to the child node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (Array.isArray(node.children) && node.children.length > 0) {
                    this.focusNode(node.children[Math.floor(node.children.length / 2)]);
                }
            };
        /** Move focus to the sibling on the left */
        /**
         * Move focus to the sibling on the left
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focusPreviousSibling = /**
         * Move focus to the sibling on the left
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.parent) {
                    this.focusNode(node.parent.children[node.parent.children.indexOf(node) - 1]);
                }
            };
        /** Move focus to the sibling on the right */
        /**
         * Move focus to the sibling on the right
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focusNextSibling = /**
         * Move focus to the sibling on the right
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.parent) {
                    this.focusNode(node.parent.children[node.parent.children.indexOf(node) + 1]);
                }
            };
        /** Focus a given node */
        /**
         * Focus a given node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.focusNode = /**
         * Focus a given node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node) {
                    this.getNodeElement(node).focus({ preventScroll: true });
                    // ensure we don't perform scrolling if the node is not in view (we rely on preventScroll as IE doesn't support it)
                    this.nodesContainer.nativeElement.scrollTop = 0;
                    this.nodesContainer.nativeElement.scrollLeft = 0;
                }
            };
        /** Determine if a node is fully visible within the viewport */
        /**
         * Determine if a node is fully visible within the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
        OrganizationChartComponent.prototype.isNodeInViewport = /**
         * Determine if a node is fully visible within the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
            function (node, insetX, insetY) {
                if (insetX === void 0) {
                    insetX = 0;
                }
                if (insetY === void 0) {
                    insetY = 0;
                }
                var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
                /** @type {?} */
                var left = node.x + x;
                /** @type {?} */
                var top = node.y + y;
                /** @type {?} */
                var right = node.x + x + this.nodeWidth;
                /** @type {?} */
                var bottom = node.y + y + this.nodeHeight;
                return left >= insetX && top >= insetY && right <= (this._width - insetX) && bottom <= (this._height - insetY);
            };
        /** Determine if a node is fully outside of the viewport */
        /**
         * Determine if a node is fully outside of the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
        OrganizationChartComponent.prototype.isNodeOutsideViewport = /**
         * Determine if a node is fully outside of the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
            function (node, insetX, insetY) {
                if (insetX === void 0) {
                    insetX = 0;
                }
                if (insetY === void 0) {
                    insetY = 0;
                }
                var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
                /** @type {?} */
                var left = node.x + x + this.nodeWidth;
                /** @type {?} */
                var top = node.y + y + this.nodeHeight;
                /** @type {?} */
                var right = node.x + x;
                /** @type {?} */
                var bottom = node.y + y;
                return left < insetX || top < insetY || right > (this._width - insetX) || bottom > (this._height - insetY);
            };
        /** Determine how far a node is from being within the viewport */
        /**
         * Determine how far a node is from being within the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
        OrganizationChartComponent.prototype.getDistanceFromViewport = /**
         * Determine how far a node is from being within the viewport
         * @param {?} node
         * @param {?=} insetX
         * @param {?=} insetY
         * @return {?}
         */
            function (node, insetX, insetY) {
                if (insetX === void 0) {
                    insetX = 0;
                }
                if (insetY === void 0) {
                    insetY = 0;
                }
                // if the node is in the viewport then it will always be 0, 0
                if (!this.isNodeOutsideViewport(node, insetX, insetY)) {
                    return [0, 0];
                }
                var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
                /** @type {?} */
                var left = insetX - (node.x + x + this.nodeWidth);
                /** @type {?} */
                var top = insetY - (node.y + y + this.nodeHeight);
                /** @type {?} */
                var right = (node.x + x) - (this._width - insetX);
                /** @type {?} */
                var bottom = (node.y + y) - (this._height - insetY);
                /** @type {?} */
                var horizontal = 0;
                /** @type {?} */
                var vertical = 0;
                if (left > 0 && left > right) {
                    horizontal = left;
                }
                if (right > 0 && left < right) {
                    horizontal = -right;
                }
                if (top > 0 && top > bottom) {
                    vertical = top;
                }
                if (bottom > 0 && top < bottom) {
                    vertical = -bottom;
                }
                // calculate the distances on both axis
                return [horizontal, vertical];
            };
        /** Begin monitoring the element focus so we only show styling when navigated by keyboard */
        /**
         * Begin monitoring the element focus so we only show styling when navigated by keyboard
         * @param {?} element
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.monitorFocus = /**
         * Begin monitoring the element focus so we only show styling when navigated by keyboard
         * @param {?} element
         * @param {?} node
         * @return {?}
         */
            function (element, node) {
                var _this = this;
                // create the focus indicator
                /** @type {?} */
                var indicator = this._focusIndicator.monitor(element, { checkChildren: false, programmaticFocusIndicator: true });
                // store the currently selected node as an instance variable
                indicator.isFocused$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isFocused) {
                    // by default the CDK runs this outside of NgZone however we need it to run inside NgZone to update the node template
                    _this._ngZone.run(function () {
                        if (isFocused) {
                            _this._focused = node.data;
                        }
                        else if (node.data === _this._focused) {
                            _this._focused = null;
                        }
                    });
                });
                // store the focus indicator reference
                this._indicators.set(node.data, indicator);
            };
        // ensure that there are at least some nodes visible
        // ensure that there are at least some nodes visible
        /**
         * @return {?}
         */
        OrganizationChartComponent.prototype.ensureNodesAreVisible =
            // ensure that there are at least some nodes visible
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                // determine how many nodes are currently visible
                /** @type {?} */
                var visibleCount = this._nodes.filter(function (node) { return !_this.isNodeOutsideViewport(node); }).size();
                if (visibleCount > 0) {
                    return;
                }
                // get the distance each node is from being within the viewport
                /** @type {?} */
                var distances = this._nodes.data().map(function (node) { return _this.getDistanceFromViewport(node, _this.nodeWidth * 1.25, _this.nodeHeight * 1.5); });
                // find the closest node
                var _a = __read(distances.reduce(function (previous, current) {
                    var _a = __read(previous, 2), previousX = _a[0], previousY = _a[1];
                    var _b = __read(current, 2), currentX = _b[0], currentY = _b[1];
                    return (Math.abs(previousX) + Math.abs(previousY)) < (Math.abs(currentX) + Math.abs(currentY)) ? previous : current;
                }), 2), x = _a[0], y = _a[1];
                // move the camera by the required amount
                this.moveCamera(x, y);
            };
        /** Expand all parent nodes */
        /**
         * Expand all parent nodes
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.expandParents = /**
         * Expand all parent nodes
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // get the parent node
                /** @type {?} */
                var parent = this.getParent(node);
                while (parent) {
                    parent.expanded = true;
                    parent = this.getParent(parent);
                }
            };
        /** Get the parent of a given node */
        /**
         * Get the parent of a given node
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.getParent = /**
         * Get the parent of a given node
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return __spread([this.coerceDataNode(this.dataset)], this.getAllChildren(this.dataset)).find(function (_node) {
                    if (!Array.isArray(_node.children)) {
                        return false;
                    }
                    return _node.children.find(function (child) { return child.id === node.id; });
                });
            };
        /** Get a flat array of all the nodes childrent */
        /**
         * Get a flat array of all the nodes childrent
         * @param {?} node
         * @return {?}
         */
        OrganizationChartComponent.prototype.getAllChildren = /**
         * Get a flat array of all the nodes childrent
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                /** @type {?} */
                var children = node.children || [];
                // check for any children on the children
                return __spread(children, children.reduce(function (accumulation, child) { return __spread(accumulation, _this.getAllChildren(child)); }, [])).map(function (child) { return _this.coerceDataNode(child); });
            };
        OrganizationChartComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-organization-chart',
                        template: "<!-- Add a button above the root node to load additional parent items -->\n<button #revealElement\n    uxFocusIndicatorOrigin\n    class=\"ux-organization-chart-reveal\"\n    tabindex=\"-1\"\n    [attr.aria-label]=\"revealAriaLabel\"\n    [hidden]=\"!showReveal\"\n    (click)=\"reveal.emit(); _focusRootNode()\"\n    (keydown.ArrowDown)=\"_focusRootNode(); $event.preventDefault()\">\n\n    <!-- Display Reveal Template -->\n    <ng-container [ngTemplateOutlet]=\"revealTemplate || defaultRevealTemplate\"></ng-container>\n</button>\n\n<!-- Show the links connecting each node -->\n<svg #links class=\"ux-organization-chart-links\"></svg>\n\n<!-- Show the nodes containing information about each item -->\n<div #nodes class=\"ux-organization-chart-nodes\"></div>\n\n<!-- Provide a default reveal template -->\n<ng-template #defaultRevealTemplate>\n    <ux-icon name=\"tab-up\"></ux-icon>\n</ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        OrganizationChartComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizeService },
                { type: i0.ComponentFactoryResolver },
                { type: i0.Injector },
                { type: i0.ApplicationRef },
                { type: i0.ViewContainerRef },
                { type: i0.Renderer2 },
                { type: FocusIndicatorService },
                { type: i0.NgZone }
            ];
        };
        OrganizationChartComponent.propDecorators = {
            dataset: [{ type: i0.Input }],
            connector: [{ type: i0.Input }],
            nodeWidth: [{ type: i0.Input }],
            nodeHeight: [{ type: i0.Input }],
            duration: [{ type: i0.Input }],
            verticalSpacing: [{ type: i0.Input }],
            showReveal: [{ type: i0.Input }],
            revealAriaLabel: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            reveal: [{ type: i0.Output }],
            transitionEnd: [{ type: i0.Output }],
            revealTemplate: [{ type: i0.ContentChild, args: ['revealTemplate', { static: false },] }],
            nodeTemplate: [{ type: i0.ContentChild, args: ['nodeTemplate', { static: false },] }],
            revealElement: [{ type: i0.ViewChild, args: ['revealElement', { static: true },] }],
            linksContainer: [{ type: i0.ViewChild, args: ['links', { static: true },] }],
            nodesContainer: [{ type: i0.ViewChild, args: ['nodes', { static: true },] }]
        };
        return OrganizationChartComponent;
    }());
    /** @enum {number} */
    var OrganizationChartAxis = {
        Horizontal: 0,
        Vertical: 1,
        Both: 2,
    };
    OrganizationChartAxis[OrganizationChartAxis.Horizontal] = 'Horizontal';
    OrganizationChartAxis[OrganizationChartAxis.Vertical] = 'Vertical';
    OrganizationChartAxis[OrganizationChartAxis.Both] = 'Both';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var OrganizationChartModule = /** @class */ (function () {
        function OrganizationChartModule() {
        }
        OrganizationChartModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            OrganizationChartComponent
                        ],
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            IconModule,
                            ResizeModule,
                        ],
                        exports: [
                            OrganizationChartComponent
                        ]
                    },] }
        ];
        return OrganizationChartModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabHeadingDirective = /** @class */ (function () {
        function TabHeadingDirective() {
        }
        TabHeadingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTabHeading]'
                    },] }
        ];
        return TabHeadingDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabsetService = /** @class */ (function () {
        function TabsetService() {
            /**
             * Store the list of tabs
             */
            this.tabs = [];
            /**
             * Store the manual state
             */
            this.manual = false;
        }
        /** Update the array of tabs - required to preserve order */
        /**
         * Update the array of tabs - required to preserve order
         * @param {?} tabs
         * @return {?}
         */
        TabsetService.prototype.update = /**
         * Update the array of tabs - required to preserve order
         * @param {?} tabs
         * @return {?}
         */
            function (tabs) {
                this.tabs = __spread(tabs);
            };
        /** Programmatically select a tab */
        /**
         * Programmatically select a tab
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.select = /**
         * Programmatically select a tab
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                if (!tab.disabled) {
                    // update the active state of each tab accordingly
                    this.tabs.forEach(function (_tab) { return _tab === tab ? _tab.selectTab() : _tab.deselectTab(); });
                }
            };
        /** Determine if there is a selected tab */
        /**
         * Determine if there is a selected tab
         * @return {?}
         */
        TabsetService.prototype.isTabActive = /**
         * Determine if there is a selected tab
         * @return {?}
         */
            function () {
                return !!this.tabs.find(function (tab) { return tab.active; });
            };
        /** Select the first non-disabled tab */
        /**
         * Select the first non-disabled tab
         * @return {?}
         */
        TabsetService.prototype.selectFirstTab = /**
         * Select the first non-disabled tab
         * @return {?}
         */
            function () {
                // find the index of the first non-disabled tab
                /** @type {?} */
                var tab = this.tabs.find(function (_tab) { return !_tab.disabled; });
                if (tab) {
                    this.select(tab);
                }
            };
        TabsetService.decorators = [
            { type: i0.Injectable }
        ];
        return TabsetService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueTabId = 0;
    var TabComponent = /** @class */ (function () {
        function TabComponent(_tabset, _changeDetector) {
            this._tabset = _tabset;
            this._changeDetector = _changeDetector;
            /**
             * Define the tab unique id
             */
            this.id = "ux-tab-" + ++uniqueTabId;
            /**
             * Define the active state of this tab
             */
            this.active = false;
            /**
             * Define if this tab is disabled
             */
            this.disabled = false;
            /**
             * Emit when this tab is selected
             */
            this.activated = new i0.EventEmitter();
            /**
             * Emit when this tab is deselected
             */
            this.deactivated = new i0.EventEmitter();
            /**
             * Unsubscribe from all subscriptions when component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        TabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TabComponent.prototype.selectTab = /**
         * @return {?}
         */
            function () {
                // if this tab is currently active do nothing
                if (this.active && !this._tabset.manual) {
                    return;
                }
                if (!this._tabset.manual) {
                    this.active = true;
                }
                this.activated.emit();
                this._changeDetector.detectChanges();
            };
        /**
         * @return {?}
         */
        TabComponent.prototype.deselectTab = /**
         * @return {?}
         */
            function () {
                // if this tab is not currently active do nothing
                if (!this.active && !this._tabset.manual) {
                    return;
                }
                if (!this._tabset.manual) {
                    this.active = false;
                }
                this.deactivated.emit();
                this._changeDetector.detectChanges();
            };
        TabComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-tab',
                        template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [style.display]=\"active ? 'block' : 'none'\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!active\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TabComponent.ctorParameters = function () {
            return [
                { type: TabsetService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        TabComponent.propDecorators = {
            id: [{ type: i0.Input }],
            active: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            heading: [{ type: i0.Input }],
            customClass: [{ type: i0.Input }],
            activated: [{ type: i0.Output }],
            deactivated: [{ type: i0.Output }],
            headingRef: [{ type: i0.ContentChild, args: [TabHeadingDirective, { read: i0.TemplateRef, static: false },] }]
        };
        return TabComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabsetComponent = /** @class */ (function () {
        function TabsetComponent(_tabset, _changeDetector) {
            this._tabset = _tabset;
            this._changeDetector = _changeDetector;
            /**
             * Determine if the appearance of the tabset
             */
            this.minimal = true;
            /**
             * Determine if the tabset should appear stacked
             */
            this.stacked = 'none';
            /**
             * Remove subscriptions on destroy
             */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(TabsetComponent.prototype, "manual", {
            /** Determine if we want to manually update the active state */
            set: /**
             * Determine if we want to manually update the active state
             * @param {?} manual
             * @return {?}
             */ function (manual) {
                this._tabset.manual = manual;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabsetComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // provide the service with the initial array of items
                this._tabset.update(this._tabs.toArray());
                // Make sure a tab is selected
                if (!this._tabset.isTabActive()) {
                    this._tabset.selectFirstTab();
                }
                // run change detection once we have setup the tabs
                this._changeDetector.detectChanges();
                // watch for any future changes
                this._tabs.changes.pipe(operators.takeUntil(this._onDestroy$)).subscribe(function (tabs) {
                    // update the internal list of tabs
                    _this._tabset.update(tabs);
                    // run change detection
                    _this._changeDetector.detectChanges();
                });
            };
        /**
         * @return {?}
         */
        TabsetComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy$.next();
                this._onDestroy$.complete();
            };
        TabsetComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-tabset',
                        template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    uxTabbableList\n    [direction]=\"stacked === 'none' ? 'horizontal' : 'vertical'\"\n    [allowBoundaryKeys]=\"true\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\"\n        class=\"nav-item\"\n        *ngFor=\"let tab of _tabset.tabs; let index = index\"\n        [class.active]=\"tab.active\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            uxTabbableListItem\n            uxFocusIndicator\n            (mousedown)=\"_tabset.select(tab)\"\n            (activated)=\"_tabset.select(tab)\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [TabsetService],
                        host: {
                            '[class.tabs-left]': 'stacked === "left"',
                            '[class.tabs-right]': 'stacked === "right"',
                        }
                    }] }
        ];
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () {
            return [
                { type: TabsetService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        TabsetComponent.propDecorators = {
            minimal: [{ type: i0.Input }],
            stacked: [{ type: i0.Input }],
            manual: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            _tabs: [{ type: i0.ContentChildren, args: [TabComponent,] }]
        };
        return TabsetComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TabsetModule = /** @class */ (function () {
        function TabsetModule() {
        }
        TabsetModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule
                        ],
                        exports: [
                            TabsetComponent,
                            TabComponent,
                            TabHeadingDirective
                        ],
                        declarations: [
                            TabsetComponent,
                            TabComponent,
                            TabHeadingDirective
                        ],
                    },] }
        ];
        return TabsetModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderCustomMenuDirective = /** @class */ (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxPageHeaderCustomMenu]'
                    },] }
        ];
        return PageHeaderCustomMenuDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderIconMenuComponent = /** @class */ (function () {
        function PageHeaderIconMenuComponent() {
        }
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.select) {
                    item.select.call(item, item);
                }
            };
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.keydownHandler = /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
            function (item, event) {
                switch (event.keyCode) {
                    case keycodes.ENTER:
                    case keycodes.SPACE:
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        /**
         * @param {?} identifier
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype._getIconType = /**
         * @param {?} identifier
         * @return {?}
         */
            function (identifier) {
                return identifier ? getIconType(identifier) : '';
            };
        PageHeaderIconMenuComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-page-header-icon-menu',
                        template: "<div class=\"page-header-icon-menu\">\n    <button\n        type=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        [uxMenuTriggerFor]=\"iconMenu\"\n        (click)=\"select(menu)\">\n\n        <!-- Support all icon types -->\n        <i *ngIf=\"_getIconType(menu.icon) !== 'component'\"\n           [ngClass]=\"[_getIconType(menu.icon), menu.icon]\">\n        </i>\n\n        <ux-icon *ngIf=\"_getIconType(menu.icon) === 'component'\"\n                 [name]=\"menu.icon\">\n        </ux-icon>\n\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n    </button>\n\n    <ux-menu #iconMenu alignment=\"end\" menuClass=\"ux-page-header-icon-menu\">\n        <ng-container *ngFor=\"let dropdown of menu?.dropdown\">\n\n            <div class=\"dropdown-header\" *ngIf=\"dropdown.header\">\n                <span class=\"font-bold\">{{ dropdown.title }}</span>\n            </div>\n\n            <button\n                type=\"button\"\n                *ngIf=\"!dropdown.header\"\n                uxMenuItem\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\">\n\n\n                <span class=\"dropdown-item-title\">\n                    <!-- Support all icon types -->\n                    <i *ngIf=\"_getIconType(dropdown.icon) !== 'component'\"\n                       class=\"hpe-fw\"\n                       [ngClass]=\"[_getIconType(dropdown.icon) || 'ux-icon', dropdown.icon || '']\">\n                    </i>\n\n                    <ux-icon *ngIf=\"_getIconType(dropdown.icon) === 'component'\"\n                             class=\"m-r-xs\"\n                             [name]=\"dropdown.icon\">\n                    </ux-icon>\n\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </button>\n\n            <ux-menu-divider *ngIf=\"dropdown.divider\"></ux-menu-divider>\n\n        </ng-container>\n    </ux-menu>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        PageHeaderIconMenuComponent.propDecorators = {
            menu: [{ type: i0.Input }]
        };
        return PageHeaderIconMenuComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderService = /** @class */ (function () {
        function PageHeaderService(_router) {
            var _this = this;
            this._router = _router;
            this.items$ = new rxjs.BehaviorSubject([]);
            this.selected$ = new rxjs.BehaviorSubject(null);
            this.selectedRoot$ = new rxjs.BehaviorSubject(null);
            this.secondary$ = new rxjs.BehaviorSubject(false);
            this.secondaryNavigationAutoselect = false;
            this._onDestroy = new rxjs.Subject();
            this.selected$
                .pipe(operators.takeUntil(this._onDestroy), operators.map(function (selected) { return _this.getRoot(selected); }))
                .subscribe(function (root) { return _this.selectedRoot$.next(root); });
            this._router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd || event instanceof router.NavigationCancel || event instanceof router.NavigationError; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.updateItemsWithActiveRoute(); });
        }
        /**
         * @return {?}
         */
        PageHeaderService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!item) {
                    return;
                }
                if (item.routerLink) {
                    // Trigger router navigation
                    /** @type {?} */
                    var routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    this._router.navigate(routerLink, item.routerExtras);
                }
                else if (this.secondaryNavigationAutoselect && item.children && item.children.length > 0) {
                    // Select the first child that isn't disabled in secondaryNavigationAutoselect mode
                    /** @type {?} */
                    var firstChild = item.children.find(function (_item) { return !_item.disabled; });
                    if (firstChild) {
                        this.select(firstChild);
                    }
                }
                else {
                    // if we are in secondary navigation mode and we click a parent - dont deselect the child
                    if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                        return;
                    }
                    // Otherwise select the given item
                    this.selected$.next(item);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.deselect = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                // deselect the current item
                item.selected = false;
                // iterate any children and deselect them
                if (item.children) {
                    item.children.forEach(function (_item) { return _this.deselect(_item); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
            };
        /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        PageHeaderService.prototype.updateItem = /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
            function (item, selected) {
                // Item is selected if it is the selected item, or one of the selected item's ancestors.
                item.selected = item === selected || this.isParentOf(selected, item);
                if (item === selected) {
                    // call the select function if present
                    if (item.select) {
                        item.select.call(item, item);
                    }
                }
            };
        /**
         * @param {?=} items
         * @return {?}
         */
        PageHeaderService.prototype.setItems = /**
         * @param {?=} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                if (items === void 0) {
                    items = [];
                }
                // identify all parent elements
                items.forEach(function (item) { return _this.setParent(item); });
                this.items$.next(items);
                // Set up the initally selected item
                // If nothing is set as selected, using the initial route
                /** @type {?} */
                var initialSelectedItem = items.find(function (item) { return item.selected === true; });
                if (initialSelectedItem) {
                    this.select(initialSelectedItem);
                }
                else {
                    this.updateItemsWithActiveRoute();
                }
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        PageHeaderService.prototype.setSecondaryNavigation = /**
         * @param {?} enabled
         * @return {?}
         */
            function (enabled) {
                this.secondary$.next(enabled);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.getRoot = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item && item.parent ? this.getRoot(item.parent) : item;
            };
        /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
        PageHeaderService.prototype.setParent = /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
            function (item, parent) {
                var _this = this;
                // set the parent field
                item.parent = parent;
                // call this function recursively on all children
                if (item.children) {
                    item.children.forEach(function (child) { return _this.setParent(child, item); });
                }
            };
        /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
        PageHeaderService.prototype.isParentOf = /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
            function (node, parent) {
                // if there are no parents return false
                if (!node || !node.parent) {
                    return false;
                }
                // if the parent is the match we are looking for return true
                if (node.parent === parent) {
                    return true;
                }
                // if there are potentially grandparents then check them too
                return this.isParentOf(node.parent, parent);
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.updateItemsWithActiveRoute = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var activeItem = new PageHeaderActiveNavigationItem();
                try {
                    for (var _b = __values(this.items$.getValue()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var item = _c.value;
                        this.findActiveItem(item, activeItem);
                        if (activeItem.exact) {
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                if (activeItem.item) {
                    this.selected$.next(activeItem.item);
                }
            };
        /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
        PageHeaderService.prototype.findActiveItem = /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
            function (item, activeItem) {
                var e_2, _a;
                if (item.routerLink) {
                    /** @type {?} */
                    var routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    /** @type {?} */
                    var urlTree = this._router.createUrlTree(routerLink, item.routerExtras);
                    if (this._router.isActive(urlTree, true) && !activeItem.exact) {
                        // When the item route is an exact match, no need to look any further
                        activeItem.item = item;
                        activeItem.exact = true;
                        return;
                    }
                    if (this._router.isActive(urlTree, false)) {
                        // Store an inexact match and continue looking
                        activeItem.item = item;
                        activeItem.exact = false;
                    }
                }
                if (item.children) {
                    try {
                        for (var _b = __values(item.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var childItem = _c.value;
                            this.findActiveItem(childItem, activeItem);
                            if (activeItem.exact) {
                                return;
                            }
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
            };
        PageHeaderService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        PageHeaderService.ctorParameters = function () {
            return [
                { type: router.Router }
            ];
        };
        return PageHeaderService;
    }());
    var PageHeaderActiveNavigationItem = /** @class */ (function () {
        function PageHeaderActiveNavigationItem() {
        }
        return PageHeaderActiveNavigationItem;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderNavigationDropdownItemComponent = /** @class */ (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
        }
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // clicking on an item that is disabled or with children then return
                if (item.disabled || item.children) {
                    return;
                }
                // emit the selected item in an event
                this._pageHeaderService.select(item);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                switch (event.which) {
                    case keycodes.ENTER:
                    case keycodes.SPACE:
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderNavigationDropdownItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                        exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0\">\n\n    <button\n        type=\"button\"\n        uxMenuItem\n        [disabled]=\"item.disabled\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        [uxMenuTriggerFor]=\"menu\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <ux-icon class=\"dropdown-item-icon\" name=\"next\"></ux-icon>\n    </button>\n\n    <ux-menu #menu placement=\"right\" menuClass=\"horizontal-navigation-dropdown-submenu\">\n        <button\n            type=\"button\"\n            *ngFor=\"let subItem of item.children\"\n            uxMenuItem\n            [disabled]=\"subItem.disabled\"\n            [class.selected]=\"subItem.selected\"\n            [attr.aria-selected]=\"subItem.selected\"\n            (click)=\"select(subItem)\"\n            (keydown)=\"keydownHandler($event, subItem)\">\n\n            <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n        </button>\n    </ux-menu>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\">\n\n    <button\n        type=\"button\"\n        uxMenuItem\n        [disabled]=\"item.disabled\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n    </button>\n\n</div>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationDropdownItemComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationDropdownItemComponent.propDecorators = {
            item: [{ type: i0.Input }]
        };
        return PageHeaderNavigationDropdownItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderNavigationService = /** @class */ (function () {
        function PageHeaderNavigationService() {
            /**
             * Emit when focus changes. We can't directly use the FocusKeyManager
             * `change` observable as it cannot be instantiate until after the view
             * has been instantiated.
             */
            this._onChange = new rxjs.Subject();
            /**
             * Unsubscribe on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make menu items navigable using arrow keys */
        /**
         * Make menu items navigable using arrow keys
         * @param {?} items
         * @return {?}
         */
        PageHeaderNavigationService.prototype.initialize = /**
         * Make menu items navigable using arrow keys
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                // store the query list for future lookups
                this._items = items;
                // create new focus key manager with horizontal orientation
                this._focusManager = new a11y.FocusKeyManager(items)
                    .withHorizontalOrientation('ltr');
                // listen for changes to the focused item
                this._focusManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._onChange.next(); });
                // make the first item tabbable initially
                this._focusManager.updateActiveItemIndex(0);
                // on changes ensure there is always an active item
                this._items.changes.subscribe(function () {
                    if (_this._items.length > 0 && _this._items.toArray().indexOf(_this._focusManager.activeItem) === -1) {
                        _this._focusManager.updateActiveItemIndex(0);
                    }
                });
                // emit the initial change
                this._onChange.next();
            };
        /** Listen for keyboard events */
        /**
         * Listen for keyboard events
         * @param {?} event
         * @return {?}
         */
        PageHeaderNavigationService.prototype.onKeydown = /**
         * Listen for keyboard events
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusManager.onKeydown(event);
            };
        /** Get the tab index for this item as an observable */
        /**
         * Get the tab index for this item as an observable
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationService.prototype.getTabIndex = /**
         * Get the tab index for this item as an observable
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                return this._onChange.pipe(operators.map(function () { return _this.getItemTabIndex(item); }), tick(), operators.takeUntil(this._onDestroy));
            };
        /** Determine the tab index of a given item */
        /**
         * Determine the tab index of a given item
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationService.prototype.getItemTabIndex = /**
         * Determine the tab index of a given item
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // until the focus key manager is set up make everything tabbable
                if (!this._items) {
                    return 0;
                }
                // get the index within the query list
                /** @type {?} */
                var index = this._items.toArray().indexOf(item);
                // if it is the current active element then it is tabbable
                return index === this._focusManager.activeItemIndex ? 0 : -1;
            };
        PageHeaderNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        return PageHeaderNavigationService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderNavigationItemComponent = /** @class */ (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService, _navigationService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this._navigationService = _navigationService;
            /**
             * Store the secondary state
             */
            this.secondary$ = this._pageHeaderService.secondary$;
            /**
             * Update the tabindex based on keyboard input
             */
            this._tabindex = this._navigationService.getTabIndex(this);
            /**
             * Unsubscribe when the component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(PageHeaderNavigationItemComponent.prototype, "item", {
            get: /**
             * @return {?}
             */ function () {
                return this._item;
            },
            /** Access the data for this dropdown item */
            set: /**
             * Access the data for this dropdown item
             * @param {?} item
             * @return {?}
             */ function (item) {
                this._item = item;
                this._iconType = getIconType(item.icon);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (selectedItem) {
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, selectedItem);
                    if (selectedItem && _this.isOpen) {
                        _this.isOpen = false;
                    }
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.navigationBtn.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                // if the item is disabled or has children then do nothing at this stage
                if (this.item.disabled || (this.item.children && this._pageHeaderService.secondary$.getValue() === false)) {
                    return;
                }
                // otherwise select the current item
                this._pageHeaderService.select(this.item);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.keyCode === keycodes.LEFT_ARROW || event.keyCode === keycodes.RIGHT_ARROW) {
                    this._navigationService.onKeydown(event);
                }
            };
        PageHeaderNavigationItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-item',
                        template: "<div *ngIf=\"_item.children && _item.children.length > 0 && !(secondary$ | async)\">\n\n    <button #navigationBtn\n        type=\"button\"\n        [tabindex]=\"_tabindex | async\"\n        [uxMenuTriggerFor]=\"menu\"\n        [disabled]=\"_item.disabled\"\n        role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.disabled]=\"_item.disabled\"\n        [class.selected]=\"_item.selected\"\n        [class.open]=\"isOpen\"\n        [attr.aria-selected]=\"_item.selected\">\n\n        <!-- Support all icon types -->\n        <ng-container *ngIf=\"_item.icon\">\n            <i *ngIf=\"_iconType !== 'component'\"\n                class=\"navigation-item-icon\"\n                [ngClass]=\"[_iconType, _item.icon]\">\n            </i>\n\n            <ux-icon *ngIf=\"_iconType === 'component'\"\n                     class=\"navigation-item-icon\"\n                     [name]=\"_item.icon\">\n            </ux-icon>\n\n        </ng-container>\n\n        <span class=\"navigation-item-label\">{{ _item?.title }}</span>\n        <ux-icon class=\"navigation-item-dropdown-icon\" name=\"down\"></ux-icon>\n\n    </button>\n\n    <ux-menu\n        #menu\n        menuClass=\"horizontal-navigation-dropdown-menu\"\n        (opened)=\"isOpen = true\"\n        (closed)=\"isOpen = false\">\n\n        <ux-page-header-horizontal-navigation-dropdown-item\n            *ngFor=\"let item of _item?.children\"\n            [item]=\"item\">\n        </ux-page-header-horizontal-navigation-dropdown-item>\n    </ux-menu>\n\n</div>\n\n<button *ngIf=\"!_item.children || _item.children.length === 0 || (secondary$ | async)\"\n    uxFocusIndicator\n    #navigationBtn\n    type=\"button\"\n    [tabindex]=\"_tabindex | async\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.disabled]=\"_item.disabled\"\n    [class.selected]=\"_item.selected\"\n    [attr.aria-selected]=\"_item.selected\"\n    (click)=\"select()\"\n    [disabled]=\"_item.disabled\">\n\n    <!-- Support all icon types -->\n    <ng-container *ngIf=\"_item.icon\">\n        <i *ngIf=\"_iconType !== 'component'\"\n            class=\"navigation-item-icon\"\n            [ngClass]=\"[_iconType, _item.icon]\">\n        </i>\n\n        <ux-icon *ngIf=\"_iconType === 'component'\"\n                 class=\"navigation-item-icon\"\n                 [name]=\"_item.icon\">\n        </ux-icon>\n\n    </ng-container>\n\n    <span class=\"navigation-item-label\">{{ _item?.title }}</span>\n\n</button>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationItemComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: PageHeaderService },
                { type: PageHeaderNavigationService }
            ];
        };
        PageHeaderNavigationItemComponent.propDecorators = {
            item: [{ type: i0.Input }],
            navigationBtn: [{ type: i0.ViewChild, args: ['navigationBtn', { static: false },] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return PageHeaderNavigationItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderNavigationSecondaryItemDirective = /** @class */ (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        PageHeaderNavigationSecondaryItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxPageHeaderNavigationSecondaryItem]'
                    },] }
        ];
        /** @nocollapse */
        PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationSecondaryItemDirective.propDecorators = {
            item: [{ type: i0.Input, args: ['uxPageHeaderNavigationSecondaryItem',] }]
        };
        return PageHeaderNavigationSecondaryItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderNavigationComponent = /** @class */ (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _navigationService, _pageHeaderService) {
            this._navigationService = _navigationService;
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._onDestroy = new rxjs.Subject();
            resizeService.addResizeListener(elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(this.updateSelectedIndicator.bind(this));
            _pageHeaderService.selected$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this));
            _pageHeaderService.secondary$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.updateSelectedIndicator();
                // setup the page focus key manager
                this._navigationService.initialize(this.menuItems);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    // find the selected item
                    /** @type {?} */
                    var selected = _this.menuItems.find(function (item) { return item.item.selected; });
                    // determine whether or not to show the indicator
                    _this.indicatorVisible = !!selected;
                    // set the width of the indicator to match the width of the navigation item
                    if (selected) {
                        /** @type {?} */
                        var styles = getComputedStyle(selected.elementRef.nativeElement);
                        _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                        _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                    }
                });
            };
        PageHeaderNavigationComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation',
                        template: "<ux-page-header-horizontal-navigation-item\n    *ngFor=\"let item of items$ | async\"\n    [item]=\"item\">\n</ux-page-header-horizontal-navigation-item>\n\n<div class=\"selected-indicator\"\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\n    [style.margin-left.px]=\"indicatorX\"\n    [style.width.px]=\"indicatorWidth\">\n</div>",
                        providers: [PageHeaderNavigationService],
                        host: {
                            'role': 'menubar'
                        }
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizeService },
                { type: PageHeaderNavigationService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationComponent.propDecorators = {
            menuItems: [{ type: i0.ViewChildren, args: [PageHeaderNavigationItemComponent,] }]
        };
        return PageHeaderNavigationComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderComponent = /** @class */ (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            /**
             * The alignment of the primary navigation tabs.
             */
            this.alignment = 'center';
            /**
             * Determines whether or not to display the page header in the regular or condensed form.
             */
            this.condensed = false;
            /**
             * Determines whether or not a back button should be visible in the page header.
             */
            this.backVisible = true;
            /**
             * The alignment of the secondary navigation tabs.
             */
            this.secondaryNavigationAlignment = 'center';
            /**
             * The style of the breadcrumbs.
             *   - standard: The breadcrumbs use the same styling as the navigation tabs.
             *   - small: The breadcrumbs use a smaller font, and case is not adjusted.
             */
            this.crumbsStyle = 'standard';
            /**
             * Emit whenever the back button is clicked
             */
            this.backClick = new i0.EventEmitter();
            /**
             * Emit whenever the product logo in the left corner is clicked.
             */
            this.logoClick = new i0.EventEmitter();
            /**
             * The currently selected page header item
             */
            this.selected$ = this._pageHeaderService.selected$;
            /**
             * The currently selected root menu item - this may be different from selected$ if a child menu item is selected
             */
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            /** If set, the first child item will get selected when the parent item is selected. */
            set: /**
             * If set, the first child item will get selected when the parent item is selected.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            /** The primary navigation tabs. Use the children property in combination with [secondaryNavigation]="true" to include secondary navigation tabs. */
            set: /**
             * The primary navigation tabs. Use the children property in combination with [secondaryNavigation]="true" to include secondary navigation tabs.
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            /** Whether to show a second level of navigation for any items with children. */
            set: /**
             * Whether to show a second level of navigation for any items with children.
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: /**
             * @return {?}
             */ function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            /** The optional set of breadcrumbs to display on the left side of the masthead. */
            set: /**
             * The optional set of breadcrumbs to display on the left side of the masthead.
             * @param {?} crumbs
             * @return {?}
             */ function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoBackground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoBackground;
            },
            /** The logo background color. This can either be the name of a color from the color palette, or a CSS color value. */
            set: /**
             * The logo background color. This can either be the name of a color from the color palette, or a CSS color value.
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoForeground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoForeground;
            },
            /** The logo text color, when a product acronym is specified via header. This can either be the name of a color from the color palette, or a CSS color value. */
            set: /**
             * The logo text color, when a product acronym is specified via header. This can either be the name of a color from the color palette, or a CSS color value.
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "_hasLogoClick", {
            get: /**
             * @return {?}
             */ function () {
                return this.logoClick.observers.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this._pageHeaderService.select(item);
            };
        PageHeaderComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-page-header',
                        exportAs: 'ux-page-header',
                        template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <div *ngIf=\"!condensed\" class=\"page-header-content\">\n\n        <!-- Logo/product acronym -->\n        <div uxFocusIndicator (keydown.enter)=\"logoClick.emit($event)\" [attr.tabindex]=\"_hasLogoClick ? 0: -1\"\n             [class.page-header-logo-template]=\"logoTemplate\" [class.clickable]=\"_hasLogoClick\"\n             class=\"page-header-logo-container\"\n             role=\"presentation\" [style.backgroundColor]=\"logoBackground\" [style.color]=\"logoForeground\" (click)=\"logoClick.emit($event)\">\n            <img *ngIf=\"logo && !logoTemplate\" [attr.src]=\"logo\" [alt]=\"header\" class=\"page-header-logo\">\n            <h1 *ngIf=\"header && !logo && !logoTemplate\" class=\"page-header-acronym\">{{header}}</h1>\n            <ng-container *ngIf=\"logoTemplate\" [ngTemplateOutlet]=\"logoTemplate\"></ng-container>\n        </div>\n\n        <!-- Sub-title -->\n        <div *ngIf=\"subheader || subheaderTemplate\" class=\"page-header-subtitle-container\">\n            <span *ngIf=\"subheader\" class=\"page-header-subtitle\">{{subheader}}</span>\n            <ng-container [ngTemplateOutlet]=\"subheaderTemplate\"></ng-container>\n        </div>\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <!-- Back button -->\n            <button *ngIf=\"backVisible === true\" uxFocusIndicator type=\"button\" class=\"page-header-back-button\" (click)=\"backClick.emit($event)\" aria-label=\"Go Back\">\n                <ux-icon name=\"previous\" class=\"text-primary\"></ux-icon>\n            </button>\n\n            <!-- Breadcrumbs and header -->\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs *ngIf=\"crumbs && crumbs.length > 0\"\n                    [class.ux-breadcrumbs-small]=\"crumbsStyle === 'small'\"\n                    [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\">{{header}}</h1>\n\n            </div>\n\n        </div>\n\n        <!-- Primary navigation -->\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <!-- Icon menus -->\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div *ngIf=\"secondaryNavigation && ((selectedRoot$ | async) !== (selected$ | async))\"\n    class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\">\n\n    <ux-tabset *ngIf=\"(selectedRoot$ | async)?.children; let children\" [manual]=\"true\">\n        <ux-tab *ngFor=\"let child of children\"\n            [heading]=\"child.title\"\n            [active]=\"child === (selected$ | async)\"\n            (activated)=\"select(child)\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\"\n            [disabled]=\"child.disabled\">\n        </ux-tab>\n    </ux-tabset>\n\n</div>\n",
                        providers: [PageHeaderService]
                    }] }
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            logo: [{ type: i0.Input }],
            header: [{ type: i0.Input }],
            subheader: [{ type: i0.Input }],
            alignment: [{ type: i0.Input }],
            condensed: [{ type: i0.Input }],
            iconMenus: [{ type: i0.Input }],
            backVisible: [{ type: i0.Input }],
            secondaryNavigationAlignment: [{ type: i0.Input }],
            secondaryNavigationAutoselect: [{ type: i0.Input }],
            items: [{ type: i0.Input }],
            secondaryNavigation: [{ type: i0.Input }],
            crumbs: [{ type: i0.Input }],
            crumbsStyle: [{ type: i0.Input }],
            logoBackground: [{ type: i0.Input }],
            logoForeground: [{ type: i0.Input }],
            backClick: [{ type: i0.Output }],
            logoClick: [{ type: i0.Output }],
            subheaderTemplate: [{ type: i0.ContentChild, args: ['subheader', { static: false },] }],
            logoTemplate: [{ type: i0.ContentChild, args: ['logoTemplate', { static: false },] }],
            customMenus: [{ type: i0.ContentChildren, args: [PageHeaderCustomMenuDirective, { read: i0.TemplateRef },] }]
        };
        return PageHeaderComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PageHeaderModule = /** @class */ (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            BreadcrumbsModule,
                            ColorServiceModule,
                            common.CommonModule,
                            IconModule,
                            MenuModule,
                            ResizeModule,
                            router.RouterModule,
                            TabsetModule,
                        ],
                        exports: [
                            PageHeaderComponent,
                            PageHeaderCustomMenuDirective
                        ],
                        declarations: [
                            PageHeaderComponent,
                            PageHeaderIconMenuComponent,
                            PageHeaderCustomMenuDirective,
                            PageHeaderNavigationComponent,
                            PageHeaderNavigationItemComponent,
                            PageHeaderNavigationDropdownItemComponent,
                            PageHeaderNavigationSecondaryItemDirective
                        ]
                    },] }
        ];
        return PageHeaderModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var PAGINATION_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return PaginationComponent; }),
        multi: true
    };
    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent() {
            /**
             * Specify if we should show the next and previous buttons
             */
            this.directionButtons = true;
            /**
             * Limit the number of pages shown at any given time
             */
            this.maxSize = 5;
            /**
             * Specify if the component should be disabled
             */
            this.disabled = false;
            /**
             * Aria Label for the component navigation
             */
            this.ariaLabel = 'Pagination Navigation';
            /**
             * Aria label for the previous button
             */
            this.previousAriaLabel = 'Navigate to the previous page';
            /**
             * Aria label for the next button
             */
            this.nextAriaLabel = 'Navigate to the next page';
            /**
             * Emit the current page number
             */
            this.pageChange = new i0.EventEmitter();
            /**
             * Emit the total number of pages
             */
            this.numPages = new i0.EventEmitter();
            /**
             * Store a list of pages to display in the UI
             */
            this.pages = [];
            /**
             * ControlValueAccessor functions
             */
            this.onTouched = function () { };
            this.onChange = function () { };
            this.isKeyboardEvent = false;
            this._page = 1;
            this._total = 100;
            this._pagesize = 10;
        }
        Object.defineProperty(PaginationComponent.prototype, "page", {
            get: /**
             * @return {?}
             */ function () {
                return this._page;
            },
            /** Specify the index of the active page */
            set: /**
             * Specify the index of the active page
             * @param {?} page
             * @return {?}
             */ function (page) {
                // do nothing if the page has not changed
                if (page === this._page) {
                    return;
                }
                this._page = page;
                this.pages = this.getPages();
                // mark this component as changed
                this.onChange(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "itemsPerPage", {
            /** Specify the page size */
            set: /**
             * Specify the page size
             * @param {?} pagesize
             * @return {?}
             */ function (pagesize) {
                this._pagesize = pagesize;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "totalItems", {
            /** Specify how many items there are in total */
            set: /**
             * Specify how many items there are in total
             * @param {?} total
             * @return {?}
             */ function (total) {
                this._total = total;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "pageCount", {
            get: /**
             * @return {?}
             */ function () {
                return Math.ceil(this._total / this._pagesize);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PaginationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.pages = this.getPages();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        PaginationComponent.prototype.select = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // find the page we want to go to
                /** @type {?} */
                var target = this.pages.find(function (page) { return page.index === index; });
                // if the page is out of bounds then do nothing
                if (!target) {
                    return;
                }
                // mark this component as touched
                this.onTouched();
                // set this as the current page
                this.page = target.index;
                // update the visible pages
                this.pages = this.getPages();
                // emit the current page
                this.pageChange.emit(this.page);
            };
        /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
        PaginationComponent.prototype.trackByFn = /**
         * @param {?} _index
         * @param {?} item
         * @return {?}
         */
            function (_index, item) {
                return item.index;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        PaginationComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        PaginationComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        PaginationComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} page
         * @return {?}
         */
        PaginationComponent.prototype.writeValue = /**
         * @param {?} page
         * @return {?}
         */
            function (page) {
                this.page = page;
            };
        /**
         * @return {?}
         */
        PaginationComponent.prototype.getPages = /**
         * @return {?}
         */
            function () {
                // create a new array to store the pages
                /** @type {?} */
                var pages = [];
                // create all possible pages
                for (var index = 1; index <= this.pageCount; index++) {
                    pages.push({ index: index, visible: this.isPageVisible(index) });
                }
                // emit the number of pages
                this.numPages.emit(this.pageCount);
                return pages;
            };
        /**
         * @param {?} index
         * @return {?}
         */
        PaginationComponent.prototype.isPageVisible = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // if we do not have a max size specified or the number of pages is less than the max size then it is always visible
                if (!this.maxSize || this.pageCount <= this.maxSize) {
                    return true;
                }
                // find the starting position
                /** @type {?} */
                var start = Math.max(1, Math.ceil(this.page - (this.maxSize / 2)));
                /** @type {?} */
                var end = Math.min(start + this.maxSize, this.pageCount + 1);
                // if the range is less than the max size we need to adjust the starting point
                /** @type {?} */
                var range = end - start;
                if (range < this.maxSize) {
                    start = start - (this.maxSize - range);
                }
                // if the item equals the start position or is less than the end position then show it
                return index >= start && index < end;
            };
        PaginationComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-pagination',
                        template: "<nav role=\"navigation\" [attr.aria-label]=\"ariaLabel\">\n  <ul #container class=\"pagination\"\n    [ngClass]=\"classes\"\n    direction=\"horizontal\"\n    (blur)=\"isKeyboardEvent = false\"\n    (keydown.ArrowLeft)=\"select(page - 1); isKeyboardEvent = true\"\n    (keydown.ArrowRight)=\"select(page + 1); isKeyboardEvent = true\"\n    (keydown.Home)=\"select(1); isKeyboardEvent = true; $event.preventDefault()\"\n    (keydown.End)=\"select(pageCount); isKeyboardEvent = true; $event.preventDefault()\">\n\n    <li class=\"pagination-prev page-item\"\n        *ngIf=\"directionButtons\"\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        [checkChildren]=\"true\"\n        [class.disabled]=\"page === 1 || disabled\">\n\n      <a class=\"page-link\"\n         [tabindex]=\"page === 1 || disabled ? -1 : 0\"\n         [attr.aria-label]=\"previousAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page - 1)\"\n         (keydown.enter)=\"select(page - 1)\">\n        <ng-container [ngTemplateOutlet]=\"previousBtnTemplate || defaultPreviousBtnTemplate\"></ng-container>\n      </a>\n    </li>\n\n    <ng-container *ngFor=\"let pg of pages; trackBy: trackByFn\">\n      <li *ngIf=\"pg.visible\"\n          uxFocusIndicator\n          [programmaticFocusIndicator]=\"true\"\n          [checkChildren]=\"true\"\n          [class.disabled]=\"disabled\"\n          [class.active]=\"page === pg.index\"\n          class=\"pagination-page page-item\">\n\n        <a class=\"page-link\"\n           tabindex=\"0\"\n           [ngClass]=\"pageBtnClass\"\n           [focusIf]=\"isKeyboardEvent && page === pg.index\"\n           [attr.aria-current]=\"page === pg.index\"\n           [attr.aria-setsize]=\"pageCount\"\n           [attr.aria-posinset]=\"pg.index\"\n           (click)=\"select(pg.index)\"\n           (keydown.enter)=\"select(pg.index)\">\n            {{ pg.index }}\n        </a>\n      </li>\n    </ng-container>\n\n    <li class=\"pagination-next page-item\"\n        *ngIf=\"directionButtons\"\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        [checkChildren]=\"true\"\n        [class.disabled]=\"page === pageCount || disabled\">\n\n      <a class=\"page-link\"\n         [tabindex]=\"page === pageCount || disabled ? -1 : 0\"\n         [attr.aria-label]=\"nextAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page + 1)\"\n         (keydown.enter)=\"select(page + 1)\">\n\n        <ng-container [ngTemplateOutlet]=\"nextBtnTemplate || defaultNextBtnTemplate\"></ng-container>\n      </a>\n    </li>\n  </ul>\n</nav>\n\n<ng-template #defaultPreviousBtnTemplate>\n    <ux-icon class=\"pagination-prev-icon-default\" name=\"previous\"></ux-icon>\n</ng-template>\n\n<ng-template #defaultNextBtnTemplate>\n    <ux-icon class=\"pagination-next-icon-default\" name=\"next\"></ux-icon>\n</ng-template>\n",
                        providers: [PAGINATION_CONTROL_VALUE_ACCESSOR]
                    }] }
        ];
        PaginationComponent.propDecorators = {
            directionButtons: [{ type: i0.Input }],
            maxSize: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            classes: [{ type: i0.Input, args: ['class',] }],
            pageBtnClass: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            previousAriaLabel: [{ type: i0.Input }],
            nextAriaLabel: [{ type: i0.Input }],
            page: [{ type: i0.Input }],
            previousBtnTemplate: [{ type: i0.Input }],
            nextBtnTemplate: [{ type: i0.Input }],
            itemsPerPage: [{ type: i0.Input }],
            totalItems: [{ type: i0.Input }],
            pageChange: [{ type: i0.Output }],
            numPages: [{ type: i0.Output }]
        };
        return PaginationComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        PaginationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            FocusIfModule,
                            IconModule,
                        ],
                        declarations: [
                            PaginationComponent
                        ],
                        exports: [
                            PaginationComponent
                        ]
                    },] }
        ];
        return PaginationModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PartitionMapSegmentEventsDirective = /** @class */ (function () {
        function PartitionMapSegmentEventsDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Emit when the segment receives focus
             */
            this.segmentFocus = new i0.EventEmitter();
            /**
             * Emit when the segment is blurred
             */
            this.segmentBlur = new i0.EventEmitter();
            /**
             * Unsubscribe from observables
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        PartitionMapSegmentEventsDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Get the parent segment element
                // Note we cannot use DI to get the element as this is a template
                // and the context has no knowledge of the partition map template
                /** @type {?} */
                var segment = this.getSegmentElement();
                if (segment) {
                    rxjs.fromEvent(segment, 'focus')
                        .pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function (event) { return _this.segmentFocus.emit(event); });
                    rxjs.fromEvent(segment, 'blur')
                        .pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function (event) { return _this.segmentBlur.emit(event); });
                }
            };
        /**
         * @return {?}
         */
        PartitionMapSegmentEventsDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Find the parent element that is a partition map segment
         */
        /**
         * Find the parent element that is a partition map segment
         * @return {?}
         */
        PartitionMapSegmentEventsDirective.prototype.getSegmentElement = /**
         * Find the parent element that is a partition map segment
         * @return {?}
         */
            function () {
                /** @type {?} */
                var ancestor = (( /** @type {?} */(this._elementRef.nativeElement))).parentElement;
                while (ancestor !== null) {
                    if (ancestor.classList.contains('partition-map-segment')) {
                        return ancestor;
                    }
                    ancestor = ancestor.parentElement;
                }
            };
        PartitionMapSegmentEventsDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[segmentFocus],[segmentBlur]',
                    },] }
        ];
        /** @nocollapse */
        PartitionMapSegmentEventsDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        PartitionMapSegmentEventsDirective.propDecorators = {
            segmentFocus: [{ type: i0.Output }],
            segmentBlur: [{ type: i0.Output }]
        };
        return PartitionMapSegmentEventsDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PartitionMapComponent = /** @class */ (function () {
        function PartitionMapComponent(_colorService, _elementRef, _changeDetector, _ngZone, _focusOrigin, _contrastRatio, _liveAnnouncer, _resizeService) {
            this._colorService = _colorService;
            this._elementRef = _elementRef;
            this._changeDetector = _changeDetector;
            this._ngZone = _ngZone;
            this._focusOrigin = _focusOrigin;
            this._contrastRatio = _contrastRatio;
            this._liveAnnouncer = _liveAnnouncer;
            this._resizeService = _resizeService;
            /**
             * Determine the pixel height of collapsed segments.
             */
            this.collapsedHeight = 40;
            /**
             * Define a minimum desired pixel width for a segment.
             */
            this.minSegmentWidth = 5;
            /**
             * Define the function that will return the aria announcement for a given segment.
             */
            this.segmentAnnouncement = this.defaultSegmentAnnouncement;
            /**
             * Emits whenever a segment is selected.
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Store the processed segments
             */
            this._segments = [];
            /**
             * Store the specified color sequences
             */
            this._colors = [[]];
            /**
             * Store the assigned colors for each segment
             */
            this._segmentColors = new Map();
            /**
             * Store the visible x scale
             */
            this._x = d3Scale.scaleLinear().range([0, 100]);
            /**
             * Store the visible y scale
             */
            this._y = d3Scale.scaleLinear().range([0, 100]);
            /**
             * Store the width of the chart on resize to avoid any reflow
             */
            this._width = this._elementRef.nativeElement.offsetWidth;
            /**
             * Store the height of the chart on resize to avoid any reflow
             */
            this._height = this._elementRef.nativeElement.offsetHeight;
            /**
             * Unsubscribe from any observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(PartitionMapComponent.prototype, "colors", {
            /** Define the colors to be used for each row and the order they should appear. */
            set: /**
             * Define the colors to be used for each row and the order they should appear.
             * @param {?} colors
             * @return {?}
             */ function (colors) {
                this._colors = colors;
                // clear the save color mappings
                this._segmentColors.clear();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PartitionMapComponent.prototype, "dataset", {
            get: /**
             * @return {?}
             */ function () {
                return this._dataset;
            },
            /** Define the dataset to display in the chart. */
            set: /**
             * Define the dataset to display in the chart.
             * @param {?} dataset
             * @return {?}
             */ function (dataset) {
                // store the current dataset
                this._dataset = dataset;
                // clear any existing color assignments
                this._segmentColors.clear();
                // update the segment layout
                this.setDataset(dataset);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PartitionMapComponent.prototype, "selected", {
            /** Define the currently selected item. */
            set: /**
             * Define the currently selected item.
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                // if this is set before the dataset is process then store it to be selected later
                if (this._segments.length === 0) {
                    this._awaitingSelection = selected;
                    return;
                }
                // perform the selection
                this.select(this.getHierarchyNodeFromSegment(selected));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PartitionMapComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (dimensions) {
                    _this._width = dimensions.width;
                    _this._height = dimensions.height;
                    _this._changeDetector.detectChanges();
                    // set our new ranges
                    if (_this._selected) {
                        _this._x.domain([_this.getSegmentX(_this._selected), _this.getSegmentX(_this._selected) + _this.getSegmentWidth(_this._selected)]);
                        _this._y.domain([_this._selected.y0, 1]).range([_this.getTotalCollapsedHeight(), 100]);
                    }
                    // render the chart to ensure positions and sizes are correct
                    _this.updateSegments();
                });
            };
        /**
         * @return {?}
         */
        PartitionMapComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Handle segment clicks */
        /**
         * Handle segment clicks
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._onSegmentSelect = /**
         * Handle segment clicks
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if the clicked node is already selected, navigate to the parent node
                this.select(this._isSelected(segment) && segment.parent ? segment.parent : segment);
            };
        /** Get the background color for a given segment */
        /**
         * Get the background color for a given segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getBackgroundColor = /**
         * Get the background color for a given segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // each segment has a determinable color key based on the name and depth
                /** @type {?} */
                var key = segment.data.name + " - " + segment.depth;
                // check if a segment with the same name (and depth) has previously
                if (this._segmentColors.has(key)) {
                    return this._segmentColors.get(key);
                }
                // get the corresponding row of colors
                /** @type {?} */
                var sequence = this.getColorSequence(segment.depth);
                // if the sequence has not been specified return a default of white
                if (!sequence || sequence.length === 0) {
                    return '#fff';
                }
                // get siblings
                /** @type {?} */
                var siblings = this.getAllSiblings(segment);
                // get the previous sibling if there is one
                /** @type {?} */
                var sibling = siblings[siblings.indexOf(segment) - 1];
                // if there is a previous sibling then get its color and use the next one in the sequence
                if (sibling) {
                    /** @type {?} */
                    var index = sequence.indexOf(this._getBackgroundColor(sibling));
                    /** @type {?} */
                    var color = sequence[(index + 1) % sequence.length];
                    // store the color by key
                    this._segmentColors.set(key, color);
                    return color;
                }
                // store the color by key
                this._segmentColors.set(key, sequence[0]);
                // if there is no previous sibling then simply return the first color in the sequence
                return sequence[0];
            };
        /** Get the tab index of a segment */
        /**
         * Get the tab index of a segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getTabIndex = /**
         * Get the tab index of a segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return segment === this._focusableSegment ? 0 : -1;
            };
        /** Shift focus to the parent segment */
        /**
         * Shift focus to the parent segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._focusParent = /**
         * Shift focus to the parent segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if there is no parent (ie, we are the root segment) then retain focus
                if (!segment.parent) {
                    return;
                }
                // otherwise focus the parent
                this.focusSegment(segment.parent);
            };
        /** Shift focus to the child segment */
        /**
         * Shift focus to the child segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._focusChild = /**
         * Shift focus to the child segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                // if there are no children (ie, we are a leaf segment) then retain focus
                if (!segment.children) {
                    return;
                }
                // find the first visible child
                /** @type {?} */
                var child = segment.children.find(function (_segment) { return _this.isVisible(_segment); });
                // otherwise focus the first visible child
                if (child) {
                    this.focusSegment(child);
                }
            };
        /** Shift focus to the sibling segment */
        /**
         * Shift focus to the sibling segment
         * @param {?} segment
         * @param {?} delta
         * @return {?}
         */
        PartitionMapComponent.prototype._focusSibling = /**
         * Shift focus to the sibling segment
         * @param {?} segment
         * @param {?} delta
         * @return {?}
         */
            function (segment, delta) {
                // if we are the root node then do nothing
                if (!segment.parent) {
                    return;
                }
                // get a list of all the siblings (at the same row regardless of the same parent)
                /** @type {?} */
                var siblings = this.getAllSiblings(segment);
                // get the index of the segment in the list of siblings
                /** @type {?} */
                var index = siblings.indexOf(segment);
                // get the target sibling
                /** @type {?} */
                var sibling = siblings[index + delta];
                // ensure the sibling is visible otherwise we can't select it
                if (!sibling || !this.isVisible(sibling)) {
                    return;
                }
                // otherwise focus the sibling
                this.focusSegment(sibling);
            };
        /**
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._focusFirstSibling = /**
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                // if we are the root node then do nothing
                if (!segment.parent) {
                    return;
                }
                // get a list of all the siblings (at the same row regardless of the same parent)
                /** @type {?} */
                var siblings = this.getAllSiblings(segment);
                // find the first visible sibling
                /** @type {?} */
                var sibling = siblings.find(function (_sibling) { return _this.isVisible(_sibling); });
                // ensure there is a sibling
                if (!sibling) {
                    return;
                }
                // otherwise focus the sibling
                this.focusSegment(sibling);
            };
        /**
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._focusLastSibling = /**
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                // if we are the root node then do nothing
                if (!segment.parent) {
                    return;
                }
                // get a list of all the siblings (at the same row regardless of the same parent)
                /** @type {?} */
                var siblings = this.getAllSiblings(segment);
                // find the last visible sibling
                /** @type {?} */
                var sibling = siblings.reverse().find(function (_sibling) { return _this.isVisible(_sibling); });
                // ensure there is a sibling
                if (!sibling) {
                    return;
                }
                // otherwise focus the sibling
                this.focusSegment(sibling);
            };
        /** Determine if a given segment is currently collapsed */
        /**
         * Determine if a given segment is currently collapsed
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._isCollapsed = /**
         * Determine if a given segment is currently collapsed
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._selected && segment.depth < this._selected.depth;
            };
        /** Determine if a given segment is currently selected */
        /**
         * Determine if a given segment is currently selected
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._isSelected = /**
         * Determine if a given segment is currently selected
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._selected === segment;
            };
        /** Get the contast color class for the segment */
        /**
         * Get the contast color class for the segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getContrastColor = /**
         * Get the contast color class for the segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                /** @type {?} */
                var backgroundColor = this._getBackgroundColor(segment);
                /** @type {?} */
                var lightColor = ThemeColor.parse('#fff');
                /** @type {?} */
                var darkColor = ThemeColor.parse('#000');
                /** @type {?} */
                var color = this._contrastRatio.getContrastColor(ThemeColor.parse(backgroundColor), lightColor, darkColor);
                return color === lightColor ? 'partition-map-segment-light' : 'partition-map-segment-dark';
            };
        /** Provide an aria announcement when the node is focused */
        /**
         * Provide an aria announcement when the node is focused
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._onFocus = /**
         * Provide an aria announcement when the node is focused
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // get all ancestors
                /** @type {?} */
                var ancestors = segment.ancestors().map(function (ancestor) { return ancestor.data; });
                // get the current node and the parent nodes
                var _a = __read(ancestors), item = _a[0], parents = _a.slice(1);
                // get the hierarchy node data from the item
                /** @type {?} */
                var hierarchichalItem = this.getHierarchyNodeFromSegment(item);
                // get the function that creates the announcement
                /** @type {?} */
                var announcement = this.segmentAnnouncement({
                    item: item,
                    parents: parents,
                    value: this._getSegmentValue(segment.data),
                    collapsed: this._isCollapsed(hierarchichalItem),
                    selected: this._isSelected(hierarchichalItem)
                });
                // make aria announcement
                this._liveAnnouncer.announce(announcement);
            };
        /** Determine if the content is smaller than the width of an ellipsis */
        /**
         * Determine if the content is smaller than the width of an ellipsis
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getSegmentContentHidden = /**
         * Determine if the content is smaller than the width of an ellipsis
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // get the width of the segment as a pixel value
                /** @type {?} */
                var width = (this._width / 100) * this.getNormalizedSegmentWidth(segment);
                // if the width is less than 50 px hide the content
                return width < 50;
            };
        /** Get the value of a segment based on the accumulation of all child values */
        /**
         * Get the value of a segment based on the accumulation of all child values
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getSegmentValue = /**
         * Get the value of a segment based on the accumulation of all child values
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                // it it has a value then return the value
                if (segment.hasOwnProperty('value')) {
                    return (( /** @type {?} */(segment))).value;
                }
                return (( /** @type {?} */(segment))).children.reduce(function (value, child) { return value + _this._getSegmentValue(child); }, 0);
            };
        /**
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype._getContext = /**
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                /** @type {?} */
                var context = {
                    segment: segment.data,
                    value: this._getSegmentValue(segment.data),
                    color: this._getBackgroundColor(segment),
                    expanded: !this._isCollapsed(segment),
                    children: []
                };
                // map the children to their contexts
                if (segment.children) {
                    context.children = segment.children.map(this._getContext.bind(this));
                }
                return context;
            };
        /** Convert the public facing data structure into the layout format we require */
        /**
         * Convert the public facing data structure into the layout format we require
         * @param {?} dataset
         * @return {?}
         */
        PartitionMapComponent.prototype.setDataset = /**
         * Convert the public facing data structure into the layout format we require
         * @param {?} dataset
         * @return {?}
         */
            function (dataset) {
                // convert the segments to a hierarchichal structure
                /** @type {?} */
                var segmentHierarchy = d3Hierarchy.hierarchy(dataset)
                    .sum(this.getSegmentValue);
                // calculate segment values based on their children
                // store the processed segments
                /** @type {?} */
                var root = ( /** @type {?} */(d3Hierarchy.partition()(segmentHierarchy)));
                // store the flattened form of the segments
                this._segments = root.descendants();
                // mark the root node as focusable
                this._focusableSegment = root;
                // we need to run change detection here so the `*ngFor` will update and add all the segments to the DOM
                this._changeDetector.detectChanges();
                // select all the segments within the chart
                this._segmentsSelection = ( /** @type {?} */(d3Selection.select(this._elementRef.nativeElement)
                    .selectAll('.partition-map-segment')
                    .data(this._segments)));
                // set the correct sizing and position of the segments
                this.updateSegments();
                // if there is an item waiting to be selected then select it
                if (this._awaitingSelection) {
                    // select the desired segment
                    this.select(this.getHierarchyNodeFromSegment(this._awaitingSelection));
                    // clear the pending selection in case the dataset changes we don't want to attempt another selection
                    this._awaitingSelection = null;
                }
            };
        /** Update the size and position of the segments */
        /**
         * Update the size and position of the segments
         * @return {?}
         */
        PartitionMapComponent.prototype.updateSegments = /**
         * Update the size and position of the segments
         * @return {?}
         */
            function () {
                var _this = this;
                // if the chart has not yet been initialised do nothing
                if (!this._segmentsSelection) {
                    return;
                }
                // perform the chart positioning and sizing
                this._segmentsSelection
                    .style('left', function (data) { return _this.getNormalizedSegmentX(data) + '%'; })
                    .style('top', function (data) { return _this.getNormalizedSegmentY(data) + '%'; })
                    .style('width', function (data) { return (_this.getNormalizedSegmentWidth(data) + 0.01) + '%'; })
                    .style('height', function (data) { return _this.getNormalizedSegmentHeight(data) + '%'; })
                    .style('padding-right', function (data) { return _this.getSegmentPaddingRight(data) + '%'; })
                    .style('padding-left', function (data) { return _this.getSegmentPaddingLeft(data) + '%'; });
            };
        /**
         * Get the X position of a given segment. The X position can be determined
         * by calculating the width of every sibling segment to the left of it
         */
        /**
         * Get the X position of a given segment. The X position can be determined
         * by calculating the width of every sibling segment to the left of it
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getSegmentX = /**
         * Get the X position of a given segment. The X position can be determined
         * by calculating the width of every sibling segment to the left of it
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var e_1, _a;
                // if root node then return the position
                if (!segment.parent) {
                    return segment.x0;
                }
                // set initial start position equal to that of the parent
                /** @type {?} */
                var accumulation = this.getSegmentX(segment.parent);
                try {
                    // iterate each previous sibling to accumulate the widths
                    for (var _b = __values(segment.parent.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var sibling = _c.value;
                        // if we have reached the current node then return all previous widths
                        if (sibling === segment) {
                            return accumulation;
                        }
                        // keep a tally of all the widths of previous siblings
                        accumulation += this.getSegmentWidth(sibling);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /** Calculate width based of each segment */
        /**
         * Calculate width based of each segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getSegmentWidth = /**
         * Calculate width based of each segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if root node then return 1 always
                if (!segment.parent) {
                    return 1;
                }
                // get width of parent
                /** @type {?} */
                var parentOffset = this.getSegmentWidth(segment.parent) / (segment.parent.x1 - segment.parent.x0);
                // get the original width of the segment
                /** @type {?} */
                var width = (segment.x1 - segment.x0);
                // if the item is a descendant of the selected item then apply the modifier
                if (this.isDescendantOfSelected(segment)) {
                    // we want to try an ensure that children are at least the specified minimum width
                    // however it may not always be possible, but we should be able to at least distribute the widths better
                    // even if we cannot meet the minimum desired width.
                    /** @type {?} */
                    var modifier = this.getDistributionModifier(segment);
                    // return the width of the current node relative to the parent
                    return (width * modifier) * parentOffset;
                }
                return width * parentOffset;
            };
        /** Return the X position of the segment in a normalized form based on the specifiec domain */
        /**
         * Return the X position of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getNormalizedSegmentX = /**
         * Return the X position of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._x(this.getSegmentX(segment));
            };
        /** Return the Y position of the segment in a normalized form based on the specifiec domain */
        /**
         * Return the Y position of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getNormalizedSegmentY = /**
         * Return the Y position of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if there is a selected node we should take into account any collapsed nodes
                if (this._isCollapsed(segment)) {
                    return segment.depth * this.getCollapsedHeight();
                }
                // otherwise simply return the normalized value
                return this._y(segment.y0);
            };
        /** Return the width of the segment in a normalized form based on the specifiec domain */
        /**
         * Return the width of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getNormalizedSegmentWidth = /**
         * Return the width of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._x(this.getSegmentX(segment) + this.getSegmentWidth(segment)) - this._x(this.getSegmentX(segment));
            };
        /** Return the height of the segment in a normalized form based on the specifiec domain */
        /**
         * Return the height of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getNormalizedSegmentHeight = /**
         * Return the height of the segment in a normalized form based on the specifiec domain
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if there is a selected node we should take into account any collapsed nodes
                if (this._isCollapsed(segment)) {
                    return this.getCollapsedHeight();
                }
                // otherwise simply return the normalized value
                return this._y(segment.y0 + (segment.y1 - segment.y0)) - this._y(segment.y0);
            };
        /**
         * As parent segments collapse they increase in size, as the content is centered this can
         * cause the content to appear either mis-aligned or off screen. We can calculate the padding
         * required to always ensure the content appears visibly centered within the node.
         */
        /**
         * As parent segments collapse they increase in size, as the content is centered this can
         * cause the content to appear either mis-aligned or off screen. We can calculate the padding
         * required to always ensure the content appears visibly centered within the node.
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getSegmentPaddingRight = /**
         * As parent segments collapse they increase in size, as the content is centered this can
         * cause the content to appear either mis-aligned or off screen. We can calculate the padding
         * required to always ensure the content appears visibly centered within the node.
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // non-collapsed node do not require any padding
                if (!this._isCollapsed(segment)) {
                    return 0;
                }
                return (this.getNormalizedSegmentWidth(segment) - this.getSegmentPaddingLeft(segment)) - this.getNormalizedSegmentWidth(this._selected);
            };
        /**
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getSegmentPaddingLeft = /**
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // non-collapsed node do not require any padding
                if (!this._isCollapsed(segment)) {
                    return 0;
                }
                return Math.abs(this.getNormalizedSegmentX(segment));
            };
        /**
         * This function returns the value for each segment. Leaf segments will have a value property which we can simply return, however
         * non-leaf segments should get their values based on the leaf segments that are children, in which case we can return 0
         */
        /**
         * This function returns the value for each segment. Leaf segments will have a value property which we can simply return, however
         * non-leaf segments should get their values based on the leaf segments that are children, in which case we can return 0
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getSegmentValue = /**
         * This function returns the value for each segment. Leaf segments will have a value property which we can simply return, however
         * non-leaf segments should get their values based on the leaf segments that are children, in which case we can return 0
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                if (segment.hasOwnProperty('value')) {
                    /** @type {?} */
                    var value = (( /** @type {?} */(segment))).value;
                    // we must ensure that a leaf node never has no width otherwise things can get weird
                    return Math.max(value, 1);
                }
                // if it has children then return 0 to base the value of the width of the children
                return 0;
            };
        /** Get the total height of all the collapse rows */
        /**
         * Get the total height of all the collapse rows
         * @return {?}
         */
        PartitionMapComponent.prototype.getTotalCollapsedHeight = /**
         * Get the total height of all the collapse rows
         * @return {?}
         */
            function () {
                return this._selected ? this._selected.depth * this.getCollapsedHeight() : 0;
            };
        /** Get the collapsed height in percentage format */
        /**
         * Get the collapsed height in percentage format
         * @return {?}
         */
        PartitionMapComponent.prototype.getCollapsedHeight = /**
         * Get the collapsed height in percentage format
         * @return {?}
         */
            function () {
                return parseFloat(((this.collapsedHeight / this._height) * 100).toPrecision(3));
            };
        /** Determine if a given segment is currently visible based on the selected segment */
        /**
         * Determine if a given segment is currently visible based on the selected segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.isVisible = /**
         * Determine if a given segment is currently visible based on the selected segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if no segment is selected then all segments are visible
                if (!this._selected) {
                    return true;
                }
                // if there is a selected node then it should be a direct ancestor or descendant to be visible
                return !!__spread(this._selected.ancestors(), this._selected.descendants()).find(function (_segment) { return _segment === segment; });
            };
        /** Update the focusable item and perform a focus */
        /**
         * Update the focusable item and perform a focus
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.focusSegment = /**
         * Update the focusable item and perform a focus
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // get the segment element from the data
                /** @type {?} */
                var element = this._segmentsSelection.nodes().find(function (node) { return d3Selection.select(node).data()[0] === segment; });
                // if for some reason an element isn't found then stop here
                if (!element) {
                    return;
                }
                // update the focusable segment
                this._focusableSegment = segment;
                // set the focus origin as a keyboard event
                this._focusOrigin.setOrigin('keyboard');
                // focus the element
                element.focus();
                // ensure we do not change scroll position when focusing
                (( /** @type {?} */(this._elementRef.nativeElement))).scrollLeft = 0;
                (( /** @type {?} */(this._elementRef.nativeElement))).scrollTop = 0;
            };
        /** Get all the segments at a given depth */
        /**
         * Get all the segments at a given depth
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getAllSiblings = /**
         * Get all the segments at a given depth
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._segments.filter(function (_segment) { return _segment.depth === segment.depth; });
            };
        /**
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getHierarchyNodeFromSegment = /**
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                return this._segments.find(function (_segment) { return _segment.data === segment; });
            };
        /** Select a specified segment */
        /**
         * Select a specified segment
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.select = /**
         * Select a specified segment
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                // if no segment is specified or it is already selected then do nothing
                if (!segment || this._isSelected(segment)) {
                    return;
                }
                // emit the selection
                this.selectedChange.emit(segment.data);
                // store the selected segment
                this._selected = segment;
                // update the focusable segment
                this._focusableSegment = segment;
                // set our new ranges
                this._x.domain([this.getSegmentX(segment), this.getSegmentX(segment) + this.getSegmentWidth(segment)]);
                this._y.domain([segment.y0, 1]).range([this.getTotalCollapsedHeight(), 100]);
                // create the transition
                /** @type {?} */
                var segmentTransition = d3Transition.transition().duration(500);
                // update the segment sizes - outside angular zone as there is lots of `requestAnimationFrames` triggering lots of change detection
                this._ngZone.runOutsideAngular(function () {
                    _this._segmentsSelection.transition(segmentTransition)
                        .style('left', function (data) { return _this.getNormalizedSegmentX(data) + '%'; })
                        .style('top', function (data) { return _this.getNormalizedSegmentY(data) + '%'; })
                        .style('width', function (data) { return (_this.getNormalizedSegmentWidth(data) + 0.01) + '%'; })
                        .style('height', function (data) { return _this.getNormalizedSegmentHeight(data) + '%'; })
                        .style('padding-right', function (data) { return _this.getSegmentPaddingRight(data) + '%'; })
                        .style('padding-left', function (data) { return _this.getSegmentPaddingLeft(data) + '%'; });
                });
            };
        /** Normalize the available colors to a string[][] from portentially a ThemeColor[][] */
        /**
         * Normalize the available colors to a string[][] from portentially a ThemeColor[][]
         * @param {?} depth
         * @return {?}
         */
        PartitionMapComponent.prototype.getColorSequence = /**
         * Normalize the available colors to a string[][] from portentially a ThemeColor[][]
         * @param {?} depth
         * @return {?}
         */
            function (depth) {
                var _this = this;
                // get the target row
                /** @type {?} */
                var colorSet = this._colors[depth];
                // if no color set available throw an error
                if (!colorSet) {
                    throw new Error('Partition Map: Please provide a color sequence for items with a depth of ' + depth);
                }
                // convert this row to an array of strings
                return colorSet.map(function (color) { return ThemeColor.isInstanceOf(color) ? (( /** @type {?} */(color))).toRgba() : _this._colorService.resolve(( /** @type {?} */(color))); });
            };
        /** Determine if a segment is a descendant of the currently selected item */
        /**
         * Determine if a segment is a descendant of the currently selected item
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.isDescendantOfSelected = /**
         * Determine if a segment is a descendant of the currently selected item
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                // if there are no segments selected then return true
                if (!this._selected) {
                    return true;
                }
                // if the segment is the selected segment then it is not a descendant
                if (this._selected === segment) {
                    return false;
                }
                return !!this._selected.descendants().find(function (_segment) { return _segment === segment; });
            };
        /**
         * We have an option to allow a minimum desired width for items. This will
         * allow us to attempt to determine the size a segment would be accounting for very
         * small segments that have their widths artifically increased to make them more visible
         */
        /**
         * We have an option to allow a minimum desired width for items. This will
         * allow us to attempt to determine the size a segment would be accounting for very
         * small segments that have their widths artifically increased to make them more visible
         * @param {?} segment
         * @return {?}
         */
        PartitionMapComponent.prototype.getDistributionModifier = /**
         * We have an option to allow a minimum desired width for items. This will
         * allow us to attempt to determine the size a segment would be accounting for very
         * small segments that have their widths artifically increased to make them more visible
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                var _this = this;
                var e_2, _a, e_3, _b;
                // calculate the desired number of pixels as a percentage
                /** @type {?} */
                var minSegmentWidth = (this.minSegmentWidth / this._width) * 100;
                // map to a segment width pair
                /** @type {?} */
                var siblings = segment.parent.children.map(function (_segment) {
                    return { segment: _segment, width: _this._x(_segment.x1 - _segment.x0) };
                });
                // a simple closure to check if we now have acceptable sizes
                /** @type {?} */
                var isAcceptable = function (segments) {
                    return !segments.find(function (_segment) { return _segment.width < minSegmentWidth; }) ||
                        segments.filter(function (_segment) { return _segment.width < minSegmentWidth; }).length === siblings.length;
                };
                // if all segments are above or below the desired width then we can stop here
                if (isAcceptable(siblings)) {
                    return 1;
                }
                // find the total amount we need to reclaim for other segments
                /** @type {?} */
                var amountToReclaim = siblings.reduce(function (accumulation, _segment) { return accumulation + (_segment.width < minSegmentWidth ? minSegmentWidth - _segment.width : 0); }, 0);
                // loop through adjusting the segments until we either make all acceptable sizes or cannot resize any further
                while (!isAcceptable(siblings) && amountToReclaim !== 0) {
                    // determine which segments can shrink
                    /** @type {?} */
                    var shrinkableSiblings = siblings.filter(function (sibling) { return sibling.width > minSegmentWidth; });
                    // determine which segments need to grow
                    /** @type {?} */
                    var growableSiblings = siblings.filter(function (sibling) { return sibling.width < minSegmentWidth; });
                    // if there are no items that can be shrunk/grown then do nothing
                    if (shrinkableSiblings.length === 0 || growableSiblings.length === 0) {
                        break;
                    }
                    // determine the target amount to remove from each segment
                    /** @type {?} */
                    var shrinkTarget = amountToReclaim / shrinkableSiblings.length;
                    // store the amount we have reclaimed in this pass
                    /** @type {?} */
                    var reclaimed = 0;
                    try {
                        // iterate each segment and subtract accordingly
                        for (var shrinkableSiblings_1 = __values(shrinkableSiblings), shrinkableSiblings_1_1 = shrinkableSiblings_1.next(); !shrinkableSiblings_1_1.done; shrinkableSiblings_1_1 = shrinkableSiblings_1.next()) {
                            var sibling = shrinkableSiblings_1_1.value;
                            // determine how much we can actually subtract - as subtracting the target may bring the width down below the
                            // minimum which we don't want, so instead determine if we can subtract the target amount, otherwise figure out
                            // how much we can subtract without bringing the width below the desired minimum
                            /** @type {?} */
                            var subtractAmount = sibling.width - shrinkTarget > minSegmentWidth ? shrinkTarget : sibling.width - minSegmentWidth;
                            // update the amount to reclaim with the new value
                            reclaimed += subtractAmount;
                            // update the sibling width
                            sibling.width -= subtractAmount;
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (shrinkableSiblings_1_1 && !shrinkableSiblings_1_1.done && (_a = shrinkableSiblings_1.return))
                                _a.call(shrinkableSiblings_1);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                    // update the amount left to reclaim
                    amountToReclaim -= reclaimed;
                    // determine the target amount to add to each segment
                    /** @type {?} */
                    var growTarget = reclaimed / growableSiblings.length;
                    try {
                        // add the available reclaimed amount to the segment that need to grow
                        for (var growableSiblings_1 = __values(growableSiblings), growableSiblings_1_1 = growableSiblings_1.next(); !growableSiblings_1_1.done; growableSiblings_1_1 = growableSiblings_1.next()) {
                            var sibling = growableSiblings_1_1.value;
                            // determine the amount we need to add. The target amount may be larger than the amount we need
                            // to add so ensure we only add the amount we need and no more.
                            /** @type {?} */
                            var addAmount = sibling.width + growTarget < minSegmentWidth ? growTarget : minSegmentWidth - sibling.width;
                            // update the sibling width
                            sibling.width += addAmount;
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (growableSiblings_1_1 && !growableSiblings_1_1.done && (_b = growableSiblings_1.return))
                                _b.call(growableSiblings_1);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                }
                // identify the current widget from all the siblings
                /** @type {?} */
                var matchingSegment = siblings.find(function (sibling) { return sibling.segment === segment; });
                // check if we are the last sibling
                /** @type {?} */
                var isLast = siblings.findIndex(function (sibling) { return sibling.segment === segment; }) === siblings.length - 1;
                // if we are the last and somehow we are smaller than the parent node, we want to bump up the size of the last node
                if (isLast) {
                    // get the total parent width
                    /** @type {?} */
                    var parentWidth = this._x(segment.parent.x1 - segment.parent.x0);
                    // get the total width of all the children
                    /** @type {?} */
                    var width = siblings.reduce(function (total, sibling) { return total + sibling.width; }, 0);
                    // check if need to expand the last node
                    if (parentWidth !== width) {
                        return (matchingSegment.width + (parentWidth - width)) / this._x(matchingSegment.segment.x1 - matchingSegment.segment.x0);
                    }
                }
                // determine the amount the size has changed
                return matchingSegment.width / this._x(matchingSegment.segment.x1 - matchingSegment.segment.x0);
            };
        /** Get the default announcement when a segment is focused */
        /**
         * Get the default announcement when a segment is focused
         * @param {?} info
         * @return {?}
         */
        PartitionMapComponent.prototype.defaultSegmentAnnouncement = /**
         * Get the default announcement when a segment is focused
         * @param {?} info
         * @return {?}
         */
            function (info) {
                // create the announcement
                if (info.parents.length === 0) {
                    return "This is the root segment. It has a value of " + info.value + ".";
                }
                // otherwise inform the user of the parent hierarchy
                return info.item.name + " has a value of " + info.value + " and is a " + info.parents.map(function (parent) { return "descendant of " + parent.name; }).join(' and a ');
            };
        PartitionMapComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-partition-map',
                        template: "<div class=\"partition-map-segment\"\n     *ngFor=\"let segment of _segments\"\n     uxFocusIndicator\n     [ngClass]=\"_getContrastColor(segment)\"\n     [style.background-color]=\"_getBackgroundColor(segment)\"\n     [tabIndex]=\"_getTabIndex(segment)\"\n     [attr.aria-expanded]=\"!_isCollapsed(segment)\"\n     [attr.aria-selected]=\"_isSelected(segment)\"\n     [attr.aria-level]=\"segment.depth\"\n     (click)=\"_onSegmentSelect(segment)\"\n     (focus)=\"_onFocus(segment)\"\n     (keydown.Enter)=\"_onSegmentSelect(segment)\"\n     (keydown.ArrowUp)=\"_focusParent(segment); $event.preventDefault()\"\n     (keydown.ArrowDown)=\"_focusChild(segment); $event.preventDefault()\"\n     (keydown.ArrowLeft)=\"_focusSibling(segment, -1); $event.preventDefault()\"\n     (keydown.ArrowRight)=\"_focusSibling(segment, 1); $event.preventDefault()\"\n     (keydown.Home)=\"_focusFirstSibling(segment); $event.preventDefault()\"\n     (keydown.End)=\"_focusLastSibling(segment); $event.preventDefault()\">\n\n     <div class=\"partition-map-segment-content\" [class.partition-map-segment-content-hidden]=\"_getSegmentContentHidden(segment)\">\n\n      <!-- Show default template if provided -->\n      <span class=\"partition-map-segment-label\" *ngIf=\"!segmentTemplate\">\n        {{ segment.data.name }}\n      </span>\n\n       <!-- Show custom template if provided -->\n      <ng-container *ngIf=\"segmentTemplate\"\n        [ngTemplateOutlet]=\"segmentTemplate\"\n        [ngTemplateOutletContext]=\"_getContext(segment)\">\n      </ng-container>\n    </div>\n\n</div>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        PartitionMapComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: i0.ElementRef },
                { type: i0.ChangeDetectorRef },
                { type: i0.NgZone },
                { type: FocusIndicatorOriginService },
                { type: ContrastService },
                { type: a11y.LiveAnnouncer },
                { type: ResizeService }
            ];
        };
        PartitionMapComponent.propDecorators = {
            colors: [{ type: i0.Input }],
            collapsedHeight: [{ type: i0.Input }],
            minSegmentWidth: [{ type: i0.Input }],
            dataset: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            segmentAnnouncement: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            segmentTemplate: [{ type: i0.ContentChild, args: ['partitionMapSegment', { static: false },] }]
        };
        return PartitionMapComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PartitionMapModule = /** @class */ (function () {
        function PartitionMapModule() {
        }
        PartitionMapModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            ColorServiceModule,
                            ResizeModule
                        ],
                        declarations: [
                            PartitionMapComponent,
                            PartitionMapSegmentEventsDirective
                        ],
                        exports: [
                            PartitionMapComponent,
                            PartitionMapSegmentEventsDirective
                        ]
                    },] }
        ];
        return PartitionMapModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ProgressBarComponent = /** @class */ (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.min = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        Object.defineProperty(ProgressBarComponent.prototype, "valueNow", {
            /** When indeteminate we should omit the valuenow label */
            get: /**
             * When indeteminate we should omit the valuenow label
             * @return {?}
             */ function () {
                return this.indeterminate ? null : this.value;
            },
            enumerable: true,
            configurable: true
        });
        ProgressBarComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-progress-bar',
                        template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"((value - min) / (max - min)) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n\n<!-- Workaround for Multiple ng-content tags issue: https://github.com/angular/angular/issues/22972 -->\n<ng-template #content><ng-content></ng-content></ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            role: 'progressbar'
                        }
                    }] }
        ];
        ProgressBarComponent.propDecorators = {
            value: [{ type: i0.Input }],
            min: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-valuemin',] }],
            max: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.aria-valuemax',] }],
            indeterminate: [{ type: i0.Input }],
            trackColor: [{ type: i0.Input }],
            barColor: [{ type: i0.Input }],
            valueNow: [{ type: i0.HostBinding, args: ['attr.aria-valuenow',] }]
        };
        return ProgressBarComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ProgressBarModule = /** @class */ (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [ProgressBarComponent],
                        declarations: [ProgressBarComponent]
                    },] }
        ];
        return ProgressBarModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return RadioButtonGroupDirective; }),
        multi: true
    };
    var RadioButtonGroupDirective = /** @class */ (function () {
        function RadioButtonGroupDirective() {
            this.valueChange = new i0.EventEmitter();
            this._onDestroy = new rxjs.Subject();
            this.onTouched = function () { };
            this.onChange = function () { };
            this._value = null;
        }
        Object.defineProperty(RadioButtonGroupDirective.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.updateSelectedRadioButton();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.updateSelectedRadioButton();
                // update the selected items any time new ones are added
                this._radioButtons.changes.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.updateSelectedRadioButton(); });
            };
        /**
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                if (this._radioButtons) {
                    this._radioButtons.forEach(function (radio) { return radio.setDisabledState(isDisabled); });
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.emitChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.valueChange.next(value);
                this.onChange(value);
                this.onTouched();
            };
        /**
         * @return {?}
         */
        RadioButtonGroupDirective.prototype.updateSelectedRadioButton = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update the selected value in all radio buttons
                if (this._radioButtons) {
                    this._radioButtons.forEach(function (radio) { return radio.writeValue(_this._value); });
                }
            };
        RadioButtonGroupDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'ux-radio-button-group, [uxRadioButtonGroup]',
                        providers: [
                            RADIO_GROUP_CONTROL_VALUE_ACCESSOR
                        ],
                        host: {
                            'role': 'radiogroup'
                        }
                    },] }
        ];
        RadioButtonGroupDirective.propDecorators = {
            value: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            _radioButtons: [{ type: i0.ContentChildren, args: [i0.forwardRef(function () { return RadioButtonComponent; }), { descendants: true },] }]
        };
        return RadioButtonGroupDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    /** @type {?} */
    var uniqueRadioId = 0;
    var RadioButtonComponent = /** @class */ (function () {
        function RadioButtonComponent(_changeDetector, _group) {
            this._changeDetector = _changeDetector;
            this._group = _group;
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            /**
             * Specify a unique Id for this component
             */
            this.id = this._radioButtonId;
            /**
             * Specify the tabindex
             */
            this.tabindex = 0;
            /**
             * If set to `true` the radio button will not change state when clicked.
             */
            this.clickable = true;
            /**
             * If this value is set to `true` then the radio button will be disabled
             */
            this.disabled = false;
            /**
             * If set to `true` the checkbox will be displayed without a border and background.
             */
            this.simplified = false;
            /**
             * Specify an aria label for the input element
             */
            this.ariaLabel = '';
            /**
             * Specify an aria labelledby property for the input element
             */
            this.ariaLabelledby = null;
            /**
             * Specify an aria describedby property for the input element
             */
            this.ariaDescribedby = null;
            /**
             * Emits when the value has been changed.
             */
            this.valueChange = new i0.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(RadioButtonComponent.prototype, "value", {
            /** This should be a two way binding and will store the currently selected option. Each radio button in the same group should have the same value variable. */
            get: /**
             * This should be a two way binding and will store the currently selected option. Each radio button in the same group should have the same value variable.
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._radioButtonId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                // toggle the checked state
                this.value = this.option;
                // if there is a group set the selected value
                if (this._group) {
                    this._group.value = this.option;
                    this._group.emitChange(this.option);
                }
                // call callback
                this.onChangeCallback(this.value);
            };
        // Functions required to update ng-model
        // Functions required to update ng-model
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue =
            // Functions required to update ng-model
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                    this._changeDetector.detectChanges();
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        RadioButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-radio-button',
                        template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n\n        <input class=\"ux-radio-button-input\"\n            uxFocusIndicator\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (indicator)=\"focused = $event\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                        providers: [RADIOBUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: RadioButtonGroupDirective, decorators: [{ type: i0.Optional }] }
            ];
        };
        RadioButtonComponent.propDecorators = {
            id: [{ type: i0.Input }],
            name: [{ type: i0.Input }],
            required: [{ type: i0.Input }],
            tabindex: [{ type: i0.Input }],
            clickable: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            simplified: [{ type: i0.Input }],
            option: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: i0.Input, args: ['aria-labelledby',] }],
            ariaDescribedby: [{ type: i0.Input, args: ['aria-describedby',] }],
            valueChange: [{ type: i0.Output }],
            value: [{ type: i0.Input }]
        };
        return RadioButtonComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var RadioButtonModule = /** @class */ (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            forms.FormsModule
                        ],
                        exports: [
                            RadioButtonComponent,
                            RadioButtonGroupDirective
                        ],
                        declarations: [
                            RadioButtonComponent,
                            RadioButtonGroupDirective
                        ]
                    },] }
        ];
        return RadioButtonModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ SankeyChart = /** @class */ (function () {
        function SankeyChart() {
            /**
             * Define the nodes in the chart
             */
            this._nodes = [];
            /**
             * Define the links in the chart
             */
            this._links = [];
            /**
             * Store the node-links
             */
            this._nodeLinks = [];
            /**
             * Define the minimum width of the nodes
             */
            this._minWidth = 0;
            /**
             * Define the maximum width of the nodes
             */
            this._maxWidth = Infinity;
            /**
             * Define the minimum distance from the edge of the chart
             */
            this._padding = 24;
        }
        /** Define the spacing of the chart */
        /**
         * Define the spacing of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} spacing
         * @return {THIS}
         */
        SankeyChart.prototype.spacing = /**
         * Define the spacing of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} spacing
         * @return {THIS}
         */
            function (spacing) {
                ( /** @type {?} */(this))._spacing = spacing;
                return ( /** @type {?} */(this));
            };
        /** Define the width of the chart */
        /**
         * Define the width of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} width
         * @return {THIS}
         */
        SankeyChart.prototype.width = /**
         * Define the width of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} width
         * @return {THIS}
         */
            function (width) {
                ( /** @type {?} */(this))._width = width;
                return ( /** @type {?} */(this));
            };
        /** Define the height of the chart */
        /**
         * Define the height of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} height
         * @return {THIS}
         */
        SankeyChart.prototype.height = /**
         * Define the height of the chart
         * @template THIS
         * @this {THIS}
         * @param {?} height
         * @return {THIS}
         */
            function (height) {
                ( /** @type {?} */(this))._height = height;
                return ( /** @type {?} */(this));
            };
        /** Define the nodes */
        /**
         * Define the nodes
         * @template THIS
         * @this {THIS}
         * @param {?} nodes
         * @return {THIS}
         */
        SankeyChart.prototype.nodes = /**
         * Define the nodes
         * @template THIS
         * @this {THIS}
         * @param {?} nodes
         * @return {THIS}
         */
            function (nodes) {
                ( /** @type {?} */(this))._nodes = nodes;
                return ( /** @type {?} */(this));
            };
        /** Define the links */
        /**
         * Define the links
         * @template THIS
         * @this {THIS}
         * @param {?} links
         * @return {THIS}
         */
        SankeyChart.prototype.links = /**
         * Define the links
         * @template THIS
         * @this {THIS}
         * @param {?} links
         * @return {THIS}
         */
            function (links) {
                ( /** @type {?} */(this))._links = links;
                return ( /** @type {?} */(this));
            };
        /** Define the minimum and maximum size of the nodes */
        /**
         * Define the minimum and maximum size of the nodes
         * @template THIS
         * @this {THIS}
         * @param {?} minWidth
         * @param {?} maxWidth
         * @param {?} minHeight
         * @return {THIS}
         */
        SankeyChart.prototype.size = /**
         * Define the minimum and maximum size of the nodes
         * @template THIS
         * @this {THIS}
         * @param {?} minWidth
         * @param {?} maxWidth
         * @param {?} minHeight
         * @return {THIS}
         */
            function (minWidth, maxWidth, minHeight) {
                ( /** @type {?} */(this))._minWidth = minWidth;
                ( /** @type {?} */(this))._maxWidth = maxWidth;
                ( /** @type {?} */(this))._minHeight = minHeight;
                return ( /** @type {?} */(this));
            };
        /** Get the sizes of each column */
        /**
         * Get the sizes of each column
         * @return {?}
         */
        SankeyChart.prototype.columns = /**
         * Get the sizes of each column
         * @return {?}
         */
            function () {
                // get the number of columns - we use this a lot so avoid multiple function calls
                /** @type {?} */
                var columnCount = this.getColumnCount();
                // get the amount of padding there should be on each side of a node
                /** @type {?} */
                var padding = this.getColumnPadding();
                /** @type {?} */
                var columnWidths = [];
                for (var idx = 0; idx < columnCount; idx++) {
                    columnWidths[idx] = this.getNodeWidth() + (padding * 2);
                    // do no have the default padding on the left of the start node
                    // or right of the last node, instead have a default padding
                    if (idx === 0 || idx === columnCount - 1) {
                        columnWidths[idx] -= (padding - this._padding);
                    }
                }
                return columnWidths;
            };
        /**
         * Perform the various stages of the layout
         * in the correct order as some steps are dependant
         * on the previous layout stages.
         */
        /**
         * Perform the various stages of the layout
         * in the correct order as some steps are dependant
         * on the previous layout stages.
         * @return {?}
         */
        SankeyChart.prototype.layout = /**
         * Perform the various stages of the layout
         * in the correct order as some steps are dependant
         * on the previous layout stages.
         * @return {?}
         */
            function () {
                this.getNodeLinks();
                this.getNodeValues();
                this.getNodeColumns();
                this.getNodeWidths();
                this.getNodeHeights();
                this.getNodePositions();
                this.getLinkPlots();
                return this._nodeLinks;
            };
        /** The curve equation for links */
        /**
         * The curve equation for links
         * @param {?} link
         * @return {?}
         */
        SankeyChart.prototype.link = /**
         * The curve equation for links
         * @param {?} link
         * @return {?}
         */
            function (link) {
                // const dist = chart.blockSpacing / 2;
                var topLeft = link.topLeft, topRight = link.topRight, bottomLeft = link.bottomLeft, bottomRight = link.bottomRight;
                /** @type {?} */
                var dist = (topRight[0] - topLeft[0]) / 2;
                /** @type {?} */
                var topLeftCurve = [topLeft[0] + dist, topLeft[1]];
                /** @type {?} */
                var topRightCurve = [topRight[0] - dist, topRight[1]];
                /** @type {?} */
                var bottomLeftCurve = [bottomLeft[0] + dist, bottomLeft[1]];
                /** @type {?} */
                var bottomRightCurve = [bottomRight[0] - dist, bottomRight[1]];
                return 'M' + topLeft[0] + ',' + topLeft[1] +
                    'C' + topLeftCurve[0] + ',' + topLeftCurve[1] +
                    ' ' + topRightCurve[0] + ',' + topRightCurve[1] +
                    ' ' + topRight[0] + ',' + topRight[1] +
                    'L' + bottomRight[0] + ',' + bottomRight[1] +
                    'C' + bottomRightCurve[0] + ',' + bottomRightCurve[1] +
                    ' ' + bottomLeftCurve[0] + ',' + bottomLeftCurve[1] +
                    ' ' + bottomLeft[0] + ',' + bottomLeft[1] +
                    'L' + topLeft[0] + ',' + topLeft[1];
            };
        /**
         * @param {?} nodeLink
         * @return {?}
         */
        SankeyChart.prototype.getFalloffPath = /**
         * @param {?} nodeLink
         * @return {?}
         */
            function (nodeLink) {
                /** @type {?} */
                var x = (nodeLink.x + nodeLink.width);
                /** @type {?} */
                var y = nodeLink.outputs.reduce(function (bottom, output) { return Math.max(bottom, output.bottomLeft[1]); }, 0);
                /** @type {?} */
                var width = 20;
                /** @type {?} */
                var radius = 6;
                /** @type {?} */
                var height = (nodeLink.y + nodeLink.height - y) + (this._spacing / 2);
                return 'M' + x + ',' + y +
                    'h ' + (width - radius) +
                    'a' + radius + ',' + radius + ' 0 0,1' +
                    (radius) + ',' + (radius) + ' ' +
                    'v' + Math.max(radius, height) + 'h-' + width + 'Z';
            };
        /**
         * Get a `SankeyNodeLink` object from the id of a node
         */
        /**
         * Get a `SankeyNodeLink` object from the id of a node
         * @param {?} id
         * @return {?}
         */
        SankeyChart.prototype.getNodeLink = /**
         * Get a `SankeyNodeLink` object from the id of a node
         * @param {?} id
         * @return {?}
         */
            function (id) {
                return this._nodeLinks.find(function (nodeLink) { return nodeLink.node.id === id; });
            };
        /** Replace the node ids with actual references */
        /**
         * Replace the node ids with actual references
         * @return {?}
         */
        SankeyChart.prototype.getNodeLinks = /**
         * Replace the node ids with actual references
         * @return {?}
         */
            function () {
                var _this = this;
                this._nodeLinks = this._nodes.map(function (node) {
                    // get all the links that input into and output from this node
                    /** @type {?} */
                    var inputs = _this._links.filter(function (link) { return link.target === node.id; });
                    /** @type {?} */
                    var outputs = _this._links.filter(function (link) { return link.source === node.id; });
                    return ( /** @type {?} */({ node: node, inputs: inputs, outputs: outputs, value: 0, column: 0, x: 0, y: 0, width: 0, height: 0, naturalHeight: 0, falloff: 0, active: false, focus: false }));
                });
            };
        /** Get the value for the node based on all its inputs and outputs */
        /**
         * Get the value for the node based on all its inputs and outputs
         * @return {?}
         */
        SankeyChart.prototype.getNodeValues = /**
         * Get the value for the node based on all its inputs and outputs
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    for (var _b = __values(this._nodeLinks), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var node = _c.value;
                        // the node value can be determined by the total values from all inputs
                        // however the first column of nodes have no inputs so must be based of their outputs.
                        // We should take the maximum value based on the inputs and outputs as nodes that are
                        // not in the first column may not output all of the amount the receive from inputs,
                        // for example in the case of falloff etc..
                        node.value = Math.max(d3Array.sum(node.inputs, function (input) { return input.value; }), d3Array.sum(node.outputs, function (output) { return output.value; }));
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /**
         * We need to determine which column the node should
         * be placed in. This is determined by taking the input
         * and adding one.
         */
        /**
         * We need to determine which column the node should
         * be placed in. This is determined by taking the input
         * and adding one.
         * @param {?=} nodeLinks
         * @param {?=} column
         * @return {?}
         */
        SankeyChart.prototype.getNodeColumns = /**
         * We need to determine which column the node should
         * be placed in. This is determined by taking the input
         * and adding one.
         * @param {?=} nodeLinks
         * @param {?=} column
         * @return {?}
         */
            function (nodeLinks, column) {
                var _this = this;
                var e_2, _a;
                if (nodeLinks === void 0) {
                    nodeLinks = this._nodeLinks.filter(function (node) { return node.inputs.length === 0; });
                }
                if (column === void 0) {
                    column = 0;
                }
                try {
                    for (var nodeLinks_1 = __values(nodeLinks), nodeLinks_1_1 = nodeLinks_1.next(); !nodeLinks_1_1.done; nodeLinks_1_1 = nodeLinks_1.next()) {
                        var nodeLink = nodeLinks_1_1.value;
                        nodeLink.column = column;
                        // call this function to all output links
                        this.getNodeColumns(nodeLink.outputs.map(function (output) { return _this.getNodeLink(output.target); }), column + 1);
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (nodeLinks_1_1 && !nodeLinks_1_1.done && (_a = nodeLinks_1.return))
                            _a.call(nodeLinks_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            };
        /** Get the width of each node */
        /**
         * Get the width of each node
         * @return {?}
         */
        SankeyChart.prototype.getNodeWidths = /**
         * Get the width of each node
         * @return {?}
         */
            function () {
                var _this = this;
                this._nodeLinks.forEach(function (node) { return node.width = _this.getNodeWidth(); });
            };
        /**
         * Scale the nodes height based on the value the represent
         */
        /**
         * Scale the nodes height based on the value the represent
         * @return {?}
         */
        SankeyChart.prototype.getNodeHeights = /**
         * Scale the nodes height based on the value the represent
         * @return {?}
         */
            function () {
                var e_3, _a, e_4, _b;
                // get columns by group
                /** @type {?} */
                var groups = this.getColumnGroups();
                /** @type {?} */
                var groupList = Object.keys(groups).map(function (group) { return groups[group]; });
                // get the column with the largest total value
                /** @type {?} */
                var total = groupList.reduce(function (count, nodes) { return Math.max(count, nodes.reduce(function (accumulation, node) { return accumulation + node.value; }, 0)); }, 0);
                try {
                    // Calculate node heights
                    for (var groupList_1 = __values(groupList), groupList_1_1 = groupList_1.next(); !groupList_1_1.done; groupList_1_1 = groupList_1.next()) {
                        var nodeLinks = groupList_1_1.value;
                        try {
                            // get the proportional size of each node based on the available space
                            for (var nodeLinks_2 = __values(nodeLinks), nodeLinks_2_1 = nodeLinks_2.next(); !nodeLinks_2_1.done; nodeLinks_2_1 = nodeLinks_2.next()) {
                                var nodeLink = nodeLinks_2_1.value;
                                nodeLink.naturalHeight = ((nodeLink.value / total) * this._height) - this._spacing;
                                nodeLink.height = Math.max(nodeLink.naturalHeight, this._minHeight);
                            }
                        }
                        catch (e_4_1) {
                            e_4 = { error: e_4_1 };
                        }
                        finally {
                            try {
                                if (nodeLinks_2_1 && !nodeLinks_2_1.done && (_b = nodeLinks_2.return))
                                    _b.call(nodeLinks_2);
                            }
                            finally {
                                if (e_4)
                                    throw e_4.error;
                            }
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (groupList_1_1 && !groupList_1_1.done && (_a = groupList_1.return))
                            _a.call(groupList_1);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                // If minHeight is defined, it might cause some columns to exceed the height of the chart following the
                // initial height calculation.
                if (this._minHeight > 0) {
                    try {
                        // Recalculate node heights until they fit (if possible)
                        this.adjustNodeHeightsToFit(groupList);
                    }
                    catch (error) {
                        // If the above recalculation fails, give up and use the naturalHeight (ignore minHeight)
                        this.setNodesToNaturalHeight(groupList);
                    }
                }
            };
        /**
         * Recalculate node heights within height limits until they fit (if possible).
         * @throws If it is not possible to fit all nodes in the chart due to `minHeight`.
         */
        /**
         * Recalculate node heights within height limits until they fit (if possible).
         * @throws If it is not possible to fit all nodes in the chart due to `minHeight`.
         * @param {?} groupList
         * @return {?}
         */
        SankeyChart.prototype.adjustNodeHeightsToFit = /**
         * Recalculate node heights within height limits until they fit (if possible).
         * @throws If it is not possible to fit all nodes in the chart due to `minHeight`.
         * @param {?} groupList
         * @return {?}
         */
            function (groupList) {
                var _this = this;
                var e_5, _a, e_6, _b;
                /** @type {?} */
                var largestColumn = this.getLargestColumn(groupList);
                while (largestColumn.height > this._height) {
                    // Get the list of nodes whose height cannot be reduced
                    /** @type {?} */
                    var fixedNodes = largestColumn.nodes.filter(function (nodeLink) { return nodeLink.height <= _this._minHeight; });
                    // Get the total height in the column which cannot shrink (including spacing)
                    /** @type {?} */
                    var fixedHeight = fixedNodes.length * this._minHeight + largestColumn.nodes.length * this._spacing;
                    // If the unshrinkable height is greater than the available height, we can't continue
                    if (fixedHeight > this._height) {
                        throw new Error("Cannot fit data into chart with minHeight = " + this._minHeight + "px (need " + fixedHeight + "px; " + this._height + "px available)");
                    }
                    // Find the amount of height which can potentially be reduced
                    /** @type {?} */
                    var flexibleHeight = largestColumn.height - fixedHeight;
                    // Find the amount of height that the above needs to fit into
                    /** @type {?} */
                    var availableHeight = this._height - fixedHeight;
                    // Get the multiplier to reduce the nodes in order to fit the available height
                    /** @type {?} */
                    var ratio = availableHeight / flexibleHeight;
                    try {
                        // Adjust the nodes and reapply the minHeight
                        for (var groupList_2 = __values(groupList), groupList_2_1 = groupList_2.next(); !groupList_2_1.done; groupList_2_1 = groupList_2.next()) {
                            var group = groupList_2_1.value;
                            try {
                                for (var group_1 = __values(group), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                                    var nodeLink = group_1_1.value;
                                    if (nodeLink.height > this._minHeight) {
                                        nodeLink.height *= ratio;
                                    }
                                    if (nodeLink.height < this._minHeight) {
                                        nodeLink.height = this._minHeight;
                                    }
                                }
                            }
                            catch (e_6_1) {
                                e_6 = { error: e_6_1 };
                            }
                            finally {
                                try {
                                    if (group_1_1 && !group_1_1.done && (_b = group_1.return))
                                        _b.call(group_1);
                                }
                                finally {
                                    if (e_6)
                                        throw e_6.error;
                                }
                            }
                        }
                    }
                    catch (e_5_1) {
                        e_5 = { error: e_5_1 };
                    }
                    finally {
                        try {
                            if (groupList_2_1 && !groupList_2_1.done && (_a = groupList_2.return))
                                _a.call(groupList_2);
                        }
                        finally {
                            if (e_5)
                                throw e_5.error;
                        }
                    }
                    largestColumn = this.getLargestColumn(groupList);
                }
            };
        /** Set all nodes height to be the same as the naturalHeight. */
        /**
         * Set all nodes height to be the same as the naturalHeight.
         * @param {?} groupList
         * @return {?}
         */
        SankeyChart.prototype.setNodesToNaturalHeight = /**
         * Set all nodes height to be the same as the naturalHeight.
         * @param {?} groupList
         * @return {?}
         */
            function (groupList) {
                var e_7, _a, e_8, _b;
                try {
                    for (var groupList_3 = __values(groupList), groupList_3_1 = groupList_3.next(); !groupList_3_1.done; groupList_3_1 = groupList_3.next()) {
                        var group = groupList_3_1.value;
                        try {
                            for (var group_2 = __values(group), group_2_1 = group_2.next(); !group_2_1.done; group_2_1 = group_2.next()) {
                                var nodeLink = group_2_1.value;
                                nodeLink.height = nodeLink.naturalHeight;
                            }
                        }
                        catch (e_8_1) {
                            e_8 = { error: e_8_1 };
                        }
                        finally {
                            try {
                                if (group_2_1 && !group_2_1.done && (_b = group_2.return))
                                    _b.call(group_2);
                            }
                            finally {
                                if (e_8)
                                    throw e_8.error;
                            }
                        }
                    }
                }
                catch (e_7_1) {
                    e_7 = { error: e_7_1 };
                }
                finally {
                    try {
                        if (groupList_3_1 && !groupList_3_1.done && (_a = groupList_3.return))
                            _a.call(groupList_3);
                    }
                    finally {
                        if (e_7)
                            throw e_7.error;
                    }
                }
            };
        /**
         * Get all nodes grouped in their corresponding columns
         */
        /**
         * Get all nodes grouped in their corresponding columns
         * @return {?}
         */
        SankeyChart.prototype.getColumnGroups = /**
         * Get all nodes grouped in their corresponding columns
         * @return {?}
         */
            function () {
                // group nodes by columns
                return this._nodeLinks.reduce(function (collection, nodeLink) {
                    collection[nodeLink.column] = collection[nodeLink.column] || [];
                    collection[nodeLink.column].push(nodeLink);
                    return collection;
                }, {});
            };
        /**
         * Get the number of columns
         */
        /**
         * Get the number of columns
         * @return {?}
         */
        SankeyChart.prototype.getColumnCount = /**
         * Get the number of columns
         * @return {?}
         */
            function () {
                return this._nodeLinks.reduce(function (column, nodeLink) { return Math.max(nodeLink.column + 1, column); }, 0);
            };
        /**
         * Position the nodes in their corresponding x and y positions
         */
        /**
         * Position the nodes in their corresponding x and y positions
         * @return {?}
         */
        SankeyChart.prototype.getNodePositions = /**
         * Position the nodes in their corresponding x and y positions
         * @return {?}
         */
            function () {
                var e_9, _a;
                // get all nodes by group
                /** @type {?} */
                var groups = this.getColumnGroups();
                // get the amount of padding required between each item
                /** @type {?} */
                var padding = this.getColumnPadding();
                try {
                    for (var _b = __values(this._nodeLinks), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var nodeLink = _c.value;
                        // get the x position based on the column
                        nodeLink.x = this.getColumnPosition(nodeLink.column) + padding;
                        if (nodeLink.column === 0) {
                            nodeLink.x = this._padding;
                        }
                        // get the y position based on the accumulative height of the nodes above it
                        nodeLink.y = groups[nodeLink.column]
                            .slice(0, groups[nodeLink.column].indexOf(nodeLink))
                            .reduce(function (top, _node) { return top + _node.height; }, 0) + (this._spacing * groups[nodeLink.column].indexOf(nodeLink));
                    }
                }
                catch (e_9_1) {
                    e_9 = { error: e_9_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_9)
                            throw e_9.error;
                    }
                }
            };
        /**
         * @return {?}
         */
        SankeyChart.prototype.getColumnPadding = /**
         * @return {?}
         */
            function () {
                // get the number of columns - we use this a lot so avoid multiple function calls
                /** @type {?} */
                var columnCount = this.getColumnCount();
                // get the chart width minus the width of the nodes
                /** @type {?} */
                var width = (this._width - (columnCount * this.getNodeWidth())) - (this._padding * 2);
                // get the total amount of places requiring padding (the first and last columns only have padding on one side)
                /** @type {?} */
                var paddingCount = Math.max(((columnCount * 2) - 2), 0);
                // get the actual size of the padding
                return width / paddingCount;
            };
        /**
         * @return {?}
         */
        SankeyChart.prototype.getLinkPlots = /**
         * @return {?}
         */
            function () {
                var e_10, _a, e_11, _b, e_12, _c;
                try {
                    for (var _d = __values(this._nodeLinks), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var nodeLink = _e.value;
                        /** @type {?} */
                        var inputY = nodeLink.y;
                        try {
                            // process each input link
                            for (var _f = __values(nodeLink.inputs), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var link = _g.value;
                                link.topRight = [nodeLink.x, inputY];
                                inputY += ((link.value / nodeLink.value) * nodeLink.height);
                                link.bottomRight = [nodeLink.x, inputY];
                            }
                        }
                        catch (e_11_1) {
                            e_11 = { error: e_11_1 };
                        }
                        finally {
                            try {
                                if (_g && !_g.done && (_b = _f.return))
                                    _b.call(_f);
                            }
                            finally {
                                if (e_11)
                                    throw e_11.error;
                            }
                        }
                        /** @type {?} */
                        var outputValue = 0;
                        /** @type {?} */
                        var outputY = nodeLink.y;
                        try {
                            // process each output link
                            for (var _h = __values(nodeLink.outputs), _j = _h.next(); !_j.done; _j = _h.next()) {
                                var link = _j.value;
                                link.topLeft = [nodeLink.x + nodeLink.width, outputY];
                                outputY += ((link.value / nodeLink.value) * nodeLink.height);
                                link.bottomLeft = [nodeLink.x + nodeLink.width, outputY];
                                outputValue += link.value;
                            }
                        }
                        catch (e_12_1) {
                            e_12 = { error: e_12_1 };
                        }
                        finally {
                            try {
                                if (_j && !_j.done && (_c = _h.return))
                                    _c.call(_h);
                            }
                            finally {
                                if (e_12)
                                    throw e_12.error;
                            }
                        }
                        // determine how much falloff there is
                        nodeLink.falloff = nodeLink.value - outputValue;
                    }
                }
                catch (e_10_1) {
                    e_10 = { error: e_10_1 };
                }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return))
                            _a.call(_d);
                    }
                    finally {
                        if (e_10)
                            throw e_10.error;
                    }
                }
            };
        /** Determine the position at which a column starts */
        /**
         * Determine the position at which a column starts
         * @param {?} column
         * @return {?}
         */
        SankeyChart.prototype.getColumnPosition = /**
         * Determine the position at which a column starts
         * @param {?} column
         * @return {?}
         */
            function (column) {
                // the position is the acculation of the widths of all previous columns
                return this.columns().splice(0, column).reduce(function (total, width) { return total + width; }, 0);
            };
        /** Get the pixel width of a node */
        /**
         * Get the pixel width of a node
         * @return {?}
         */
        SankeyChart.prototype.getNodeWidth = /**
         * Get the pixel width of a node
         * @return {?}
         */
            function () {
                /** @type {?} */
                var width = (this._width - (this._padding * 2)) / ((this.getColumnCount() * 2) - 1);
                return Math.min(this._maxWidth, Math.max(this._minWidth, width));
            };
        /** Get the column with the greatest height (along with its height) */
        /**
         * Get the column with the greatest height (along with its height)
         * @param {?} groupList
         * @return {?}
         */
        SankeyChart.prototype.getLargestColumn = /**
         * Get the column with the greatest height (along with its height)
         * @param {?} groupList
         * @return {?}
         */
            function (groupList) {
                var e_13, _a;
                /** @type {?} */
                var largestColumn = null;
                /** @type {?} */
                var largestColumnHeight = 0;
                try {
                    for (var groupList_4 = __values(groupList), groupList_4_1 = groupList_4.next(); !groupList_4_1.done; groupList_4_1 = groupList_4.next()) {
                        var group = groupList_4_1.value;
                        /** @type {?} */
                        var totalHeight = group.reduce(function (acc, node) { return acc += node.height; }, 0) + group.length * this._spacing;
                        if (totalHeight > largestColumnHeight) {
                            largestColumnHeight = totalHeight;
                            largestColumn = group;
                        }
                    }
                }
                catch (e_13_1) {
                    e_13 = { error: e_13_1 };
                }
                finally {
                    try {
                        if (groupList_4_1 && !groupList_4_1.done && (_a = groupList_4.return))
                            _a.call(groupList_4);
                    }
                    finally {
                        if (e_13)
                            throw e_13.error;
                    }
                }
                return {
                    nodes: largestColumn,
                    height: largestColumnHeight
                };
            };
        return SankeyChart;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SankeyFocusManager = /** @class */ (function () {
        function SankeyFocusManager() {
            /**
             * Store the node that can currently be tabbed to
             */
            this.active$ = new rxjs.BehaviorSubject(null);
            /**
             * Emit whenever an item should receive focus
             */
            this.focused$ = new rxjs.Subject();
            /**
             * Store the nodes
             */
            this._nodes = [];
        }
        Object.defineProperty(SankeyFocusManager.prototype, "_active", {
            /** Get the current active item */
            get: /**
             * Get the current active item
             * @return {?}
             */ function () {
                return this.active$.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SankeyFocusManager.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.active$.complete();
                this.focused$.complete();
            };
        /** Update the list of possible nodes */
        /**
         * Update the list of possible nodes
         * @param {?} nodes
         * @return {?}
         */
        SankeyFocusManager.prototype.setNodes = /**
         * Update the list of possible nodes
         * @param {?} nodes
         * @return {?}
         */
            function (nodes) {
                this._nodes = nodes;
                // check if there is currently a tabbable node, if not we should make the first node tabbable
                if (!this.hasActiveNode()) {
                    this.setActiveItem(this._nodes[0]);
                }
            };
        /** Set the current active item */
        /**
         * Set the current active item
         * @param {?} node
         * @return {?}
         */
        SankeyFocusManager.prototype.setActiveItem = /**
         * Set the current active item
         * @param {?} node
         * @return {?}
         */
            function (node) {
                this.active$.next(node);
            };
        /** Handle keyboard input from nodes */
        /**
         * Handle keyboard input from nodes
         * @param {?} event
         * @return {?}
         */
        SankeyFocusManager.prototype.onKeydown = /**
         * Handle keyboard input from nodes
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        this.shiftFocusVertically(-1);
                        event.preventDefault();
                        break;
                    case keycodes.DOWN_ARROW:
                        this.shiftFocusVertically(1);
                        event.preventDefault();
                        break;
                    case keycodes.LEFT_ARROW:
                        this.shiftFocusHorizontally(-1);
                        event.preventDefault();
                        break;
                    case keycodes.RIGHT_ARROW:
                        this.shiftFocusHorizontally(1);
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        SankeyFocusManager.prototype.setFocusedItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.setActiveItem(item);
                this.focused$.next(item);
            };
        /**
         * @param {?} delta
         * @return {?}
         */
        SankeyFocusManager.prototype.shiftFocusVertically = /**
         * @param {?} delta
         * @return {?}
         */
            function (delta) {
                var _this = this;
                /** @type {?} */
                var nodes = this.getNodesInColumn(this._active.column);
                // get the node below or above the active node
                /** @type {?} */
                var target = nodes[nodes.findIndex(function (node) { return node.node.id === _this._active.node.id; }) + delta];
                if (target) {
                    this.setFocusedItem(target);
                }
            };
        /** Shift the focus to a node in a sibling column */
        /**
         * Shift the focus to a node in a sibling column
         * @param {?} delta
         * @return {?}
         */
        SankeyFocusManager.prototype.shiftFocusHorizontally = /**
         * Shift the focus to a node in a sibling column
         * @param {?} delta
         * @return {?}
         */
            function (delta) {
                var _this = this;
                // get nodes in the sibling column in the desired direction
                /** @type {?} */
                var nodes = this.getNodesInColumn(this._active.column + delta);
                // if there are no nodes then do nothing as we cannot reduce an empty array
                if (nodes.length === 0) {
                    return;
                }
                // get the node with the most similar y position
                /** @type {?} */
                var target = nodes.reduce(function (closest, node) {
                    /** @type {?} */
                    var closestDiff = Math.max(closest.y, _this._active.y) - Math.min(closest.y, _this._active.y);
                    /** @type {?} */
                    var currentDiff = Math.max(node.y, _this._active.y) - Math.min(node.y, _this._active.y);
                    return closestDiff < currentDiff ? closest : node;
                });
                if (target) {
                    this.setFocusedItem(target);
                }
            };
        /** Get a list of nodes that are in a given column */
        /**
         * Get a list of nodes that are in a given column
         * @param {?} column
         * @return {?}
         */
        SankeyFocusManager.prototype.getNodesInColumn = /**
         * Get a list of nodes that are in a given column
         * @param {?} column
         * @return {?}
         */
            function (column) {
                return this.getNodesInOrder(this._nodes.filter(function (node) { return node.column === column; }));
            };
        /** Sort the nodes based on the Y position */
        /**
         * Sort the nodes based on the Y position
         * @param {?} nodes
         * @return {?}
         */
        SankeyFocusManager.prototype.getNodesInOrder = /**
         * Sort the nodes based on the Y position
         * @param {?} nodes
         * @return {?}
         */
            function (nodes) {
                return __spread(nodes).sort(function (nodeOne, nodeTwo) { return nodeOne.y - nodeTwo.y; });
            };
        /** Determine whether or not there is a not that is tabbable */
        /**
         * Determine whether or not there is a not that is tabbable
         * @return {?}
         */
        SankeyFocusManager.prototype.hasActiveNode = /**
         * Determine whether or not there is a not that is tabbable
         * @return {?}
         */
            function () {
                var _this = this;
                return !!this.active$.value && !!this._nodes.find(function (node) { return node.node.id === _this.active$.value.node.id; });
            };
        SankeyFocusManager.decorators = [
            { type: i0.Injectable }
        ];
        return SankeyFocusManager;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SankeyNodeDirective = /** @class */ (function () {
        function SankeyNodeDirective(_focusManager, _elementRef) {
            this._focusManager = _focusManager;
            this._elementRef = _elementRef;
            /**
             * Specify the tab index of the current item
             */
            this.tabIndex = -1;
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        SankeyNodeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Update the tabindex based on the current active item
                this._focusManager.active$.pipe(operators.map(function (item) { return item && item.node.id === _this.node.node.id; }), operators.takeUntil(this._onDestroy))
                    .subscribe(function (isActive) { return _this.tabIndex = isActive ? 0 : -1; });
                // If this element should be focused perform the focus
                this._focusManager.focused$.pipe(operators.filter(function (node) { return node.node.id === _this.node.node.id; }), operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        SankeyNodeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SankeyNodeDirective.prototype.onClick = /**
         * @return {?}
         */
            function () {
                this._focusManager.setActiveItem(this.node);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SankeyNodeDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusManager.onKeydown(event);
            };
        SankeyNodeDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxSankeyNode]',
                    },] }
        ];
        /** @nocollapse */
        SankeyNodeDirective.ctorParameters = function () {
            return [
                { type: SankeyFocusManager },
                { type: i0.ElementRef }
            ];
        };
        SankeyNodeDirective.propDecorators = {
            node: [{ type: i0.Input, args: ['uxSankeyNode',] }],
            tabIndex: [{ type: i0.HostBinding }],
            onClick: [{ type: i0.HostListener, args: ['click',] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return SankeyNodeDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SankeyChartComponent = /** @class */ (function () {
        function SankeyChartComponent(_focusManager, _changeDetector, _colorService) {
            this._focusManager = _focusManager;
            this._changeDetector = _changeDetector;
            this._colorService = _colorService;
            /**
             * Define the nodes to display
             */
            this.nodes = [];
            /**
             * Define the links to display
             */
            this.links = [];
            /**
             * Define the headers of each column
             */
            this.columns = [];
            /**
             * Define the minimum width of a node
             */
            this.minWidth = 0;
            /**
             * Define the maximum width of a node
             */
            this.maxWidth = Infinity;
            /**
             * The minimum height of a node.
             */
            this.minHeight = 0;
            /**
             * Define the function to get the contents of a link tooltip
             */
            this.linkTooltip = this.getLinkTooltip;
            /**
             * Define the function to get the contents of a falloff tooltip
             */
            this.falloffTooltip = this.getFalloffTooltip;
            /**
             * Define the nodes that should be rendered
             */
            this._nodes = [];
            /**
             * Define the columns to display
             */
            this._columns = [];
            /**
             * Determine if the tooltip should be visible or not
             */
            this._isTooltipOpen = false;
            /**
             * Define the position of the tooltip
             */
            this._tooltipPosition = { x: 0, y: 0 };
            /**
             * Determine if the component is initialised
             */
            this._isInitialised = false;
            /**
             * Store the instance of the sankey layout
             */
            this._sankey = new SankeyChart();
        }
        /**
         * @return {?}
         */
        SankeyChartComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // verify we have a node template defined before proceeding
                if (!this.nodeTemplate) {
                    throw new Error('Sankey Chart - Node Template has not been defined.');
                }
                // set the initial chart size
                this._width = this.nodeContainer.nativeElement.offsetWidth;
                this._height = this.nodeContainer.nativeElement.offsetHeight;
                // perform the initial render
                this._render();
                // mark the component as initialised
                this._isInitialised = true;
            };
        /**
         * Detect any changes from Inputs. We can skip
         * the first function call as this happens before
         * the initial render so it has no effect.
         */
        /**
         * Detect any changes from Inputs. We can skip
         * the first function call as this happens before
         * the initial render so it has no effect.
         * @return {?}
         */
        SankeyChartComponent.prototype.ngOnChanges = /**
         * Detect any changes from Inputs. We can skip
         * the first function call as this happens before
         * the initial render so it has no effect.
         * @return {?}
         */
            function () {
                if (this._isInitialised) {
                    this._render();
                }
            };
        /** Re-render the chart */
        /**
         * Re-render the chart
         * @return {?}
         */
        SankeyChartComponent.prototype._render = /**
         * Re-render the chart
         * @return {?}
         */
            function () {
                this._nodes = this._sankey
                    .nodes(this.nodes)
                    .links(this.links)
                    .spacing(14)
                    .size(this.minWidth, this.maxWidth, this.minHeight)
                    .width(this._width || this.nodeContainer.nativeElement.offsetWidth)
                    .height(this._height || this.nodeContainer.nativeElement.offsetHeight)
                    .layout();
                // ensure the focus manager has the latest node data
                this._focusManager.setNodes(this._nodes);
                this._columns = this.getColumns();
                this._changeDetector.detectChanges();
            };
        /** Update the layout whenever the dimensions change changes */
        /**
         * Update the layout whenever the dimensions change changes
         * @param {?} dimensions
         * @return {?}
         */
        SankeyChartComponent.prototype._onResize = /**
         * Update the layout whenever the dimensions change changes
         * @param {?} dimensions
         * @return {?}
         */
            function (dimensions) {
                this._width = dimensions.width;
                this._height = dimensions.height;
                this._render();
            };
        /**
         * Column count should be based on the data, not the titles
         * as they may not specify titles but the nodes will still be
         * rendered.
         */
        /**
         * Column count should be based on the data, not the titles
         * as they may not specify titles but the nodes will still be
         * rendered.
         * @return {?}
         */
        SankeyChartComponent.prototype._getColumnCount = /**
         * Column count should be based on the data, not the titles
         * as they may not specify titles but the nodes will still be
         * rendered.
         * @return {?}
         */
            function () {
                return this._nodes.reduce(function (column, node) { return Math.max(column, node.column); }, 0);
            };
        /**
         * Get the SVG path that defines the shape of the link
         */
        /**
         * Get the SVG path that defines the shape of the link
         * @param {?} link
         * @return {?}
         */
        SankeyChartComponent.prototype._getPath = /**
         * Get the SVG path that defines the shape of the link
         * @param {?} link
         * @return {?}
         */
            function (link) {
                return this._sankey.link(link);
            };
        /**
         * Set the active state of a node and the inputs and outputs
         * associated with this node.
         */
        /**
         * Set the active state of a node and the inputs and outputs
         * associated with this node.
         * @param {?} nodeLink
         * @param {?} active
         * @return {?}
         */
        SankeyChartComponent.prototype._setNodeActive = /**
         * Set the active state of a node and the inputs and outputs
         * associated with this node.
         * @param {?} nodeLink
         * @param {?} active
         * @return {?}
         */
            function (nodeLink, active) {
                var _this = this;
                // set the node active state
                nodeLink.active = active;
                // set the active state of each link
                nodeLink.inputs.forEach(function (link) { return link.active = active; });
                nodeLink.outputs.forEach(function (link) { return link.active = active; });
                // set the active state of all input and output nodes
                nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.active = active; });
                nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.active = active; });
                nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.active = active; });
                nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.active = active; });
                // ensure we update the view to show highlights
                this._changeDetector.detectChanges();
            };
        /**
         * Set the focused state of a node and the inputs and outputs
         * associated with this node.
         */
        /**
         * Set the focused state of a node and the inputs and outputs
         * associated with this node.
         * @param {?} nodeLink
         * @param {?} focused
         * @param {?} element
         * @return {?}
         */
        SankeyChartComponent.prototype._setNodeFocus = /**
         * Set the focused state of a node and the inputs and outputs
         * associated with this node.
         * @param {?} nodeLink
         * @param {?} focused
         * @param {?} element
         * @return {?}
         */
            function (nodeLink, focused, element) {
                var _this = this;
                // set the node focus state
                nodeLink.focus = focused;
                // set the active state of each link
                nodeLink.inputs.forEach(function (link) { return link.focus = focused; });
                nodeLink.outputs.forEach(function (link) { return link.focus = focused; });
                // set the active state of all input and output nodes
                nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.focus = focused; });
                nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.focus = focused; });
                nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.focus = focused; });
                nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.focus = focused; });
                // we need to add the focus indicator here programmatically. The default quantum-ux-aspects focus indicator
                // styling uses `!important` so our inline style needs to also be `!important` to override this, and unfortunately
                // there is a known issue with `NgStyle` and `[style.xyz]` bindings preventing them from adding the `!important`
                // modifier so we must do it manually (not using `Renderer2`).
                if (this.color) {
                    element.style.setProperty('box-shadow', this._getFocusIndicator(nodeLink), 'important');
                }
                // ensure we update the view to show highlights
                this._changeDetector.detectChanges();
            };
        /**
         * Set the active state of a link and the source and target
         * nodes associated with the link
         */
        /**
         * Set the active state of a link and the source and target
         * nodes associated with the link
         * @param {?} link
         * @param {?} active
         * @return {?}
         */
        SankeyChartComponent.prototype._setLinkActive = /**
         * Set the active state of a link and the source and target
         * nodes associated with the link
         * @param {?} link
         * @param {?} active
         * @return {?}
         */
            function (link, active) {
                link.active = active;
                if (link.source !== undefined) {
                    this._sankey.getNodeLink(link.source).active = active;
                }
                if (link.target !== undefined) {
                    this._sankey.getNodeLink(link.target).active = active;
                }
                // update the tooltip visibility
                this._isTooltipOpen = active;
                // update the tooltip content
                this._tooltipContent = active ? this.linkTooltip(link) : '';
                // ensure we update the view to show highlights
                this._changeDetector.detectChanges();
            };
        /**
         * This is required because we want to toggle a class based on the `active`
         * property on a link, however toggling classes using `NgClass` or the class
         * binding syntax `[class.xyz]` does not work in IE when applied to an SVG
         * element. (https://github.com/angular/angular/issues/6327)
         *
         * The alternatice is to bind directly to the `class` attribute and return a
         * string that will toggle the class based on the `active` property.
         */
        /**
         * This is required because we want to toggle a class based on the `active`
         * property on a link, however toggling classes using `NgClass` or the class
         * binding syntax `[class.xyz]` does not work in IE when applied to an SVG
         * element. (https://github.com/angular/angular/issues/6327)
         *
         * The alternatice is to bind directly to the `class` attribute and return a
         * string that will toggle the class based on the `active` property.
         * @param {?} link
         * @return {?}
         */
        SankeyChartComponent.prototype._getLinkClass = /**
         * This is required because we want to toggle a class based on the `active`
         * property on a link, however toggling classes using `NgClass` or the class
         * binding syntax `[class.xyz]` does not work in IE when applied to an SVG
         * element. (https://github.com/angular/angular/issues/6327)
         *
         * The alternatice is to bind directly to the `class` attribute and return a
         * string that will toggle the class based on the `active` property.
         * @param {?} link
         * @return {?}
         */
            function (link) {
                return "ux-sankey-chart-link " + ((link.active || link.focus) ? 'ux-sankey-chart-link-active' : '');
            };
        /**
         * Get the SVG path that defines the shape of the falloff indicator
         */
        /**
         * Get the SVG path that defines the shape of the falloff indicator
         * @param {?} node
         * @return {?}
         */
        SankeyChartComponent.prototype._getFalloffPath = /**
         * Get the SVG path that defines the shape of the falloff indicator
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return this._sankey.getFalloffPath(node);
            };
        /**
         * Falloff represents the amount of data that does not get passed on,
         * for example, if a node gets 1,000,000 items from inputs and only outputs
         * 500,000 then there is falloff of 500,000. However, items in the last column
         * never pass on any information, so tecnhically 100% of their input is falloff
         * so we shouldn't show it in the last column.
         */
        /**
         * Falloff represents the amount of data that does not get passed on,
         * for example, if a node gets 1,000,000 items from inputs and only outputs
         * 500,000 then there is falloff of 500,000. However, items in the last column
         * never pass on any information, so tecnhically 100% of their input is falloff
         * so we shouldn't show it in the last column.
         * @param {?} nodeLink
         * @return {?}
         */
        SankeyChartComponent.prototype._showFalloff = /**
         * Falloff represents the amount of data that does not get passed on,
         * for example, if a node gets 1,000,000 items from inputs and only outputs
         * 500,000 then there is falloff of 500,000. However, items in the last column
         * never pass on any information, so tecnhically 100% of their input is falloff
         * so we shouldn't show it in the last column.
         * @param {?} nodeLink
         * @return {?}
         */
            function (nodeLink) {
                return nodeLink.column < this._columns.length - 1;
            };
        /** Update the visibility and content of the tooltip on falloff hover */
        /**
         * Update the visibility and content of the tooltip on falloff hover
         * @param {?} nodeLink
         * @param {?} isVisible
         * @return {?}
         */
        SankeyChartComponent.prototype._setFalloffTooltip = /**
         * Update the visibility and content of the tooltip on falloff hover
         * @param {?} nodeLink
         * @param {?} isVisible
         * @return {?}
         */
            function (nodeLink, isVisible) {
                this._isTooltipOpen = isVisible;
                this._tooltipContent = isVisible ? this.falloffTooltip(nodeLink.falloff) : '';
                this._changeDetector.detectChanges();
            };
        /**
         * Update the position of the tooltip
         */
        /**
         * Update the position of the tooltip
         * @param {?} event
         * @return {?}
         */
        SankeyChartComponent.prototype._setTooltipPosition = /**
         * Update the position of the tooltip
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _a = (( /** @type {?} */(this.nodeContainer.nativeElement))).getBoundingClientRect(), left = _a.left, top = _a.top;
                /** @type {?} */
                var x = (event.pageX - left) - (window.scrollX || document.documentElement.scrollLeft);
                /** @type {?} */
                var y = (event.pageY - top) - (window.scrollY || document.documentElement.scrollTop);
                this._tooltipPosition = { x: x, y: y };
                this._changeDetector.detectChanges();
            };
        /**
         * Correctly track the node changes in `*ngFor` based on
         * the unique node ids to prevent unnecessary re-rendering
         */
        /**
         * Correctly track the node changes in `*ngFor` based on
         * the unique node ids to prevent unnecessary re-rendering
         * @param {?} _index
         * @param {?} nodeLink
         * @return {?}
         */
        SankeyChartComponent.prototype._trackNodeBy = /**
         * Correctly track the node changes in `*ngFor` based on
         * the unique node ids to prevent unnecessary re-rendering
         * @param {?} _index
         * @param {?} nodeLink
         * @return {?}
         */
            function (_index, nodeLink) {
                return nodeLink.node.id;
            };
        /**
         * Correctly track the link changes in `*ngFor` based on
         * the source and target to prevent unnecessary re-rendering
         */
        /**
         * Correctly track the link changes in `*ngFor` based on
         * the source and target to prevent unnecessary re-rendering
         * @param {?} _index
         * @param {?} link
         * @return {?}
         */
        SankeyChartComponent.prototype._trackLinkBy = /**
         * Correctly track the link changes in `*ngFor` based on
         * the source and target to prevent unnecessary re-rendering
         * @param {?} _index
         * @param {?} link
         * @return {?}
         */
            function (_index, link) {
                return link.source + "-" + link.target;
            };
        /**
         * Get the color of node based on whether or not
         * the `color` input has been provided.
         */
        /**
         * Get the color of node based on whether or not
         * the `color` input has been provided.
         * @param {?} item
         * @return {?}
         */
        SankeyChartComponent.prototype._getColor = /**
         * Get the color of node based on whether or not
         * the `color` input has been provided.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // if we are not node hovering or focusing or no custom color is defined then return nothing
                if (!item.active && !item.focus || !this.color) {
                    return;
                }
                // return an rgba value if it is a `ThemeColor` to support transparency
                return this.color instanceof ThemeColor ? this.color.toRgba() : this._colorService.resolve(this.color);
            };
        /**
         * We want the focus indicator color to match the active color,
         * which if programmatically defined need to be overriden
         */
        /**
         * We want the focus indicator color to match the active color,
         * which if programmatically defined need to be overriden
         * @param {?} nodeLink
         * @return {?}
         */
        SankeyChartComponent.prototype._getFocusIndicator = /**
         * We want the focus indicator color to match the active color,
         * which if programmatically defined need to be overriden
         * @param {?} nodeLink
         * @return {?}
         */
            function (nodeLink) {
                // if the node is not focused or there is no custom color
                // then return null in which case CSS indicator will show
                if (!nodeLink.focus || !this.color) {
                    return '';
                }
                // otherwise return the shadow based on the color provided.
                /** @type {?} */
                var color = this.color instanceof ThemeColor ? this.color : ThemeColor.parse(this._colorService.resolve(this.color));
                // generate a box shadow based on the specified color
                return "0 0 0 1px #fff, 0 0 0 3px " + color.setAlpha(0.5).toRgba();
            };
        /**
         * Get columns mapped with their title if they have any
         */
        /**
         * Get columns mapped with their title if they have any
         * @return {?}
         */
        SankeyChartComponent.prototype.getColumns = /**
         * Get columns mapped with their title if they have any
         * @return {?}
         */
            function () {
                var _this = this;
                return this._sankey.columns().map(function (width, index) { return ({ width: width, title: _this.columns[index] || '', position: _this.getColumnPosition(index) }); });
            };
        /**
         * Get the start position of a column which can be determined
         * by finding a node that is in that column and using its
         * x position as all nodes start at the same position within a column.
         */
        /**
         * Get the start position of a column which can be determined
         * by finding a node that is in that column and using its
         * x position as all nodes start at the same position within a column.
         * @param {?} column
         * @return {?}
         */
        SankeyChartComponent.prototype.getColumnPosition = /**
         * Get the start position of a column which can be determined
         * by finding a node that is in that column and using its
         * x position as all nodes start at the same position within a column.
         * @param {?} column
         * @return {?}
         */
            function (column) {
                // find a node in this column and take its x position
                /** @type {?} */
                var node = this._nodes.find(function (_node) { return _node.column === column; });
                return node ? node.x : 0;
            };
        /**
         * Get the default content of a link tooltip
         */
        /**
         * Get the default content of a link tooltip
         * @param {?} link
         * @return {?}
         */
        SankeyChartComponent.prototype.getLinkTooltip = /**
         * Get the default content of a link tooltip
         * @param {?} link
         * @return {?}
         */
            function (link) {
                return link.value.toLocaleString('en') + ' items';
            };
        /**
         * Get the default content of a falloff tooltip
         */
        /**
         * Get the default content of a falloff tooltip
         * @param {?} falloff
         * @return {?}
         */
        SankeyChartComponent.prototype.getFalloffTooltip = /**
         * Get the default content of a falloff tooltip
         * @param {?} falloff
         * @return {?}
         */
            function (falloff) {
                return falloff.toLocaleString('en') + ' items';
            };
        SankeyChartComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-sankey-chart',
                        template: "<div class=\"ux-sankey-chart-columns\" *ngIf=\"columns && columns.length > 0\">\n    <div *ngFor=\"let column of _columns\"\n         class=\"ux-sankey-chart-column\"\n         [style.width.px]=\"column.width\">\n\n        <p class=\"ux-sankey-chart-column-title\"\n            [style.left.px]=\"column.position\">\n            {{ column.title }}\n        </p>\n    </div>\n</div>\n\n<svg #linkContainer\n     [attr.width]=\"_width\"\n     [attr.height]=\"_height\"\n     class=\"ux-sankey-chart-links\"\n     [style.top.px]=\"!columns || columns.length === 0 ? 8 : null\">\n\n    <defs>\n        <linearGradient id=\"falloff-gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n            <stop class=\"ux-sankey-chart-falloff-gradient-start\" offset=\"25%\"></stop>\n            <stop class=\"ux-sankey-chart-falloff-gradient-end\" offset=\"100%\"></stop>\n        </linearGradient>\n    </defs>\n    <g>\n        <ng-container *ngFor=\"let node of _nodes; trackBy: _trackNodeBy\">\n            <path *ngFor=\"let link of node.outputs; trackBy: _trackLinkBy\"\n                    [attr.class]=\"_getLinkClass(link)\"\n                    [attr.d]=\"_getPath(link)\"\n                    [style.fill]=\"_getColor(link)\"\n                    (mouseenter)=\"_setLinkActive(link, true)\"\n                    (mouseleave)=\"_setLinkActive(link, false)\"\n                    (mousemove)=\"_setTooltipPosition($event)\">\n            </path>\n            <path *ngIf=\"node.falloff && _showFalloff(node)\"\n                    class=\"ux-sankey-chart-falloff-indicator\"\n                    [attr.d]=\"_getFalloffPath(node)\"\n                    (mouseenter)=\"_setFalloffTooltip(node, true)\"\n                    (mouseleave)=\"_setFalloffTooltip(node, false)\"\n                    (mousemove)=\"_setTooltipPosition($event)\">\n            </path>\n        </ng-container>\n    </g>\n</svg>\n\n<div #nodeContainer\n     class=\"ux-sankey-chart-nodes\"\n     (uxResize)=\"_onResize($event)\"\n     [style.top.px]=\"!columns || columns.length === 0 ? 8 : null\">\n\n    <div *ngFor=\"let node of _nodes; trackBy: _trackNodeBy\"\n        #nodeElement\n        [uxSankeyNode]=\"node\"\n        uxFocusIndicator\n        class=\"ux-sankey-chart-node\"\n        [class.ux-sankey-chart-node-active]=\"node.active || node.focus\"\n        [style.left.px]=\"node.x\"\n        [style.top.px]=\"node.y\"\n        [style.width.px]=\"node.width\"\n        [style.height.px]=\"node.height\"\n        [style.background-color]=\"_getColor(node)\"\n        (mouseenter)=\"_setNodeActive(node, true)\"\n        (mouseleave)=\"_setNodeActive(node, false)\"\n        (indicator)=\"_setNodeFocus(node, $event, nodeElement)\">\n\n        <ng-container\n            [ngTemplateOutlet]=\"nodeTemplate\"\n            [ngTemplateOutletContext]=\"{ node: node.node, active: node.active, focus: node.focus }\">\n        </ng-container>\n    </div>\n\n    <ux-tooltip *ngIf=\"_isTooltipOpen\"\n                class=\"ux-sankey-tooltip\"\n                placement=\"top\"\n                [content]=\"_tooltipContent\"\n                alignment=\"center\"\n                [style.left.px]=\"_tooltipPosition.x\"\n                [style.top.px]=\"_tooltipPosition.y\"\n                [@tooltipAnimation]>\n    </ux-tooltip>\n\n</div>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        viewProviders: [SankeyFocusManager],
                        animations: [
                            animations.trigger('tooltipAnimation', [
                                animations.transition(':enter', [
                                    animations.style({ opacity: 0 }),
                                    animations.animate(160, animations.style({ opacity: 1 }))
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(160, animations.style({ opacity: 0 }))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        SankeyChartComponent.ctorParameters = function () {
            return [
                { type: SankeyFocusManager },
                { type: i0.ChangeDetectorRef },
                { type: ColorService }
            ];
        };
        SankeyChartComponent.propDecorators = {
            nodes: [{ type: i0.Input }],
            links: [{ type: i0.Input }],
            columns: [{ type: i0.Input }],
            minWidth: [{ type: i0.Input }],
            maxWidth: [{ type: i0.Input }],
            minHeight: [{ type: i0.Input }],
            linkTooltip: [{ type: i0.Input }],
            falloffTooltip: [{ type: i0.Input }],
            color: [{ type: i0.Input }],
            nodeTemplate: [{ type: i0.ContentChild, args: ['sankeyNodeTemplate', { static: false },] }],
            linkContainer: [{ type: i0.ViewChild, args: ['linkContainer', { static: true },] }],
            nodeContainer: [{ type: i0.ViewChild, args: ['nodeContainer', { static: true },] }]
        };
        return SankeyChartComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SankeyChartModule = /** @class */ (function () {
        function SankeyChartModule() {
        }
        SankeyChartModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            SankeyChartComponent,
                            SankeyNodeDirective
                        ],
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            ResizeModule,
                            TooltipModule,
                            ColorServiceModule
                        ],
                        exports: [
                            SankeyChartComponent
                        ]
                    },] }
        ];
        return SankeyChartModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var UNSET_FOCUS = { groupId: null, index: -1 };
    var SearchBuilderFocusService = /** @class */ (function () {
        function SearchBuilderFocusService() {
            this.focus$ = new rxjs.BehaviorSubject(UNSET_FOCUS);
        }
        /**
         * Set focus on a search builder component.
         * @param groupId The `id` of the group containing the component.
         * @param index The (zero-based) index of the component.
         */
        /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.setFocus = /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
            function (groupId, index) {
                this.focus$.next({ groupId: groupId, index: index });
            };
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         */
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.clearFocus = /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
            function () {
                this.focus$.next(UNSET_FOCUS);
            };
        SearchBuilderFocusService.decorators = [
            { type: i0.Injectable }
        ];
        return SearchBuilderFocusService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderService = /** @class */ (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new rxjs.Subject();
            this.validationChange = new rxjs.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponent = /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
            function (component) {
                // ensure there are no components with a matching name
                if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                    throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
                }
                // if unique then add the component to the list
                this._components.push(component);
            };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponents = /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
            function (components) {
                var _this = this;
                components.forEach(function (component) { return _this.registerComponent(component); });
            };
        /**
         * Get a registered component class
         */
        /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
        SearchBuilderService.prototype.getComponent = /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
            function (name) {
                // find the component
                /** @type {?} */
                var component = this._components.find(function (cmp) { return cmp.name === name; });
                // if there is no match throw an exception
                if (!component) {
                    throw new Error("No search build component with the name " + name + " exists");
                }
                // ensure config is defined - at least to an empty object
                component.config = component.config || {};
                return component;
            };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
        SearchBuilderService.prototype.setQuery = /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.query = Object.assign({}, query);
            };
        /**
         * Return the current query state
         */
        /**
         * Return the current query state
         * @return {?}
         */
        SearchBuilderService.prototype.getQuery = /**
         * Return the current query state
         * @return {?}
         */
            function () {
                return this.query;
            };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
        SearchBuilderService.prototype.queryHasChanged = /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
            function () {
                this.queryChange.next(this.query);
            };
        /**
         * Store the validation state of the query
         */
        /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
        SearchBuilderService.prototype.setValid = /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
            function (id, valid) {
                var _this = this;
                // store the state for this specific component
                this._validation[id] = valid;
                // evaluate the entire validation state
                this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
            };
        /**
         * Generate a unique id for each component
         */
        /**
         * Generate a unique id for each component
         * @return {?}
         */
        SearchBuilderService.prototype.generateComponentId = /**
         * Generate a unique id for each component
         * @return {?}
         */
            function () {
                return this._componentId++;
            };
        SearchBuilderService.decorators = [
            { type: i0.Injectable }
        ];
        return SearchBuilderService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderGroupService = /** @class */ (function () {
        function SearchBuilderGroupService(_searchBuilderService, _searchBuilderFocusService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
        }
        /**
         * Initialise the group by defining an id
         */
        /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
        SearchBuilderGroupService.prototype.init = /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
            function (id) {
                var _this = this;
                // store the name of the group
                this._id = id;
                // create the entry in the query object if it doesn't exist
                if (!this._searchBuilderService.query[this._id]) {
                    // create the section
                    this._searchBuilderService.query[this._id] = [];
                    // emit the changes after the initial setup
                    setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
                }
            };
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         */
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupService.prototype.removeAtIndex = /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // get the query for this group
                /** @type {?} */
                var query = this.getQuery();
                // remove the field from the array
                query.splice(index, 1);
                // Focus the previous item if available
                this._searchBuilderFocusService.setFocus(this._id, index <= 0 ? 0 : index - 1);
            };
        /**
         * Get the query for this specific search group
         */
        /**
         * Get the query for this specific search group
         * @return {?}
         */
        SearchBuilderGroupService.prototype.getQuery = /**
         * Get the query for this specific search group
         * @return {?}
         */
            function () {
                return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
            };
        SearchBuilderGroupService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        SearchBuilderGroupService.ctorParameters = function () {
            return [
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        return SearchBuilderGroupService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderGroupComponent = /** @class */ (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderFocusService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new i0.EventEmitter();
            this.remove = new i0.EventEmitter();
            this.focusIndex = -1;
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // ensure we have a name otherwise throw an error
                if (!this.id) {
                    throw new Error('Search builder group must have an id attribute.');
                }
                // otherwise register the group
                this.searchBuilderGroupService.init(this.id);
                // Track focus for child components
                this._searchBuilderFocusService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focus) {
                    _this.focusIndex = (focus.groupId === _this.id) ? focus.index : -1;
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.addField = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.add.emit(event);
            };
        /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.removeFieldAtIndex = /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
            function (index, field) {
                this.searchBuilderGroupService.removeAtIndex(index);
                this.remove.emit(field);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.setFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this._searchBuilderFocusService.setFocus(this.id, index);
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.clearFocus = /**
         * @return {?}
         */
            function () {
                this._searchBuilderFocusService.clearFocus();
            };
        SearchBuilderGroupComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-builder-group',
                        template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<div class=\"search-group-content\">\n\n  <div class=\"search-group-operator search-group-operator-{{ operator }}\"\n    [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</div>\n\n  <div class=\"search-group-items\">\n\n    <div *ngFor=\"let field of searchBuilderGroupService.getQuery(); let i = index\"\n      class=\"search-group-item-container\"\n      [class.search-group-item-focus]=\"focusIndex === i\"\n      (uxFocusWithin)=\"setFocus(i)\"\n      (uxBlurWithin)=\"clearFocus()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field; groupId: id; index: i\"></ng-container>\n      </div>\n\n      <button type=\"button\"\n        uxFocusIndicator\n        aria-label=\"Remove field\"\n        class=\"search-group-item-remove\"\n        (click)=\"removeFieldAtIndex(i, field)\">\n\n        <ux-icon name=\"close\"></ux-icon>\n\n      </button>\n\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n\n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n\n      </div>\n\n      <!-- Allow a custom placeholder -->\n      <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </div>\n\n  <button type=\"button\" uxFocusIndicator class=\"search-builder-group-add-field\" (click)=\"addField($event)\">\n        <ux-icon class=\"search-builder-group-add-field-icon\" name=\"add\"></ux-icon>\n        <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n  </button>\n\n</div>\n\n<hr class=\"search-builder-group-divider\">\n",
                        providers: [SearchBuilderGroupService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderGroupComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderGroupService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderGroupComponent.propDecorators = {
            id: [{ type: i0.Input }],
            header: [{ type: i0.Input }],
            operator: [{ type: i0.Input }],
            addText: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            showPlaceholder: [{ type: i0.Input }],
            add: [{ type: i0.Output }],
            remove: [{ type: i0.Output }]
        };
        return SearchBuilderGroupComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderOutletDirective = /** @class */ (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService, _searchBuilderFocusService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // get the class from the type
                /** @type {?} */
                var componentDefinition = this._searchBuilderService.getComponent(this.outlet);
                // create the component factory
                /** @type {?} */
                var componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
                // create the component instance
                this._componentRef = this._viewContainerRef.createComponent(componentFactory);
                // combine the predefined config with any dynmaic config
                /** @type {?} */
                var config = Object.assign({}, componentDefinition.config, this.context.config || {});
                // set the context and config property on the component instance
                this._componentRef.instance.context = this.context;
                this._componentRef.instance.config = config;
                this._searchBuilderFocusService.focus$
                    .pipe(operators.distinctUntilChanged(), operators.delay(0), operators.takeUntil(this._onDestroy))
                    .subscribe(function (focus) {
                    _this._componentRef.instance.focus = (focus.groupId === _this.groupId && focus.index === _this.index);
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        SearchBuilderOutletDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxSearchBuilderOutlet]'
                    },] }
        ];
        /** @nocollapse */
        SearchBuilderOutletDirective.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.ComponentFactoryResolver },
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderOutletDirective.propDecorators = {
            outlet: [{ type: i0.Input, args: ['uxSearchBuilderOutlet',] }],
            context: [{ type: i0.Input, args: ['uxSearchBuilderOutletContext',] }],
            groupId: [{ type: i0.Input, args: ['uxSearchBuilderOutletGroupId',] }],
            index: [{ type: i0.Input, args: ['uxSearchBuilderOutletIndex',] }]
        };
        return SearchBuilderOutletDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderComponent = /** @class */ (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new i0.EventEmitter();
            this.valid = new i0.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: /**
             * @param {?} components
             * @return {?}
             */ function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: /**
             * @return {?}
             */ function () {
                return this._searchBuilderService.getQuery();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
        SearchBuilderComponent.prototype.ngOnDestroy = /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
            function () {
                this._querySubscription.unsubscribe();
                this._validSubscription.unsubscribe();
            };
        SearchBuilderComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-builder',
                        template: "<ng-content></ng-content>",
                        providers: [SearchBuilderService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        SearchBuilderComponent.propDecorators = {
            components: [{ type: i0.Input }],
            query: [{ type: i0.Input }],
            queryChange: [{ type: i0.Output }],
            valid: [{ type: i0.Output }]
        };
        return SearchBuilderComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$8 = 0;
    /** @type {?} */
    var SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    /**
     * @template T
     */
    var SelectComponent = /** @class */ (function () {
        function SelectComponent(_element, _platform, _document, _typeaheadKeyService) {
            this._element = _element;
            this._platform = _platform;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            /**
             * A unique id for the component.
             */
            this.id = "ux-select-" + ++uniqueId$8;
            /**
             * Controls whether the value of the single select control can be cleared by deleting the selected value in the
             * input field. This does not affect the initial state of the control, so specify a value for `value` if null should
             * never be allowed.
             */
            this.allowNull = false;
            /**
             * Controls the disabled state of the tag input.
             */
            this.disabled = false;
            /**
             * The positioning of the typeahead dropdown in relation to its parent.
             */
            this.dropDirection = 'down';
            /**
             * The maximum height of the typeahead dropdown, as a CSS value.
             */
            this.maxHeight = '250px';
            /**
             * Controls whether the user can select more than one option in the select control. If set to true, selected
             * options will appear as tags in the input area. If set to false, the selected value will appear as editable text
             * in the input area.
             */
            this.multiple = false;
            /**
             * The number of options to request in a page. This should ideally be more than twice the number of items which
             * fit into the height of the dropdown, but this is not required.
             */
            this.pageSize = 20;
            /**
             * The placeholder text which appears in the text input area when it is empty.
             */
            this.placeholder = '';
            /**
             * Defines the `autocomplete` property on the `input` element which can be used to prevent the browser from
             * displaying autocomplete suggestions.
             */
            this.autocomplete = 'off';
            /**
             * If `true` the input field will be readonly and selection can only occur by using the dropdown.
             */
            this.readonlyInput = false;
            /**
             * Determine if we should show the clear all button
             */
            this.clearButton = false;
            /**
             * Determine an aria label for the clear button
             */
            this.clearButtonAriaLabel = 'Reset selection';
            /**
             * Emits when `value` changes.
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Emits when `input` changes.
             */
            this.inputChange = new i0.EventEmitter();
            /**
             * Emits when `dropdownOpen` changes.
             */
            this.dropdownOpenChange = new i0.EventEmitter();
            this._value$ = new rxjs.ReplaySubject(1);
            this._hasValue = false;
            this._input$ = new rxjs.BehaviorSubject('');
            this._dropdownOpen = false;
            this._userInput = false;
            this._onChange = function (_) { };
            this._onTouched = function () { };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** The selected option (for single select) or array of options (for multiple select). */
            set: /**
             * The selected option (for single select) or array of options (for multiple select).
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input$.value;
            },
            /** The text in the input area. This is used to filter the options dropdown. */
            set: /**
             * The text in the input area. This is used to filter the options dropdown.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropdownOpen;
            },
            /** The status of the typeahead dropdown. */
            set: /**
             * The status of the typeahead dropdown.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._value$.pipe(operators.skip(1), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy))
                    .subscribe(function (value) { return _this.valueChange.emit(value); });
                // Emit change events
                this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this._value = value;
                    _this._onChange(value);
                    _this._hasValue = !!value;
                });
                this._input$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this.inputChange.emit(value);
                });
                // Changes to the input field
                this._input$.pipe(operators.filter(function () { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.value = null; });
                // Set up filter from input
                this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
                // open the dropdown once the filter debounce has elapsed
                this.filter$.pipe(operators.filter(function () { return _this._userInput; }), operators.take(1), operators.takeUntil(this._onDestroy))
                    .subscribe(function () {
                    _this.dropdownOpen = true;
                    _this._userInput = false;
                });
                // Update the single-select input when the model changes
                this._value$.pipe(operators.distinctUntilChanged(), operators.delay(0), operators.filter(function (value) { return value !== null && !_this.multiple; }), operators.takeUntil(this._onDestroy)).subscribe(function (value) {
                    _this.input = _this.getDisplay(value);
                });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SelectComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.multiple && !changes.multiple.firstChange && changes.multiple.currentValue !== changes.multiple.previousValue) {
                    this.input = '';
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SelectComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj !== undefined && obj !== this.value) {
                    this.value = obj;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SelectComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.inputClickHandler = /**
         * @return {?}
         */
            function () {
                this.selectInputText();
                this.dropdownOpen = true;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.inputBlurHandler = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // If a click on the typeahead is in progress, just refocus the input.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.singleTypeahead && this.singleTypeahead.clicking) {
                    this.singleInput.nativeElement.focus();
                    return;
                }
                // Close dropdown and reset text input if focus is lost
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.dropdownOpen = false;
                        if (!_this.multiple) {
                            _this.input = _this.getDisplay(_this.value);
                        }
                    }
                }, 200);
            };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputKeyHandler = /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Standard keys for typeahead (up/down/esc)
                this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
                if (event.keyCode === keycodes.ENTER) {
                    if (this._dropdownOpen) {
                        // Set the highlighted option as the value and close
                        this.value = this.singleTypeahead.highlighted;
                        this.dropdownOpen = false;
                    }
                    else {
                        this.dropdownOpen = true;
                    }
                    // Update the input field. If dropdown isn't open then reset it to the previous value.
                    this.input = this.getDisplay(this.value);
                    event.preventDefault();
                }
                // when the user types and the value is not empty then we should open the dropdown except for non printable keys.
                if (event.key.length === 1) {
                    this._userInput = true;
                    this._dropdownOpen = true;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.singleOptionSelected = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.option) {
                    this.value = event.option;
                    this.dropdownOpen = false;
                }
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        SelectComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option === null || option === undefined) {
                    return '';
                }
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
                    return option[( /** @type {?} */(this.display))];
                }
                return ( /** @type {?} */(option));
            };
        /** Toggle the dropdown open state */
        /**
         * Toggle the dropdown open state
         * @return {?}
         */
        SelectComponent.prototype.toggle = /**
         * Toggle the dropdown open state
         * @return {?}
         */
            function () {
                // if the select is disabled then do not show the dropdown
                if (this.disabled) {
                    return;
                }
                if (this.dropdownOpen) {
                    this.dropdownOpen = false;
                }
                else {
                    this.inputClickHandler();
                }
            };
        /** Handle input focus events */
        /**
         * Handle input focus events
         * @return {?}
         */
        SelectComponent.prototype.onFocus = /**
         * Handle input focus events
         * @return {?}
         */
            function () {
                // mark form control as touched
                this._onTouched();
                // if the input is readonly we do not want to select the text on focus
                if (this.readonlyInput) {
                    // cast the select input element
                    /** @type {?} */
                    var element_1 = ( /** @type {?} */(this.singleInput.nativeElement));
                    // firefox requires a delay before clearing the selection (other browsers don't)
                    this._platform.FIREFOX ? requestAnimationFrame(function () { return element_1.setSelectionRange(0, 0); }) : element_1.setSelectionRange(0, 0);
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.clear = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                // clear the value and input text
                this.value = null;
                this.input = null;
                this.selectInputText();
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.selectInputText = /**
         * @return {?}
         */
            function () {
                if (!this.readonlyInput) {
                    this.singleInput.nativeElement.select();
                }
            };
        SelectComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-select, ux-combobox, ux-dropdown',
                        template: "<ux-tag-input\r\n    *ngIf=\"multiple\"\r\n    #tagInput=\"ux-tag-input\"\r\n    [id]=\"id + '-input'\"\r\n    [tags]=\"_value$ | async\"\r\n    (tagsChange)=\"_value$.next($event)\"\r\n    [(input)]=\"input\"\r\n    [ariaLabel]=\"ariaLabel\"\r\n    [autocomplete]=\"autocomplete\"\r\n    [addOnPaste]=\"false\"\r\n    [disabled]=\"disabled\"\r\n    [display]=\"display\"\r\n    [freeInput]=\"false\"\r\n    [placeholder]=\"placeholder || ''\"\r\n    [tagTemplate]=\"tagTemplate\"\r\n    (inputFocus)=\"onFocus()\"\r\n    [showTypeaheadOnClick]=\"true\"\r\n    [readonlyInput]=\"readonlyInput\"\r\n    [icon]=\"icon\"\r\n    [clearButton]=\"clearButton\"\r\n    [clearButtonAriaLabel]=\"clearButtonAriaLabel\"\r\n>\r\n    <ux-typeahead #multipleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [disabledOptions]=\"_value$ | async\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"true\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\">\r\n    </ux-typeahead>\r\n\r\n</ux-tag-input>\r\n\r\n<div *ngIf=\"!multiple\"\r\n    class=\"ux-select-container\"\r\n    [class.disabled]=\"disabled\"\r\n    role=\"combobox\"\r\n    [attr.aria-expanded]=\"dropdownOpen\"\r\n    aria-haspopup=\"listbox\">\r\n\r\n    <input #singleInput type=\"text\"\r\n        [attr.id]=\"id + '-input'\"\r\n        class=\"form-control\"\r\n        [class.ux-tag-input-clear-inset]=\"clearButton && allowNull && _hasValue\"\r\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\r\n        aria-autocomplete=\"list\"\r\n        [attr.aria-controls]=\"singleTypeahead.id\"\r\n        [attr.aria-label]=\"ariaLabel\"\r\n        aria-multiline=\"false\"\r\n        [autocomplete]=\"autocomplete\"\r\n        [(ngModel)]=\"input\"\r\n        [placeholder]=\"placeholder || ''\"\r\n        [disabled]=\"disabled\"\r\n        (click)=\"toggle()\"\r\n        (focus)=\"onFocus()\"\r\n        (blur)=\"inputBlurHandler()\"\r\n        (keydown)=\"inputKeyHandler($event)\"\r\n        [readonly]=\"readonlyInput\">\r\n\r\n    <div class=\"ux-select-icons\">\r\n        <i *ngIf=\"clearButton && allowNull && _hasValue\"\r\n           uxFocusIndicator\r\n           [attr.tabindex]=\"disabled ? -1 : 0\"\r\n           [attr.aria-label]=\"clearButtonAriaLabel\"\r\n           class=\"ux-select-icon ux-icon ux-icon-close ux-select-clear-icon\"\r\n           (click)=\"clear(); $event.stopPropagation()\"\r\n           (keydown.enter)=\"clear(); $event.stopPropagation()\">\r\n        </i>\r\n        <i *ngIf=\"!icon\"\r\n           class=\"ux-select-icon ux-icon ux-select-chevron-icon\"\r\n           [class.ux-icon-up]=\"dropDirection === 'up'\"\r\n           [class.ux-icon-down]=\"dropDirection === 'down'\"\r\n           (click)=\"toggle(); $event.stopPropagation()\">\r\n        </i>\r\n        <div *ngIf=\"icon\" class=\"ux-custom-icon\">\r\n            <ng-container [ngTemplateOutlet]=\"icon\"></ng-container>\r\n        </div>\r\n    </div>\r\n\r\n    <ux-typeahead #singleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [active]=\"_value$ | async\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"false\"\r\n        [openOnFilterChange]=\"false\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\"\r\n        (optionSelected)=\"singleOptionSelected($event)\"\r\n        (highlightedElementChange)=\"highlightedElement = $event\">\r\n    </ux-typeahead>\r\n\r\n</div>",
                        providers: [SELECT_VALUE_ACCESSOR],
                        host: {
                            '[class.ux-select-custom-icon]': '!!icon',
                            '[class.ux-select-disabled]': 'disabled'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: platform.Platform },
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        SelectComponent.propDecorators = {
            id: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.id',] }],
            value: [{ type: i0.Input }],
            input: [{ type: i0.Input }],
            dropdownOpen: [{ type: i0.Input }],
            options: [{ type: i0.Input }],
            display: [{ type: i0.Input }],
            key: [{ type: i0.Input }],
            allowNull: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            dropDirection: [{ type: i0.Input }],
            maxHeight: [{ type: i0.Input }],
            multiple: [{ type: i0.Input }],
            pageSize: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            tagTemplate: [{ type: i0.Input }],
            autocomplete: [{ type: i0.Input }],
            loadingTemplate: [{ type: i0.Input }],
            noOptionsTemplate: [{ type: i0.Input }],
            readonlyInput: [{ type: i0.Input }],
            clearButton: [{ type: i0.Input }],
            clearButtonAriaLabel: [{ type: i0.Input }],
            optionTemplate: [{ type: i0.Input }],
            valueChange: [{ type: i0.Output }],
            inputChange: [{ type: i0.Output }],
            dropdownOpenChange: [{ type: i0.Output }],
            icon: [{ type: i0.ContentChild, args: ['icon', { static: false },] }],
            singleInput: [{ type: i0.ViewChild, args: ['singleInput', { static: false },] }],
            tagInput: [{ type: i0.ViewChild, args: ['tagInput', { static: false },] }],
            multipleTypeahead: [{ type: i0.ViewChild, args: ['multipleTypeahead', { static: false },] }],
            singleTypeahead: [{ type: i0.ViewChild, args: ['singleTypeahead', { static: false },] }]
        };
        return SelectComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TagInputEvent = /** @class */ (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        /**
         * @return {?}
         */
        TagInputEvent.prototype.preventDefault = /**
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        TagInputEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return TagInputEvent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$9 = 0;
    /** @type {?} */
    var TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    /** @type {?} */
    var TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: i0.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    /**
     * @template T
     */
    var TagInputComponent = /** @class */ (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            /**
             * Specify a unique Id for the component
             */
            this.id = "ux-tag-input-" + ++uniqueId$9;
            /**
             * The editable text appearing in the tag input.
             */
            this.input = '';
            /**
             * Controls whether pasting text into the text input area automatically converts that text into one or more tags.
             */
            this.addOnPaste = true;
            /**
             * Controls the disabled state of the tag input.
             */
            this.disabled = false;
            /**
             * If set to `true`, the tag input will prevent addition and removal of tags to enforce the minTags and maxTags settings.
             * Otherwise, a validation error will be raised.
             */
            this.enforceTagLimits = false;
            /**
             * If `true`, input entered into the text input area can be converted into a tag by pressing enter.
             * Otherwise, tags can only be added from the typeahead list or other external means.
             * (Note that the `maxTags` and `tagPattern` will prevent invalid inputs regardless of this setting.)
             */
            this.freeInput = true;
            /**
             * If `true` the input field will be readonly and selection can only occur by using the dropdown.
             */
            this.readonlyInput = false;
            /**
             * The maximum number of tags permitted in the tag input. If the number of tags is equal to `maxTags` and
             * `enforceTagLimits` is `true`, addition of tags will be prevented until a tag is removed
             */
            this.maxTags = Number.MAX_VALUE;
            /**
             * The minimum number of tags permitted in the tag input. If the number of tags is equal to `minTags` and `enforceTagLimits` is
             * `true`, removal of tags will be prevented until a new tag is added.
             */
            this.minTags = 0;
            /**
             * The placeholder text which appears in the text input area when it is empty.
             */
            this.placeholder = '';
            /**
             * Controls whether the typeahead appears when the text input area is clicked. This has no effect if the ux-typeahead component is not configured.
             */
            this.showTypeaheadOnClick = false;
            /**
             * A string containing the characters which delimit tags.
             * Typing one of the characters in `tagDelimiters` will cause the preceding text to be added as a tag,
             * and the text input area will be cleared. Pasting a string containing one or more of characters in
             * `tagDelimiters` will cause the string to be split into multiple tags.
             * Note that the delimiter character will not be part of the tag text.
             */
            this.tagDelimiters = '';
            /**
             * A function which returns either a string, string[], or Set<string>, compatible with the NgClass directive. The function receives the following parameters:
             * - `tag: any` - the string or custom object representing the tag.
             * - `index: number` - the zero-based index of the tag as it appears in the tag input.
             * - `selected: boolean` - true if the tag is currently selected.
             */
            this.tagClass = function () { return undefined; };
            /**
             * An object which contains details of validation errors. The following properties will be present if there is a related validation error:
             * - `tagRangeError` - present if the number of tags is outside the range specified by minTags and maxTags.
             * - `inputPattern` - present if an input has been submitted which does not match the tagPattern.
             */
            this.validationErrors = {};
            /**
             * Defines the autocomplete property on the input field which can be used to prevent the browser from displaying autocomplete suggestions.
             */
            this.autocomplete = 'off';
            /**
             * Determine if we should show the clear all button
             */
            this.clearButton = false;
            /**
             * Determine an aria label for the clear button
             */
            this.clearButtonAriaLabel = 'Reset selection';
            /**
             * Emits when tags is changed.
             */
            this.tagsChange = new i0.EventEmitter();
            /**
             * Emits when input is changed.
             */
            this.inputChange = new i0.EventEmitter();
            /**
             * Raised when a tag is about to be added. The `tag` property of the event contains the tag to be added. Call `preventDefault()` on the event to prevent addition.
             */
            this.tagAdding = new i0.EventEmitter();
            /**
             * Raised when a tag has been added. The tag property of the event contains the tag.
             */
            this.tagAdded = new i0.EventEmitter();
            /**
             * Raised when a tag has failed validation according to the `tagPattern`. The tag property of the event contains the string which failed validation.
             */
            this.tagInvalidated = new i0.EventEmitter();
            /**
             * Raised when a tag is about to be removed. The `tag` property of the event contains the tag to be removed. Call `preventDefault()` on the event to prevent removal.
             */
            this.tagRemoving = new i0.EventEmitter();
            /**
             * Raised when a tag has been removed. The tag property of the event contains the tag.
             */
            this.tagRemoved = new i0.EventEmitter();
            /**
             * Raised when a tag has been clicked. The `tag` property of the event contains the clicked tag. Call `preventDefault()` on the event to prevent the default behaviour of selecting the tag.
             */
            this.tagClick = new i0.EventEmitter();
            // When clicking on the input during mutliple mode it will send a on touched event to the parent component
            this.inputFocus = new i0.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            /**
             * The list of tags appearing in the tag input. This can be an array of strings or custom objects.
             * See the `displayProperty` property for details of using a custom object.
             */
            get: /**
             * The list of tags appearing in the tag input. This can be an array of strings or custom objects.
             * See the `displayProperty` property for details of using a custom object.
             * @return {?}
             */ function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = Array.isArray(value) ? value : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "_showClearButton", {
            get: /**
             * @return {?}
             */ function () {
                return this.clearButton && this.tags && this.tags.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Watch for optional child typeahead control
                this.connectTypeahead(this.typeaheadQuery.first);
                this.typeaheadQuery.changes.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (query) { return _this.connectTypeahead(query.first); });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TagInputComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.disabled) {
                    if (changes.disabled.currentValue) {
                        // Clear selection and close dropdown
                        this.selectedIndex = -1;
                        if (this.typeahead) {
                            this.typeahead.open = false;
                        }
                    }
                }
                // Update validation status
                this.validate();
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TagInputComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.tags = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChangeHandler = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouchedHandler = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TagInputComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * Set focus on the input field.
         */
        /**
         * Set focus on the input field.
         * @return {?}
         */
        TagInputComponent.prototype.focus = /**
         * Set focus on the input field.
         * @return {?}
         */
            function () {
                if (this.tagInput) {
                    this.tagInput.nativeElement.focus();
                }
            };
        /**
         * Validate the value of the control (tags property).
         */
        /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
        TagInputComponent.prototype.validate = /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
            function () {
                this.valid = true;
                /** @type {?} */
                var tagRangeError = null;
                if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                    tagRangeError = {
                        given: this.tags.length,
                        min: this.minTags,
                        max: this.maxTags
                    };
                    this.valid = false;
                }
                this.validationErrors['tagRangeError'] = tagRangeError;
                // forward any error to the form control
                return tagRangeError;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.keyHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // Get the input field cursor location
                /** @type {?} */
                var inputCursorPos = this.tagInput.nativeElement.selectionStart;
                // Determine if the input field has any text selected
                /** @type {?} */
                var hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
                // Determine if a tag has focus
                /** @type {?} */
                var tagSelected = this.isValidTagIndex(this.selectedIndex);
                /** @type {?} */
                var inputLength = this.input ? this.input.length : 0;
                // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
                /** @type {?} */
                var canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
                /** @type {?} */
                var canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
                // Forward key events to the typeahead component.
                this._typeaheadKeyService.handleKey(event, this.typeahead);
                switch (event.which) {
                    case keycodes.ENTER:
                        // Check if a typeahead option is highlighted
                        if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                            // Add the typeahead option as a tag, clear the input, and close the dropdown
                            this.commitTypeahead(this.typeahead.highlighted);
                            this.typeahead.open = false;
                        }
                        else if (this.typeahead && !this.typeahead.open && !this.freeInput) {
                            this.typeahead.open = true;
                        }
                        else {
                            // Validate and add the input text as a tag, if possible
                            this.commitInput();
                        }
                        event.preventDefault();
                        break;
                    case keycodes.BACKSPACE:
                        if (canNavigateLeft) {
                            this.backspace();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        break;
                    case keycodes.DELETE:
                        if (tagSelected) {
                            this.removeTagAt(this.selectedIndex);
                        }
                        break;
                    case keycodes.LEFT_ARROW:
                        if (canNavigateLeft) {
                            this.moveSelection(-1);
                            event.preventDefault();
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (canNavigateRight) {
                            this.moveSelection(1);
                            event.preventDefault();
                        }
                        break;
                }
                // Check for keys in the tagDelimiters
                if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                    // Commit previous text
                    this.commitInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.focusOutHandler = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // If a click on the typeahead is in progress, don't do anything.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.typeahead && this.typeahead.clicking) {
                    return;
                }
                // Close the dropdown on blur
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.selectedIndex = -1;
                        if (_this.typeahead) {
                            _this.typeahead.open = false;
                        }
                    }
                }, 200);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.onClick = /**
         * @return {?}
         */
            function () {
                // Prevent error if you click input when at max tag limit
                if (this.tagInput === undefined) {
                    return;
                }
                // focus the input element
                this.tagInput.nativeElement.focus();
                // show the typeahead if we need to
                this.inputClickHandler();
            };
        /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.tagClickHandler = /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
            function (event, tag, index) {
                if (this.disabled) {
                    return;
                }
                // Send tagClick event
                /** @type {?} */
                var tagClickEvent = new TagInputEvent(tag);
                this.tagClick.emit(tagClickEvent);
                // Prevent focus if preventDefault() was called
                if (tagClickEvent.defaultPrevented()) {
                    event.preventDefault();
                    return;
                }
                // Select the tag (for IE that doesn't propagate focus)
                this.selectTagAt(index);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputClickHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (this.typeahead && this.showTypeaheadOnClick) {
                    this.typeahead.open = true;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputFocusHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectInput();
                // mark form control as touched
                this._onTouchedHandler();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.inputPasteHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                if (this.addOnPaste) {
                    // Get text from the clipboard
                    /** @type {?} */
                    var input = null;
                    if (event.clipboardData) {
                        input = event.clipboardData.getData('text/plain');
                    }
                    else if ((( /** @type {?} */(window))).clipboardData) {
                        // Internet Explorer only
                        input = (( /** @type {?} */(window))).clipboardData.getData('Text');
                    }
                    // Commit the clipboard text directly
                    if (this.commit(input)) {
                        this.selectInput();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.typeaheadOptionSelectedHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // When the typeahead sends the optionSelected event, commit the object directly
                this.commitTypeahead(event.option);
            };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
        TagInputComponent.prototype.commitInput = /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
            function () {
                if (this.commit(this.input)) {
                    this.selectInput();
                    this.setInputValue('');
                }
            };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.commitTypeahead = /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (this.addTag(tag)) {
                    this.selectInput();
                    this.setInputValue('');
                }
            };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.commit = /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                var e_1, _a, e_2, _b;
                if (input && this.freeInput) {
                    // Split the tags by the tagDelimiters if configured
                    /** @type {?} */
                    var newTags = this.splitTagInput(input);
                    // Check tag validation for all of the individual values
                    /** @type {?} */
                    var allValid = true;
                    try {
                        for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                            var newTag = newTags_1_1.value;
                            /** @type {?} */
                            var valid = this.validateTag(newTag);
                            if (!valid) {
                                allValid = false;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                                _a.call(newTags_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    // Add the tags if all are valid
                    if (allValid) {
                        try {
                            for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                                var newTag = newTags_2_1.value;
                                this.addTag(this.createTag(newTag));
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                    _b.call(newTags_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return true;
                    }
                }
                return false;
            };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
        TagInputComponent.prototype.backspace = /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (!this.isValidTagIndex(this.selectedIndex)) {
                    this.selectTagAt(this.tags.length - 1);
                }
                else {
                    this.removeTagAt(this.selectedIndex);
                }
            };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TagInputComponent.prototype.moveSelection = /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (delta) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidSelectIndex(this.selectedIndex)) {
                    this.selectedIndex += delta;
                    // Do wrapping of selection when out of bounds
                    if (this.selectedIndex < 0) {
                        this.selectedIndex = this.tags.length;
                    }
                    else if (this.selectedIndex > this.tags.length) {
                        this.selectedIndex = 0;
                    }
                }
            };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.getTagDisplay = /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (typeof this.display === 'function') {
                    return this.display(tag);
                }
                if (typeof this.display === 'string') {
                    return tag[( /** @type {?} */(this.display))];
                }
                return tag;
            };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isSelected = /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index === this.selectedIndex;
            };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.selectTagAt = /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidTagIndex(tagIndex)) {
                    this.selectedIndex = tagIndex;
                }
            };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
        TagInputComponent.prototype.selectInput = /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectedIndex = this.tags.length;
            };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.removeTagAt = /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                    return;
                }
                // Check that the tagIndex is in range
                if (this.isValidTagIndex(tagIndex)) {
                    /** @type {?} */
                    var tag = this.tags[tagIndex];
                    /** @type {?} */
                    var tagRemovingEvent = new TagInputEvent(tag);
                    this.tagRemoving.emit(tagRemovingEvent);
                    if (!tagRemovingEvent.defaultPrevented()) {
                        // Select input first to avoid issues with dropping focus
                        this.selectInput();
                        // Remove the tag
                        this.tags = this.tags.filter(function (_tag, index) { return index !== tagIndex; });
                        this.setTagsValue(this._tags);
                        // Set focus again since indices have changed
                        this.selectInput();
                        this.tagRemoved.emit(new TagInputEvent(tag));
                        this.validate();
                    }
                }
            };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.canRemoveTagAt = /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return this.tags.length > this.minTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if the input field should be available.
         */
        /**
         * Returns true if the input field should be available.
         * @return {?}
         */
        TagInputComponent.prototype.isInputVisible = /**
         * Returns true if the input field should be available.
         * @return {?}
         */
            function () {
                return this.tags.length < this.maxTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if any part of the control has focus.
         */
        /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
        TagInputComponent.prototype.hasFocus = /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
            function () {
                return this.isValidSelectIndex(this.selectedIndex);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.typeahead && this.typeahead.open ? this.typeahead.open = false : this.inputClickHandler();
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.clear = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.tags = [];
                this.setTagsValue(this._tags);
                this.setInputValue('');
                this.focus();
            };
        /**
         * @param {?} text
         * @return {?}
         */
        TagInputComponent.prototype.setInputValue = /**
         * @param {?} text
         * @return {?}
         */
            function (text) {
                this.input = text;
                this.inputChange.emit(text);
            };
        /**
         * @param {?} tags
         * @return {?}
         */
        TagInputComponent.prototype.setTagsValue = /**
         * @param {?} tags
         * @return {?}
         */
            function (tags) {
                this._onChangeHandler(tags);
                this.tagsChange.emit(tags);
            };
        /**
         * @param {?} typeahead
         * @return {?}
         */
        TagInputComponent.prototype.connectTypeahead = /**
         * @param {?} typeahead
         * @return {?}
         */
            function (typeahead) {
                var _this = this;
                if (this._subscription) {
                    this._subscription.unsubscribe();
                    this._subscription = null;
                }
                this.typeahead = typeahead;
                if (this.typeahead) {
                    // Set up event handler for selected options
                    this._subscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                    // Set up event handler for the highlighted element
                    // Added a delay to move it out of the current change detection cycle
                    this._subscription.add(this.typeahead.highlightedElementChange.pipe(tick())
                        .subscribe(function (element) { return _this.highlightedElement = element; }));
                }
            };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         */
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.validateTag = /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                /** @type {?} */
                var inputPattern = null;
                this.inputValid = true;
                if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                    inputPattern = {
                        given: tagValue,
                        pattern: this.tagPattern
                    };
                    this.inputValid = false;
                }
                this.validationErrors['inputPattern'] = inputPattern;
                return this.inputValid;
            };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         */
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.createTag = /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                /** @type {?} */
                var tag = null;
                if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                    tag = this.createTagHandler(tagValue);
                }
                else if (typeof this.display === 'string') {
                    tag = {};
                    tag[( /** @type {?} */(this.display))] = tagValue;
                }
                else {
                    tag = tagValue;
                }
                return tag;
            };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         */
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.addTag = /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (tag) {
                    // Verify that the new tag can be displayed
                    /** @type {?} */
                    var displayValue = this.getTagDisplay(tag);
                    if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                        /** @type {?} */
                        var tagAddingEvent = new TagInputEvent(tag);
                        this.tagAdding.emit(tagAddingEvent);
                        if (!tagAddingEvent.defaultPrevented()) {
                            this.tags = __spread(this.tags, [tag]);
                            this.setTagsValue(this._tags);
                            this.tagAdded.emit(new TagInputEvent(tag));
                            this.validate();
                            return true;
                        }
                    }
                }
                return false;
            };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         */
        /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.isValidTagIndex = /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return tagIndex >= 0 && tagIndex < this.tags.length;
            };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         */
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isValidSelectIndex = /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index >= 0 && index <= this.tags.length;
            };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         */
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.getKeyChar = /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.SPACE:
                        return ' ';
                }
                return event.key;
            };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         */
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.splitTagInput = /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                /** @type {?} */
                var tagValues = [input];
                if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                    /** @type {?} */
                    var escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    /** @type {?} */
                    var delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                    tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
                }
                return tagValues;
            };
        TagInputComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-tag-input',
                        exportAs: 'ux-tag-input',
                        template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\"\n    [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\"\n    [class.ux-tag-input-clear-inset]=\"_showClearButton\"\n    [class.ux-tag-input-icon-inset]=\"icon\"\n    (click)=\"toggle()\">\n\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i); $event.stopPropagation()\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate || defaultTagTemplate\"\n                      [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n               [ngModel]=\"input\"\n               (ngModelChange)=\"setInputValue($event)\"\n               [autocomplete]=\"autocomplete\"\n               [class.invalid]=\"!inputValid\"\n               [attr.aria-activedescendant]=\"highlightedElement?.id\"\n               [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n               [attr.aria-controls]=\"typeahead?.id\"\n               [attr.aria-label]=\"ariaLabel\"\n               aria-multiline=\"false\"\n               [placeholder]=\"disabled ? '' : (placeholder || '')\"\n               [disabled]=\"disabled\"\n               [focusIf]=\"isSelected(tags.length)\"\n               (click)=\"toggle(); $event.stopPropagation()\"\n               (focus)=\"inputFocusHandler(); inputFocus.emit($event)\"\n               (paste)=\"inputPasteHandler($event)\"\n               [readonly]=\"readonlyInput\">\n    </li>\n</ol>\n\n<!-- Insert the custom icon if provided -->\n<div class=\"ux-tag-icons\" *ngIf=\"icon || _showClearButton\" (click)=\"toggle(); $event.stopPropagation()\">\n\n    <!-- Clear All Button -->\n    <i uxFocusIndicator\n       class=\"ux-tag-icon ux-icon ux-icon-close ux-select-clear-icon\"\n       [attr.tabindex]=\"disabled ? -1 : 0\"\n       [attr.aria-label]=\"clearButtonAriaLabel\"\n       *ngIf=\"_showClearButton\"\n       (click)=\"clear(); $event.stopPropagation()\"\n       (keydown.enter)=\"clear(); $event.stopPropagation()\">\n    </i>\n\n    <!-- Custom Icon -->\n    <div *ngIf=\"icon\" class=\"ux-custom-icon\">\n        <ng-container [ngTemplateOutlet]=\"icon\"></ng-container>\n    </div>\n</div>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{ api.getTagDisplay(tag) }}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n            uxFocusIndicator\n            type=\"button\"\n            class=\"ux-tag-remove\"\n            aria-label=\"Remove Item\"\n            [disabled]=\"disabled\"\n            (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <ux-icon name=\"close\"></ux-icon>\n    </button>\n</ng-template>",
                        providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.focus]': 'hasFocus()',
                            '[class.invalid]': '!valid || !inputValid'
                        }
                    }] }
        ];
        /** @nocollapse */
        TagInputComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        TagInputComponent.propDecorators = {
            id: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.id',] }],
            tags: [{ type: i0.Input }],
            input: [{ type: i0.Input }],
            display: [{ type: i0.Input }],
            addOnPaste: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            enforceTagLimits: [{ type: i0.Input }],
            freeInput: [{ type: i0.Input }],
            readonlyInput: [{ type: i0.Input }],
            maxTags: [{ type: i0.Input }],
            minTags: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            showTypeaheadOnClick: [{ type: i0.Input }],
            tagDelimiters: [{ type: i0.Input }],
            tagPattern: [{ type: i0.Input }],
            tagTemplate: [{ type: i0.Input }],
            tagClass: [{ type: i0.Input }],
            validationErrors: [{ type: i0.Input }],
            autocomplete: [{ type: i0.Input }],
            createTagHandler: [{ type: i0.Input, args: ['createTag',] }],
            icon: [{ type: i0.Input }],
            clearButton: [{ type: i0.Input }],
            clearButtonAriaLabel: [{ type: i0.Input }],
            tagsChange: [{ type: i0.Output }],
            inputChange: [{ type: i0.Output }],
            tagAdding: [{ type: i0.Output }],
            tagAdded: [{ type: i0.Output }],
            tagInvalidated: [{ type: i0.Output }],
            tagRemoving: [{ type: i0.Output }],
            tagRemoved: [{ type: i0.Output }],
            tagClick: [{ type: i0.Output }],
            inputFocus: [{ type: i0.Output }],
            typeaheadQuery: [{ type: i0.ContentChildren, args: [TypeaheadComponent,] }],
            tagInput: [{ type: i0.ViewChild, args: ['tagInput', { static: false },] }],
            keyHandler: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
            focusOutHandler: [{ type: i0.HostListener, args: ['focusout',] }],
            onClick: [{ type: i0.HostListener, args: ['click',] }]
        };
        return TagInputComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TagInputModule = /** @class */ (function () {
        function TagInputModule() {
        }
        TagInputModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            FocusIfModule,
                            IconModule,
                            TypeaheadModule
                        ],
                        exports: [
                            TagInputComponent
                        ],
                        declarations: [
                            TagInputComponent
                        ]
                    },] }
        ];
        return TagInputModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SelectModule = /** @class */ (function () {
        function SelectModule() {
        }
        SelectModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            InfiniteScrollModule,
                            TagInputModule,
                            TypeaheadModule,
                            platform.PlatformModule
                        ],
                        exports: [SelectComponent],
                        declarations: [SelectComponent]
                    },] }
        ];
        return SelectModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var BaseSearchComponent = /** @class */ (function () {
        function BaseSearchComponent(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "ux-search-builder-search-component-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: /**
             * Get the current value of the component
             * @return {?}
             */ function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: /**
             * Set the current value of the component
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
        BaseSearchComponent.prototype.ngOnDestroy = /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
            function () {
                this.valid = true;
            };
        /**
         * Perform any required validation on the value
         */
        /**
         * Perform any required validation on the value
         * @return {?}
         */
        BaseSearchComponent.prototype.validate = /**
         * Perform any required validation on the value
         * @return {?}
         */
            function () {
                // if a custom validation function has been provided then use it
                this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
            };
        BaseSearchComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-base-search',
                        template: ''
                    }] }
        ];
        /** @nocollapse */
        BaseSearchComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        return BaseSearchComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchDateRangeComponent = /** @class */ (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: /**
             * @param {?} fromValue
             * @return {?}
             */ function (fromValue) {
                // create new object based on the current value
                /** @type {?} */
                var value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: /**
             * @param {?} toValue
             * @return {?}
             */ function (toValue) {
                // create new object based on the current value
                /** @type {?} */
                var value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        /**
         * Override the default validation
         * @return {?}
         */
        SearchDateRangeComponent.prototype.validate = /**
         * Override the default validation
         * @return {?}
         */
            function () {
                // check if there is a config validation function
                if (this.config.validation) {
                    return _super.prototype.validate.call(this);
                }
                // create copies of the dates so we can modify time value (to ignore it)
                /** @type {?} */
                var from = new Date(this.value.from);
                /** @type {?} */
                var to = new Date(this.value.to);
                // set the time to the same so we dont compare it
                from.setHours(0, 0, 0, 0);
                to.setHours(0, 0, 0, 0);
                // valid if the from date is less than or equal to the to date
                this.valid = from <= to;
            };
        SearchDateRangeComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-date-range',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <ux-icon name=\"calendar\"></ux-icon>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\" [focusIf]=\"focus\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <ux-icon name=\"calendar\"></ux-icon>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateRangeComponent;
    }(BaseSearchComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchDateComponent = /** @class */ (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SearchDateComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // by default set to the current date if not specified
                if (!this.value) {
                    this.value = new Date();
                }
            };
        SearchDateComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-date',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <ux-icon name=\"calendar\"></ux-icon>\n    </span>\n    <input type=\"text\"\n        class=\"form-control\"\n        aria-label=\"Selected date\"\n        [placeholder]=\"placeholder\"\n        #popover=\"ux-popover\"\n        [ngModel]=\"value | date:'dd MMMM yyyy'\"\n        [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\"\n        popoverClass=\"date-time-picker-popover\"\n        [focusIf]=\"focus\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateComponent;
    }(BaseSearchComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchSelectComponent = /** @class */ (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: /**
             * Provide defaults for undefined properties
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-select',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\"\n           [options]=\"options\"\n           [multiple]=\"multiple\"\n           [placeholder]=\"placeholder\"\n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\"\n           [focusIf]=\"focus\">\n</ux-select>"
                    }] }
        ];
        return SearchSelectComponent;
    }(BaseSearchComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchTextComponent = /** @class */ (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-search-text',
                        template: "<label *ngIf=\"label\" class=\"form-label\" [attr.for]=\"id\">{{ label }}</label>\n<input [attr.id]=\"id\" class=\"form-control\" [placeholder]=\"placeholder\" [(ngModel)]=\"value\" [focusIf]=\"focus\">"
                    }] }
        ];
        return SearchTextComponent;
    }(BaseSearchComponent));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SearchBuilderModule = /** @class */ (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            DateTimePickerModule,
                            FocusIfModule,
                            forms.FormsModule,
                            IconModule,
                            PopoverModule,
                            SelectModule,
                        ],
                        exports: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            BaseSearchComponent
                        ],
                        declarations: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchBuilderOutletDirective,
                            SearchSelectComponent,
                            BaseSearchComponent
                        ],
                        entryComponents: [
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchSelectComponent
                        ],
                        providers: [
                            SearchBuilderFocusService
                        ]
                    },] }
        ];
        return SearchBuilderModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ SelectionStrategy = /** @class */ (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        /**
         * @param {?} selectionService
         * @return {?}
         */
        SelectionStrategy.prototype.setSelectionService = /**
         * @param {?} selectionService
         * @return {?}
         */
            function (selectionService) {
                this.selectionService = selectionService;
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.mousedown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * Select the item - default behavior
         */
        /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.select = /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var _a;
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).select.apply(_a, __spread(data));
            };
        /**
         * Replace the current selection with the list of items specified
         */
        /**
         * Replace the current selection with the list of items specified
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.selectOnly = /**
         * Replace the current selection with the list of items specified
         * @param {...?} data
         * @return {?}
         */
            function () {
                var _a;
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).selectOnly.apply(_a, __spread(data));
            };
        /**
         * Toggle the item's selected state - default behavior
         */
        /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.toggle = /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var _a;
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).toggle.apply(_a, __spread(data));
            };
        /**
         * Deselect the item - default behavior
         */
        /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.deselect = /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var _a;
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).deselect.apply(_a, __spread(data));
            };
        /**
         * Select all items - default behavior
         */
        /**
         * Select all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.selectAll = /**
         * Select all items - default behavior
         * @return {?}
         */
            function () {
                this.select.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * Deselect all items - default behavior
         */
        /**
         * Deselect all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.deselectAll = /**
         * Deselect all items - default behavior
         * @return {?}
         */
            function () {
                // call deselect on all items in the dataset
                this.selectionService.deselectAll();
            };
        /**
         * @return {?}
         */
        SelectionStrategy.prototype.destroy = /**
         * @return {?}
         */
            function () { };
        return SelectionStrategy;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ RowSelectionStrategy = /** @class */ (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // store the most recently selected row
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
        RowSelectionStrategy.prototype.mousedown = /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * When a row is clicked we want to handle selection
         */
        /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.click = /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if the shift key is pressed we want to perform a multiple selection
                if (shiftKey) {
                    return this.multipleSelect(data);
                }
                // if the control key is pressed we want to perform an additive toggle selection
                if (ctrlKey) {
                    return this.toggle(data);
                }
                // perform a single selection where all other rows are deselected
                this.singleSelect(data);
            };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.keydown = /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.navigate(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        // also activate the item
                        this.selectionService.activate(data);
                        break;
                }
            };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                _super.prototype.toggle.call(this, data);
                // store or clear the selection
                this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
            };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         */
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.singleSelect = /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // deselect all other rows if neither modifier key is pressed
                this.deselectAll();
                // select the current row
                this.select(data);
                // store the current item as the selection start
                this.setSelectionStart(data);
            };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.multipleSelect = /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if no selection currently exists then perform initial selection
                if (!this._selection.start) {
                    // select the row
                    this.select(data);
                    // store the starting point
                    return this.setSelectionStart(data);
                }
                // if a multiple selection already took place - clear the previous selection
                if (this._selection.start && this._selection.end) {
                    this.deselect.apply(this, __spread(this.getSelectedItems()));
                }
                // set the new selection end point
                this.setSelectionEnd(data);
                // select all the items in the range
                this.select.apply(this, __spread(this.getSelectedItems()));
            };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         */
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionStart = /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.start = data;
                this._selection.end = null;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Set the selection end point
         */
        /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionEnd = /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.end = data;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Clear both start and end selection points
         */
        /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
        RowSelectionStrategy.prototype.clearSelection = /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
            function (deactivate) {
                if (deactivate === void 0) {
                    deactivate = true;
                }
                // reset the selected item
                this._selection = { start: null, end: null };
                // remove the current active item
                if (deactivate) {
                    this.selectionService.deactivate();
                }
            };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         */
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
        RowSelectionStrategy.prototype.getSelectedItems = /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
            function () {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                /** @type {?} */
                var startIdx = dataset.indexOf(this._selection.start);
                /** @type {?} */
                var endIdx = dataset.indexOf(this._selection.end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        /**
         * Activate the sibling item when arrow keys are pressed
         */
        /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.navigate = /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
                /** @type {?} */
                var sibling = this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                // if the shift key is pressed then we also want to toggle the state if the item
                if (shiftKey && sibling) {
                    // if there is no current selection start then select the current row
                    if (!this._selection.start) {
                        this.multipleSelect(data);
                    }
                    this.multipleSelect(sibling);
                }
            };
        return RowSelectionStrategy;
    }(SelectionStrategy));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ RowAltSelectionStrategy = /** @class */ (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.handleCursorKey(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        break;
                }
            };
        /**
         * Select the sibling item when arrow keys are pressed
         */
        /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.handleCursorKey = /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                if (ctrlKey) {
                    this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                }
                else {
                    /** @type {?} */
                    var sibling = this.selectionService.getSibling(event.which === keycodes.UP_ARROW);
                    this.multipleSelect(sibling ? sibling : data);
                }
            };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ SimpleSelectionStrategy = /** @class */ (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.click = /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                this.toggle(data);
            };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.keydown = /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        event.preventDefault();
                        this.selectionService.activateSibling(true);
                        return;
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.selectionService.activateSibling(false);
                        return;
                    case keycodes.SPACE:
                        event.preventDefault();
                        return this.toggle(data);
                }
            };
        /**
         * Override the standard toggle function to always activate the item
         */
        /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                _super.prototype.toggle.call(this, data);
                this.selectionService.activate(data);
            };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SelectionService = /** @class */ (function () {
        function SelectionService() {
            /**
             * The active selection strategy that defines how selections can be made
             */
            this.strategy = new SimpleSelectionStrategy(this);
            /**
             * Define if selections can be performed on any items
             */
            this.isEnabled = true;
            /**
             * Define if the mouse can be used to perform selections
             */
            this.isClickEnabled = true;
            /**
             * Define if the keyboard can be used to perform selections
             */
            this.isKeyboardEnabled = true;
            /**
             * Define the currently focused item
             */
            this.focus$ = new rxjs.BehaviorSubject(null);
            /**
             * Define the currently active item
             */
            this.active$ = new rxjs.BehaviorSubject(null);
            /**
             * Store the current list of selected items as an array
             */
            this.selection$ = new rxjs.BehaviorSubject([]);
            /**
             * Store the current set of selectable items
             */
            this._dataset = [];
            /**
             * Store the selection strategy that should be destroyed
             */
            this._strategyToDestroy = this.strategy;
            /**
             * Store the current selection in a set
             */
            this._selection = new Set();
            /**
             * Store the current disabled items in a set
             */
            this._disabled = new Set();
        }
        Object.defineProperty(SelectionService.prototype, "dataset", {
            /** Get the current set of selectable items */
            get: /**
             * Get the current set of selectable items
             * @return {?}
             */ function () {
                return this._dataset;
            },
            /** Store the current set of selectable items and ensure an item can be focused */
            set: /**
             * Store the current set of selectable items and ensure an item can be focused
             * @param {?} dataset
             * @return {?}
             */ function (dataset) {
                this._dataset = dataset;
                if (this._dataset.indexOf(this._active) === -1) {
                    this.setFirstItemFocusable();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // destroy the active stategy
                if (this._strategyToDestroy) {
                    this._strategyToDestroy.destroy();
                }
                // complete all observables
                this.focus$.complete();
                this.active$.complete();
                this.selection$.complete();
            };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.select = /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // filter out any disabled items
                selections = selections.filter(function (item) { return !_this._disabled.has(item); });
                // add each selection to the set
                selections.forEach(function (selection) { return _this._selection.add(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Deselect all currently selected items and replace with a new selection
         */
        /**
         * Deselect all currently selected items and replace with a new selection
         * @param {...?} selection
         * @return {?}
         */
        SelectionService.prototype.selectOnly = /**
         * Deselect all currently selected items and replace with a new selection
         * @param {...?} selection
         * @return {?}
         */
            function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i] = arguments[_i];
                }
                // filter out any disabled items
                selection = selection.filter(function (item) { return !_this._disabled.has(item); });
                // remove all currently selected items
                this._selection.clear();
                // select only the specified item
                selection.forEach(function (item) { return _this._selection.add(item); });
                // emit the changes
                this.selectionHasMutated();
            };
        /**
         * Remove an item from the list of selected items
         */
        /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.deselect = /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // remove each item from the set
                selections.forEach(function (selection) { return _this._selection.delete(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove all items from the list of selected items
         */
        /**
         * Remove all items from the list of selected items
         * @return {?}
         */
        SelectionService.prototype.deselectAll = /**
         * Remove all items from the list of selected items
         * @return {?}
         */
            function () {
                // remove all items in the array
                this.deselect.apply(this, __spread(this._dataset));
                // clear the set in case any items have been removed from the DOM but are still selected
                this._selection.clear();
            };
        /**
         * Toggle the selected state of any specified items
         */
        /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.toggle = /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
            };
        /**
         * Determine whether or not a specific item is currently selected
         */
        /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.isSelected = /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return this._selection.has(data);
            };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.getSelectionState = /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var _this = this;
                return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
            };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
        SelectionService.prototype.setStrategy = /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                if (this._strategyToDestroy) {
                    // Destroy previous strategy if it was created internally
                    this._strategyToDestroy.destroy();
                    this._strategyToDestroy = null;
                }
                if (mode instanceof SelectionStrategy) {
                    // Custom strategy - pass in the service instance
                    this.strategy = mode;
                    this.strategy.setSelectionService(this);
                }
                else {
                    switch (mode.toLowerCase().trim()) {
                        case 'simple':
                            this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                            break;
                        case 'row':
                            this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                            break;
                        case 'row-alt':
                            this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                            break;
                        default:
                            throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                    }
                }
            };
        /**
         * Set the current active item
         */
        /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.activate = /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._active = data;
                this.active$.next(this._active);
            };
        /**
         * Deactive all items
         */
        /**
         * Deactive all items
         * @return {?}
         */
        SelectionService.prototype.deactivate = /**
         * Deactive all items
         * @return {?}
         */
            function () {
                this._active = null;
                this.active$.next(this._active);
            };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
        SelectionService.prototype.getSibling = /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                // check if there is a current active item
                if (!this._active) {
                    return;
                }
                // get the index of the current item
                /** @type {?} */
                var idx = this.dataset.indexOf(this._active);
                /** @type {?} */
                var target = this.dataset[previous ? idx - 1 : idx + 1];
                return target;
            };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
        SelectionService.prototype.activateSibling = /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                /** @type {?} */
                var target = this.getSibling(previous);
                // check if the target exists
                if (target) {
                    this.activate(target);
                }
                return target;
            };
        /**
         * @param {?} disabled
         * @return {?}
         */
        SelectionService.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
            function (disabled) {
                // store the current disabled state
                this.isEnabled = !disabled;
                // clear any stateful data
                this._active = null;
                this.active$.next(this._active);
                this._selection.clear();
                // emit the selection change information
                this.selectionHasMutated();
            };
        /** Store the disabled state of an item */
        /**
         * Store the disabled state of an item
         * @param {?} item
         * @param {?} isDisabled
         * @return {?}
         */
        SelectionService.prototype.setItemDisabled = /**
         * Store the disabled state of an item
         * @param {?} item
         * @param {?} isDisabled
         * @return {?}
         */
            function (item, isDisabled) {
                // update the internal list of disabled items
                if (isDisabled && !this._disabled.has(item)) {
                    this._disabled.add(item);
                }
                else if (!isDisabled) {
                    this._disabled.delete(item);
                }
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.selectionHasMutated = /**
         * @return {?}
         */
            function () {
                this.selection$.next(Array.from(this._selection));
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.setFirstItemFocusable = /**
         * @return {?}
         */
            function () {
                if (this._dataset.length > 0) {
                    this.focus$.next(this._dataset[0]);
                    this._active = this._dataset[0];
                }
                else {
                    this._active = null;
                }
            };
        SelectionService.decorators = [
            { type: i0.Injectable }
        ];
        return SelectionService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SelectListItemComponent = /** @class */ (function () {
        function SelectListItemComponent(_selection, elementRef, focusIndicatorService) {
            var _this = this;
            this._selection = _selection;
            this.tabindex = -1;
            /**
             * Unsubscribe from all subscriptions on destroy
             */
            this._onDestroy = new rxjs.Subject();
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
            _selection.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (data) { return data === _this.data; })).subscribe(function (active) {
                _selection.focus$.next(active);
                elementRef.nativeElement.focus();
            });
            // make this item tabbable or not based on the focused element
            _selection.focus$.pipe(operators.takeUntil(this._onDestroy), tick())
                .subscribe(function (focused) { return _this.tabindex = focused === _this.data ? 0 : -1; });
        }
        Object.defineProperty(SelectListItemComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selection.isSelected(this.data);
            },
            set: /**
             * @param {?} isSelected
             * @return {?}
             */ function (isSelected) {
                isSelected ? this._selection.select(this.data) : this._selection.deselect(this.data);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this._focusIndicator.destroy();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onMouseDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.mousedown(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.click(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.keydown(event, this.data);
            };
        SelectListItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-select-list-item',
                        template: "<ng-content></ng-content>",
                        host: {
                            role: 'listitem'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListItemComponent.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: i0.ElementRef },
                { type: FocusIndicatorService }
            ];
        };
        SelectListItemComponent.propDecorators = {
            data: [{ type: i0.Input }],
            tabindex: [{ type: i0.HostBinding, args: ['tabindex',] }],
            selected: [{ type: i0.HostBinding, args: ['class.selected',] }, { type: i0.HostBinding, args: ['attr.aria-selected',] }],
            onMouseDown: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }],
            onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return SelectListItemComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SelectionItemDirective = /** @class */ (function () {
        function SelectionItemDirective(_selectionService, _elementRef, focusIndicatorService, _managedFocusContainerService) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            /**
             * Defines the tab index of the row
             */
            this.tabindex = null;
            /**
             * Defines whether or not this item is currently selected.
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Store the current focused state of the item
             */
            this.active = false;
            /**
             * Store the current selected state
             */
            this._selected = false;
            /**
             * Store the disabled state
             */
            this._isDisabled = false;
            /**
             * Store the tab indexed if using the managed focus container
             */
            this._managedTabIndex = -1;
            /**
             * Automatically unsubscribe when the component is destroyed
             */
            this._onDestroy = new rxjs.Subject();
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            /** Defines whether or not this item is currently selected. */
            set: /**
             * Defines whether or not this item is currently selected.
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "uxSelectionDisabled", {
            /** Determine whether or not this item can be selected */
            set: /**
             * Determine whether or not this item can be selected
             * @param {?} isDisabled
             * @return {?}
             */ function (isDisabled) {
                // if this item was selected then deselect it
                if (this._selected && isDisabled) {
                    this.deselect();
                }
                // inform the selection service of the disabled state
                this._selectionService.setItemDisabled(this.uxSelectionItem, isDisabled);
                // store the current disabled state
                this._isDisabled = isDisabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is no associated data then throw an error
                if (!this.uxSelectionItem) {
                    throw new Error('The uxSelectionItem directive must have data associated with it.');
                }
                // subscribe to selection changes on this item
                this._selectionService.getSelectionState(this.uxSelectionItem).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (selected) {
                    // store the selected state
                    _this._selected = selected;
                    // emit the selected state
                    _this.selectedChange.emit(selected);
                });
                this._selected = this._selectionService.isSelected(this.uxSelectionItem);
                this.selectedChange.emit(this._selected);
                // subscribe to changes to the active state
                this._selectionService.active$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                    // store the focus state
                    _this.active = active;
                    // if it is active then focus the element
                    if (active === true) {
                        _this._selectionService.focus$.next(_this.uxSelectionItem);
                        _this._elementRef.nativeElement.focus();
                    }
                });
                // Subscribe to changes to the focus target
                // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
                this._selectionService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focusTarget) {
                    _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
                });
                // Watch for focus within the container element and manage tabindex of descendants
                this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this._focusIndicator.destroy();
                this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this._isDisabled && this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.click(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.mousedown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this._isDisabled && this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.keydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if the space key (selection key) is pressed and we are disabled then we should block
                // the event from propagating. However if this is a key such as arrow presses then we do
                // still want this to propagate to allow keyboard navigation for accessibility purposes.
                /** @type {?} */
                var isDisabled = this._isDisabled && event.keyCode === keycodes.SPACE;
                if (!isDisabled && this._selectionService.isEnabled && this._selectionService.isKeyboardEnabled) {
                    this._selectionService.strategy.keydown(event, this.uxSelectionItem);
                }
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // If tabbed to from outside the component, activate.
                if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                    this._selectionService.activate(this.uxSelectionItem);
                }
            };
        /**
         * Select this item using the current strategy
         */
        /**
         * Select this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.select = /**
         * Select this item using the current strategy
         * @return {?}
         */
            function () {
                if (!this._isDisabled && this._selectionService.isEnabled) {
                    this._selectionService.strategy.select(this.uxSelectionItem);
                }
            };
        /**
         * Deselect this item using the current strategy
         */
        /**
         * Deselect this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.deselect = /**
         * Deselect this item using the current strategy
         * @return {?}
         */
            function () {
                if (!this._isDisabled && this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselect(this.uxSelectionItem);
                }
            };
        SelectionItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxSelectionItem]',
                        exportAs: 'ux-selection-item'
                    },] }
        ];
        /** @nocollapse */
        SelectionItemDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: i0.ElementRef },
                { type: FocusIndicatorService },
                { type: ManagedFocusContainerService }
            ];
        };
        SelectionItemDirective.propDecorators = {
            uxSelectionItem: [{ type: i0.Input }],
            selected: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.ux-selection-selected',] }, { type: i0.HostBinding, args: ['attr.aria-selected',] }],
            tabindex: [{ type: i0.Input }],
            uxSelectionDisabled: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            active: [{ type: i0.HostBinding, args: ['class.ux-selection-focused',] }],
            attrTabIndex: [{ type: i0.HostBinding, args: ['attr.tabindex',] }],
            click: [{ type: i0.HostListener, args: ['click', ['$event'],] }],
            mousedown: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }],
            keydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }],
            focus: [{ type: i0.HostListener, args: ['focus',] }]
        };
        return SelectionItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SelectionDirective = /** @class */ (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            /**
             * The tabstop of the selection outer element
             */
            this.tabindex = null;
            /**
             * This event will be triggered when there is a change to the selected items. It will contain an array of the currently selected items.
             */
            this.uxSelectionChange = new i0.EventEmitter();
            /**
             * Unsubscribe from all observables on component destroy
             */
            this._onDestroy = new rxjs.Subject();
            _selectionService.selection$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (items) {
                if (_this.isSelectionChanged(items)) {
                    _this.uxSelectionChange.emit(items);
                }
                // store the most recent selection
                _this._lastSelection = __spread(items);
            });
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            /** Defines the items that should be selected. */
            set: /**
             * Defines the items that should be selected.
             * @param {?} items
             * @return {?}
             */ function (items) {
                var _a;
                (_a = this._selectionService).selectOnly.apply(_a, __spread(items));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            /** Can be used to enabled/disable selection behavior. */
            set: /**
             * Can be used to enabled/disable selection behavior.
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            /**
             * Defines the selection behavior. Alternatively, custom selection behavior can be defined by defining a
             * class which extends SelectionStrategy, and providing an instance of the custom class to this property.
             * See below for details of the SelectionStrategy class.
             */
            set: /**
             * Defines the selection behavior. Alternatively, custom selection behavior can be defined by defining a
             * class which extends SelectionStrategy, and providing an instance of the custom class to this property.
             * See below for details of the SelectionStrategy class.
             * @param {?} mode
             * @return {?}
             */ function (mode) {
                this._selectionService.setStrategy(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            /**
             * Can be used to enable/disable click selection on items. This can be used to manually control the selection of an item,
             * for example, binding the selection state to a checkbox.
             */
            set: /**
             * Can be used to enable/disable click selection on items. This can be used to manually control the selection of an item,
             * for example, binding the selection state to a checkbox.
             * @param {?} isClickEnabled
             * @return {?}
             */ function (isClickEnabled) {
                this._selectionService.isClickEnabled = isClickEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            /** Can be used to enable/disable keyboard navigation on items. Use this if you wish to provide custom keyboard controls for selection. */
            set: /**
             * Can be used to enable/disable keyboard navigation on items. Use this if you wish to provide custom keyboard controls for selection.
             * @param {?} isKeyboardEnabled
             * @return {?}
             */ function (isKeyboardEnabled) {
                this._selectionService.isKeyboardEnabled = isKeyboardEnabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // provide the initial list of selection items
                this.update();
                // if the list changes then inform the service
                this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.update(); });
            };
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Update the dataset to reflect the latest selection items
         */
        /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
        SelectionDirective.prototype.update = /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
            function () {
                this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
                // Make sure that a tab target has been defined so that the component can be tabbed to.
                if (this._selectionService.focus$.getValue() === null && this._selectionService.dataset.length > 0) {
                    this._selectionService.focus$.next(this._selectionService.dataset[0]);
                }
                // The above could trigger a change in the computed tabindex for selection items
                this._cdRef.detectChanges();
            };
        /**
         * Select all the items in the list
         */
        /**
         * Select all the items in the list
         * @return {?}
         */
        SelectionDirective.prototype.selectAll = /**
         * Select all the items in the list
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.selectAll();
                }
            };
        /**
         * Deselect all currently selected items
         */
        /**
         * Deselect all currently selected items
         * @return {?}
         */
        SelectionDirective.prototype.deselectAll = /**
         * Deselect all currently selected items
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselectAll();
                }
            };
        /**
         * Determine if the previous selection is the same as the current selection
         */
        /**
         * Determine if the previous selection is the same as the current selection
         * @param {?} selection
         * @return {?}
         */
        SelectionDirective.prototype.isSelectionChanged = /**
         * Determine if the previous selection is the same as the current selection
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                // fast, efficient check, if length is different they must have changed
                if (!this._lastSelection && selection || this._lastSelection.length !== selection.length) {
                    return true;
                }
                // if both arrays have 0 items then they have not changed
                if (this._lastSelection.length === 0 && selection.length === 0) {
                    return false;
                }
                // otherwise do a check on each item
                return !this._lastSelection.every(function (item) { return selection.indexOf(item) !== -1; });
            };
        SelectionDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxSelection]',
                        exportAs: 'ux-selection',
                        providers: [SelectionService]
                    },] }
        ];
        /** @nocollapse */
        SelectionDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        SelectionDirective.propDecorators = {
            uxSelection: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            mode: [{ type: i0.Input }],
            clickSelection: [{ type: i0.Input }],
            keyboardSelection: [{ type: i0.Input }],
            tabindex: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.tabindex',] }],
            uxSelectionChange: [{ type: i0.Output }],
            items: [{ type: i0.ContentChildren, args: [SelectionItemDirective,] }]
        };
        return SelectionDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SelectionModule = /** @class */ (function () {
        function SelectionModule() {
        }
        SelectionModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [SelectionDirective, SelectionItemDirective],
                        exports: [SelectionDirective, SelectionItemDirective]
                    },] }
        ];
        return SelectionModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ MultipleSelectListStrategy = /** @class */ (function (_super) {
        __extends(MultipleSelectListStrategy, _super);
        function MultipleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** Prevent the browser from highlighting text on shift click */
        /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.mousedown = /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // activate the clicked item
                this.selectionService.activate(data);
                // if the shift key is pressed we want to perform a multiple selection
                if (event.shiftKey) {
                    return this.multipleSelect(data);
                }
                // otherwise perform a single toggle selection
                if (this.selectionService.isSelected(data)) {
                    this.deselect(data);
                    this._lastSelection = null;
                }
                else {
                    this.select(data);
                    this._lastSelection = data;
                }
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        /** @type {?} */
                        var sibling = this.selectionService.activateSibling(true);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        /** @type {?} */
                        var sibling = this.selectionService.activateSibling(false);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.toggle(data);
                        this._lastSelection = this.selectionService.isSelected(data) ? data : null;
                        break;
                }
            };
        /**
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.multipleSelect = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if there is no start item selected
                if (!this._lastSelection) {
                    this.select(data);
                    this._lastSelection = data;
                    return;
                }
                // if there already is a start item then find the items in the range
                this.select.apply(this, __spread(this.getSelectedItems(this._lastSelection, data)));
                // store the selection end point
                this._lastSelection = data;
            };
        /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.getSelectedItems = /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
            function (start, end) {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                /** @type {?} */
                var startIdx = dataset.indexOf(start);
                /** @type {?} */
                var endIdx = dataset.indexOf(end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        return MultipleSelectListStrategy;
    }(SelectionStrategy));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ SingleSelectListStrategy = /** @class */ (function (_super) {
        __extends(SingleSelectListStrategy, _super);
        function SingleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.click = /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                // activate the clicked item
                this.selectionService.activate(data);
                // toggle the selected state of the item
                if (!this.selectionService.isSelected(data)) {
                    this.selectOnly(data);
                }
                else {
                    this.deselect(data);
                }
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(true);
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(false);
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.click(null, data);
                        break;
                }
            };
        return SingleSelectListStrategy;
    }(SelectionStrategy));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var SelectListComponent = /** @class */ (function () {
        function SelectListComponent(_selection) {
            var _this = this;
            this._selection = _selection;
            /**
             * Emit when the selection changes
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Automatically unsubscribe all observables
             */
            this._onDestroy = new rxjs.Subject();
            // set the selection strategy to single by default
            this._selection.setStrategy(new SingleSelectListStrategy());
            // emit the selection changes when they occur
            this._selection.selection$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (selection) { return _this.selectedChange.emit(selection); });
        }
        Object.defineProperty(SelectListComponent.prototype, "multiple", {
            /** Determine if we allow multiple items to be selected */
            set: /**
             * Determine if we allow multiple items to be selected
             * @param {?} multiple
             * @return {?}
             */ function (multiple) {
                this._selection.strategy.deselectAll();
                this._selection.setStrategy(multiple ? new MultipleSelectListStrategy() : new SingleSelectListStrategy());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectListComponent.prototype, "selected", {
            /** Set the selected items */
            set: /**
             * Set the selected items
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                var _a;
                // if the selection entered is the same as the current selection then do nothing
                if (this._selection.selection$.value === selected) {
                    return;
                }
                // if selected is an array and has not items and there are no items currently selected also do nothing
                if (Array.isArray(selected) && selected.length === 0 && this._selection.selection$.value.length === 0) {
                    return;
                }
                // select only the specified items
                if (Array.isArray(selected)) {
                    (_a = this._selection).selectOnly.apply(_a, __spread(selected));
                }
                else {
                    this._selection.selectOnly(( /** @type {?} */(selected)));
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // supply the initial item set
                this._selection.dataset = this.items.map(function (item) { return item.data; });
                // if the item set changes update the list
                this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._selection.dataset = _this.items.map(function (item) { return item.data; }); });
            };
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        SelectListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-select-list',
                        template: "<ng-content></ng-content>",
                        providers: [SelectionService],
                        host: {
                            role: 'list'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListComponent.ctorParameters = function () {
            return [
                { type: SelectionService }
            ];
        };
        SelectListComponent.propDecorators = {
            multiple: [{ type: i0.Input }],
            selected: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            items: [{ type: i0.ContentChildren, args: [SelectListItemComponent,] }]
        };
        return SelectListComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SelectListModule = /** @class */ (function () {
        function SelectListModule() {
        }
        SelectListModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule
                        ],
                        declarations: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                        exports: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                    },] }
        ];
        return SelectListModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var InputDropdownComponent = /** @class */ (function () {
        function InputDropdownComponent() {
            /**
             * Define the placeholder for the filter input
             */
            this.placeholder = 'Type to filter...';
            /**
             * Aria label of the filter field. If not specified, the placeholder will be used.
             */
            this.ariaLabel = '';
            /**
             * Emit when the selected item is changed
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Emit when the filter text is changed
             */
            this.filterChange = new i0.EventEmitter();
            this.filterText = '';
            this.onChange = function () { };
            this.onTouched = function () { };
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(InputDropdownComponent.prototype, "maxHeight", {
            /** Define the max height of the dropdown */
            set: /**
             * Define the max height of the dropdown
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._maxHeightString = coercion.coerceCssPixelValue(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        InputDropdownComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.selected) {
                    if (this.menuTrigger && !changes.selected.firstChange) {
                        this.menuTrigger.closeMenu();
                    }
                    this.selectedChange.emit(changes.selected.currentValue);
                    this.onChange(changes.selected.currentValue);
                    this.onTouched();
                }
            };
        /**
         * @return {?}
         */
        InputDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy$.next();
                this._onDestroy$.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        InputDropdownComponent.prototype.resetFilter = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.filterText = '';
                this.filterChange.emit(this.filterText);
                this.filterInputElement.nativeElement.focus();
                event.stopPropagation();
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        InputDropdownComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChange = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        InputDropdownComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouched = onTouched;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        InputDropdownComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selected = value;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        InputDropdownComponent.prototype.resetValue = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.writeValue(undefined);
                event.stopPropagation();
            };
        /**
         * @return {?}
         */
        InputDropdownComponent.prototype._focusFilter = /**
         * @return {?}
         */
            function () {
                if (this.filterInputElement) {
                    this.filterInputElement.nativeElement.focus();
                }
            };
        InputDropdownComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-input-dropdown',
                        template: "<div class=\"ux-select-container\">\n    <button #button type=\"button\" class=\"form-control\"\n            [uxMenuTriggerFor]=\"menu\">\n        <ng-template #defaultDisplayContent>{{selected ? (selected | json) : '-'}}</ng-template>\n        <ng-container [ngTemplateOutlet]=\"displayContentRef || defaultDisplayContent\"></ng-container>\n    </button>\n    <div class=\"ux-select-icons\">\n        <ux-icon name=\"close\"\n                 uxFocusIndicator\n                 class=\"ux-select-icon ux-select-clear-icon\"\n                 *ngIf=\"allowNull && selected\"\n                 (click)=\"resetValue($event)\"\n                 (keydown.enter)=\"resetValue($event)\"\n                 tabindex=\"0\">\n        </ux-icon>\n        <ux-icon name=\"chevron-down\"\n                 class=\"ux-select-icon ux-select-chevron-icon\"\n                 (click)=\"menuTrigger.toggleMenu(); $event.stopPropagation()\">\n        </ux-icon>\n    </div>\n</div>\n\n<ux-menu #menu menuClass=\"select-menu\"\n         (opened)=\"_focusFilter()\">\n\n    <div [style.max-height]=\"_maxHeightString\"\n         [style.width.px]=\"button.offsetWidth\">\n\n        <div *ngIf=\"!hideFilter\"\n             class=\"filter-container\">\n\n            <input #filterInput\n                    type=\"text\"\n                    [placeholder]=\"placeholder\"\n                    class=\"form-control\"\n                    [(ngModel)]=\"filterText\"\n                    (input)=\"filterChange.emit(filterText)\"\n                    (click)=\"$event.stopPropagation()\"\n                    [attr.aria-label]=\"ariaLabel || placeholder\"/>\n\n            <button type=\"button\"\n                    class=\"btn btn-flat filter-button\"\n                    (click)=\"resetFilter($event)\"\n                    [tabindex]=\"filterText.length > 0 ? 0 : -1\">\n                <ux-icon [name]=\"filterText.length === 0 ? 'search' : 'close'\"></ux-icon>\n            </button>\n        </div>\n\n        <ng-content></ng-content>\n\n    </div>\n</ux-menu>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                multi: true,
                                useExisting: i0.forwardRef(function () { return InputDropdownComponent; })
                            }
                        ]
                    }] }
        ];
        InputDropdownComponent.propDecorators = {
            selected: [{ type: i0.Input }],
            hideFilter: [{ type: i0.Input }],
            maxHeight: [{ type: i0.Input }],
            allowNull: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            selectedChange: [{ type: i0.Output }],
            filterChange: [{ type: i0.Output }],
            displayContentRef: [{ type: i0.ContentChild, args: ['displayContent', { static: false },] }],
            menuTrigger: [{ type: i0.ViewChild, args: [MenuTriggerDirective, { static: false },] }],
            filterInputElement: [{ type: i0.ViewChild, args: ['filterInput', { static: false },] }]
        };
        return InputDropdownComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var InputDropdownModule = /** @class */ (function () {
        function InputDropdownModule() {
        }
        InputDropdownModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, IconModule, MenuModule, AccessibilityModule],
                        declarations: [
                            InputDropdownComponent
                        ],
                        exports: [
                            InputDropdownComponent
                        ]
                    },] }
        ];
        return InputDropdownModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SidePanelCloseDirective = /** @class */ (function () {
        function SidePanelCloseDirective(_service, _focusOrigin) {
            this._service = _service;
            this._focusOrigin = _focusOrigin;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        SidePanelCloseDirective.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine the correct origin for the trigger event
                this._focusOrigin.setOrigin(isKeyboardTrigger(event) ? 'keyboard' : 'mouse');
                // close the side panel menu
                this._service.close();
            };
        SidePanelCloseDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxSidePanelClose]'
                    },] }
        ];
        /** @nocollapse */
        SidePanelCloseDirective.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: FocusIndicatorOriginService }
            ];
        };
        SidePanelCloseDirective.propDecorators = {
            onClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return SidePanelCloseDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPORTS = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = /** @class */ (function () {
        function SidePanelModule() {
        }
        SidePanelModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            a11y.A11yModule,
                            FocusIfModule
                        ],
                        exports: EXPORTS,
                        declarations: EXPORTS
                    },] }
        ];
        return SidePanelModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SparkComponent = /** @class */ (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: /**
             * @return {?}
             */ function () {
                return this._theme;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._trackColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._barColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.values;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // ensure 'value' is an array at this point
                /** @type {?} */
                var values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                /** @type {?} */
                var total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the aria label for the spark chart
         */
        /**
         * Get the aria label for the spark chart
         * @return {?}
         */
        SparkComponent.prototype.getAriaLabel = /**
         * Get the aria label for the spark chart
         * @return {?}
         */
            function () {
                if (!Array.isArray(this.ariaLabel)) {
                    return this.ariaLabel || this.tooltip;
                }
            };
        /**
         * If this is a multi-value chart and we have multiple aria
         * labels then provide the appropriate label
         */
        /**
         * If this is a multi-value chart and we have multiple aria
         * labels then provide the appropriate label
         * @param {?} segment
         * @return {?}
         */
        SparkComponent.prototype.getSegmentAriaLabel = /**
         * If this is a multi-value chart and we have multiple aria
         * labels then provide the appropriate label
         * @param {?} segment
         * @return {?}
         */
            function (segment) {
                if (Array.isArray(this.ariaLabel)) {
                    return this.ariaLabel[segment];
                }
            };
        SparkComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-spark',
                        template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div role=\"progressbar\"\n            [attr.aria-label]=\"getAriaLabel()\"\n            [attr.aria-description]=\"ariaDescription\"\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n            [attr.aria-valuenow]=\"values.length === 1 ? values[0] : undefined\"\n            class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\"\n            [style.height.px]=\"barHeight\"\n            [style.backgroundColor]=\"trackColor\"\n            [uxTooltip]=\"tooltip\">\n\n            <div class=\"ux-spark-bar\"\n                *ngFor=\"let line of values; let idx = index\"\n                [attr.aria-label]=\"getSegmentAriaLabel(idx)\"\n                [style.width.%]=\"line\"\n                [style.backgroundColor]=\"barColor[idx]\">\n            </div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\" [attr.aria-label]=\"ariaLabel\" [attr.aria-description]=\"ariaDescription\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div role=\"progressbar\"\n        [attr.aria-label]=\"getAriaLabel()\"\n        [attr.aria-description]=\"ariaDescription\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n        [attr.aria-valuenow]=\"values.length === 1 ? values[0] : undefined\"\n        class=\"ux-spark ux-spark-theme-{{theme}}\"\n        [class.ux-spark-multi-value]=\"values.length > 1\"\n        [style.height.px]=\"barHeight\"\n        [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n\n        <div class=\"ux-spark-bar\"\n            *ngFor=\"let line of value; let idx = index\"\n            [attr.aria-label]=\"getSegmentAriaLabel(idx)\"\n            [style.width.%]=\"line\"\n            [style.backgroundColor]=\"barColor[idx]\">\n        </div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SparkComponent.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        SparkComponent.propDecorators = {
            barHeight: [{ type: i0.Input }],
            inlineLabel: [{ type: i0.Input }],
            topLeftLabel: [{ type: i0.Input }],
            topRightLabel: [{ type: i0.Input }],
            bottomLeftLabel: [{ type: i0.Input }],
            bottomRightLabel: [{ type: i0.Input }],
            tooltip: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            ariaDescription: [{ type: i0.Input, args: ['aria-description',] }],
            theme: [{ type: i0.Input }],
            trackColor: [{ type: i0.Input }],
            barColor: [{ type: i0.Input }],
            value: [{ type: i0.Input }]
        };
        return SparkComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SparkModule = /** @class */ (function () {
        function SparkModule() {
        }
        SparkModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule
                        ],
                        exports: [SparkComponent],
                        declarations: [SparkComponent]
                    },] }
        ];
        return SparkModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ColumnPickerComponent = /** @class */ (function () {
        function ColumnPickerComponent(_liveAnnouncer, _changeDetectorRef) {
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a list of all selected columns
             */
            this.selected = [];
            /**
             * Define a list of columns that must be selected
             */
            this.locked = [];
            /**
             * Define a list of columns that are not selected or locked
             */
            this.deselected = [];
            /**
             * Define a function to get the aria label of reorderable items
             */
            this.selectedAriaLabel = this.getSelectedAriaLabel;
            /**
             * Define a function that return a column move announcement
             */
            this.columnMovedAnnouncement = this.getColumnMovedAnnouncement;
            /**
             * Emits when the selected items change
             */
            this.selectedChange = new i0.EventEmitter();
            /**
             * Emits when the deselected items change
             */
            this.deselectedChange = new i0.EventEmitter();
            /**
             * Store the list of deselected columns that can be moved
             */
            this._deselectedSelection = [];
            /**
             * Store the list of selected columns that can be moved
             */
            this._selectedSelection = [];
            /**
             * Cache selection during reordering
             */
            this._selection = [];
        }
        /** Select the currently selected columns */
        /**
         * Select the currently selected columns
         * @param {?=} columns
         * @return {?}
         */
        ColumnPickerComponent.prototype.addColumns = /**
         * Select the currently selected columns
         * @param {?=} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                if (columns === void 0) {
                    columns = this._deselectedSelection;
                }
                // add each item to the selected columns list
                columns.forEach(function (column) { return _this.selected = __spread(_this.selected, [column]); });
                // remove each item from the deselected columns list
                this.deselected = this.deselected.filter(function (column) { return columns.indexOf(column) === -1; });
                // emit the selection changes
                this.selectedChange.emit(this.selected);
                this.deselectedChange.emit(this.deselected);
                // clear the current selection
                this._deselectedSelection = [];
            };
        /** Deselect the currently selected columns */
        /**
         * Deselect the currently selected columns
         * @param {?=} columns
         * @return {?}
         */
        ColumnPickerComponent.prototype.removeColumns = /**
         * Deselect the currently selected columns
         * @param {?=} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                if (columns === void 0) {
                    columns = this._selectedSelection;
                }
                // add each item to the deselected columns list
                columns.forEach(function (column) { return _this.deselected = __spread(_this.deselected, [column]); });
                // remove each item from the selected columns list
                this.selected = this.selected.filter(function (column) { return columns.indexOf(column) === -1; });
                // emit the selection changes
                this.selectedChange.emit(this.selected);
                this.deselectedChange.emit(this.deselected);
                // clear the current selection
                this._selectedSelection = [];
            };
        /** Select all deselected columns */
        /**
         * Select all deselected columns
         * @return {?}
         */
        ColumnPickerComponent.prototype.addAllColumns = /**
         * Select all deselected columns
         * @return {?}
         */
            function () {
                this.addColumns(this.deselected);
            };
        /** Deselect all selected columns */
        /**
         * Deselect all selected columns
         * @return {?}
         */
        ColumnPickerComponent.prototype.removeAllColumns = /**
         * Deselect all selected columns
         * @return {?}
         */
            function () {
                this.removeColumns(this.selected);
            };
        /** Ensure we don't select while dragging */
        /**
         * Ensure we don't select while dragging
         * @return {?}
         */
        ColumnPickerComponent.prototype.storeSelection = /**
         * Ensure we don't select while dragging
         * @return {?}
         */
            function () {
                this._selection = __spread(this._selectedSelection);
            };
        /** Restore the selection once dragging ends */
        /**
         * Restore the selection once dragging ends
         * @return {?}
         */
        ColumnPickerComponent.prototype.restoreSelection = /**
         * Restore the selection once dragging ends
         * @return {?}
         */
            function () {
                this._selectedSelection = this._selection;
            };
        /** Update when reordering has occured */
        /**
         * Update when reordering has occured
         * @return {?}
         */
        ColumnPickerComponent.prototype.onReorder = /**
         * Update when reordering has occured
         * @return {?}
         */
            function () {
                this.selectedChange.emit(this.selected);
            };
        /** Get an aria label for reorderable items */
        /**
         * Get an aria label for reorderable items
         * @param {?} column
         * @return {?}
         */
        ColumnPickerComponent.prototype.getSelectedAriaLabel = /**
         * Get an aria label for reorderable items
         * @param {?} column
         * @return {?}
         */
            function (column) {
                return column + ". Press Alt up and alt down to reorder.";
            };
        /** Get the announcement to read when a selected column is moved */
        /**
         * Get the announcement to read when a selected column is moved
         * @param {?} column
         * @param {?} delta
         * @return {?}
         */
        ColumnPickerComponent.prototype.getColumnMovedAnnouncement = /**
         * Get the announcement to read when a selected column is moved
         * @param {?} column
         * @param {?} delta
         * @return {?}
         */
            function (column, delta) {
                return column + " column moved " + (delta > 0 ? 'down' : 'up');
            };
        /** Perform a reorder with the keyboard */
        /**
         * Perform a reorder with the keyboard
         * @param {?} column
         * @param {?} delta
         * @return {?}
         */
        ColumnPickerComponent.prototype.move = /**
         * Perform a reorder with the keyboard
         * @param {?} column
         * @param {?} delta
         * @return {?}
         */
            function (column, delta) {
                var _this = this;
                // perform the move
                /** @type {?} */
                var index = this.selected.indexOf(column);
                this.swap(index, index + delta);
                // Announce the move if the order has changed
                if (this.selected.indexOf(column) !== index) {
                    this._liveAnnouncer.announce("Column moved " + (delta > 0 ? 'down' : 'up'));
                }
                // emit the changes
                this.selectedChange.emit(this.selected);
                // perform change detection
                this._changeDetectorRef.detectChanges();
                // after the UI has updated focus the element again (ngFor creates new DOM elements)
                setTimeout(function () {
                    /** @type {?} */
                    var columnIndex = _this.selected.indexOf(column);
                    /** @type {?} */
                    var target = _this.selectedElements.toArray()[columnIndex];
                    if (target) {
                        // focus the element
                        target.nativeElement.focus();
                    }
                });
            };
        /** Provide a trackBy function for the reorderable options */
        /**
         * Provide a trackBy function for the reorderable options
         * @param {?} index
         * @param {?} column
         * @return {?}
         */
        ColumnPickerComponent.prototype.selectedTrackBy = /**
         * Provide a trackBy function for the reorderable options
         * @param {?} index
         * @param {?} column
         * @return {?}
         */
            function (index, column) {
                return index + column;
            };
        /** Swap two elements in the selected columns array */
        /**
         * Swap two elements in the selected columns array
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ColumnPickerComponent.prototype.swap = /**
         * Swap two elements in the selected columns array
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                var _a;
                // perform boundary checks
                if (target < 0 || target > this.selected.length - 1) {
                    return;
                }
                // create a copy of the array to manipulate
                /** @type {?} */
                var selected = __spread(this.selected);
                // swap the array elements
                _a = __read([selected[source], selected[target]], 2), selected[target] = _a[0], selected[source] = _a[1];
                // update the original array
                this.selected = __spread(selected);
            };
        /** Update the order of the items when reordering has changed */
        /**
         * Update the order of the items when reordering has changed
         * @param {?} model
         * @return {?}
         */
        ColumnPickerComponent.prototype.onReorderChange = /**
         * Update the order of the items when reordering has changed
         * @param {?} model
         * @return {?}
         */
            function (model) {
                this.selected = __spread(model);
            };
        /** Get the action context, ensuring that functions have a pre-bound context */
        /**
         * Get the action context, ensuring that functions have a pre-bound context
         * @return {?}
         */
        ColumnPickerComponent.prototype._getActionContext = /**
         * Get the action context, ensuring that functions have a pre-bound context
         * @return {?}
         */
            function () {
                return {
                    addSelection: this._deselectedSelection,
                    removeSelection: this._selectedSelection,
                    addColumns: this.addColumns.bind(this),
                    removeColumns: this.removeColumns.bind(this),
                    addAllColumns: this.addAllColumns.bind(this),
                    removeAllColumns: this.removeAllColumns.bind(this)
                };
            };
        ColumnPickerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-column-picker',
                        template: "<div class=\"column-picker-column\">\n\n    <div class=\"column-picker-stats\">\n\n        <ng-container *ngIf=\"!deselectedTitleTemplate\">\n            {{ _deselectedSelection.length }} of {{ deselected.length }} selected\n        </ng-container>\n\n        <ng-container\n            *ngIf=\"deselectedTitleTemplate\"\n            [ngTemplateOutlet]=\"deselectedTitleTemplate\">\n        </ng-container>\n    </div>\n\n    <div class=\"column-picker-list\" [(uxSelection)]=\"_deselectedSelection\">\n\n        <div *ngFor=\"let column of deselected\"\n             class=\"column-picker-list-item\"\n             [uxSelectionItem]=\"column\">\n\n            <ng-container *ngIf=\"!deselectedTemplate\">{{ column }}</ng-container>\n\n            <ng-container\n                *ngIf=\"deselectedTemplate\"\n                [ngTemplateOutlet]=\"deselectedTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: column }\">\n            </ng-container>\n        </div>\n    </div>\n</div>\n\n<div class=\"column-picker-actions-column\">\n    <!-- Show the default action buttons -->\n    <ng-container *ngIf=\"!actionsTemplate\">\n        <button class=\"btn button-primary btn-block\" [disabled]=\"_deselectedSelection.length === 0\" (click)=\"addColumns()\">\n            <ux-icon name=\"chevron-right\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-primary btn-block m-b-md\" [disabled]=\"_selectedSelection.length === 0\" (click)=\"removeColumns()\">\n            <ux-icon name=\"chevron-left\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-secondary btn-block\" [disabled]=\"deselected.length === 0\" (click)=\"addAllColumns()\">\n            <ux-icon name=\"chevron-right-double\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-secondary btn-block\" [disabled]=\"selected.length === 0\" (click)=\"removeAllColumns()\">\n            <ux-icon name=\"chevron-left-double\"></ux-icon>\n        </button>\n    </ng-container>\n\n    <!-- Allow custom actions template -->\n    <ng-container\n        *ngIf=\"actionsTemplate\"\n        [ngTemplateOutlet]=\"actionsTemplate\"\n        [ngTemplateOutletContext]=\"_getActionContext()\">\n    </ng-container>\n\n</div>\n\n<div class=\"column-picker-column\">\n    <div class=\"column-picker-stats\">\n\n        <ng-container *ngIf=\"!selectedTitleTemplate\">\n            {{ selected.length + locked.length }} columns added\n        </ng-container>\n\n        <ng-container\n            *ngIf=\"selectedTitleTemplate\"\n            [ngTemplateOutlet]=\"selectedTitleTemplate\">\n        </ng-container>\n    </div>\n\n    <div class=\"column-picker-list\">\n\n        <div *ngFor=\"let column of locked\"\n             class=\"column-picker-list-item column-picker-list-item-locked\">\n\n             <ng-container *ngIf=\"!lockedTemplate\">\n                {{ column }} <ux-icon name=\"lock\"></ux-icon>\n            </ng-container>\n\n             <ng-container\n                *ngIf=\"lockedTemplate\"\n                [ngTemplateOutlet]=\"lockedTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: column }\">\n            </ng-container>\n        </div>\n\n        <div [(uxSelection)]=\"_selectedSelection\" uxReorderable [reorderableModel]=\"selected\" (reorderableModelChange)=\"onReorderChange($event)\" (reorderStart)=\"storeSelection()\"\n            (reorderEnd)=\"restoreSelection()\" (reorderEnd)=\"onReorder()\">\n\n            <div *ngFor=\"let column of selected; trackBy: selectedTrackBy; let index = index\"\n                 #selectedColumn\n                 uxFocusIndicator\n                 [programmaticFocusIndicator]=\"true\"\n                 class=\"column-picker-list-item column-picker-list-item-selected\"\n                 [uxSelectionItem]=\"column\"\n                 [uxReorderableModel]=\"column\"\n                 [attr.aria-label]=\"getSelectedAriaLabel(column)\"\n                 (keydown.alt.arrowup)=\"move(column, -1)\"\n                 (keydown.alt.arrowdown)=\"move(column, 1)\">\n\n                 <ng-container *ngIf=\"!selectedTemplate\">\n                    <ux-icon uxReorderableHandle name=\"drag\" class=\"drag-handle-icon\"></ux-icon>\n                    {{ column }}\n                 </ng-container>\n\n                 <ng-container\n                    *ngIf=\"selectedTemplate\"\n                    [ngTemplateOutlet]=\"selectedTemplate\"\n                    [ngTemplateOutletContext]=\"{ $implicit: column }\">\n                </ng-container>\n            </div>\n        </div>\n\n    </div>\n</div>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        ColumnPickerComponent.ctorParameters = function () {
            return [
                { type: a11y.LiveAnnouncer },
                { type: i0.ChangeDetectorRef }
            ];
        };
        ColumnPickerComponent.propDecorators = {
            selected: [{ type: i0.Input }],
            locked: [{ type: i0.Input }],
            deselected: [{ type: i0.Input }],
            selectedTitleTemplate: [{ type: i0.Input }],
            deselectedTitleTemplate: [{ type: i0.Input }],
            deselectedTemplate: [{ type: i0.Input }],
            selectedTemplate: [{ type: i0.Input }],
            lockedTemplate: [{ type: i0.Input }],
            actionsTemplate: [{ type: i0.Input }],
            selectedAriaLabel: [{ type: i0.Input }],
            columnMovedAnnouncement: [{ type: i0.Input }],
            selectedChange: [{ type: i0.Output }],
            deselectedChange: [{ type: i0.Output }],
            selectedElements: [{ type: i0.ViewChildren, args: ['selectedColumn',] }]
        };
        return ColumnPickerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ BaseResizableTableService = /** @class */ (function () {
        function BaseResizableTableService() {
            /**
             * Emit an event whenever a column is resized
             */
            this.onResize$ = new rxjs.Subject();
            /**
             * Store the current width of the table
             */
            this.tableWidth = 0;
            /**
             * Determine if we are currently resizing
             */
            this.isResizing$ = new rxjs.BehaviorSubject(false);
            /**
             * Indicate when the columns are ready
             */
            this.isInitialised$ = new rxjs.BehaviorSubject(false);
            /**
             * Store the percentage widths of each column
             */
            this.columns = [];
        }
        /** Cleanup when service is disposed */
        /**
         * Cleanup when service is disposed
         * @return {?}
         */
        BaseResizableTableService.prototype.ngOnDestroy = /**
         * Cleanup when service is disposed
         * @return {?}
         */
            function () {
                this.onResize$.complete();
            };
        /** Update the resizing state */
        /**
         * Update the resizing state
         * @param {?} isResizing
         * @return {?}
         */
        BaseResizableTableService.prototype.setResizing = /**
         * Update the resizing state
         * @param {?} isResizing
         * @return {?}
         */
            function (isResizing) {
                this.isResizing$.next(isResizing);
            };
        /** Get the width of a column in a specific unit */
        /**
         * Get the width of a column in a specific unit
         * @param {?} index
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
        BaseResizableTableService.prototype.getColumnWidth = /**
         * Get the width of a column in a specific unit
         * @param {?} index
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
            function (index, unit, columns) {
                if (columns === void 0) {
                    columns = this.columns;
                }
                switch (unit) {
                    case ColumnUnit.Percentage:
                        return columns[index];
                    case ColumnUnit.Pixel:
                        return (this.tableWidth / 100) * columns[index];
                }
            };
        return BaseResizableTableService;
    }());
    /** @enum {number} */
    var ColumnUnit = {
        Pixel: 0,
        Percentage: 1,
    };
    ColumnUnit[ColumnUnit.Pixel] = 'Pixel';
    ColumnUnit[ColumnUnit.Percentage] = 'Percentage';
    /** @enum {number} */
    var ResizableTableType = {
        Standard: 0,
        Expand: 1,
    };
    ResizableTableType[ResizableTableType.Standard] = 'Standard';
    ResizableTableType[ResizableTableType.Expand] = 'Expand';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableTableService = /** @class */ (function (_super) {
        __extends(ResizableTableService, _super);
        function ResizableTableService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define the type of resizing we should use
             */
            _this.type = ResizableTableType.Standard;
            return _this;
        }
        /** Store the size of each column */
        /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
        ResizableTableService.prototype.setColumns = /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // store the current columns
                this._columns = columns;
                // store the sizes
                this.columns = columns.map(function (column) { return (column.getNaturalWidth() / _this.tableWidth) * 100; });
                // check if there is any overflow
                this.columns = this.ensureNoOverflow(this.columns);
                // ensure all the columns fit
                this._columns.forEach(function (column, idx) {
                    if (!column.disabled) {
                        _this.resizeColumn(idx, 0, false);
                    }
                });
                // indicate we are now initialised
                if (this.isInitialised$.value === false) {
                    this.isInitialised$.next(true);
                }
            };
        /** Set all resizable columns to the same width */
        /**
         * Set all resizable columns to the same width
         * @return {?}
         */
        ResizableTableService.prototype.setUniformWidths = /**
         * Set all resizable columns to the same width
         * @return {?}
         */
            function () {
                var _this = this;
                // set any disabled columns to their specified width
                this.columns = this._columns.map(function (column) { return column.disabled ? (column.getNaturalWidth() / _this.tableWidth) * 100 : 0; });
                // check to see if we've reached 100% of the table width
                /** @type {?} */
                var totalWidth = this.columns.reduce(function (partial, columnWidth) { return partial + columnWidth; });
                if (totalWidth > 100) {
                    // remove overflow
                    this.columns = this.ensureNoOverflow(this.columns);
                }
                else {
                    // get the list of resizable columns
                    /** @type {?} */
                    var resizableColumns = this._columns.toArray().filter(function (column) { return !column.disabled; });
                    // work out what we need to add to each column to make up the full width
                    /** @type {?} */
                    var newWidth_1 = (100 - totalWidth) / resizableColumns.length;
                    // set the non-disabled columns to the new width
                    this.columns = this._columns.map(function (column, idx) { return column.disabled ? _this.columns[idx] : newWidth_1; });
                }
                // do the resizing
                this._columns.forEach(function (column, idx) {
                    if (!column.disabled) {
                        _this.resizeColumn(idx, 0, false);
                    }
                });
            };
        /**
         * @param {?} columns
         * @return {?}
         */
        ResizableTableService.prototype.ensureNoOverflow = /**
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // get the total width
                /** @type {?} */
                var total = columns.reduce(function (width, column) { return width + column; });
                // if we have no overflow then we don't need to do anything
                if (total <= 100) {
                    return columns;
                }
                // if there is overflow identify which columns can be resized
                /** @type {?} */
                var variableColumns = this._columns.filter(function (column) { return !column.disabled && _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns) > column.minWidth; });
                // if there are no columns that can be resized then stop here
                if (variableColumns.length === 0) {
                    return columns;
                }
                // determine the total width of the variable columns
                /** @type {?} */
                var totalWidth = this._columns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns); }, 0);
                // determine to the width of all the variable columns
                /** @type {?} */
                var variableColumnsWidth = variableColumns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns); }, 0);
                // determine how much the columns are currently too large (ignoring fixed columns)
                /** @type {?} */
                var targetWidth = this.tableWidth - (totalWidth - variableColumnsWidth);
                // determine how much we need to reduce a column by
                /** @type {?} */
                var difference = variableColumnsWidth - targetWidth;
                // find the column with the largest size
                /** @type {?} */
                var target = variableColumns.reduce(function (widest, column) {
                    /** @type {?} */
                    var columnWidth = _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns);
                    /** @type {?} */
                    var widestWidth = _this.getColumnWidth(widest.getCellIndex(), ColumnUnit$1.Pixel, columns);
                    return columnWidth > widestWidth ? column : widest;
                });
                // perform the resize
                columns = this.setColumnWidth(target.getCellIndex(), this.getColumnWidth(target.getCellIndex(), ColumnUnit$1.Pixel, columns) - difference, ColumnUnit$1.Pixel, columns);
                // check if we are still over the limit (allow some variance for javascript double precision)
                if (columns.reduce(function (width, column) { return width + column; }) > 100.01) {
                    return this.ensureNoOverflow(columns);
                }
                return columns;
            };
        /** Allow setting the column size in any unit */
        /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
        ResizableTableService.prototype.setColumnWidth = /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
            function (index, value, unit, columns) {
                if (columns === void 0) {
                    columns = this.columns;
                }
                // create a new array so we keep the instance array immutable
                /** @type {?} */
                var sizes = __spread(columns);
                switch (unit) {
                    case ColumnUnit$1.Percentage:
                        sizes[index] = value;
                        break;
                    case ColumnUnit$1.Pixel:
                        sizes[index] = (value / this.tableWidth) * 100;
                        break;
                }
                // update the instance variable
                return sizes;
            };
        /** Resize a column by a specific pixel amount */
        /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @param {?=} isDragging
         * @return {?}
         */
        ResizableTableService.prototype.resizeColumn = /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @param {?=} isDragging
         * @return {?}
         */
            function (index, delta, isDragging) {
                if (isDragging === void 0) {
                    isDragging = true;
                }
                // get the sibling column that will also be resized
                /** @type {?} */
                var sibling = this.getSiblingColumn(index);
                // if there is no sibling that can be resized then stop here
                if (!sibling) {
                    return;
                }
                // create a new array for the sizes
                /** @type {?} */
                var columns = ( /** @type {?} */(__spread(this.columns)));
                // resize the column to the desired size
                columns = ( /** @type {?} */(this.setColumnWidth(index, Math.round(this.getColumnWidth(index, ColumnUnit$1.Pixel) + delta), ColumnUnit$1.Pixel, columns)));
                columns = ( /** @type {?} */(this.setColumnWidth(sibling, Math.round(this.getColumnWidth(sibling, ColumnUnit$1.Pixel) - delta), ColumnUnit$1.Pixel, columns)));
                // if the move is not possible then stop here
                if (!this.isWidthValid(index, this.getColumnWidth(index, ColumnUnit$1.Pixel, columns)) || !this.isWidthValid(sibling, this.getColumnWidth(sibling, ColumnUnit$1.Pixel, columns))) {
                    return;
                }
                // check that we add up to exactly 100%
                /** @type {?} */
                var total = columns.reduce(function (count, column) { return column + count; }, 0);
                // if the columns to not add to 100 ensure we make them
                if (total !== 100) {
                    // get the column with a variable width
                    /** @type {?} */
                    var target = this.getVariableColumn(100 - total);
                    if (target && !isDragging) {
                        columns[this._columns.toArray().indexOf(target)] += (100 - total);
                    }
                    else {
                        columns[index] += (100 - total);
                    }
                }
                // store the new sizes
                this.columns = columns;
                // emit the resize event for each column
                this.onResize$.next();
            };
        /**
         * @param {?} delta
         * @return {?}
         */
        ResizableTableService.prototype.getVariableColumn = /**
         * @param {?} delta
         * @return {?}
         */
            function (delta) {
                var _this = this;
                // get all variable width columns that are not disabled
                /** @type {?} */
                var variableColumns = this._columns.filter(function (column) { return !column.isFixedWidth && !column.disabled; });
                // find one that is greater than its min width by enough
                return variableColumns.reverse().find(function (column) { return _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel) >= column.minWidth + delta; });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getColumn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._columns ? this._columns.toArray()[index] : null;
            };
        /**
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getColumnDisabled = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.getColumn(index) ? this.getColumn(index).disabled : false;
            };
        /** Determine whether a column is above or below its minimum width */
        /**
         * Determine whether a column is above or below its minimum width
         * @param {?} index
         * @param {?} width
         * @return {?}
         */
        ResizableTableService.prototype.isWidthValid = /**
         * Determine whether a column is above or below its minimum width
         * @param {?} index
         * @param {?} width
         * @return {?}
         */
            function (index, width) {
                // get the column at a given position
                /** @type {?} */
                var column = this.getColumnInstance(index);
                // determine if the specified width is greater than the min width
                return column && width >= column.minWidth;
            };
        /** Get the next column in the sequence of columns */
        /**
         * Get the next column in the sequence of columns
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getSiblingColumn = /**
         * Get the next column in the sequence of columns
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // find the first sibling that is not disabled
                for (var idx = index + 1; idx < this.columns.length; idx++) {
                    /** @type {?} */
                    var sibling = this.getColumnInstance(idx);
                    if (!sibling || !sibling.disabled) {
                        return idx;
                    }
                }
                return null;
            };
        /** Get the column class from our query list */
        /**
         * Get the column class from our query list
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getColumnInstance = /**
         * Get the column class from our query list
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._columns ? this._columns.toArray()[index] : null;
            };
        ResizableTableService.decorators = [
            { type: i0.Injectable }
        ];
        return ResizableTableService;
    }(BaseResizableTableService));
    /** @enum {number} */
    var ColumnUnit$1 = {
        Pixel: 0,
        Percentage: 1,
    };
    ColumnUnit$1[ColumnUnit$1.Pixel] = 'Pixel';
    ColumnUnit$1[ColumnUnit$1.Percentage] = 'Percentage';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var RESIZABLE_TABLE_SERVICE_TOKEN = new i0.InjectionToken('RESIZABLE_TABLE_SERVICE_TOKEN');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableTableCellDirective = /** @class */ (function () {
        function ResizableTableCellDirective(_elementRef, _renderer, _table) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._table = _table;
            /**
             * Unsubscribe from all subscriptions on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        ResizableTableCellDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._minWidth = parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
                // update the sizes when columns are resized
                rxjs.combineLatest([this._table.onResize$, this._table.isResizing$]).pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.setColumnWidth();
                    _this.setColumnFlex();
                });
            };
        /**
         * @return {?}
         */
        ResizableTableCellDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Get the column index this cell is part of */
        /**
         * Get the column index this cell is part of
         * @return {?}
         */
        ResizableTableCellDirective.prototype.getCellIndex = /**
         * Get the column index this cell is part of
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this._elementRef.nativeElement))).cellIndex;
            };
        /** Set the width of the column */
        /**
         * Set the width of the column
         * @return {?}
         */
        ResizableTableCellDirective.prototype.setColumnWidth = /**
         * Set the width of the column
         * @return {?}
         */
            function () {
                /** @type {?} */
                var width = this._table.isResizing$.value || this._table.getColumnDisabled(this.getCellIndex()) ?
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel) + "px" :
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%";
                if (this._table.type === ResizableTableType.Expand) {
                    /** @type {?} */
                    var minWidth = Math.max(this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel), this._minWidth);
                    this._renderer.setStyle(this._elementRef.nativeElement, 'min-width', minWidth + "px");
                }
                this._renderer.setStyle(this._elementRef.nativeElement, 'width', width);
            };
        /** Set the flex value of the column */
        /**
         * Set the flex value of the column
         * @return {?}
         */
        ResizableTableCellDirective.prototype.setColumnFlex = /**
         * Set the flex value of the column
         * @return {?}
         */
            function () {
                // if we are resizing then always return 'none' to allow free movement
                if (this._table.isResizing$.value || this._table.getColumnDisabled(this.getCellIndex())) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'flex', 'none');
                    return;
                }
                /** @type {?} */
                var flex = this._table.isInitialised$.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%" : '';
                this._renderer.setStyle(this._elementRef.nativeElement, 'flex', flex);
            };
        ResizableTableCellDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxResizableTableCell]'
                    },] }
        ];
        /** @nocollapse */
        ResizableTableCellDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: BaseResizableTableService, decorators: [{ type: i0.Inject, args: [RESIZABLE_TABLE_SERVICE_TOKEN,] }] }
            ];
        };
        return ResizableTableCellDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableTableColumnComponent = /** @class */ (function () {
        function ResizableTableColumnComponent(_elementRef, _table, _renderer) {
            var _this = this;
            this._elementRef = _elementRef;
            this._table = _table;
            this._renderer = _renderer;
            /**
             * Disabled the column resizing
             */
            this.disabled = false;
            /**
             * Emit the current column width
             */
            this.widthChange = new i0.EventEmitter();
            /**
             * Determine if this column is a variable width column
             */
            this.isFixedWidth = false;
            /**
             * Emit when all observables should be unsubscribed
             */
            this._onDestroy = new rxjs.Subject();
            // initially emit the size when we have initialised
            _table.isInitialised$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (isInitialised) { return isInitialised; }))
                .subscribe(function () {
                // get the current min-width
                _this._minWidth = parseFloat(getComputedStyle(_this._elementRef.nativeElement).minWidth);
                _this.widthChange.emit(_table.getColumnWidth(_this.getCellIndex(), ColumnUnit$1.Pixel));
            });
            // ensure the correct width gets emitted on column size change
            _table.onResize$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.setColumnWidth();
                _this.setColumnFlex();
                // get the current table width
                /** @type {?} */
                var width = _table.getColumnWidth(_this.getCellIndex(), ColumnUnit$1.Pixel);
                // check if the width actually changed - otherwise don't emit
                if (_this._width === undefined || Math.max(width, _this._width) - Math.min(width, _this._width) >= 1) {
                    _this.widthChange.emit(width);
                }
            });
        }
        Object.defineProperty(ResizableTableColumnComponent.prototype, "width", {
            get: /**
             * @return {?}
             */ function () {
                return this._width;
            },
            /** Define the width of a column */
            set: /**
             * Define the width of a column
             * @param {?} width
             * @return {?}
             */ function (width) {
                // there may be cases where columns are created with an `*ngFor` and a width
                // may be specified on *some* columns and not others. This this setter will
                // still be called whenever the value is empty and this will mark this column
                // as having a fixed width, even though it doesn't. So we should only proceed
                // whenever there is an actual numeric value passed in.
                if (width === null || width === undefined) {
                    return;
                }
                // ensure width is a valid number
                this._width = coercion.coerceNumberProperty(width);
                // note that this column has a fixed width
                this.isFixedWidth = true;
                // if we have not initialised then set the element width
                if (!this._table.isInitialised$.value) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'width', this._width + "px");
                }
                else {
                    // if it is initialised then resize the column
                    /** @type {?} */
                    var currentWidth = this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel);
                    // resize the column by the difference in size
                    this._table.resizeColumn(this.getCellIndex(), this._width - currentWidth, false);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableColumnComponent.prototype, "minWidth", {
            /** Get the minimum width allowed by the column */
            get: /**
             * Get the minimum width allowed by the column
             * @return {?}
             */ function () {
                // determine the minimum width of the column based on its computed CSS value
                /** @type {?} */
                var computed = parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
                // if it is disabled use its current width - otherwise use its CSS min width if it is valid
                return this.disabled ? this._elementRef.nativeElement.offsetWidth : isNaN(computed) ? 0 : computed;
            },
            enumerable: true,
            configurable: true
        });
        /** Cleanup when component is destroyed */
        /**
         * Cleanup when component is destroyed
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.ngOnDestroy = /**
         * Cleanup when component is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Get the natural pixel width of the column */
        /**
         * Get the natural pixel width of the column
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.getNaturalWidth = /**
         * Get the natural pixel width of the column
         * @return {?}
         */
            function () {
                return this._width || this._elementRef.nativeElement.offsetWidth;
            };
        /** When the dragging starts */
        /**
         * When the dragging starts
         * @param {?} event
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragStart = /**
         * When the dragging starts
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine the mouse position within the handle
                this._offset = event.clientX - (( /** @type {?} */(event.target))).getBoundingClientRect().left;
            };
        /** When the mouse is moved */
        /**
         * When the mouse is moved
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragMove = /**
         * When the mouse is moved
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
            function (event, handle) {
                // get the current mouse position
                /** @type {?} */
                var mouseX = event.pageX - pageXOffset;
                // position of the drag handle
                var left = handle.getBoundingClientRect().left;
                // determine how much the mouse has moved since the last update
                /** @type {?} */
                var delta = mouseX - (left + this._offset);
                // perform resizing
                this._table.resizeColumn(this.getCellIndex(), delta);
                // set the resizing state
                this._table.setResizing(true);
            };
        /** When the dragging ends */
        /**
         * When the dragging ends
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onDragEnd = /**
         * When the dragging ends
         * @return {?}
         */
            function () {
                this._table.setResizing(false);
            };
        /** Shrink the column when the left arrow key is pressed */
        /**
         * Shrink the column when the left arrow key is pressed
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onMoveLeft = /**
         * Shrink the column when the left arrow key is pressed
         * @return {?}
         */
            function () {
                this._table.resizeColumn(this.getCellIndex(), -10);
            };
        /** Grow the column when the right arrow key is pressed */
        /**
         * Grow the column when the right arrow key is pressed
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.onMoveRight = /**
         * Grow the column when the right arrow key is pressed
         * @return {?}
         */
            function () {
                this._table.resizeColumn(this.getCellIndex(), 10);
            };
        /** Get the column index this cell is part of */
        /**
         * Get the column index this cell is part of
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.getCellIndex = /**
         * Get the column index this cell is part of
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this._elementRef.nativeElement))).cellIndex;
            };
        /** The percentage width of the column */
        /**
         * The percentage width of the column
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.setColumnWidth = /**
         * The percentage width of the column
         * @return {?}
         */
            function () {
                if (this.disabled && this._width !== undefined) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'width', this._width + "px");
                    this._renderer.setStyle(this._elementRef.nativeElement, 'max-width', this._width + "px");
                    return;
                }
                if (!this._table.isInitialised$.value) {
                    return;
                }
                /** @type {?} */
                var width = this._table.isResizing$.value ?
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel) + "px" :
                    this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%";
                if (this._table.type === ResizableTableType.Expand) {
                    /** @type {?} */
                    var minWidth = Math.max(this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel), this._minWidth);
                    this._renderer.setStyle(this._elementRef.nativeElement, 'min-width', minWidth + "px");
                }
                this._renderer.setStyle(this._elementRef.nativeElement, 'width', width);
                this._renderer.setStyle(this._elementRef.nativeElement, 'max-width', null);
            };
        /** The flex width of the column */
        /**
         * The flex width of the column
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.setColumnFlex = /**
         * The flex width of the column
         * @return {?}
         */
            function () {
                // if we are resizing then always return 'none' to allow free movement
                if (this._table.isResizing$.value || this.disabled) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'flex', 'none');
                }
                /** @type {?} */
                var flex = this._table.isInitialised$.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%" : '';
                this._renderer.setStyle(this._elementRef.nativeElement, 'flex', flex);
            };
        ResizableTableColumnComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: '[uxResizableTableColumn]',
                        template: "<ng-content></ng-content>\n\n<div #handle\n     uxDrag\n     uxFocusIndicator\n     tabindex=\"0\"\n     aria-label=\"Column resize handle. Use arrow keys to change the column width.\"\n     class=\"ux-resizable-table-column-handle\"\n     *ngIf=\"!disabled\"\n     (onDragStart)=\"onDragStart($event)\"\n     (onDrag)=\"onDragMove($event, handle)\"\n     (onDragEnd)=\"onDragEnd()\"\n     (keydown.ArrowLeft)=\"onMoveLeft()\"\n     (keydown.ArrowRight)=\"onMoveRight()\">\n\n     <div class=\"ux-resizable-table-column-handle-icon\"></div>\n</div>\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        host: {
                            class: 'ux-resizable-table-column'
                        }
                    }] }
        ];
        /** @nocollapse */
        ResizableTableColumnComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: BaseResizableTableService, decorators: [{ type: i0.Inject, args: [RESIZABLE_TABLE_SERVICE_TOKEN,] }] },
                { type: i0.Renderer2 }
            ];
        };
        ResizableTableColumnComponent.propDecorators = {
            disabled: [{ type: i0.Input }],
            width: [{ type: i0.Input }],
            widthChange: [{ type: i0.Output }]
        };
        return ResizableTableColumnComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var BaseResizableTableDirective = /** @class */ (function () {
        function BaseResizableTableDirective(_elementRef, _table, _renderer, resize) {
            var _this = this;
            this._elementRef = _elementRef;
            this._table = _table;
            this._renderer = _renderer;
            /**
             * Unsubscribe from the observables
             */
            this._onDestroy = new rxjs.Subject();
            /**
             * Store the initialised state of the table
             */
            this._initialised = false;
            // watch for the table being resized
            resize.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                // store the latest table size
                _table.tableWidth = _this.getScrollWidth();
                // run the initial logic if the table is fully visible
                _this.onTableReady();
            });
        }
        /** Once we have the columns make them resizable and watch for changes to columns */
        /**
         * Once we have the columns make them resizable and watch for changes to columns
         * @return {?}
         */
        BaseResizableTableDirective.prototype.ngAfterViewInit = /**
         * Once we have the columns make them resizable and watch for changes to columns
         * @return {?}
         */
            function () {
                this.onTableReady();
            };
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        BaseResizableTableDirective.prototype.ngOnDestroy = /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set all resizable columns to the same width */
        /**
         * Set all resizable columns to the same width
         * @return {?}
         */
        BaseResizableTableDirective.prototype.setUniformWidths = /**
         * Set all resizable columns to the same width
         * @return {?}
         */
            function () {
                this._table.setUniformWidths();
            };
        /** Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable) */
        /**
         * Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable)
         * @return {?}
         */
        BaseResizableTableDirective.prototype.getScrollWidth = /**
         * Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable)
         * @return {?}
         */
            function () {
                return Array.from((( /** @type {?} */(this._elementRef.nativeElement))).tBodies)
                    .reduce(function (width, tbody) { return Math.min(width, tbody.scrollWidth); }, (( /** @type {?} */(this._elementRef.nativeElement))).offsetWidth);
            };
        /** @nocollapse */
        BaseResizableTableDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: BaseResizableTableService, decorators: [{ type: i0.Inject, args: [RESIZABLE_TABLE_SERVICE_TOKEN,] }] },
                { type: i0.Renderer2 },
                { type: ResizeService }
            ];
        };
        return BaseResizableTableDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableExpandingTableService = /** @class */ (function (_super) {
        __extends(ResizableExpandingTableService, _super);
        function ResizableExpandingTableService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define the type of resizing we should use
             */
            _this.type = ResizableTableType.Expand;
            return _this;
        }
        /** Store the size of each column */
        /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
        ResizableExpandingTableService.prototype.setColumns = /**
         * Store the size of each column
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // store the current columns
                this._columns = columns;
                // store the sizes
                this.columns = columns.map(function (column) { return (column.getNaturalWidth() / _this.tableWidth) * 100; });
                // ensure all the columns fit
                this._columns.forEach(function (column, idx) {
                    if (!column.disabled) {
                        _this.columns = _this.setColumnWidth(idx, _this.columns[idx], ColumnUnit$2.Percentage, _this.columns);
                    }
                });
                // indicate we are now initialised
                if (this.isInitialised$.value === false) {
                    this.isInitialised$.next(true);
                }
            };
        /** Set all resizable columns to the same width */
        /**
         * Set all resizable columns to the same width
         * @return {?}
         */
        ResizableExpandingTableService.prototype.setUniformWidths = /**
         * Set all resizable columns to the same width
         * @return {?}
         */
            function () {
                var _this = this;
                // set any disabled columns to their specified width
                this.columns = this._columns.map(function (column) { return column.disabled ? (column.getNaturalWidth() / _this.tableWidth) * 100 : 0; });
                // check to see if we've reached 100% of the table width
                /** @type {?} */
                var totalWidth = this.columns.reduce(function (partial, columnWidth) { return partial + columnWidth; });
                if (totalWidth > 98) {
                    // remove overflow
                    this.columns = this.ensureNoOverflow(this.columns);
                }
                else {
                    // get the list of resizable columns
                    /** @type {?} */
                    var resizableColumns = this._columns.toArray().filter(function (column) { return !column.disabled; });
                    // work out what we need to add to each column to make up the full width
                    /** @type {?} */
                    var newWidth_1 = (98 - totalWidth) / resizableColumns.length;
                    // set the non-disabled columns to the new width
                    this.columns = this._columns.map(function (column, idx) { return column.disabled ? _this.columns[idx] : newWidth_1; });
                }
                // do the resizing
                this._columns.forEach(function (column, idx) {
                    if (!column.disabled) {
                        _this.resizeColumn(idx, 0, false);
                    }
                });
            };
        /**
         * @param {?} columns
         * @return {?}
         */
        ResizableExpandingTableService.prototype.ensureNoOverflow = /**
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // get the total width
                /** @type {?} */
                var total = columns.reduce(function (width, column) { return width + column; });
                // if we have no overflow then we don't need to do anything
                if (total <= 100) {
                    return columns;
                }
                // if there is overflow identify which columns can be resized
                /** @type {?} */
                var variableColumns = this._columns.filter(function (column) { return !column.disabled && _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns) > column.minWidth; });
                // if there are no columns that can be resized then stop here
                if (variableColumns.length === 0) {
                    return columns;
                }
                // determine the total width of the variable columns
                /** @type {?} */
                var totalWidth = this._columns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns); }, 0);
                // determine to the width of all the variable columns
                /** @type {?} */
                var variableColumnsWidth = variableColumns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns); }, 0);
                // determine how much the columns are currently too large (ignoring fixed columns)
                /** @type {?} */
                var targetWidth = this.tableWidth - (totalWidth - variableColumnsWidth);
                // determine how much we need to reduce a column by
                /** @type {?} */
                var difference = variableColumnsWidth - targetWidth;
                // find the column with the largest size
                /** @type {?} */
                var target = variableColumns.reduce(function (widest, column) {
                    /** @type {?} */
                    var columnWidth = _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns);
                    /** @type {?} */
                    var widestWidth = _this.getColumnWidth(widest.getCellIndex(), ColumnUnit$2.Pixel, columns);
                    return columnWidth > widestWidth ? column : widest;
                });
                // perform the resize
                columns = this.setColumnWidth(target.getCellIndex(), this.getColumnWidth(target.getCellIndex(), ColumnUnit$2.Pixel, columns) - difference, ColumnUnit$2.Pixel, columns);
                // check if we are still over the limit (allow some variance for javascript double precision)
                if (columns.reduce(function (width, column) { return width + column; }) > 100.01) {
                    return this.ensureNoOverflow(columns);
                }
                return columns;
            };
        /** Allow setting the column size in any unit */
        /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
        ResizableExpandingTableService.prototype.setColumnWidth = /**
         * Allow setting the column size in any unit
         * @param {?} index
         * @param {?} value
         * @param {?} unit
         * @param {?=} columns
         * @return {?}
         */
            function (index, value, unit, columns) {
                if (columns === void 0) {
                    columns = this.columns;
                }
                // create a new array so we keep the instance array immutable
                /** @type {?} */
                var sizes = __spread(columns);
                switch (unit) {
                    case ColumnUnit$2.Percentage:
                        sizes[index] = value;
                        break;
                    case ColumnUnit$2.Pixel:
                        sizes[index] = (value / this.tableWidth) * 100;
                        break;
                }
                // update the instance variable
                return sizes;
            };
        /** Resize a column by a specific pixel amount */
        /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @param {?=} isDragging
         * @return {?}
         */
        ResizableExpandingTableService.prototype.resizeColumn = /**
         * Resize a column by a specific pixel amount
         * @param {?} index
         * @param {?} delta
         * @param {?=} isDragging
         * @return {?}
         */
            function (index, delta, isDragging) {
                if (isDragging === void 0) {
                    isDragging = true;
                }
                /** @type {?} */
                var columns = ( /** @type {?} */(__spread(this.columns)));
                // convert the delta to a percentage value
                /** @type {?} */
                var percentageDelta = (delta / this.tableWidth) * 100;
                columns = this.setColumnWidth(index, this.columns[index] + percentageDelta, ColumnUnit$2.Percentage, this.columns);
                this.columns = columns;
                // emit the resize event for each column
                this.onResize$.next();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        ResizableExpandingTableService.prototype.getColumn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._columns ? this._columns.toArray()[index] : null;
            };
        /**
         * @param {?} index
         * @return {?}
         */
        ResizableExpandingTableService.prototype.getColumnDisabled = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.getColumn(index) ? this.getColumn(index).disabled : false;
            };
        ResizableExpandingTableService.decorators = [
            { type: i0.Injectable }
        ];
        return ResizableExpandingTableService;
    }(BaseResizableTableService));
    /** @enum {number} */
    var ColumnUnit$2 = {
        Pixel: 0,
        Percentage: 1,
    };
    ColumnUnit$2[ColumnUnit$2.Pixel] = 'Pixel';
    ColumnUnit$2[ColumnUnit$2.Percentage] = 'Percentage';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableExpandingTableDirective = /** @class */ (function (_super) {
        __extends(ResizableExpandingTableDirective, _super);
        function ResizableExpandingTableDirective(elementRef, table, renderer, resize, _platformId) {
            var _this = _super.call(this, elementRef, table, renderer, resize) || this;
            _this._platformId = _platformId;
            /**
             * Has horizontal overflow
             */
            _this._overflowX = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ResizableExpandingTableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var e_1, _a;
                _super.prototype.ngAfterViewInit.call(this);
                if (common.isPlatformBrowser(this._platformId)) {
                    /** @type {?} */
                    var tableHeaders_1 = this._elementRef.nativeElement.querySelectorAll('thead > tr');
                    var _loop_1 = function (body) {
                        rxjs.fromEvent(body, 'scroll').pipe(operators.takeUntil(this_1._onDestroy)).subscribe(function () {
                            Array.from(tableHeaders_1).forEach(function (thead) { return _this._renderer.setStyle(thead, 'margin-left', "-" + body.scrollLeft + "px"); });
                        });
                    };
                    var this_1 = this;
                    try {
                        for (var _b = __values(Array.from(this._elementRef.nativeElement.tBodies)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var body = _c.value;
                            _loop_1(body);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    /** checks if the table is resizing and allows for a class to be added for when moving from
                     overflow to no overflow */
                    this._table.onResize$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                        _this._overflowX = _this._elementRef.nativeElement.tBodies[0].scrollWidth > _this._elementRef.nativeElement.tBodies[0].offsetWidth;
                    });
                }
            };
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         */
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         * @return {?}
         */
        ResizableExpandingTableDirective.prototype.onTableReady = /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         * @return {?}
         */
            function () {
                var _this = this;
                // if we have already initialised or the table width is currently 0 then do nothing
                if (this._initialised || this.getScrollWidth() === 0) {
                    // if the table has been initialized but the width is now 0
                    // for example, due to the element being hidden (eg. in a collapsed accordion)
                    // we would need to re-run this logic whenever the width is back over 0
                    // to do this we can mark the table as not having been initialized
                    if (this._initialised && this.getScrollWidth() === 0) {
                        this._initialised = false;
                    }
                    return;
                }
                // ensure we initially set the table width
                this._table.tableWidth = this.getScrollWidth();
                // set the columns - prevent expression changed error
                Promise.resolve().then(function () {
                    // initially set the columns
                    _this._table.setColumns(_this.columns);
                    // force relayout to occur to ensure the UI is consistent with the internal state
                    _this.updateLayout();
                });
                // watch for any future changes to the columns
                this.columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    return Promise.resolve().then(function () { return _this._table.setColumns(_this.columns); });
                });
                this._initialised = true;
            };
        /** Force the layout to recalculate */
        /**
         * Force the layout to recalculate
         * @return {?}
         */
        ResizableExpandingTableDirective.prototype.updateLayout = /**
         * Force the layout to recalculate
         * @return {?}
         */
            function () {
                var _this = this;
                Promise.resolve().then(function () { return _this.columns.forEach(function (_column, index) { return _this._table.resizeColumn(index, 0); }); });
            };
        ResizableExpandingTableDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxResizableExpandingTable]',
                        exportAs: 'ux-resizable-expanding-table',
                        providers: [
                            {
                                provide: RESIZABLE_TABLE_SERVICE_TOKEN,
                                useClass: ResizableExpandingTableService
                            }
                        ],
                        host: {
                            'class': 'ux-resizable-expanding-table',
                            '[class.ux-resizable-expanding-table-overflow]': '_overflowX'
                        }
                    },] }
        ];
        /** @nocollapse */
        ResizableExpandingTableDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizableExpandingTableService, decorators: [{ type: i0.Inject, args: [RESIZABLE_TABLE_SERVICE_TOKEN,] }] },
                { type: i0.Renderer2 },
                { type: ResizeService },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        ResizableExpandingTableDirective.propDecorators = {
            columns: [{ type: i0.ContentChildren, args: [ResizableTableColumnComponent, { descendants: true },] }]
        };
        return ResizableExpandingTableDirective;
    }(BaseResizableTableDirective));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ResizableTableDirective = /** @class */ (function (_super) {
        __extends(ResizableTableDirective, _super);
        function ResizableTableDirective(elementRef, table, renderer, resize) {
            var _this = _super.call(this, elementRef, table, renderer, resize) || this;
            // we should hide any horizontal overflow when we are resizing
            _this._table.isResizing$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.setOverflow.bind(_this));
            return _this;
        }
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         */
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         * @return {?}
         */
        ResizableTableDirective.prototype.onTableReady = /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         * @return {?}
         */
            function () {
                var _this = this;
                // if we have already initialised or the table width is currently 0 then do nothing
                if (this._initialised || this.getScrollWidth() === 0) {
                    return;
                }
                // ensure we initially set the table width
                this._table.tableWidth = this.getScrollWidth();
                // set the columns - prevent expression changed error
                Promise.resolve().then(function () {
                    // initially set the columns
                    _this._table.setColumns(_this.columns);
                    // force relayout to occur to ensure the UI is consistent with the internal state
                    _this.updateLayout();
                });
                // watch for any future changes to the columns
                this.columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    return Promise.resolve().then(function () { return _this._table.setColumns(_this.columns); });
                });
                this._initialised = true;
            };
        /** Force the layout to recalculate */
        /**
         * Force the layout to recalculate
         * @return {?}
         */
        ResizableTableDirective.prototype.updateLayout = /**
         * Force the layout to recalculate
         * @return {?}
         */
            function () {
                var _this = this;
                Promise.resolve().then(function () { return _this.columns.forEach(function (_column, index) { return _this._table.resizeColumn(index, 0); }); });
            };
        /**
         * We should hide any horizontal overflow whenever we are resizing, this is because when we are dragging a column
         * we must set the column widths in pixel values as percentages cause some jankiness when moving them. However pixel
         * values are less precise and can in some cases cause overflow, so we should hide overflow when we are resizing
         */
        /**
         * We should hide any horizontal overflow whenever we are resizing, this is because when we are dragging a column
         * we must set the column widths in pixel values as percentages cause some jankiness when moving them. However pixel
         * values are less precise and can in some cases cause overflow, so we should hide overflow when we are resizing
         * @param {?} isResizing
         * @return {?}
         */
        ResizableTableDirective.prototype.setOverflow = /**
         * We should hide any horizontal overflow whenever we are resizing, this is because when we are dragging a column
         * we must set the column widths in pixel values as percentages cause some jankiness when moving them. However pixel
         * values are less precise and can in some cases cause overflow, so we should hide overflow when we are resizing
         * @param {?} isResizing
         * @return {?}
         */
            function (isResizing) {
                var _this = this;
                Array.from((( /** @type {?} */(this._elementRef.nativeElement))).tBodies)
                    .forEach(function (tbody) { return _this._renderer.setStyle(tbody, 'overflow-x', isResizing ? 'hidden' : null); });
            };
        ResizableTableDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxResizableTable]',
                        exportAs: 'ux-resizable-table',
                        providers: [
                            {
                                provide: RESIZABLE_TABLE_SERVICE_TOKEN,
                                useClass: ResizableTableService
                            }
                        ],
                        host: {
                            class: 'ux-resizable-table'
                        }
                    },] }
        ];
        /** @nocollapse */
        ResizableTableDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizableTableService, decorators: [{ type: i0.Inject, args: [RESIZABLE_TABLE_SERVICE_TOKEN,] }] },
                { type: i0.Renderer2 },
                { type: ResizeService }
            ];
        };
        ResizableTableDirective.propDecorators = {
            columns: [{ type: i0.ContentChildren, args: [ResizableTableColumnComponent, { descendants: true },] }]
        };
        return ResizableTableDirective;
    }(BaseResizableTableDirective));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        TableModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            AccessibilityModule,
                            common.CommonModule,
                            DragModule,
                            IconModule,
                            ResizeModule,
                            ReorderableModule,
                            SelectionModule
                        ],
                        declarations: [
                            ResizableTableDirective,
                            ResizableExpandingTableDirective,
                            ResizableTableColumnComponent,
                            ResizableTableCellDirective,
                            ColumnPickerComponent,
                        ],
                        exports: [
                            ResizableTableDirective,
                            ResizableExpandingTableDirective,
                            ResizableTableColumnComponent,
                            ResizableTableCellDirective,
                            ColumnPickerComponent,
                        ]
                    },] }
        ];
        return TableModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var uniqueId$a = 0;
    var TimelineEventComponent = /** @class */ (function () {
        function TimelineEventComponent() {
            /**
             * Define the id for the event
             */
            this.id = "ux-timeline-event-" + uniqueId$a++;
        }
        TimelineEventComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-timeline-event',
                        template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\" [attr.aria-describedby]=\"id\">\r\n    <span>{{ badgeTitle }}</span>\r\n</div>\r\n\r\n<div class=\"timeline-panel\" [id]=\"id\">\r\n    <ng-content></ng-content>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        TimelineEventComponent.propDecorators = {
            id: [{ type: i0.Input }],
            badgeColor: [{ type: i0.Input }],
            badgeTitle: [{ type: i0.Input }]
        };
        return TimelineEventComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TimelineComponent = /** @class */ (function () {
        function TimelineComponent() {
        }
        TimelineComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-timeline',
                        template: "<div class=\"timeline\">\r\n    <div class=\"timeline-connector\"></div>\r\n    <ux-icon class=\"timeline-arrow\" name=\"chevron-down\"></ux-icon>\r\n    <ng-content></ng-content>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return TimelineComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TimelineModule = /** @class */ (function () {
        function TimelineModule() {
        }
        TimelineModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            IconModule
                        ],
                        exports: [
                            TimelineComponent,
                            TimelineEventComponent
                        ],
                        declarations: [
                            TimelineComponent,
                            TimelineEventComponent
                        ]
                    },] }
        ];
        return TimelineModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    /** @type {?} */
    var uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = /** @class */ (function () {
        function ToggleSwitchComponent() {
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            /**
             * Specify a unique id for the element.
             */
            this.id = this._toggleSwitchId;
            /**
             * Specify a tabindex.
             */
            this.tabindex = 0;
            /**
             * If set to `false` the switch will not be updated when clicking on it, can be used if something else is updating the state of the switch.
             */
            this.clickable = true;
            /**
             * If this value is set to `true` then the toggle switch will be disabled.
             */
            this.disabled = false;
            /**
             * Specify an aria label for the input element
             */
            this.ariaLabel = '';
            /**
             * Specify an aria labelledby property for the input element
             */
            this.ariaLabelledby = null;
            /**
             * Emits when `value` has been changed.
             */
            this.valueChange = new i0.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
            /** Binding for the state of the switch; `true` for "on" and `false` for "off." */
            get: /**
             * Binding for the state of the switch; `true` for "on" and `false` for "off."
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // Update value output
                this.valueChange.emit(value);
                // Notify ngModel
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._toggleSwitchId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToggleSwitchComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (!this.disabled && this.clickable) {
                    this.value = !this.value;
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ToggleSwitchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = !!value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        ToggleSwitchComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        ToggleSwitchComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-toggleswitch',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           uxFocusIndicator\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (indicator)=\"focused = $event\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                        providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                    }] }
        ];
        ToggleSwitchComponent.propDecorators = {
            id: [{ type: i0.Input }],
            name: [{ type: i0.Input }],
            tabindex: [{ type: i0.Input }],
            clickable: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            ariaLabel: [{ type: i0.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: i0.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: i0.Output }],
            value: [{ type: i0.Input }]
        };
        return ToggleSwitchComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ToggleSwitchModule = /** @class */ (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            forms.FormsModule
                        ],
                        exports: [
                            ToggleSwitchComponent
                        ],
                        declarations: [
                            ToggleSwitchComponent
                        ]
                    },] }
        ];
        return ToggleSwitchModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ToolbarSearchButtonDirective = /** @class */ (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Emit whenever the button is clicked
             */
            this.clicked = new i0.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            /** Get the width of the button element */
            get: /**
             * Get the width of the button element
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchButtonDirective.prototype.clickHandler = /**
         * @return {?}
         */
            function () {
                this.clicked.emit();
            };
        ToolbarSearchButtonDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxToolbarSearchButton]'
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchButtonDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        ToolbarSearchButtonDirective.propDecorators = {
            clicked: [{ type: i0.Output }],
            clickHandler: [{ type: i0.HostListener, args: ['click',] }]
        };
        return ToolbarSearchButtonDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TOOLBAR_SEARCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return ToolbarSearchFieldDirective; }),
        multi: true
    };
    var ToolbarSearchFieldDirective = /** @class */ (function () {
        function ToolbarSearchFieldDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Emit whenever the escape key is pressed
             */
            this.cancel = new i0.EventEmitter();
            /**
             * Emit whenever the enter key is pressed
             */
            this.submitted = new i0.EventEmitter();
            /**
             * For use with the Forms and ReactiveForms
             */
            this.onTouchedCallback = function () { };
            /**
             * Call this function with the latest value to update ngModel or formControl name
             */
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            /** Get the current value of the input control */
            get: /**
             * Get the current value of the input control
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // mark the control as dirty
                this.onTouchedCallback();
                // focus the input control after a delay to ensure the element is present
                requestAnimationFrame(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.blur = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // blur the input control after a delay to ensure the element is present
                requestAnimationFrame(function () { return _this._elementRef.nativeElement.blur(); });
            };
        /** Clear the input, if we have an ngModel reset its value otherwise just set the input value to empty */
        /**
         * Clear the input, if we have an ngModel reset its value otherwise just set the input value to empty
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.clear = /**
         * Clear the input, if we have an ngModel reset its value otherwise just set the input value to empty
         * @return {?}
         */
            function () {
                this.setValue('');
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.onEnter = /**
         * @return {?}
         */
            function () {
                this.submitted.emit(this.text);
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.onEscape = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.blur();
                this.cancel.emit();
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.onInput = /**
         * @return {?}
         */
            function () {
                this.setValue(this.text);
            };
        /** Update the input value based on ngModel or formControl */
        /**
         * Update the input value based on ngModel or formControl
         * @param {?} value
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.writeValue = /**
         * Update the input value based on ngModel or formControl
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.setValue(value);
            };
        /** Register a function to update form control */
        /**
         * Register a function to update form control
         * @param {?} fn
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.registerOnChange = /**
         * Register a function to update form control
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /** Register a function to mark form control as touched */
        /**
         * Register a function to mark form control as touched
         * @param {?} fn
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.registerOnTouched = /**
         * Register a function to mark form control as touched
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /** Update the value in all required places */
        /**
         * Update the value in all required places
         * @param {?} value
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.setValue = /**
         * Update the value in all required places
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // ngModel/form control can set the default value to null or undefined, which can show in the input. Replace with empty string
                if (!value) {
                    value = '';
                }
                // update the form value if there is one in use
                this.onChangeCallback(value);
                // update the content of the input control
                this._elementRef.nativeElement.value = value;
            };
        ToolbarSearchFieldDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxToolbarSearchField]',
                        providers: [TOOLBAR_SEARCH_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchFieldDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        ToolbarSearchFieldDirective.propDecorators = {
            cancel: [{ type: i0.Output }],
            submitted: [{ type: i0.Output }],
            onEnter: [{ type: i0.HostListener, args: ['keydown.enter',] }],
            onEscape: [{ type: i0.HostListener, args: ['keydown.escape',] }],
            onInput: [{ type: i0.HostListener, args: ['input',] }]
        };
        return ToolbarSearchFieldDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ToolbarSearchComponent = /** @class */ (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _renderer, _platformId) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._renderer = _renderer;
            this._platformId = _platformId;
            /**
             * The direction in which the search box will expand. If the search button is aligned to the right edge of the container, specify left.
             */
            this.direction = 'right';
            /**
             * Whether the color scheme is inverted. For use when the component is hosted on a dark background, e.g. the masthead.
             */
            this.inverse = false;
            /**
             * Indicate whether or not the search field should always be expanded
             */
            this.alwaysExpanded = false;
            /**
             * Emitted when the expanded state changes
             */
            this.expandedChange = new i0.EventEmitter();
            /**
             * Emitted when a search query has been submitted, either by pressing enter when the search field has focus, or by clicking the search button
             * when the search field contains text. The event contains the search text.
             */
            this.search = new i0.EventEmitter();
            /**
             * Store the CSS position value as this may change to absolute
             */
            this._position = 'relative';
            /**
             * Store the active background color
             */
            this._backgroundColor = 'transparent';
            /**
             * Store the expanded state
             */
            this._expanded = false;
            /**
             * Unsubscribe from all subscriptions on component destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this.alwaysExpanded || this._expanded;
            },
            /** Whether the input field is visible. Use this to collapse or expand the control in response to other events. */
            set: /**
             * Whether the input field is visible. Use this to collapse or expand the control in response to other events.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded = value;
                this.expandedChange.emit(this.expanded);
                if (this.expanded) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            /*
             * The background color of the component. Color names from the Color Palette can be used here.
             * Specify this when a transparent background would cause display issues, such as background items showing through the search field.
             */
            set: /*
                 * The background color of the component. Color names from the Color Palette can be used here.
                 * Specify this when a transparent background would cause display issues, such as background items showing through the search field.
                 */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "_expandedAnimation", {
            /** Return the correct animation based on the expanded state */
            get: /**
             * Return the correct animation based on the expanded state
             * @return {?}
             */ function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Subscribe to the submitted event on the input field, triggering the search event
                this.field.submitted.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (text) { return _this.search.emit(text); });
                // Subscribe to cancel events coming from the input field
                this.field.cancel.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.expanded = false; });
                // Subscribe to the button click event
                this.button.clicked.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.expanded && _this.field.text ? _this.search.emit(_this.field.text) : _this.expanded = !_this.expanded;
                });
                // Create placeholder element to avoid changing layout when switching to position: absolute
                // If the platform is a server we dont want to do this as we can't access getComputedStyle
                if (!common.isPlatformServer(this._platformId)) {
                    this.createPlaceholder();
                }
            };
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                /**
                 * We programmatically created the placeholder node so Angular is not aware of its existence
                 * so we must manually destroy it otherwise the reference will be retained.
                 * Note, the `destroyNode` function may be null or undefined as mentioned in the
                 * Angular API docs (https://angular.io/api/core/Renderer2#destroyNode) so
                 * we must check that the function is available before attempting to call it
                */
                if (this._placeholder && this._renderer && this._renderer.destroyNode) {
                    this._renderer.destroyNode(this._placeholder);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'expanded') {
                    this._position = 'absolute';
                    this.setPlaceholderVisible(true);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationDone = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'collapsed') {
                    this._position = 'relative';
                    this.setPlaceholderVisible(false);
                }
            };
        /** Programmatically create a placeholder element */
        /**
         * Programmatically create a placeholder element
         * @return {?}
         */
        ToolbarSearchComponent.prototype.createPlaceholder = /**
         * Programmatically create a placeholder element
         * @return {?}
         */
            function () {
                // Get width and height of the component
                /** @type {?} */
                var styles = getComputedStyle(this._elementRef.nativeElement);
                // Create invisible div with the same dimensions
                this._placeholder = this._renderer.createElement('div');
                this._renderer.setStyle(this._placeholder, 'display', 'none');
                this._renderer.setStyle(this._placeholder, 'width', this.button.width + 'px');
                this._renderer.setStyle(this._placeholder, 'height', styles.height);
                this._renderer.setStyle(this._placeholder, 'visibility', 'hidden');
                // Add as a sibling
                this._renderer.insertBefore(this._elementRef.nativeElement.parentNode, this._placeholder, this._elementRef.nativeElement);
            };
        /** Update the visibility of the placeholder node */
        /**
         * Update the visibility of the placeholder node
         * @param {?} isVisible
         * @return {?}
         */
        ToolbarSearchComponent.prototype.setPlaceholderVisible = /**
         * Update the visibility of the placeholder node
         * @param {?} isVisible
         * @return {?}
         */
            function (isVisible) {
                this._renderer.setStyle(this._placeholder, 'display', isVisible ? 'inline-block' : 'none');
            };
        ToolbarSearchComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-toolbar-search',
                        template: "<ng-content></ng-content>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('expanded', [
                                animations.state('collapsed', animations.style({ width: '{{initialWidth}}' }), { params: { initialWidth: '30px' } }),
                                animations.state('expanded', animations.style({ width: '100%' })),
                                animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                            ])
                        ],
                        host: {
                            '[class.expanded]': 'expanded',
                            '[class.left]': 'direction === "left"',
                            '[class.right]': 'direction === "right"',
                            '[class.inverse]': 'inverse',
                            '[style.position]': '_position',
                            '[style.background-color]': '_backgroundColor',
                            '[@expanded]': '_expandedAnimation'
                        }
                    }] }
        ];
        /** @nocollapse */
        ToolbarSearchComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ColorService },
                { type: i0.Renderer2 },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        ToolbarSearchComponent.propDecorators = {
            direction: [{ type: i0.Input }],
            inverse: [{ type: i0.Input }],
            alwaysExpanded: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            background: [{ type: i0.Input }],
            expandedChange: [{ type: i0.Output }],
            search: [{ type: i0.Output }],
            field: [{ type: i0.ContentChild, args: [ToolbarSearchFieldDirective, { static: true },] }],
            button: [{ type: i0.ContentChild, args: [ToolbarSearchButtonDirective, { static: false },] }],
            animationStart: [{ type: i0.HostListener, args: ['@expanded.start', ['$event'],] }],
            animationDone: [{ type: i0.HostListener, args: ['@expanded.done', ['$event'],] }]
        };
        return ToolbarSearchComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = /** @class */ (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$6,
                        declarations: DECLARATIONS$6,
                        providers: [],
                    },] }
        ];
        return ToolbarSearchModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var VirtualForService = /** @class */ (function () {
        function VirtualForService() {
            /**
             * Store the size of each item
             */
            this.itemSize = 0;
            /**
             * Emit the current dataset
             */
            this.dataset = new rxjs.ReplaySubject(1);
            /**
             * Emit the visible range
             */
            this.range = new rxjs.ReplaySubject(1);
        }
        VirtualForService.decorators = [
            { type: i0.Injectable }
        ];
        return VirtualForService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * This implementation is inspired by the CDK virtual for:
     * https://github.com/angular/material2/blob/master/src/cdk/scrolling/virtual-for-of.ts
     * However the CDK requires a container component which limits use in places such
     * as fixed header tables, so this is a more generic implementation that does not
     * require a parent element but instead uses an attribute on the parent container instead
     * @template T
     */
    var VirtualForDirective = /** @class */ (function () {
        function VirtualForDirective(_viewContainerRef, _templateRef, _differs, _renderer, _virtualScroll) {
            this._viewContainerRef = _viewContainerRef;
            this._templateRef = _templateRef;
            this._differs = _differs;
            this._renderer = _renderer;
            this._virtualScroll = _virtualScroll;
            /**
             * Provide a trackBy function to optimize rendering
             */
            this.uxVirtualForTrackBy = this.defaultTrackBy;
            /**
             * Indicate whether we need to perform a view update
             */
            this._isDirty = false;
            /**
             * Store a cache of recently disposed views for reuse
             */
            this._templateCache = [];
            /**
             * Limit the size of the cache as it can use a lot of memory
             */
            this._cacheSize = 20;
            /**
             * Unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
            // While marked as optional, it isn't. We do this so we can provide a more helpful error message
            if (!this._virtualScroll) {
                throw new Error('The "uxVirtualFor" directive requires the "uxVirtualForContainer" directive to be added to the parent element.');
            }
        }
        Object.defineProperty(VirtualForDirective.prototype, "uxVirtualForOf", {
            /** Store the list of items to display */
            set: /**
             * Store the list of items to display
             * @param {?} dataset
             * @return {?}
             */ function (dataset) {
                // emit the latest dataset
                this._virtualScroll.dataset.next(dataset);
                // store a local version of the dataset
                this._dataset = dataset;
                // if this is an update and not the initial dataset then we should
                // forcibly redraw the list of items. In cases where the length of
                // the dataset change would trigger a re-renderer as the scroll position
                // would change, however if we are performing sorting then it would not
                // so we must ensure we update everytime the dataset changes.
                if (this._renderedRange) {
                    this.onRangeChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VirtualForDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // update the UI whenever the range changes
                this._virtualScroll.range.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(this.isRangeSame)).subscribe(function (range) {
                    _this._renderedRange = range;
                    _this.onRangeChange();
                });
            };
        /**
         * @return {?}
         */
        VirtualForDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this._isDirty && this._differ) {
                    // check if there area any changes
                    /** @type {?} */
                    var changes = this.getChanges();
                    if (changes) {
                        this.applyChanges(changes);
                    }
                    else {
                        this.updateContexts();
                    }
                    // now that we have rendered any change we should store this so we don't perform unneeded updates
                    this._isDirty = false;
                }
            };
        /**
         * @return {?}
         */
        VirtualForDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** If an itemSize is not specified we need to calculate it */
        /**
         * If an itemSize is not specified we need to calculate it
         * @param {?} context
         * @param {?} length
         * @return {?}
         */
        VirtualForDirective.prototype.getHeight = /**
         * If an itemSize is not specified we need to calculate it
         * @param {?} context
         * @param {?} length
         * @return {?}
         */
            function (context, length) {
                // create a temporary view
                /** @type {?} */
                var view = this.createView(0);
                // set the implicit value to the item value
                view.context.$implicit = context;
                view.context.count = length;
                view.context.even = true;
                view.context.odd = false;
                view.context.first = true;
                view.context.last = length === 1;
                // run change detection
                view.detectChanges();
                // get the size of the view
                /** @type {?} */
                var height = view.rootNodes[0].offsetHeight;
                // destroy the view
                this._viewContainerRef.remove(0);
                view.destroy();
                return height;
            };
        /** Determine if the range has changed (performance optimization) */
        /**
         * Determine if the range has changed (performance optimization)
         * @param {?} previous
         * @param {?} current
         * @return {?}
         */
        VirtualForDirective.prototype.isRangeSame = /**
         * Determine if the range has changed (performance optimization)
         * @param {?} previous
         * @param {?} current
         * @return {?}
         */
            function (previous, current) {
                return previous.start === current.start && previous.end === current.end;
            };
        /**
         * @return {?}
         */
        VirtualForDirective.prototype.onRangeChange = /**
         * @return {?}
         */
            function () {
                // store the visible range
                this._renderedItems = this._dataset.slice(this._renderedRange.start, this._renderedRange.end);
                // create the Angular differ if we haven't previously done so
                if (!this._differ) {
                    this._differ = this._differs.find(this._renderedItems).create(this.uxVirtualForTrackBy);
                }
                // mark the view for re-render
                this._isDirty = true;
            };
        /** Determine which items have changed */
        /**
         * Determine which items have changed
         * @return {?}
         */
        VirtualForDirective.prototype.getChanges = /**
         * Determine which items have changed
         * @return {?}
         */
            function () {
                return this._differ.diff(this._renderedItems);
            };
        /** Insert, move and remove any items within the view */
        /**
         * Insert, move and remove any items within the view
         * @param {?} changes
         * @return {?}
         */
        VirtualForDirective.prototype.applyChanges = /**
         * Insert, move and remove any items within the view
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                var _this = this;
                // Go through each changes and either add or rearrange accordingly
                changes.forEachOperation(function (record, previousIndex, currentIndex) {
                    // check if a new item was added
                    if (previousIndex === null) {
                        // create the new embedded view
                        /** @type {?} */
                        var view = _this.createView(currentIndex);
                        // set the implicit value to the item value
                        view.context.$implicit = record.item;
                    }
                    else if (currentIndex === null) { // check if the item should be removed
                        // check if the item should be removed
                        /** @type {?} */
                        var view = ( /** @type {?} */(_this._viewContainerRef.detach(currentIndex)));
                        /** @type {?} */
                        var index = _this._viewContainerRef.indexOf(view);
                        // if there is space in the cache then store the detached view
                        if (_this._templateCache.length < _this._cacheSize) {
                            _this._templateCache.push(view);
                        }
                        else {
                            index === -1 ? view.destroy() : _this._viewContainerRef.remove(index);
                        }
                    }
                    else { // the position of the item has changed
                        // the position of the item has changed
                        // get the view from its current position
                        /** @type {?} */
                        var view = ( /** @type {?} */(_this._viewContainerRef.get(previousIndex)));
                        // move it to the new position
                        _this._viewContainerRef.move(view, currentIndex);
                        // update the implicit value (the rest will stay the same)
                        view.context.$implicit = record.item;
                    }
                });
                // Ensure the implicit value is correct for any items whose identity changed
                changes.forEachIdentityChange(function (record) {
                    /** @type {?} */
                    var view = ( /** @type {?} */(_this._viewContainerRef.get(record.currentIndex)));
                    if (view) {
                        view.context.$implicit = record.item;
                    }
                });
                this.updateContexts();
            };
        /**
         * @return {?}
         */
        VirtualForDirective.prototype.updateContexts = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var _loop_1 = function (idx) {
                    // get the view at a given position
                    /** @type {?} */
                    var view = ( /** @type {?} */(this_1._viewContainerRef.get(idx)));
                    // update the properties
                    view.context.index = this_1._renderedRange.start + idx;
                    view.context.count = this_1._dataset.length;
                    view.context.first = view.context.index === 0;
                    view.context.last = view.context.index === view.context.count - 1;
                    view.context.even = view.context.index % 2 === 0;
                    view.context.odd = !view.context.even;
                    // update the position in the DOM
                    view.rootNodes.forEach(function (node) {
                        _this._renderer.setStyle(node, 'position', 'absolute');
                        _this._renderer.setStyle(node, 'width', '100%');
                        _this._renderer.setStyle(node, 'top', '0');
                        _this._renderer.setStyle(node, 'transform', "translateY(" + view.context.index * _this._virtualScroll.itemSize + "px");
                    });
                    view.detectChanges();
                };
                var this_1 = this;
                // update all the other context properties
                for (var idx = 0; idx < this._viewContainerRef.length; idx++) {
                    _loop_1(idx);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        VirtualForDirective.prototype.createView = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // get a checked EmbeddedViewRef is there is one
                /** @type {?} */
                var cachedTemplate = this._templateCache.pop();
                if (cachedTemplate) {
                    // replace existing context with the defaults
                    cachedTemplate.context.$implicit = null;
                    cachedTemplate.context.index = -1;
                    cachedTemplate.context.count = -1;
                    cachedTemplate.context.first = false;
                    cachedTemplate.context.last = false;
                    cachedTemplate.context.even = false;
                    cachedTemplate.context.odd = false;
                    // insert the view
                    this._viewContainerRef.insert(cachedTemplate, index);
                    // return the cached EmbeddedViewRef
                    return cachedTemplate;
                }
                // otherwise create a new view and insert it
                return this._viewContainerRef.createEmbeddedView(this._templateRef, {
                    $implicit: null,
                    index: -1,
                    count: -1,
                    first: false,
                    last: false,
                    even: false,
                    odd: false,
                }, index);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        VirtualForDirective.prototype.defaultTrackBy = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        VirtualForDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxVirtualFor][uxVirtualForOf]',
                    },] }
        ];
        /** @nocollapse */
        VirtualForDirective.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: i0.TemplateRef },
                { type: i0.IterableDiffers },
                { type: i0.Renderer2 },
                { type: VirtualForService, decorators: [{ type: i0.Optional }] }
            ];
        };
        VirtualForDirective.propDecorators = {
            uxVirtualForOf: [{ type: i0.Input }],
            uxVirtualForTrackBy: [{ type: i0.Input }]
        };
        return VirtualForDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var VirtualForContainerComponent = /** @class */ (function () {
        function VirtualForContainerComponent(_elementRef, _virtualScroll, _tabbableList) {
            this._elementRef = _elementRef;
            this._virtualScroll = _virtualScroll;
            this._tabbableList = _tabbableList;
            /**
             * Keep a local reference of the dataset
             */
            this._dataset = [];
            /**
             * Indicate if the component has finished initialising
             */
            this._initialized = false;
            /**
             * Unsubscribe from all observables
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(VirtualForContainerComponent.prototype, "itemSize", {
            get: /**
             * @return {?}
             */ function () {
                return this._virtualScroll.itemSize;
            },
            /** Define the height of each virtual item */
            set: /**
             * Define the height of each virtual item
             * @param {?} itemSize
             * @return {?}
             */ function (itemSize) {
                var _this = this;
                this._virtualScroll.itemSize = itemSize;
                if (this._initialized) {
                    requestAnimationFrame(function () {
                        _this.updateContainer();
                        _this.virtualFor.updateContexts();
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VirtualForContainerComponent.prototype, "_isTable", {
            /** Determine if this is a table */
            get: /**
             * Determine if this is a table
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.tagName === 'TABLE' || this._elementRef.nativeElement.tagName === 'TBODY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VirtualForContainerComponent.prototype, "_isList", {
            /** Determine if this is a list */
            get: /**
             * Determine if this is a list
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.tagName === 'OL' || this._elementRef.nativeElement.tagName === 'UL';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VirtualForContainerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // subscribe to changes to the dataset
                this._virtualScroll.dataset.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (dataset) {
                    // store the latest dataset
                    _this._dataset = dataset;
                    // update the container properties
                    requestAnimationFrame(function () {
                        _this.updateContainer();
                        // mark the component as ready
                        _this._initialized = true;
                    });
                });
            };
        /**
         * @return {?}
         */
        VirtualForContainerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        VirtualForContainerComponent.prototype.updateContainer = /**
         * @return {?}
         */
            function () {
                if (this.itemSize === 0 && this._dataset.length > 0) {
                    this.itemSize = this.virtualFor.getHeight(this._dataset[0], this._dataset.length);
                }
                // calculate the total height of all the items
                this._totalHeight = this._dataset.length * this.itemSize;
                // get the actual height of the container element
                /** @type {?} */
                var height = this.getContainerHeight();
                // determine the number of items it takes to fill the container height (multiply by 2 to give us some buffer items)
                /** @type {?} */
                var itemCount = Math.ceil((height / this.itemSize) * 2);
                /**
                 * Determine the number of items we have as a top buffer
                 * @type {?}
                 */
                var topBufferCount = Math.ceil((height / this.itemSize) * 0.5);
                // get the scroll offset
                /** @type {?} */
                var scrollOffset = this.getScrollOffset();
                // determine the start index based on the scroll offset
                /** @type {?} */
                var startIdx = Math.max(Math.floor(scrollOffset / this.itemSize) - Math.floor(topBufferCount), 0);
                // determine the end index based on the start and the number of items to display
                /** @type {?} */
                var endIdx = Math.min(startIdx + itemCount, this._dataset.length);
                // update the range
                this._range = { start: startIdx, end: endIdx };
                // emit the new visible range
                this._virtualScroll.range.next(this._range);
            };
        /** If cells are automatically getting their height detected you may want to update the size */
        /**
         * If cells are automatically getting their height detected you may want to update the size
         * @return {?}
         */
        VirtualForContainerComponent.prototype.recalculateCellSize = /**
         * If cells are automatically getting their height detected you may want to update the size
         * @return {?}
         */
            function () {
                this.itemSize = 0;
            };
        /**
         * @param {?} event
         * @param {?} keyCode
         * @return {?}
         */
        VirtualForContainerComponent.prototype.onKeydown = /**
         * @param {?} event
         * @param {?} keyCode
         * @return {?}
         */
            function (event, keyCode) {
                var _this = this;
                if (!this._tabbableList) {
                    return;
                }
                switch (keyCode) {
                    case keycodes.PAGE_UP:
                        this._tabbableList.focusKeyManager.setFirstItemActive();
                        event.preventDefault();
                        break;
                    case keycodes.PAGE_DOWN:
                        this._tabbableList.focusKeyManager.setLastItemActive();
                        event.preventDefault();
                        break;
                    case keycodes.HOME:
                        // ensure the QueryList doesn't do any updates until we have finished
                        this._tabbableList.shouldFocusOnChange = false;
                        // scroll to the top of the container
                        this._elementRef.nativeElement.scrollTop = 0;
                        // after the update the activate the first item
                        requestAnimationFrame(function () {
                            _this._tabbableList.focusKeyManager.setFirstItemActive();
                            _this._tabbableList.shouldFocusOnChange = true;
                        });
                        event.preventDefault();
                        break;
                    case keycodes.END:
                        // ensure the QueryList doesn't do any updates until we have finished
                        this._tabbableList.shouldFocusOnChange = false;
                        // scroll to the bottom of the container
                        this._elementRef.nativeElement.scrollTop = this._elementRef.nativeElement.scrollHeight;
                        // after the update the activate the last item
                        requestAnimationFrame(function () {
                            _this._tabbableList.focusKeyManager.setLastItemActive();
                            _this._tabbableList.shouldFocusOnChange = true;
                        });
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @return {?}
         */
        VirtualForContainerComponent.prototype.getScrollOffset = /**
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this._elementRef.nativeElement))).scrollTop;
            };
        /**
         * @return {?}
         */
        VirtualForContainerComponent.prototype.getContainerHeight = /**
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this._elementRef.nativeElement))).clientHeight;
            };
        VirtualForContainerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: '[uxVirtualForContainer]',
                        template: "<!-- Display the appropriate top spacer -->\n<tr class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"_isTable\">\n</tr>\n\n<li class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"_isList\">\n</li>\n\n<div class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"!_isTable && !_isList\">\n</div>\n\n\n<ng-content></ng-content>\n",
                        providers: [VirtualForService],
                        host: {
                            '[style.position]': '"relative"'
                        }
                    }] }
        ];
        /** @nocollapse */
        VirtualForContainerComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: VirtualForService },
                { type: TabbableListService, decorators: [{ type: i0.Self }, { type: i0.Optional }] }
            ];
        };
        VirtualForContainerComponent.propDecorators = {
            itemSize: [{ type: i0.Input }],
            virtualFor: [{ type: i0.ContentChild, args: [VirtualForDirective, { static: false },] }],
            updateContainer: [{ type: i0.HostListener, args: ['scroll',] }],
            onKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event', '$event.keyCode'],] }]
        };
        return VirtualForContainerComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var VirtualScrollCellDirective = /** @class */ (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxVirtualScrollCell]'
                    },] }
        ];
        return VirtualScrollCellDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var VirtualScrollLoadButtonDirective = /** @class */ (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxVirtualScrollLoadButton]'
                    },] }
        ];
        return VirtualScrollLoadButtonDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var VirtualScrollLoadingDirective = /** @class */ (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxVirtualScrollLoading]'
                    },] }
        ];
        return VirtualScrollLoadingDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var VirtualScrollComponent = /** @class */ (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            /**
             * Provide the collection of items to display
             */
            this.collection = rxjs.Observable.create();
            /**
             * Indicate whether pages should be loaded on scroll or button click
             */
            this.loadOnScroll = true;
            /**
             * Emit when we need to load another page
             */
            this.loading = new i0.EventEmitter();
            this.cells = new rxjs.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            this._buffer = 5;
            this._onDestroy = new rxjs.Subject();
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this._height = event.height; });
        }
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.cellHeight) {
                    throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
                }
                // subscribe to the collection
                this.setupObservable();
                // load the first page of data
                this.loadNextPage();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // re-render cells now that we can display any loading indicator or loading button
                this.renderCells();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.collection && changes.collection.currentValue !== changes.collection.previousValue && !changes.collection.isFirstChange()) {
                    this.setupObservable();
                    this.reset();
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.setupObservable = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is a current subscription, unsubscribe
                if (this._subscription && this._subscription.unsubscribe) {
                    this._subscription.unsubscribe();
                }
                this._subscription = this.collection.subscribe(function (collection) {
                    _this.data = __spread(_this.data, collection);
                    _this.renderCells();
                    _this.isLoading = false;
                }, null, function () {
                    _this.loadingComplete = true;
                });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.renderCells = /**
         * @return {?}
         */
            function () {
                this.cells.next(this.getVisibleCells());
                if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                    /** @type {?} */
                    var remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                    // if the current cells take up less than the height of the component then load the next page
                    if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                        this.loadNextPage();
                    }
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getVisibleCells = /**
         * @return {?}
         */
            function () {
                // store the initial element height
                if (!this._height) {
                    this._height = this._elementRef.nativeElement.offsetHeight;
                }
                // perform some calculations
                /** @type {?} */
                var scrollTop = this._elementRef.nativeElement.scrollTop;
                /** @type {?} */
                var startCell = Math.floor(scrollTop / this.cellHeight);
                /** @type {?} */
                var endCell = Math.ceil(this._height / this.cellHeight);
                // we want to add some buffer cells on both the top and bottom of the visible list
                /** @type {?} */
                var startBuffer = Math.max(0, startCell - this._buffer);
                /** @type {?} */
                var endBuffer = startCell + (startCell - startBuffer) + Math.min(this.data.length, endCell + this._buffer);
                // update the scroll position
                this.scrollTop = (scrollTop - (scrollTop % this.cellHeight)) - ((startCell - startBuffer) * this.cellHeight);
                // return a sublist of items visible on the screen
                /** @type {?} */
                var cells = this.data.slice(startBuffer, endBuffer);
                // now map these cells to a virtual cell interface
                return cells.map(function (cell, index) { return ({ data: cell, index: startBuffer + index }); });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getTotalHeight = /**
         * @return {?}
         */
            function () {
                return this.cellHeight * this.data.length;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.loadNextPage = /**
         * @return {?}
         */
            function () {
                this.isLoading = true;
                this.loading.next(this.pageNumber);
                this.pageNumber++;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.reset = /**
         * @return {?}
         */
            function () {
                // reset all values
                this.scrollTop = 0;
                this.data = [];
                this._height = undefined;
                this.pageNumber = 0;
                this.loadingComplete = false;
                // set scroll position
                this._elementRef.nativeElement.scrollTop = 0;
                // clear the current cells
                this.renderCells();
                // reload first page
                this.loadNextPage();
            };
        VirtualScrollComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'ux-virtual-scroll',
                        template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell.data, index: cell.index }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n\n</div>"
                    }] }
        ];
        /** @nocollapse */
        VirtualScrollComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizeService }
            ];
        };
        VirtualScrollComponent.propDecorators = {
            collection: [{ type: i0.Input }],
            cellHeight: [{ type: i0.Input }],
            loadOnScroll: [{ type: i0.Input }],
            loading: [{ type: i0.Output }],
            cellTemplate: [{ type: i0.ContentChild, args: [VirtualScrollCellDirective, { read: i0.TemplateRef, static: false },] }],
            loadingIndicatorTemplate: [{ type: i0.ContentChild, args: [VirtualScrollLoadingDirective, { read: i0.TemplateRef, static: false },] }],
            loadButtonTemplate: [{ type: i0.ContentChild, args: [VirtualScrollLoadButtonDirective, { read: i0.TemplateRef, static: false },] }],
            renderCells: [{ type: i0.HostListener, args: ['scroll',] }]
        };
        return VirtualScrollComponent;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective,
        VirtualForContainerComponent,
        VirtualForDirective,
    ];
    var VirtualScrollModule = /** @class */ (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            ResizeModule
                        ],
                        exports: DECLARATIONS$7,
                        declarations: DECLARATIONS$7
                    },] }
        ];
        return VirtualScrollModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AutoGrowDirective = /** @class */ (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.update();
            };
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.update = /**
         * @return {?}
         */
            function () {
                // perform sizing
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
                // get the new total height and element height
                var scrollHeight = this._elementRef.nativeElement.scrollHeight;
                var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
                // determine what the maximum allowed height is
                /** @type {?} */
                var maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
                // if there is a max height specifed we want to show the scrollbars
                if (maximum < scrollHeight) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
                }
                else {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
                }
            };
        AutoGrowDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxAutoGrow]'
                    },] }
        ];
        /** @nocollapse */
        AutoGrowDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        AutoGrowDirective.propDecorators = {
            update: [{ type: i0.HostListener, args: ['input',] }]
        };
        return AutoGrowDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var AutoGrowModule = /** @class */ (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [AutoGrowDirective],
                        declarations: [AutoGrowDirective]
                    },] }
        ];
        return AutoGrowModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var FixedHeaderTableDirective = /** @class */ (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer, _resizeService) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._resizeService = _resizeService;
            /**
             * Emit when the table tries to load more data
             */
            this.tablePaging = new i0.EventEmitter();
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(FixedHeaderTableDirective.prototype, "dataset", {
            /** Allow dataset changes to trigger re-layout */
            set: /**
             * Allow dataset changes to trigger re-layout
             * @param {?} _dataset
             * @return {?}
             */ function (_dataset) {
                var _this = this;
                requestAnimationFrame(function () { return _this.setLayout(); });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // add class to the table
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
                // locate the important elements
                this._tableHead = ( /** @type {?} */(this._elementRef.nativeElement.querySelector('thead')));
                this._tableBody = ( /** @type {?} */(this._elementRef.nativeElement.querySelector('tbody')));
                // bind to scroll events on the table body
                this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
                // resize the table header to account for scrollbar
                this.setLayout();
                // if a resize occurs perform a relayout (this can be useful when displaying tables in modals)
                this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.setLayout(); });
                // trigger the loading of the first page
                this.tablePaging.emit();
            };
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.getTable = /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement;
            };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         */
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.setLayout = /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
            function () {
                if (!this._tableBody || !this._tableHead) {
                    return;
                }
                // calculate the size of the scrollbar
                /** @type {?} */
                var scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
                // add padding to the header to account for this
                this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
                // set the desired height of the table body
                this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
            };
        /**
         * Handle scroll events
         */
        /**
         * Handle scroll events
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.onScroll = /**
         * Handle scroll events
         * @return {?}
         */
            function () {
                // determine if we are scrolled to the bottom and if so load the next page
                /** @type {?} */
                var scrollTop = this._tableBody.scrollTop;
                /** @type {?} */
                var scrollHeight = this._tableBody.scrollHeight - this._tableBody.offsetHeight;
                /** @type {?} */
                var delta = Math.max(scrollTop, scrollHeight) - Math.min(scrollTop, scrollHeight);
                // its possible for the difference to be a value < 1 when we are at the bottom. Account for this:
                if (delta < 1) {
                    this.tablePaging.emit();
                }
            };
        FixedHeaderTableDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFixedHeaderTable]',
                        exportAs: 'ux-fixed-header-table'
                    },] }
        ];
        /** @nocollapse */
        FixedHeaderTableDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: ResizeService }
            ];
        };
        FixedHeaderTableDirective.propDecorators = {
            dataset: [{ type: i0.Input }],
            tableHeight: [{ type: i0.Input }],
            tablePaging: [{ type: i0.Output }]
        };
        return FixedHeaderTableDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FixedHeaderTableModule = /** @class */ (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: [
                            FixedHeaderTableDirective
                        ],
                        declarations: [
                            FixedHeaderTableDirective
                        ]
                    },] }
        ];
        return FixedHeaderTableModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var FloatLabelDirective = /** @class */ (function () {
        function FloatLabelDirective(_elementRef, _renderer, _autofillMonitor) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._autofillMonitor = _autofillMonitor;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
            this._subscription = new rxjs.Subscription();
        }
        Object.defineProperty(FloatLabelDirective.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input;
            },
            set: /**
             * @param {?} input
             * @return {?}
             */ function (input) {
                var _this = this;
                // remove any previous autofill subscriptions
                if (this._input) {
                    this._autofillMonitor.stopMonitoring(this._input);
                }
                this._subscription.unsubscribe();
                this._input = input;
                // if the input is null then don't need to subscribe to autofillMonitor
                if (!input) {
                    return;
                }
                // create a new autofillMonitor subscription
                this._subscription = this._autofillMonitor.monitor(input).subscribe(function (event) {
                    if (!_this.raised && event.isAutofilled) {
                        _this.raised = true;
                    }
                    if (_this.raised && !event.isAutofilled && !_this.hasText()) {
                        _this.raised = false;
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
                // Check initial input value
                this.raised = this.hasText();
                // Ensure that the `for` attribute is set
                if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                if (!(this.mode === 'focus' && this._focused)) {
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // Unsubscribe event handles
                this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
                this._autofillMonitor.stopMonitoring(this._input);
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.hasText = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined) {
                    return !!this.input.value;
                }
                return !!this.value;
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputFocus = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = true;
                    this.raised = true;
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputBlur = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = false;
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputChange = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'input') {
                    this.raised = this.hasText();
                }
            };
        FloatLabelDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxFloatLabel]',
                        host: {
                            'class': 'ux-float-label'
                        }
                    },] }
        ];
        /** @nocollapse */
        FloatLabelDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: textField.AutofillMonitor }
            ];
        };
        FloatLabelDirective.propDecorators = {
            input: [{ type: i0.Input, args: ['uxFloatLabel',] }],
            value: [{ type: i0.Input }],
            mode: [{ type: i0.Input }],
            raised: [{ type: i0.HostBinding, args: ['class.ux-float-label-raised',] }]
        };
        return FloatLabelDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FloatLabelModule = /** @class */ (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [FloatLabelDirective],
                        declarations: [FloatLabelDirective],
                        providers: [],
                    },] }
        ];
        return FloatLabelModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HelpCenterService = /** @class */ (function () {
        function HelpCenterService() {
            this.items = new rxjs.BehaviorSubject([]);
        }
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.registerItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                /** @type {?} */
                var items = this.items.getValue();
                // add the new item to the list
                items.push(item);
                // update the observable
                this.items.next(items);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.unregisterItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                /** @type {?} */
                var items = this.items.getValue();
                // remove the item being unregistered
                items = items.filter(function (itm) { return itm !== item; });
                // update the observable
                this.items.next(items);
            };
        HelpCenterService.decorators = [
            { type: i0.Injectable }
        ];
        return HelpCenterService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HelpCenterItemDirective = /** @class */ (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // register the item in the service
                this._helpCenterService.registerItem(this.uxHelpCenterItem);
            };
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // remove this item when it is destroyed
                this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
            };
        HelpCenterItemDirective.decorators = [
            { type: i0.Directive, args: [{ selector: '[uxHelpCenterItem]' },] }
        ];
        /** @nocollapse */
        HelpCenterItemDirective.ctorParameters = function () {
            return [
                { type: HelpCenterService }
            ];
        };
        HelpCenterItemDirective.propDecorators = {
            uxHelpCenterItem: [{ type: i0.Input }]
        };
        return HelpCenterItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HelpCenterModule = /** @class */ (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [HelpCenterItemDirective],
                        declarations: [HelpCenterItemDirective],
                        providers: [HelpCenterService],
                    },] }
        ];
        return HelpCenterModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HoverActionService = /** @class */ (function () {
        function HoverActionService() {
            this.active = new rxjs.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.register = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions.push(action);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.unregister = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions = this._actions.filter(function (actn) { return actn !== action; });
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        HoverActionService.prototype.setFocusState = /**
         * @param {?} focus
         * @return {?}
         */
            function (focus) {
                this._focused = focus;
                this.updateVisibility();
            };
        /**
         * @param {?} hover
         * @return {?}
         */
        HoverActionService.prototype.setHoverState = /**
         * @param {?} hover
         * @return {?}
         */
            function (hover) {
                this._hovered = hover;
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.updateVisibility = /**
         * @return {?}
         */
            function () {
                this.active.next(this._focused || this._hovered || this.actionHasFocus());
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.actionHasFocus = /**
         * @return {?}
         */
            function () {
                return !!this.getFocusedAction();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedAction = /**
         * @return {?}
         */
            function () {
                return this._actions.find(function (action) { return action.focused; });
            };
        HoverActionService.decorators = [
            { type: i0.Injectable }
        ];
        return HoverActionService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HoverActionContainerDirective = /** @class */ (function () {
        function HoverActionContainerDirective(_elementRef, _managedFocusContainerService, _hoverActionService) {
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            this._onDestroy = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Watch for focus within the container element and manage tabindex of descendants
                this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
                // Track focus and update state for the child directives
                this._managedFocusContainerService.hasFocus(this._elementRef.nativeElement)
                    .pipe(operators.takeUntil(this._onDestroy)).subscribe(function (active) {
                    _this.active = active;
                    _this._hoverActionService.setFocusState(active);
                });
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onHover = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onLeave = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(false);
            };
        HoverActionContainerDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxHoverActionContainer]',
                        providers: [HoverActionService]
                    },] }
        ];
        /** @nocollapse */
        HoverActionContainerDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ManagedFocusContainerService },
                { type: HoverActionService }
            ];
        };
        HoverActionContainerDirective.propDecorators = {
            tabindex: [{ type: i0.Input }, { type: i0.HostBinding, args: ['tabindex',] }],
            active: [{ type: i0.HostBinding, args: ['class.hover-action-container-active',] }],
            onHover: [{ type: i0.HostListener, args: ['mouseenter',] }],
            onLeave: [{ type: i0.HostListener, args: ['mouseleave',] }]
        };
        return HoverActionContainerDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var HoverActionDirective = /** @class */ (function () {
        function HoverActionDirective(_elementRef, _hoverActionService, focusIndicatorService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            this.focused = false;
            this._onDestroy = new rxjs.Subject();
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this._hoverActionService.active.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
                this._hoverActionService.unregister(this);
                this._focusIndicator.destroy();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this.focused = true;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this.focused = false;
                this._hoverActionService.updateVisibility();
            };
        HoverActionDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxHoverAction]'
                    },] }
        ];
        /** @nocollapse */
        HoverActionDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: HoverActionService },
                { type: FocusIndicatorService }
            ];
        };
        HoverActionDirective.propDecorators = {
            tabindex: [{ type: i0.Input }, { type: i0.HostBinding, args: ['tabindex',] }],
            active: [{ type: i0.HostBinding, args: ['class.hover-action-active',] }],
            focused: [{ type: i0.HostBinding, args: ['class.hover-action-focused',] }],
            onFocus: [{ type: i0.HostListener, args: ['focus',] }],
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return HoverActionDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = /** @class */ (function () {
        function HoverActionModule() {
        }
        HoverActionModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule
                        ],
                        exports: DECLARATIONS$8,
                        declarations: DECLARATIONS$8
                    },] }
        ];
        return HoverActionModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var LayoutSwitcherItemDirective = /** @class */ (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getLayout = /**
         * @return {?}
         */
            function () {
                return this._templateRef;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getConfig = /**
         * @return {?}
         */
            function () {
                return this._config;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.activate = /**
         * @return {?}
         */
            function () {
                this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.deactivate = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var index = this._viewContainerRef.indexOf(this._embeddedView);
                this._viewContainerRef.remove(index);
                this._embeddedView = null;
            };
        LayoutSwitcherItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxLayoutSwitcherItem]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherItemDirective.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        LayoutSwitcherItemDirective.propDecorators = {
            _config: [{ type: i0.Input, args: ['uxLayoutSwitcherItem',] }]
        };
        return LayoutSwitcherItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var LayoutSwitcherDirective = /** @class */ (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // if the active group has changed then render the appropriate layout
                if (changes.group.currentValue !== changes.group.previousValue) {
                    this.updateActiveLayout();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.getActiveLayout = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there are currently no layouts then do nothing
                if (!this._layouts) {
                    return null;
                }
                // otherwise find layouts that match the active group and that meet the constraints
                return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                    /** @type {?} */
                    var minWidth = layout.getConfig().minWidth || 0;
                    /** @type {?} */
                    var maxWidth = layout.getConfig().maxWidth || Infinity;
                    return _this._width >= minWidth && _this._width < maxWidth;
                });
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.updateActiveLayout = /**
         * @return {?}
         */
            function () {
                // get the layout that should be shown
                /** @type {?} */
                var layout = this.getActiveLayout();
                // check if we are currently showing the layout
                if (this._activeLayout === layout) {
                    return;
                }
                // remove the current layout
                if (this._activeLayout) {
                    this._activeLayout.deactivate();
                }
                // store the new active layout
                this._activeLayout = layout;
                // if there is an active layout then activate
                if (this._activeLayout) {
                    this._activeLayout.activate();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // store the initial current element width
                this._width = this._elementRef.nativeElement.offsetWidth;
                // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
                requestAnimationFrame(this.updateActiveLayout.bind(this));
            };
        LayoutSwitcherDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxLayoutSwitcher]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResizeService },
                { type: i0.ViewContainerRef }
            ];
        };
        LayoutSwitcherDirective.propDecorators = {
            group: [{ type: i0.Input }],
            _layouts: [{ type: i0.ContentChildren, args: [LayoutSwitcherItemDirective,] }]
        };
        return LayoutSwitcherDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = /** @class */ (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: DECLARATIONS$9,
                        declarations: DECLARATIONS$9,
                        providers: [],
                    },] }
        ];
        return LayoutSwitcherModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuNavigationService = /** @class */ (function () {
        function MenuNavigationService() {
            /**
             * Store a list of items that belong to this menu
             */
            this.menuItems = [];
            /**
             * Store the current active menu item
             */
            this.active$ = new rxjs.BehaviorSubject(null);
        }
        /** Add an item to this menu */
        /**
         * Add an item to this menu
         * @param {?} menuItem
         * @return {?}
         */
        MenuNavigationService.prototype.register = /**
         * Add an item to this menu
         * @param {?} menuItem
         * @return {?}
         */
            function (menuItem) {
                this.menuItems = __spread(this.menuItems, [menuItem]);
            };
        /** Remove an item from the list of menu items */
        /**
         * Remove an item from the list of menu items
         * @param {?} menuItem
         * @return {?}
         */
        MenuNavigationService.prototype.unregister = /**
         * Remove an item from the list of menu items
         * @param {?} menuItem
         * @return {?}
         */
            function (menuItem) {
                this.menuItems = this.menuItems.filter(function (_menuItem) { return _menuItem !== menuItem; });
            };
        MenuNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        return MenuNavigationService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuNavigationItemDirective = /** @class */ (function () {
        function MenuNavigationItemDirective(_menuNavigationService, _elementRef, focusIndicatorService) {
            var _this = this;
            this._menuNavigationService = _menuNavigationService;
            this._elementRef = _elementRef;
            /**
             * Emit when this menu is activated
             */
            this.activated = new i0.EventEmitter();
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
            // register this item with the menu - this allows for nested menus as we each uxMenuNavigation will create its own service
            _menuNavigationService.register(this);
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement, { programmaticFocusIndicator: true, checkChildren: false });
            /** Subscribe to the current active index */
            _menuNavigationService.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (item) { return item === _this; })).subscribe(function () { return _this.setActive(); });
        }
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._menuNavigationService.unregister(this);
                this._onDestroy.unsubscribe();
                this._focusIndicator.destroy();
            };
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.setActive = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
                this.activated.emit();
            };
        MenuNavigationItemDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMenuNavigationItem]'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationItemDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService },
                { type: i0.ElementRef },
                { type: FocusIndicatorService }
            ];
        };
        MenuNavigationItemDirective.propDecorators = {
            activated: [{ type: i0.Output }]
        };
        return MenuNavigationItemDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuNavigationToggleDirective = /** @class */ (function () {
        function MenuNavigationToggleDirective(elementRef, focusIndicatorService) {
            /**
             * Define the position the menu appears relative to the button
             */
            this.menuPosition = 'bottom';
            /**
             * Emit when the menu open state changes
             */
            this.menuOpenChange = new i0.EventEmitter();
            /**
             * Emits whenever a key that opens the menu is pressed
             */
            this.keyEnter = new i0.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            /** Define if the menu is open */
            get: /**
             * Define if the menu is open
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusIndicator.destroy();
            };
        /**
         * @param {?=} origin
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.focus = /**
         * @param {?=} origin
         * @return {?}
         */
            function (origin) {
                this._focusIndicator.focus(origin);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                if (this.isKeyMatch(event.which)) {
                    // Open the menu
                    this.menuOpen = true;
                    // Allow the menu to init, then send the event to give it focus
                    setTimeout(function () { return _this.keyEnter.emit(); });
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.isKeyMatch = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                switch (key) {
                    case keycodes.ENTER:
                    case keycodes.SPACE:
                        return true;
                    case keycodes.UP_ARROW:
                        return this.menuPosition === 'top';
                    case keycodes.DOWN_ARROW:
                        return this.menuPosition === 'bottom';
                    case keycodes.LEFT_ARROW:
                        return this.menuPosition === 'left';
                    case keycodes.RIGHT_ARROW:
                        return this.menuPosition === 'right';
                }
                return false;
            };
        MenuNavigationToggleDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMenuNavigationToggle]',
                        exportAs: 'uxMenuNavigationToggle'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationToggleDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: FocusIndicatorService }
            ];
        };
        MenuNavigationToggleDirective.propDecorators = {
            menuOpen: [{ type: i0.Input }],
            menuPosition: [{ type: i0.Input }],
            menuOpenChange: [{ type: i0.Output }],
            keyEnter: [{ type: i0.Output }],
            keydownHandler: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuNavigationToggleDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var MenuNavigationDirective = /** @class */ (function () {
        function MenuNavigationDirective(_menuNavigationService) {
            this._menuNavigationService = _menuNavigationService;
            /**
             * Define the position of the toggle button relative to the menu
             */
            this.toggleButtonPosition = 'top';
            /**
             * Emit when the menu is no longer focused
             */
            this.navigatedOut = new i0.EventEmitter();
            /**
             * Determine if the menu currently has focus
             */
            this._isFocused = false;
            /**
             * Unsubscribe from all observables on destroy
             */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            /** Get the index of the currently active item */
            get: /**
             * Get the index of the currently active item
             * @return {?}
             */ function () {
                return this.menuItems.indexOf(this._menuNavigationService.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuNavigationDirective.prototype, "menuItems", {
            // get the list of menu items
            get: 
            // get the list of menu items
            /**
             * @return {?}
             */
            function () {
                return this._menuNavigationService.menuItems;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.toggleButton) {
                    this.toggleButton.keyEnter.pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function () { return _this.focusFirst(); });
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.focusFirst = /**
         * @return {?}
         */
            function () {
                this.moveFirst();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.onFocusIn = /**
         * @return {?}
         */
            function () {
                this._isFocused = true;
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.onFocusOut = /**
         * @return {?}
         */
            function () {
                this._isFocused = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Only handle events when focus in within the list of menu items
                if (this._isFocused === false) {
                    return;
                }
                /** @type {?} */
                var handled = false;
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        this.movePrevious(event);
                        handled = true;
                        break;
                    case keycodes.DOWN_ARROW:
                        this.moveNext(event);
                        handled = true;
                        break;
                    case keycodes.LEFT_ARROW:
                        if (this.toggleButtonPosition === 'left') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (this.toggleButtonPosition === 'right') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case keycodes.HOME:
                        this.moveFirst();
                        handled = true;
                        break;
                    case keycodes.END:
                        this.moveLast();
                        handled = true;
                        break;
                    case keycodes.ESCAPE:
                        this.moveToToggleButton(event);
                        handled = true;
                        break;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveNext = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                /** @type {?} */
                var nextIndex = this.activeIndex + 1;
                if (nextIndex < this.menuItems.length) {
                    // Activate the next menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._menuNavigationService.active$.next(this.menuItems[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'bottom') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.movePrevious = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                /** @type {?} */
                var nextIndex = this.activeIndex - 1;
                if (nextIndex >= 0) {
                    // Activate the previous menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._menuNavigationService.active$.next(this.menuItems[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'top') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveFirst = /**
         * @return {?}
         */
            function () {
                if (this.menuItems.length > 0) {
                    this._menuNavigationService.active$.next(this.menuItems[0]);
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveLast = /**
         * @return {?}
         */
            function () {
                if (this.menuItems.length > 0) {
                    this._menuNavigationService.active$.next(this.menuItems[this.menuItems.length - 1]);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveToToggleButton = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.toggleButton) {
                    this.toggleButton.focus('keyboard');
                    this.toggleButton.menuOpen = false;
                }
                this.navigatedOut.emit(event);
            };
        MenuNavigationDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxMenuNavigation]',
                        exportAs: 'uxMenuNavigation',
                        providers: [MenuNavigationService]
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService }
            ];
        };
        MenuNavigationDirective.propDecorators = {
            toggleButton: [{ type: i0.Input }],
            toggleButtonPosition: [{ type: i0.Input }],
            navigatedOut: [{ type: i0.Output }],
            onFocusIn: [{ type: i0.HostListener, args: ['focusin',] }],
            onFocusOut: [{ type: i0.HostListener, args: ['focusout',] }],
            keydownHandler: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuNavigationDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPORTS$1 = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = /** @class */ (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            AccessibilityModule
                        ],
                        exports: EXPORTS$1,
                        declarations: EXPORTS$1,
                    },] }
        ];
        return MenuNavigationModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var OverflowDirective = /** @class */ (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow overflow to be within a range before emitting
             */
            this.tolerance = 0;
            /**
             * Emit when there is a change to the overflow state - horizontal or vertical
             */
            this.uxOverflowObserver = new i0.EventEmitter();
            /**
             * Emit when there is a change to overflow on the horizontal axis
             */
            this.uxOverflowHorizontalObserver = new i0.EventEmitter();
            /**
             * Emit when there is a change to overflow on the vertical axis
             */
            this.uxOverflowVerticalObserver = new i0.EventEmitter();
            /**
             * Store the overflow state on both axis
             */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /**
             * Unsubscribe from all the observables
             */
            this._onDestroy = new rxjs.Subject();
        }
        /** Set up the trigger if specified */
        /**
         * Set up the trigger if specified
         * @return {?}
         */
        OverflowDirective.prototype.ngOnInit = /**
         * Set up the trigger if specified
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.trigger) {
                    this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
                }
            };
        /** Perform an intial check for overflow */
        /**
         * Perform an intial check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.ngAfterViewInit = /**
         * Perform an intial check for overflow
         * @return {?}
         */
            function () {
                var _this = this;
                requestAnimationFrame(function () { return _this.checkForOverflow(); });
            };
        /** Unsubscribe from the trigger */
        /**
         * Unsubscribe from the trigger
         * @return {?}
         */
        OverflowDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from the trigger
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Programmatically trigger check for overflow */
        /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.checkForOverflow = /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
            function () {
                var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
                /** @type {?} */
                var horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
                /** @type {?} */
                var verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
                if (horizontalOverflow !== this._state.horizontalOverflow) {
                    this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
                }
                if (verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowVerticalObserver.emit(verticalOverflow);
                }
                if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
                }
                // store the state
                this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
            };
        OverflowDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                        exportAs: 'ux-overflow-observer'
                    },] }
        ];
        /** @nocollapse */
        OverflowDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        OverflowDirective.propDecorators = {
            trigger: [{ type: i0.Input }],
            tolerance: [{ type: i0.Input }],
            uxOverflowObserver: [{ type: i0.Output }],
            uxOverflowHorizontalObserver: [{ type: i0.Output }],
            uxOverflowVerticalObserver: [{ type: i0.Output }]
        };
        return OverflowDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ObserversModule = /** @class */ (function () {
        function ObserversModule() {
        }
        ObserversModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [OverflowDirective],
                        declarations: [OverflowDirective]
                    },] }
        ];
        return ObserversModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridState = /** @class */ (function () {
        function TreeGridState(level, setSize, positionInSet) {
            this.level = level;
            this.setSize = setSize;
            this.positionInSet = positionInSet;
            this.loading$ = new rxjs.BehaviorSubject(false);
        }
        return TreeGridState;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridService = /** @class */ (function () {
        function TreeGridService(_changeDetector) {
            var _this = this;
            this._changeDetector = _changeDetector;
            /**
             * The raw table data
             */
            this.data$ = new rxjs.BehaviorSubject([]);
            /**
             * The flattened table data
             */
            this.rows$ = new rxjs.BehaviorSubject([]);
            /**
             * Ensure we destroy all observables correctly
             */
            this._onDestroy = new rxjs.Subject();
            this.data$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (data) { return _this.rows$.next(_this.getFlattenedTree(data)); });
        }
        /** Unsubscribe from all observables */
        /**
         * Unsubscribe from all observables
         * @return {?}
         */
        TreeGridService.prototype.ngOnDestroy = /**
         * Unsubscribe from all observables
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set the expanded state of a row */
        /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
        TreeGridService.prototype.setExpanded = /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
            function (item, expanded) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!expanded)
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, this.getChildren(item)];
                            case 1:
                                _a.sent();
                                this.insertChildren(item);
                                return [3 /*break*/, 3];
                            case 2:
                                this.removeChildren(item);
                                _a.label = 3;
                            case 3:
                                this._changeDetector.detectChanges();
                                return [2 /*return*/];
                        }
                    });
                });
            };
        /** A function to flatten tree data */
        /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
        TreeGridService.prototype.getFlattenedTree = /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
            function (data, parent) {
                var _this = this;
                // flatten the nodes at this level
                return data.reduce(function (previous, item, index) {
                    item.state = new TreeGridState(parent ? parent.state.level + 1 : 0, data.length, index + 1);
                    // Convert any child nodes
                    /** @type {?} */
                    var children = (item.children && item.expanded) ? _this.getFlattenedTree(item.children, item) : [];
                    // return the nodes in a flattened array
                    return __spread(previous, [item], children);
                }, []);
            };
        /** Load any children dynamically */
        /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
        TreeGridService.prototype.getChildren = /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!(!item.children && this.loadChildren))
                                    return [3 /*break*/, 4];
                                item.state.loading$.next(true);
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, , 3, 4]);
                                _a = item;
                                return [4 /*yield*/, this.getNormalizedChildren(this.loadChildren(item))];
                            case 2:
                                _a.children = _b.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                item.state.loading$.next(false);
                                return [7 /*endfinally*/];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
        /** We want to support an array, a promise and an observable. This will return all types as a promise */
        /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
        TreeGridService.prototype.getNormalizedChildren = /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
            function (response) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!rxjs.isObservable(response))
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, response.toPromise()];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                if (!(response instanceof Promise))
                                    return [3 /*break*/, 4];
                                return [4 /*yield*/, response];
                            case 3: return [2 /*return*/, _a.sent()];
                            case 4:
                                // if it is an array then make it an observable
                                return [2 /*return*/, response];
                        }
                    });
                });
            };
        /** Insert the children into the flattened tree at the correct location */
        /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.insertChildren = /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                if (!parent.children) {
                    return;
                }
                /** @type {?} */
                var row = this.rows$.getValue();
                /** @type {?} */
                var index = row.indexOf(parent);
                if (index < 0) {
                    return;
                }
                // Skip duplicates - this could happen if an already expanded child has been inserted
                /** @type {?} */
                var uniqueChildren = parent.children.filter(function (child) { return row.indexOf(child) === -1; });
                /** @type {?} */
                var childRows = this.getFlattenedTree(uniqueChildren, parent);
                row.splice.apply(row, __spread([index + 1, 0], childRows));
            };
        /** Remove all rows from the flattened tree */
        /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.removeChildren = /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                /** @type {?} */
                var rows = this.rows$.getValue();
                /** @type {?} */
                var index = rows.indexOf(parent);
                if (index < 0) {
                    return;
                }
                while (index + 1 < rows.length && rows[index + 1].state.level > parent.state.level) {
                    rows.splice(index + 1, 1);
                }
            };
        TreeGridService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        TreeGridService.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        return TreeGridService;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridRowDirective = /** @class */ (function () {
        function TreeGridRowDirective(_treeGridService) {
            var _this = this;
            this._treeGridService = _treeGridService;
            this.expandedChange = new i0.EventEmitter();
            this.loading = false;
            this.isExpanded = false;
            this._expanded$ = new rxjs.BehaviorSubject(false);
            this._onDestroy = new rxjs.Subject();
            this._expanded$.pipe(operators.skip(1), tick(), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                _this.expandedChange.emit(expanded);
                _this._treeGridService.setExpanded(_this.item, expanded);
                _this.isExpanded = expanded;
            });
        }
        Object.defineProperty(TreeGridRowDirective.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded$.getValue();
            },
            set: /**
             * @param {?} expanded
             * @return {?}
             */ function (expanded) {
                this._expanded$.next(!!expanded);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.item || !this.item.state) {
                    throw new Error('uxTreeGridRow should be configured with an object emitted by uxTreeGrid.rows.');
                }
                this.item.state.loading$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (loading) { return _this.loading = loading; });
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.collapse = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.expand = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                // take into account whether or not the item can expanded
                this.expanded = this.canExpand && true;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.expanded ? this.collapse() : this.expand();
            };
        TreeGridRowDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTreeGridRow]',
                        exportAs: 'uxTreeGridRow',
                        host: {
                            '[class.treegrid-row]': 'true'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridRowDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridRowDirective.propDecorators = {
            item: [{ type: i0.Input, args: ['uxTreeGridRow',] }],
            canExpand: [{ type: i0.Input }],
            expanded: [{ type: i0.Input }],
            expandedChange: [{ type: i0.Output }],
            loading: [{ type: i0.HostBinding, args: ['class.treegrid-row-loading',] }],
            isExpanded: [{ type: i0.HostBinding, args: ['class.treegrid-row-expanded',] }],
            collapse: [{ type: i0.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            expand: [{ type: i0.HostListener, args: ['keydown.ArrowRight', ['$event'],] }]
        };
        return TreeGridRowDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridIndentDirective = /** @class */ (function () {
        function TreeGridIndentDirective(_row) {
            this._row = _row;
        }
        Object.defineProperty(TreeGridIndentDirective.prototype, "indentation", {
            /** The padding value applied to each level */
            get: /**
             * The padding value applied to each level
             * @return {?}
             */ function () {
                return this._row && this._row.item ? 7 + (this._row.item.state.level * (this.uxTreeGridIndent || 25)) : 7;
            },
            enumerable: true,
            configurable: true
        });
        TreeGridIndentDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTreeGridIndent]',
                    },] }
        ];
        /** @nocollapse */
        TreeGridIndentDirective.ctorParameters = function () {
            return [
                { type: TreeGridRowDirective }
            ];
        };
        TreeGridIndentDirective.propDecorators = {
            uxTreeGridIndent: [{ type: i0.Input }],
            indentation: [{ type: i0.HostBinding, args: ['style.padding-left.px',] }]
        };
        return TreeGridIndentDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridDirective = /** @class */ (function () {
        function TreeGridDirective(_treeGridService) {
            this._treeGridService = _treeGridService;
            this.rowsChange = new i0.EventEmitter();
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(TreeGridDirective.prototype, "data", {
            set: /**
             * @param {?} data
             * @return {?}
             */ function (data) {
                this._treeGridService.data$.next(data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeGridDirective.prototype, "loadChildren", {
            set: /**
             * @param {?} loadChildren
             * @return {?}
             */ function (loadChildren) {
                this._treeGridService.loadChildren = loadChildren;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._treeGridService.rows$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (rows) { return _this.rowsChange.emit(rows); });
            };
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        TreeGridDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[uxTreeGrid]',
                        providers: [TreeGridService],
                        host: {
                            class: 'treegrid'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridDirective.propDecorators = {
            data: [{ type: i0.Input, args: ['uxTreeGrid',] }],
            loadChildren: [{ type: i0.Input }],
            rows: [{ type: i0.Input }],
            rowsChange: [{ type: i0.Output }]
        };
        return TreeGridDirective;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TreeGridModule = /** @class */ (function () {
        function TreeGridModule() {
        }
        TreeGridModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ],
                        exports: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ]
                    },] }
        ];
        return TreeGridModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var StringFilterPipe = /** @class */ (function () {
        function StringFilterPipe() {
        }
        /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
        StringFilterPipe.prototype.transform = /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
            function (items, value) {
                if (!items) {
                    return [];
                }
                return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
            };
        StringFilterPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'stringFilter'
                    },] },
            { type: i0.Injectable }
        ];
        return StringFilterPipe;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var StringFilterModule = /** @class */ (function () {
        function StringFilterModule() {
        }
        StringFilterModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [StringFilterPipe],
                        declarations: [StringFilterPipe]
                    },] }
        ];
        return StringFilterModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ɵ0$3 = function () { };
    /** @type {?} */
    var timelineDefaultOptions = {
        timeline: {
            backgroundColor: '#f1f2f3',
            selectionColor: 'rgba(198, 23, 157, 0.15)',
            onChange: ɵ0$3,
            keyboard: {
                step: 2592000000 // 30 days
            },
            handles: {
                backgroundColor: '#000',
                foregroundColor: '#dcdedf',
                focusIndicatorColor: 'rgba(0, 115, 231, 0.5)'
            },
            range: {
                lower: null,
                upper: null,
                minimum: 0,
                maximum: Infinity
            },
            state: {
                lowerHandleFocus: false,
                upperHandleFocus: false,
                rangeHandleFocus: false
            }
        }
    };
    var TimelineChartPlugin = /** @class */ (function () {
        function TimelineChartPlugin() {
        }
        /** Register this plugin */
        /**
         * Register this plugin
         * @return {?}
         */
        TimelineChartPlugin.register = /**
         * Register this plugin
         * @return {?}
         */
            function () {
                /**
                 * We have to register this plugin globally because
                 * ng2-charts doesn't support plugins on an invidual
                 * basis. We must check in all lifecycle hooks that
                 * it is an timeline chart before performing any actions.
                 *
                 * We also need to have it inside the class otherwise it
                 * will be included in every application by default.
                 * Having it here allows it to be tree-shaken.
                 */
                if (!this._isRegistered) {
                    if (!(( /** @type {?} */(window))).Chart) {
                        throw new Error('Please import Chart.js to use the timeline chart.');
                    }
                    // register the plugin
                    (( /** @type {?} */(window))).Chart.pluginService.register(new TimelineChartPlugin());
                    this._isRegistered = true;
                }
            };
        /**
         * When chart is initialised store the chart instance and context
         * for use outside lifecycle hooks.
         *
         * We should also supply default options for any options that have
         * not been specified by the consuming application.
         *
         * We also need to add some event listeners for events that Chart.js
         * does not inform us of.
         */
        /**
         * When chart is initialised store the chart instance and context
         * for use outside lifecycle hooks.
         *
         * We should also supply default options for any options that have
         * not been specified by the consuming application.
         *
         * We also need to add some event listeners for events that Chart.js
         * does not inform us of.
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.beforeInit = /**
         * When chart is initialised store the chart instance and context
         * for use outside lifecycle hooks.
         *
         * We should also supply default options for any options that have
         * not been specified by the consuming application.
         *
         * We also need to add some event listeners for events that Chart.js
         * does not inform us of.
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                var _this = this;
                // provide the default options for any missing properties
                if (this.getEnabled(chart)) {
                    // chart.config.options.timeline = { ...timelineDefaultOptions.timeline, ...this.getOptions(chart) };
                    chart.config.options.timeline = this.getOptionsWithDefaults(this.getOptions(chart));
                    // get the range
                    var _a = this.getRange(chart), lower = _a.lower, upper = _a.upper;
                    // ensure we have an initial range set
                    if (lower === null || upper === null) {
                        throw new Error('Timeline Chart - Ensure that both an upper and lower range are initially provided.');
                    }
                    // setup the function
                    chart.config.options.timeline.state.onMouseDown = function () { return _this.onMouseDown(chart); };
                    chart.config.options.timeline.state.onMouseUp = function () { return _this.onMouseUp(chart); };
                    // add mouse down and mouseup event listeners
                    chart.canvas.addEventListener('mousedown', chart.config.options.timeline.state.onMouseDown);
                    document.addEventListener('mouseup', chart.config.options.timeline.state.onMouseUp);
                }
            };
        /**
         * We want to setup some additional functionality
         * after the chart has initialized.
         */
        /**
         * We want to setup some additional functionality
         * after the chart has initialized.
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.afterInit = /**
         * We want to setup some additional functionality
         * after the chart has initialized.
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                if (this.getEnabled(chart)) {
                    // add accessibility attributes and elements to the chart
                    this.setupAccessibility(chart);
                    // intially call the onChange function
                    this.triggerOnChange(chart);
                }
            };
        /**
         * The timeline chart should have a subtle background
         * color behind the main chart area (excluding the axis area).
         * Suprisingly Chart.js does not support this out of the box
         * so we need to add this functionality but it should be behind
         * all chart elements.
         */
        /**
         * The timeline chart should have a subtle background
         * color behind the main chart area (excluding the axis area).
         * Suprisingly Chart.js does not support this out of the box
         * so we need to add this functionality but it should be behind
         * all chart elements.
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.beforeDraw = /**
         * The timeline chart should have a subtle background
         * color behind the main chart area (excluding the axis area).
         * Suprisingly Chart.js does not support this out of the box
         * so we need to add this functionality but it should be behind
         * all chart elements.
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                if (this.getEnabled(chart)) {
                    this.drawBackgroundColor(chart);
                }
            };
        /**
         * Once the Chart elements have been drawn we want to draw the drag
         * handles and the overlay showing the selected region
         */
        /**
         * Once the Chart elements have been drawn we want to draw the drag
         * handles and the overlay showing the selected region
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.afterDraw = /**
         * Once the Chart elements have been drawn we want to draw the drag
         * handles and the overlay showing the selected region
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                if (this.getEnabled(chart)) {
                    this.drawSelection(chart);
                    this.drawHandles(chart);
                }
            };
        /**
         * We want to update the cursor whenever the mouse is over
         * one of the drag handles. We have do calculate this manually
         * as there are no DOM element to add CSS to.
         */
        /**
         * We want to update the cursor whenever the mouse is over
         * one of the drag handles. We have do calculate this manually
         * as there are no DOM element to add CSS to.
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
        TimelineChartPlugin.prototype.afterEvent = /**
         * We want to update the cursor whenever the mouse is over
         * one of the drag handles. We have do calculate this manually
         * as there are no DOM element to add CSS to.
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
            function (chart, event) {
                // skip this if timeline is not enabled
                if (!this.getEnabled(chart)) {
                    return;
                }
                switch (event.type) {
                    case 'mousemove':
                        this.setCursor(chart, ( /** @type {?} */(event)));
                        this.setRangeOnDrag(chart, ( /** @type {?} */(event)));
                        // store the latest mouse position
                        this.setState(chart, { mouseX: event.x });
                        break;
                    case 'mouseout':
                        this.resetCursor(chart);
                        break;
                }
            };
        /**
         * Unbind from the event listeners we manually set up
         */
        /**
         * Unbind from the event listeners we manually set up
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.destroy = /**
         * Unbind from the event listeners we manually set up
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                if (this.getEnabled(chart)) {
                    document.removeEventListener('mouseup', chart.config.options.timeline.state.onMouseUp, true);
                }
            };
        /** Get the timeline options from the chart instance */
        /**
         * Get the timeline options from the chart instance
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getOptions = /**
         * Get the timeline options from the chart instance
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                return chart.config.options.timeline;
            };
        /** Determine if this chart is using the timeline */
        /**
         * Determine if this chart is using the timeline
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getEnabled = /**
         * Determine if this chart is using the timeline
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                return !!this.getOptions(chart);
            };
        /** Get the timeline range from the chart instance */
        /**
         * Get the timeline range from the chart instance
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getRange = /**
         * Get the timeline range from the chart instance
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                return this.getOptions(chart).range;
            };
        /** Get the chart area but include any padding */
        /**
         * Get the chart area but include any padding
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getChartArea = /**
         * Get the chart area but include any padding
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                var _a = chart.chartArea, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
                /** @type {?} */
                var padding = chart.config.options.layout && chart.config.options.layout.padding ? chart.config.options.layout.padding : 0;
                if (typeof padding === 'number') {
                    return { top: top - padding, right: right - padding, left: left - padding, bottom: bottom - padding };
                }
                else if (typeof padding === 'object') {
                    return { top: top - padding.top, right: right - padding.right, left: left - padding.left, bottom: bottom - padding.bottom };
                }
                return chart.chartArea;
            };
        /** Get stored state inside the chart options */
        /**
         * Get stored state inside the chart options
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getState = /**
         * Get stored state inside the chart options
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                return this.getOptions(chart).state;
            };
        /** Store state inside the chart options */
        /**
         * Store state inside the chart options
         * @param {?} chart
         * @param {?} state
         * @return {?}
         */
        TimelineChartPlugin.prototype.setState = /**
         * Store state inside the chart options
         * @param {?} chart
         * @param {?} state
         * @return {?}
         */
            function (chart, state) {
                // store the latest state
                chart.config.options.timeline.state = __assign({}, chart.config.options.timeline.state, state);
                // trigger a chart re-render
                chart.update();
            };
        /** Call the callback with the latest range */
        /**
         * Call the callback with the latest range
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.triggerOnChange = /**
         * Call the callback with the latest range
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                // get the current date range
                var _a = this.getRange(chart), lower = _a.lower, upper = _a.upper;
                // get the callback function
                var onChange = this.getOptions(chart).onChange;
                // call the callback with the lower and upper values
                requestAnimationFrame(function () { return onChange(lower, upper); });
                // get the handle elements
                var _b = this.getState(chart), lowerHandleElement = _b.lowerHandleElement, upperHandleElement = _b.upperHandleElement;
                // update the aria properties
                lowerHandleElement.setAttribute('aria-valuemin', new Date(this.getHandleMinimum(chart, TimelineHandle.Lower)).toDateString());
                lowerHandleElement.setAttribute('aria-valuenow', lower.toDateString());
                lowerHandleElement.setAttribute('aria-valuemax', new Date(this.getHandleMaximum(chart, TimelineHandle.Lower)).toDateString());
                upperHandleElement.setAttribute('aria-valuemin', new Date(this.getHandleMinimum(chart, TimelineHandle.Upper)).toDateString());
                upperHandleElement.setAttribute('aria-valuenow', upper.toDateString());
                upperHandleElement.setAttribute('aria-valuemax', new Date(this.getHandleMaximum(chart, TimelineHandle.Upper)).toDateString());
            };
        /** To make the chart accessible add some internal elements that can be focused */
        /**
         * To make the chart accessible add some internal elements that can be focused
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.setupAccessibility = /**
         * To make the chart accessible add some internal elements that can be focused
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                var _this = this;
                // create the invisible elements
                /** @type {?} */
                var lowerHandle = document.createElement('div');
                /** @type {?} */
                var upperHandle = document.createElement('div');
                /** @type {?} */
                var rangeHandle = document.createElement('div');
                // make the items focusable
                lowerHandle.setAttribute('tabindex', '0');
                upperHandle.setAttribute('tabindex', '0');
                rangeHandle.setAttribute('tabindex', '0');
                // insert the elements
                chart.canvas.appendChild(lowerHandle);
                chart.canvas.appendChild(upperHandle);
                chart.canvas.appendChild(rangeHandle);
                // add the event handlers
                lowerHandle.addEventListener('focus', function () { return _this.setState(chart, { lowerHandleFocus: true }); });
                lowerHandle.addEventListener('blur', function () { return _this.setState(chart, { lowerHandleFocus: false }); });
                lowerHandle.addEventListener('keydown', function (event) { return _this.onKeydown(chart, event, TimelineHandle.Lower); });
                upperHandle.addEventListener('focus', function () { return _this.setState(chart, { upperHandleFocus: true }); });
                upperHandle.addEventListener('blur', function () { return _this.setState(chart, { upperHandleFocus: false }); });
                upperHandle.addEventListener('keydown', function (event) { return _this.onKeydown(chart, event, TimelineHandle.Upper); });
                rangeHandle.addEventListener('focus', function () { return _this.setState(chart, { rangeHandleFocus: true }); });
                rangeHandle.addEventListener('blur', function () { return _this.setState(chart, { rangeHandleFocus: false }); });
                rangeHandle.addEventListener('keydown', function (event) { return _this.onRangeKeydown(chart, event); });
                // store the items in the state object
                this.setState(chart, { lowerHandleElement: lowerHandle, upperHandleElement: upperHandle, rangeHandleElement: rangeHandle });
            };
        /** Handle keyboard accessibility events */
        /**
         * Handle keyboard accessibility events
         * @param {?} chart
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.onKeydown = /**
         * Handle keyboard accessibility events
         * @param {?} chart
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
            function (chart, event, handle) {
                // get the current value for the given handle
                /** @type {?} */
                var value = this.getHandleValue(chart, handle).getTime();
                /** @type {?} */
                var step = this.getOptions(chart).keyboard.step;
                var _a = __read(this.getChartRange(chart), 2), minimum = _a[0], maximum = _a[1];
                switch (event.keyCode) {
                    case keycodes.LEFT_ARROW:
                        this.setHandleValue(chart, handle, new Date(value - step));
                        event.preventDefault();
                        break;
                    case keycodes.HOME:
                        this.setHandleValue(chart, handle, new Date(minimum));
                        event.preventDefault();
                        break;
                    case keycodes.RIGHT_ARROW:
                        this.setHandleValue(chart, handle, new Date(value + step));
                        event.preventDefault();
                        break;
                    case keycodes.END:
                        this.setHandleValue(chart, handle, new Date(maximum));
                        event.preventDefault();
                        break;
                }
            };
        /**
         * Handle range changes made with the keyboard as these are exempt from
         * many of the validation checks that are required when dragging only one
         * handle at a time.
         */
        /**
         * Handle range changes made with the keyboard as these are exempt from
         * many of the validation checks that are required when dragging only one
         * handle at a time.
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
        TimelineChartPlugin.prototype.onRangeKeydown = /**
         * Handle range changes made with the keyboard as these are exempt from
         * many of the validation checks that are required when dragging only one
         * handle at a time.
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
            function (chart, event) {
                // get the current handle values
                /** @type {?} */
                var lowerValue = this.getHandleValue(chart, TimelineHandle.Lower).getTime();
                /** @type {?} */
                var upperValue = this.getHandleValue(chart, TimelineHandle.Upper).getTime();
                /** @type {?} */
                var step = this.getOptions(chart).keyboard.step;
                /** @type {?} */
                var difference = upperValue - lowerValue;
                // get the chart boundaries
                var _a = __read(this.getChartRange(chart), 2), minimum = _a[0], maximum = _a[1];
                switch (event.keyCode) {
                    case keycodes.LEFT_ARROW:
                        lowerValue = Math.max(lowerValue - step, minimum);
                        upperValue = lowerValue + difference;
                        event.preventDefault();
                        break;
                    case keycodes.RIGHT_ARROW:
                        upperValue = Math.min(upperValue + step, maximum);
                        lowerValue = upperValue - difference;
                        event.preventDefault();
                        break;
                    case keycodes.HOME:
                        lowerValue = minimum;
                        upperValue = lowerValue + difference;
                        event.preventDefault();
                        break;
                    case keycodes.END:
                        upperValue = maximum;
                        lowerValue = upperValue - difference;
                        event.preventDefault();
                        break;
                }
                // store the new values
                chart.config.options.timeline.range[TimelineHandle.Lower] = new Date(lowerValue);
                chart.config.options.timeline.range[TimelineHandle.Upper] = new Date(upperValue);
                // update the chart
                chart.update();
                // emit the latest range
                this.triggerOnChange(chart);
            };
        /**
         * When the mouse is first pressed within a chart we should see if we are
         * currently over a drag handle to start the dragging
         */
        /**
         * When the mouse is first pressed within a chart we should see if we are
         * currently over a drag handle to start the dragging
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.onMouseDown = /**
         * When the mouse is first pressed within a chart we should see if we are
         * currently over a drag handle to start the dragging
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                // get the position from the chart area
                var top = this.getChartArea(chart).top;
                // get the properties from the state
                var mouseX = this.getState(chart).mouseX;
                // check if the event started within a drag handle
                /** @type {?} */
                var handle = this.isWithinHandle(chart, { x: mouseX, y: top });
                // if it did then we are now dragging the handle and should store it
                this.setState(chart, { handle: handle !== null ? handle : null });
            };
        /** When the mouse is released we are no longer dragging */
        /**
         * When the mouse is released we are no longer dragging
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.onMouseUp = /**
         * When the mouse is released we are no longer dragging
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                if (chart.canvas) {
                    this.setState(chart, { handle: null });
                }
            };
        /** Update the range when dragged */
        /**
         * Update the range when dragged
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
        TimelineChartPlugin.prototype.setRangeOnDrag = /**
         * Update the range when dragged
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
            function (chart, event) {
                var _a = this.getState(chart), handle = _a.handle, mouseX = _a.mouseX;
                // if we are not dragging then do nothing
                if (handle === null) {
                    return;
                }
                // get the chart area
                var _b = this.getChartArea(chart), left = _b.left, right = _b.right;
                // get the current range
                var _c = this.getRange(chart), lower = _c.lower, upper = _c.upper;
                // get the difference in x position since the last mouse position
                /** @type {?} */
                var delta = event.x - mouseX;
                // get the width of the chart area
                /** @type {?} */
                var width = right - left;
                // get the time range on the x-axis
                var _d = __read(this.getChartRange(chart), 2), minimum = _d[0], maximum = _d[1];
                // determine how much of the time range was spanned in the move
                /** @type {?} */
                var percentageDiff = (delta / width) * 100;
                // calculate the time difference in the movement
                /** @type {?} */
                var valueDiff = (((maximum - minimum) / 100) * percentageDiff);
                if (handle === TimelineHandle.Lower) {
                    this.setHandleValue(chart, TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
                }
                if (handle === TimelineHandle.Upper) {
                    this.setHandleValue(chart, TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
                }
                if (handle === TimelineHandle.Range) {
                    // get the current range
                    /** @type {?} */
                    var range = upper.getTime() - lower.getTime();
                    // update the values
                    if (valueDiff < 0) {
                        this.setHandleValue(chart, TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
                        this.setHandleValue(chart, TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
                    }
                    else {
                        this.setHandleValue(chart, TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
                        this.setHandleValue(chart, TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
                    }
                    // calculate the new range
                    /** @type {?} */
                    var currentRange = chart.config.options.timeline.range.upper.getTime() - chart.config.options.timeline.range.lower.getTime();
                    // ensure the range is still the same
                    if (currentRange !== range) {
                        if (valueDiff < 0) {
                            this.setHandleValue(chart, TimelineHandle.Upper, new Date(chart.config.options.timeline.range.upper.getTime() + (range - currentRange)));
                        }
                        else {
                            this.setHandleValue(chart, TimelineHandle.Lower, new Date(chart.config.options.timeline.range.lower.getTime() + (currentRange - range)));
                        }
                    }
                }
            };
        /**
         * Draw the background color in the region that sits behind all the chart content
         */
        /**
         * Draw the background color in the region that sits behind all the chart content
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.drawBackgroundColor = /**
         * Draw the background color in the region that sits behind all the chart content
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                // get the region that the chart is drawn on (excluding axis)
                var _a = this.getChartArea(chart), top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
                // fill the background color
                chart.ctx.save();
                chart.ctx.fillStyle = ( /** @type {?} */(this.getOptions(chart).backgroundColor));
                chart.ctx.fillRect(left, top, right - left, bottom - top);
                chart.ctx.restore();
            };
        /** Draw the overlay that indicates the selected region */
        /**
         * Draw the overlay that indicates the selected region
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.drawSelection = /**
         * Draw the overlay that indicates the selected region
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                // get the region that the chart is drawn on (excluding axis)
                var _a = this.getChartArea(chart), top = _a.top, bottom = _a.bottom;
                // get the fill color
                /** @type {?} */
                var selectionColor = this.getOptions(chart).selectionColor;
                // get the focus indicator color
                var focusIndicatorColor = this.getOptions(chart).handles.focusIndicatorColor;
                // get the lower and upper handle render regions
                /** @type {?} */
                var lower = this.getHandleArea(chart, TimelineHandle.Lower);
                /** @type {?} */
                var upper = this.getHandleArea(chart, TimelineHandle.Upper);
                // draw selection region
                chart.ctx.save();
                chart.ctx.fillStyle = ( /** @type {?} */(selectionColor));
                chart.ctx.fillRect(lower.left, 0, upper.right - lower.left, bottom - top);
                // check if we are focused on the range handle
                if (this.isHandleFocused(chart, TimelineHandle.Range)) {
                    chart.ctx.strokeStyle = ( /** @type {?} */(focusIndicatorColor));
                    /** @type {?} */
                    var handleWidth = 4;
                    /** @type {?} */
                    var lineWidth = 2;
                    chart.ctx.lineWidth = lineWidth;
                    chart.ctx.strokeRect(lower.left + handleWidth + lineWidth, lineWidth / 2, (upper.right - lower.left) - ((handleWidth + lineWidth) * 2), (bottom - top) - lineWidth);
                }
                chart.ctx.restore();
            };
        /** Darw the drag handles */
        /**
         * Darw the drag handles
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.drawHandles = /**
         * Darw the drag handles
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                var _this = this;
                // get the region that the chart is drawn on (excluding axis)
                var _a = this.getChartArea(chart), top = _a.top, bottom = _a.bottom;
                // get the handle colors
                var _b = this.getOptions(chart).handles, backgroundColor = _b.backgroundColor, foregroundColor = _b.foregroundColor, focusIndicatorColor = _b.focusIndicatorColor;
                // draw each handle
                [TimelineHandle.Lower, TimelineHandle.Upper].forEach(function (handle) {
                    // get the area of the handle
                    /** @type {?} */
                    var area = _this.getHandleArea(chart, handle);
                    /** @type {?} */
                    var handleWidth = 5;
                    /** @type {?} */
                    var chartHeight = bottom - top;
                    chart.ctx.save();
                    // if the handle is focused draw an outline
                    if (_this.isHandleFocused(chart, handle)) {
                        chart.ctx.fillStyle = ( /** @type {?} */(focusIndicatorColor));
                        chart.ctx.fillRect(area.left - 2, 0, handleWidth + 4, chartHeight);
                    }
                    // draw the handle
                    chart.ctx.fillStyle = ( /** @type {?} */(backgroundColor));
                    chart.ctx.fillRect(area.left, 0, handleWidth, chartHeight);
                    // draw the 3 drag handles within the drag handle
                    chart.ctx.fillStyle = ( /** @type {?} */(foregroundColor));
                    // calculate size and position
                    /** @type {?} */
                    var width = 3;
                    /** @type {?} */
                    var height = 3;
                    /** @type {?} */
                    var x = area.left + (handleWidth - width) / 2;
                    /** @type {?} */
                    var midpoint = area.top + (chartHeight / 2);
                    /** @type {?} */
                    var topY = midpoint - (height * 2.5);
                    /** @type {?} */
                    var middleY = midpoint - (height / 2);
                    /** @type {?} */
                    var bottomY = midpoint + (height * 1.5);
                    chart.ctx.fillRect(x, topY, width, height);
                    chart.ctx.fillRect(x, middleY, width, height);
                    chart.ctx.fillRect(x, bottomY, width, height);
                    chart.ctx.restore();
                });
            };
        /**
         * Update the CSS cursor on the canvas element if we are hovering over a drag handle
         */
        /**
         * Update the CSS cursor on the canvas element if we are hovering over a drag handle
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
        TimelineChartPlugin.prototype.setCursor = /**
         * Update the CSS cursor on the canvas element if we are hovering over a drag handle
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
            function (chart, event) {
                // get the handle if we are hovering over one
                /** @type {?} */
                var handle = this.getState(chart).handle || this.isWithinHandle(chart, event);
                if (handle === TimelineHandle.Lower || handle === TimelineHandle.Upper) {
                    chart.canvas.style.cursor = 'ew-resize';
                }
                else if (handle === TimelineHandle.Range) {
                    chart.canvas.style.cursor = 'move';
                }
                else {
                    this.resetCursor(chart);
                }
            };
        // restore the cursor to the default
        // restore the cursor to the default
        /**
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.resetCursor =
            // restore the cursor to the default
            /**
             * @param {?} chart
             * @return {?}
             */
            function (chart) {
                if (chart.canvas.style.cursor !== '') {
                    chart.canvas.style.cursor = '';
                }
            };
        /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.isHandleFocused = /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
            function (chart, handle) {
                if (handle === TimelineHandle.Lower) {
                    return this.getState(chart).lowerHandleFocus;
                }
                if (handle === TimelineHandle.Upper) {
                    return this.getState(chart).upperHandleFocus;
                }
                if (handle === TimelineHandle.Range) {
                    return this.getState(chart).rangeHandleFocus;
                }
                return false;
            };
        /** Determine if a position is within one of the drag handles */
        /**
         * Determine if a position is within one of the drag handles
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
        TimelineChartPlugin.prototype.isWithinHandle = /**
         * Determine if a position is within one of the drag handles
         * @param {?} chart
         * @param {?} event
         * @return {?}
         */
            function (chart, event) {
                // get the lower and upper handle render regions
                /** @type {?} */
                var lower = this.getHandleArea(chart, TimelineHandle.Lower);
                /** @type {?} */
                var upper = this.getHandleArea(chart, TimelineHandle.Upper);
                // get the position co-ordinates
                var x = event.x, y = event.y;
                if (x >= lower.left && x <= lower.right && y >= lower.top && y <= lower.bottom) {
                    return TimelineHandle.Lower;
                }
                if (x >= upper.left && x <= upper.right && y >= upper.top && y <= upper.bottom) {
                    return TimelineHandle.Upper;
                }
                if (x > lower.right && x < upper.left && y >= lower.top && y <= lower.bottom) {
                    return TimelineHandle.Range;
                }
                return null;
            };
        /** Get the area a specific handle covers within the chart */
        /**
         * Get the area a specific handle covers within the chart
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.getHandleArea = /**
         * Get the area a specific handle covers within the chart
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
            function (chart, handle) {
                // get the region that the chart is drawn on (excluding axis)
                var _a = this.getChartArea(chart), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;
                // perform some calculations on the chart area
                /** @type {?} */
                var width = right - left;
                // get the minimum and maximum ticks on the chart
                var _b = __read(this.getChartRange(chart), 2), minimum = _b[0], maximum = _b[1];
                // get the lower and upper range values
                var _c = this.getOptions(chart).range, lower = _c.lower, upper = _c.upper;
                if (handle === TimelineHandle.Lower) {
                    /** @type {?} */
                    var percentage = ((lower.getTime() - minimum) / (maximum - minimum) * 100);
                    /** @type {?} */
                    var position = left + ((width / 100) * percentage);
                    return { top: top, left: position - 5, right: position, bottom: bottom };
                }
                if (handle === TimelineHandle.Upper) {
                    /** @type {?} */
                    var percentage = ((upper.getTime() - minimum) / (maximum - minimum) * 100);
                    /** @type {?} */
                    var position = left + ((width / 100) * percentage);
                    return { top: top, left: position, right: position + 5, bottom: bottom };
                }
            };
        /**
         * Get the minimum and maximum values on the x-axis
         */
        /**
         * Get the minimum and maximum values on the x-axis
         * @param {?} chart
         * @return {?}
         */
        TimelineChartPlugin.prototype.getChartRange = /**
         * Get the minimum and maximum values on the x-axis
         * @param {?} chart
         * @return {?}
         */
            function (chart) {
                // get the current data
                var data = chart.getDatasetMeta(0).data;
                // get the range on the x-axis
                /** @type {?} */
                var minimum = (( /** @type {?} */(data[0])))._xScale.min;
                /** @type {?} */
                var maximum = (( /** @type {?} */(data[0])))._xScale.max;
                return [minimum, maximum];
            };
        /** Get the value for a given handle */
        /**
         * Get the value for a given handle
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.getHandleValue = /**
         * Get the value for a given handle
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
            function (chart, handle) {
                var _a = this.getOptions(chart).range, lower = _a.lower, upper = _a.upper;
                return handle === TimelineHandle.Lower ? lower : upper;
            };
        /**
         * @param {?} chart
         * @param {?} handle
         * @param {?} value
         * @return {?}
         */
        TimelineChartPlugin.prototype.setHandleValue = /**
         * @param {?} chart
         * @param {?} handle
         * @param {?} value
         * @return {?}
         */
            function (chart, handle, value) {
                // perform lower handle validation
                if (handle === TimelineHandle.Lower) {
                    value = new Date(Math.min(Math.max(this.getHandleMinimum(chart, handle), value.getTime()), this.getHandleMaximum(chart, handle)));
                }
                // perform upper handle validation
                if (handle === TimelineHandle.Upper) {
                    value = new Date(Math.max(Math.min(this.getHandleMaximum(chart, handle), value.getTime()), this.getHandleMinimum(chart, handle)));
                }
                // store the new value
                chart.config.options.timeline.range[handle] = value;
                // update the chart
                chart.update();
                // emit the latest range
                this.triggerOnChange(chart);
            };
        /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.getHandleMinimum = /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
            function (chart, handle) {
                // get the minimum distance
                /** @type {?} */
                var minDistance = this.getOptions(chart).range.minimum || 0;
                /** @type {?} */
                var maxDistance = this.getOptions(chart).range.maximum || Infinity;
                // get the chart boundaries
                var _a = __read(this.getChartRange(chart), 1), minimum = _a[0];
                // get the current date range
                var _b = this.getRange(chart), lower = _b.lower, upper = _b.upper;
                if (handle === TimelineHandle.Lower) {
                    return Math.max((upper.getTime() - maxDistance), minimum);
                }
                if (handle === TimelineHandle.Upper) {
                    return lower.getTime() + minDistance;
                }
            };
        /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
        TimelineChartPlugin.prototype.getHandleMaximum = /**
         * @param {?} chart
         * @param {?} handle
         * @return {?}
         */
            function (chart, handle) {
                // get the minimum distance
                /** @type {?} */
                var minDistance = this.getOptions(chart).range.minimum || 0;
                /** @type {?} */
                var maxDistance = this.getOptions(chart).range.maximum || Infinity;
                // get the chart boundaries
                var _a = __read(this.getChartRange(chart), 2), maximum = _a[1];
                // get the current date range
                var _b = this.getRange(chart), lower = _b.lower, upper = _b.upper;
                if (handle === TimelineHandle.Lower) {
                    return upper.getTime() - minDistance;
                }
                if (handle === TimelineHandle.Upper) {
                    return Math.min((lower.getTime() + maxDistance), maximum);
                }
            };
        /**
         * @template T
         * @param {?} options
         * @return {?}
         */
        TimelineChartPlugin.prototype.getOptionsWithDefaults = /**
         * @template T
         * @param {?} options
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var merge = function (target, source) {
                    var e_1, _a;
                    try {
                        for (var _b = __values(Object.keys(source)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            if (source[key] instanceof Object && !(source[key] instanceof Date) && typeof source[key] !== 'function') {
                                Object.assign(source[key], merge(target[key], source[key]));
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return Object.assign(target || {}, source);
                };
                return merge(( /** @type {?} */(__assign({}, timelineDefaultOptions.timeline))), options);
            };
        /**
         * We only want to register the plugin once per application
         */
        TimelineChartPlugin._isRegistered = false;
        return TimelineChartPlugin;
    }());
    /**
     * Directly exporting a file that is not an Angular component, module, etc..
     * can cause build issues. We can use a module that instantiates the plugin
     * instead of directly exporting the Chart.js plugin.
     */
    var TimelineChartModule = /** @class */ (function () {
        function TimelineChartModule() {
            TimelineChartPlugin.register();
        }
        TimelineChartModule.decorators = [
            { type: i0.NgModule, args: [{},] }
        ];
        /** @nocollapse */
        TimelineChartModule.ctorParameters = function () { return []; };
        return TimelineChartModule;
    }());
    /** @enum {string} */
    var TimelineHandle = {
        Lower: 'lower',
        Upper: 'upper',
        Range: 'range',
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var CookieAdapter = /** @class */ (function () {
        function CookieAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                if (document.cookie) {
                    // get all the cookies for this site
                    /** @type {?} */
                    var cookies = document.cookie.split(';');
                    // process the cookies into a from we can easily manage
                    /** @type {?} */
                    var match = cookies
                        .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                        .find(function (cookie) { return cookie.key === key; });
                    return match ? match.value : null;
                }
                return null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        CookieAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                document.cookie = key + "=" + value + "; path=/";
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                document.cookie.split(';').forEach(function (cookie) {
                    /** @type {?} */
                    var eqPos = cookie.indexOf('=');
                    /** @type {?} */
                    var name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                    if (name === key) {
                        document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                    }
                });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // call remove item on each cookie
                document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                    .forEach(function (cookie) { return _this.removeItem(cookie); });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // cookies are supported in all browsers
                return this;
            };
        return CookieAdapter;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var LocalStorageAdapter = /** @class */ (function () {
        function LocalStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return localStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        LocalStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                localStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                localStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                localStorage.clear();
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!localStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    localStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return LocalStorageAdapter;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var SessionStorageAdapter = /** @class */ (function () {
        function SessionStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return sessionStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        SessionStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                sessionStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                sessionStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                sessionStorage.clear();
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!sessionStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    sessionStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return SessionStorageAdapter;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PersistentDataService = /** @class */ (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.setItem = /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
            function (key, value, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).setItem(key, value);
            };
        /**
         * Get a stored value from persistent storage
         */
        /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.getItem = /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                return this.getAdapter(type).getItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.removeItem = /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).removeItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.clear = /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
            function (type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).clear();
            };
        /**
         * Return the appropriate adapter based on the type requested
         */
        /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
        PersistentDataService.prototype.getAdapter = /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
            function (type) {
                switch (type) {
                    case PersistentDataStorageType.Cookie:
                        return new CookieAdapter();
                    case PersistentDataStorageType.LocalStorage:
                        /** @type {?} */
                        var localStorageAdapter = new LocalStorageAdapter();
                        return localStorageAdapter.getSupported();
                    case PersistentDataStorageType.SessionStorage:
                        /** @type {?} */
                        var sessionStorageAdapter = new SessionStorageAdapter();
                        return sessionStorageAdapter.getSupported();
                }
            };
        PersistentDataService.decorators = [
            { type: i0.Injectable }
        ];
        return PersistentDataService;
    }());
    /** @enum {number} */
    var PersistentDataStorageType = {
        LocalStorage: 0,
        Cookie: 1,
        SessionStorage: 2,
    };
    PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = 'LocalStorage';
    PersistentDataStorageType[PersistentDataStorageType.Cookie] = 'Cookie';
    PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = 'SessionStorage';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var PersistentDataModule = /** @class */ (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule.decorators = [
            { type: i0.NgModule, args: [{
                        providers: [PersistentDataService],
                    },] }
        ];
        return PersistentDataModule;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ StorageAdapter = /** @class */ (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    exports.Color = Color;
    exports.getIconType = getIconType;
    exports.IconType = IconType;
    exports.tick = tick;
    exports.isKeyboardTrigger = isKeyboardTrigger;
    exports.isMouseTrigger = isMouseTrigger;
    exports.AccordionPanelHeadingDirective = AccordionPanelHeadingDirective;
    exports.AccordionPanelComponent = AccordionPanelComponent;
    exports.AccordionComponent = AccordionComponent;
    exports.AccordionModule = AccordionModule;
    exports.AccordionService = AccordionService;
    exports.AlertIconDirective = AlertIconDirective;
    exports.AlertComponent = AlertComponent;
    exports.AlertModule = AlertModule;
    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CheckboxModule = CheckboxModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ColorPickerColor = ColorPickerColor;
    exports.ColorPickerComponent = ColorPickerComponent;
    exports.ColorPickerModule = ColorPickerModule;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ColumnSortingState = ColumnSortingState;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ConduitZone = ConduitZone;
    exports.ConduitComponent = ConduitComponent;
    exports.Conduit = Conduit;
    exports.CONDUITS = CONDUITS;
    exports.defaultConduitProps = defaultConduitProps;
    exports.DashboardModule = DashboardModule;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardService = DashboardService;
    exports.defaultOptions = defaultOptions;
    exports.ActionDirection = ActionDirection;
    exports.Rounding = Rounding;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DashboardGrabHandleDirective = DashboardGrabHandleDirective;
    exports.DateRangePickerComponent = DateRangePickerComponent;
    exports.DateRangeOptions = DateRangeOptions;
    exports.DateRangePickerDirective = DateRangePickerDirective;
    exports.DateRangePickerModule = DateRangePickerModule;
    exports.DateRangeService = DateRangeService;
    exports.DateRangePicker = DateRangePicker;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DatePickerMode = DatePickerMode;
    exports.ModeDirection = ModeDirection;
    exports.DatePickerHeaderEvent = DatePickerHeaderEvent;
    exports.gridify = gridify;
    exports.range = range;
    exports.dateRange = dateRange;
    exports.compareDays = compareDays;
    exports.dateComparator = dateComparator;
    exports.differenceBetweenDates = differenceBetweenDates;
    exports.timezoneComparator = timezoneComparator;
    exports.getStartOfDay = getStartOfDay;
    exports.isDateAfter = isDateAfter;
    exports.isDateBefore = isDateBefore;
    exports.months = months;
    exports.monthsShort = monthsShort;
    exports.weekdays = weekdays;
    exports.weekdaysShort = weekdaysShort;
    exports.meridians = meridians;
    exports.timezones = timezones;
    exports.EboxModule = EboxModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxContentDirective = EboxContentDirective;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetClearButtonDirective = FacetClearButtonDirective;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.FacetService = FacetService;
    exports.FacetsModule = FacetsModule;
    exports.Facet = Facet;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FilterTypeaheadHighlight = FilterTypeaheadHighlight;
    exports.FilterModule = FilterModule;
    exports.FilterService = FilterService;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.ICON_OPTIONS_TOKEN = ICON_OPTIONS_TOKEN;
    exports.IconComponent = IconComponent;
    exports.IconModule = IconModule;
    exports.IconService = IconService;
    exports.hpeIconset = hpeIconset;
    exports.uxIconset = uxIconset;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.MarqueeWizardStepIconDirective = MarqueeWizardStepIconDirective;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerCustomControlDirective = MediaPlayerCustomControlDirective;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.MenuDividerComponent = MenuDividerComponent;
    exports.MenuItemComponent = MenuItemComponent;
    exports.MenuTabbableItemDirective = MenuTabbableItemDirective;
    exports.MenuTriggerDirective = MenuTriggerDirective;
    exports.MenuModule = MenuModule;
    exports.MenuComponent = MenuComponent;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NavigationLinkDirective = NavigationLinkDirective;
    exports.NAVIGATION_MODULE_OPTIONS = NAVIGATION_MODULE_OPTIONS;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationModule = NavigationModule;
    exports.NavigationService = NavigationService;
    exports.NestedDonutChartComponent = NestedDonutChartComponent;
    exports.NestedDonutChartModule = NestedDonutChartModule;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.OrganizationChartComponent = OrganizationChartComponent;
    exports.OrganizationChartAxis = OrganizationChartAxis;
    exports.OrganizationChartModule = OrganizationChartModule;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PAGINATION_CONTROL_VALUE_ACCESSOR = PAGINATION_CONTROL_VALUE_ACCESSOR;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationModule = PaginationModule;
    exports.PartitionMapSegmentEventsDirective = PartitionMapSegmentEventsDirective;
    exports.PartitionMapComponent = PartitionMapComponent;
    exports.PartitionMapModule = PartitionMapModule;
    exports.PopoverModule = PopoverModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.ProgressBarModule = ProgressBarModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.RadioButtonModule = RadioButtonModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.RADIO_GROUP_CONTROL_VALUE_ACCESSOR = RADIO_GROUP_CONTROL_VALUE_ACCESSOR;
    exports.RadioButtonGroupDirective = RadioButtonGroupDirective;
    exports.SankeyChart = SankeyChart;
    exports.SankeyNodeDirective = SankeyNodeDirective;
    exports.SankeyChartComponent = SankeyChartComponent;
    exports.SankeyChartModule = SankeyChartModule;
    exports.SearchBuilderFocusService = SearchBuilderFocusService;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SearchBuilderService = SearchBuilderService;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SelectListItemComponent = SelectListItemComponent;
    exports.SelectListComponent = SelectListComponent;
    exports.SelectListModule = SelectListModule;
    exports.InputDropdownComponent = InputDropdownComponent;
    exports.InputDropdownModule = InputDropdownModule;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SelectComponent = SelectComponent;
    exports.SelectModule = SelectModule;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderModule = SliderModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderType = SliderType;
    exports.SliderStyle = SliderStyle;
    exports.SliderSize = SliderSize;
    exports.SliderCalloutTrigger = SliderCalloutTrigger;
    exports.SliderSnap = SliderSnap;
    exports.SliderTickType = SliderTickType;
    exports.SliderThumbEvent = SliderThumbEvent;
    exports.SliderThumb = SliderThumb;
    exports.SparkModule = SparkModule;
    exports.SparkComponent = SparkComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.ColumnPickerComponent = ColumnPickerComponent;
    exports.ResizableTableCellDirective = ResizableTableCellDirective;
    exports.ResizableTableColumnComponent = ResizableTableColumnComponent;
    exports.ResizableExpandingTableDirective = ResizableExpandingTableDirective;
    exports.ResizableTableDirective = ResizableTableDirective;
    exports.TableModule = TableModule;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabComponent = TabComponent;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetModule = TabsetModule;
    exports.TabsetService = TabsetService;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputModule = TagInputModule;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimePickerModule = TimePickerModule;
    exports.TimelineModule = TimelineModule;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.TOOLBAR_SEARCH_VALUE_ACCESSOR = TOOLBAR_SEARCH_VALUE_ACCESSOR;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadModule = TypeaheadModule;
    exports.VirtualForContainerComponent = VirtualForContainerComponent;
    exports.VirtualForDirective = VirtualForDirective;
    exports.VirtualForService = VirtualForService;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.WizardModule = WizardModule;
    exports.WizardComponent = WizardComponent;
    exports.StepChangingEvent = StepChangingEvent;
    exports.WizardStepComponent = WizardStepComponent;
    exports.AccessibilityModule = AccessibilityModule;
    exports.ColorContrastDirective = ColorContrastDirective;
    exports.ContrastService = ContrastService;
    exports.DefaultFocusIndicatorDirective = DefaultFocusIndicatorDirective;
    exports.FocusIndicator = FocusIndicator;
    exports.LocalFocusIndicatorOptions = LocalFocusIndicatorOptions;
    exports.FocusIndicatorOptionsDirective = FocusIndicatorOptionsDirective;
    exports.FocusIndicatorOrigin = FocusIndicatorOrigin;
    exports.FocusIndicatorOriginDirective = FocusIndicatorOriginDirective;
    exports.FocusIndicatorOriginService = FocusIndicatorOriginService;
    exports.FocusIndicatorDirective = FocusIndicatorDirective;
    exports.FocusIndicatorService = FocusIndicatorService;
    exports.FocusWithinDirective = FocusWithinDirective;
    exports.ManagedFocusContainerDirective = ManagedFocusContainerDirective;
    exports.ManagedFocusContainerService = ManagedFocusContainerService;
    exports.AccessibilityOptionsService = AccessibilityOptionsService;
    exports.ACCESSIBILITY_OPTIONS_TOKEN = ACCESSIBILITY_OPTIONS_TOKEN;
    exports.SplitterAccessibilityDirective = SplitterAccessibilityDirective;
    exports.TabbableListItemDirective = TabbableListItemDirective;
    exports.TabbableListDirective = TabbableListDirective;
    exports.TabbableListService = TabbableListService;
    exports.AutoGrowModule = AutoGrowModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.DragDirective = DragDirective;
    exports.DragModule = DragModule;
    exports.DragService = DragService;
    exports.DropDirective = DropDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationToggleDirective = MenuNavigationToggleDirective;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.ObserversModule = ObserversModule;
    exports.OverflowDirective = OverflowDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableService = ReorderableService;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ResizeService = ResizeService;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.TreeGridIndentDirective = TreeGridIndentDirective;
    exports.TreeGridRowDirective = TreeGridRowDirective;
    exports.TreeGridState = TreeGridState;
    exports.TreeGridDirective = TreeGridDirective;
    exports.TreeGridModule = TreeGridModule;
    exports.DurationPipeModule = DurationPipeModule;
    exports.DurationPipe = DurationPipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FileSizePipe = FileSizePipe;
    exports.StringFilterPipe = StringFilterPipe;
    exports.StringFilterModule = StringFilterModule;
    exports.DateFormatterPipeModule = DateFormatterPipeModule;
    exports.DateFormatterPipe = DateFormatterPipe;
    exports.TimelineChartPlugin = TimelineChartPlugin;
    exports.TimelineChartModule = TimelineChartModule;
    exports.TimelineHandle = TimelineHandle;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AudioService = AudioService;
    exports.colorSets = colorSets;
    exports.COLOR_SET_TOKEN = COLOR_SET_TOKEN;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColorService = ColorService;
    exports.ThemeColor = ThemeColor;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PersistentDataStorageType = PersistentDataStorageType;
    exports.StorageAdapter = StorageAdapter;
    exports.CookieAdapter = CookieAdapter;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.ɵd = DashboardGrabHandleService;
    exports.ɵf = DayViewComponent;
    exports.ɵg = DayViewService;
    exports.ɵe = HeaderComponent;
    exports.ɵh = MonthViewComponent;
    exports.ɵi = MonthViewService;
    exports.ɵm = WeekDaySortPipe;
    exports.ɵl = TimeViewComponent;
    exports.ɵj = YearViewComponent;
    exports.ɵk = YearViewService;
    exports.ɵn = FacetCheckListItemComponent;
    exports.ɵo = FacetTypeaheadListItemComponent;
    exports.ɵt = FloatingActionButtonsService;
    exports.ɵy = HierarchyBarCollapsedComponent;
    exports.ɵv = HierarchyBarNodeIconDirective;
    exports.ɵx = HierarchyBarNodeComponent;
    exports.ɵba = HierarchyBarPopoverItemComponent;
    exports.ɵz = HierarchyBarPopoverComponent;
    exports.ɵw = HierarchyBarStandardComponent;
    exports.ɵu = HierarchyBarService;
    exports.ɵbb = commonIcons;
    exports.ɵbf = MarqueeWizardService;
    exports.ɵbg = MediaPlayerService;
    exports.ɵr = MENU_OPTIONS_TOKEN;
    exports.ɵbk = PageHeaderNavigationDropdownItemComponent;
    exports.ɵbj = PageHeaderNavigationItemComponent;
    exports.ɵbl = PageHeaderNavigationSecondaryItemDirective;
    exports.ɵbi = PageHeaderNavigationService;
    exports.ɵbh = PageHeaderService;
    exports.ɵbm = SankeyFocusManager;
    exports.ɵbd = SidePanelAnimationState;
    exports.ɵbe = sidePanelStateAnimation;
    exports.ɵbc = SidePanelService;
    exports.ɵbp = BaseResizableTableDirective;
    exports.ɵbo = BaseResizableTableService;
    exports.ɵbn = RESIZABLE_TABLE_SERVICE_TOKEN;
    exports.ɵbr = ResizableExpandingTableService;
    exports.ɵbs = ResizableTableService;
    exports.ɵq = TypeaheadHighlightDirective;
    exports.ɵp = TypeaheadService;
    exports.ɵbt = HoverActionService;
    exports.ɵbu = MenuNavigationService;
    exports.ɵbq = ResizeService;
    exports.ɵbv = TreeGridService;
    exports.ɵa = KEPPEL_COLOR_SET;
    exports.ɵb = MICRO_FOCUS_COLOR_SET;
    Object.defineProperty(exports, '__esModule', { value: true });
})));
//# sourceMappingURL=ux-aspects-ux-aspects.umd.js.map
