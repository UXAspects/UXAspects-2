(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('@angular/common'), require('@angular/cdk/a11y'), require('@angular/cdk/platform'), require('@angular/cdk/coercion'), require('rxjs/operators'), require('angular-split'), require('@angular/cdk/keycodes'), require('@angular/router'), require('resize-observer-polyfill'), require('@angular/forms'), require('@angular/cdk/observers'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('dragula/dist/dragula'), require('@angular/animations'), require('@angular/common/http'), require('d3'), require('@angular/cdk/text-field')) :
        typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', 'rxjs', '@angular/core', '@angular/common', '@angular/cdk/a11y', '@angular/cdk/platform', '@angular/cdk/coercion', 'rxjs/operators', 'angular-split', '@angular/cdk/keycodes', '@angular/router', 'resize-observer-polyfill', '@angular/forms', '@angular/cdk/observers', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/cdk/scrolling', 'dragula/dist/dragula', '@angular/animations', '@angular/common/http', 'd3', '@angular/cdk/text-field'], factory) :
            (global = global || self, factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}), global.rxjs, global.ng.core, global.ng.common, global.ng.cdk.a11y, global.ng.cdk.platform, global.ng.cdk.coercion, global.rxjs.operators, global.angularSplit, global.ng.cdk.keycodes, global.ng.router, global.ResizeObserver, global.ng.forms, global.ng.cdk.observers, global.ng.cdk.overlay, global.ng.cdk.portal, global.ng.cdk.scrolling, global.dragulaNamespace, global.ng.animations, global.ng.common.http, global.d3, global.ng.cdk['text-field']));
}(this, (function (exports, rxjs, core, common, a11y, platform, coercion, operators, angularSplit, keycodes, router, ResizeObserver, forms, observers, overlay, portal, scrolling, dragulaNamespace, animations, http, d3, textField) {
    'use strict';
    ResizeObserver = ResizeObserver && Object.prototype.hasOwnProperty.call(ResizeObserver, 'default') ? ResizeObserver['default'] : ResizeObserver;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __exportStar(m, exports) {
        for (var p in m)
            if (!exports.hasOwnProperty(p))
                exports[p] = m[p];
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    result[k] = mod[k];
        result.default = mod;
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }
    (function (Color) {
        Color["Primary"] = "primary";
        Color["Accent"] = "accent";
        Color["Secondary"] = "secondary";
        Color["Alternate1"] = "alternate1";
        Color["Alternate2"] = "alternate2";
        Color["Alternate3"] = "alternate3";
        Color["Vibrant1"] = "vibrant1";
        Color["Vibrant2"] = "vibrant2";
        Color["Grey1"] = "grey1";
        Color["Grey2"] = "grey2";
        Color["Grey3"] = "grey3";
        Color["Grey4"] = "grey4";
        Color["Grey5"] = "grey5";
        Color["Grey6"] = "grey6";
        Color["Grey7"] = "grey7";
        Color["Grey8"] = "grey8";
        Color["Chart1"] = "chart1";
        Color["Chart2"] = "chart2";
        Color["Chart3"] = "chart3";
        Color["Chart4"] = "chart4";
        Color["Chart5"] = "chart5";
        Color["Chart6"] = "chart6";
        Color["Ok"] = "ok";
        Color["Warning"] = "warning";
        Color["Critical"] = "critical";
        Color["Partition1"] = "partition1";
        Color["Partition9"] = "partition9";
        Color["Partition10"] = "partition10";
        Color["Partition11"] = "partition11";
        Color["Partition12"] = "partition12";
        Color["Partition13"] = "partition13";
        Color["Partition14"] = "partition14";
        Color["SocialChartNode"] = "social-chart-node";
        Color["SocialChartEdge"] = "social-chart-edge";
    })(exports.Color || (exports.Color = {}));
    /**
     * Determine the type of icon based upon the identifier.
     *
     * We support the following iconset:
     *
     * - `hpe-icons` - HPE Icon Set
     * - `ux-icon` - UX Icon Set
     * - `component` - Component icon not tied to a specific set
     *
     * @param identifier - The name of the icon
     */
    function getIconType(identifier) {
        if (identifier && identifier.trim().indexOf('hpe-') === 0) {
            return exports.IconType.HpeIcon;
        }
        if (identifier && identifier.trim().indexOf('ux-') === 0) {
            return exports.IconType.UxIcon;
        }
        return exports.IconType.Component;
    }
    (function (IconType) {
        IconType["HpeIcon"] = "hpe-icon";
        IconType["UxIcon"] = "ux-icon";
        IconType["Component"] = "component";
    })(exports.IconType || (exports.IconType = {}));
    /**
     * This is a simple RxJS operator to allow us to avoid the
     * "expression has changed after it was checked issue"
     * by making the subscription asynchronous. We could just use a
     * delay operator but this uses a timeout which is significantly
     * slower than using requestAnimationFrame.
     */
    var tick = function () {
        return function (source) {
            return new rxjs.Observable(function (subscriber) {
                source.subscribe({
                    next: function (value) { requestAnimationFrame(function () { return subscriber.next(value); }); },
                    error: function (err) { subscriber.error(err); },
                    complete: function () { subscriber.complete(); },
                });
            });
        };
    };
    /**
     * A button will trigger a click event whenever the a mouse click occurs or the enter key is pressed.
     * These functions can be used to identify if a `click` event was caused by the keyboard or
     * by a mouse.
     *
     * The `event.detail` property will change based on the source of the event.
     * A mouse click will have varying values based on the browser, however
     * the enter key will always have a value of `0` so we can check against that
     */
    function isKeyboardTrigger(event) {
        return event.detail === 0;
    }
    function isMouseTrigger(event) {
        return !isKeyboardTrigger(event);
    }
    var AccordionPanelHeadingDirective = /** @class */ (function () {
        function AccordionPanelHeadingDirective() {
        }
        AccordionPanelHeadingDirective = __decorate([
            core.Directive({
                selector: 'ux-accordion-panel-header'
            })
        ], AccordionPanelHeadingDirective);
        return AccordionPanelHeadingDirective;
    }());
    var AccordionService = /** @class */ (function () {
        function AccordionService() {
            this.collapseOthers = false;
            this.collapse = new rxjs.Subject();
        }
        AccordionService.prototype.collapseAll = function () {
            this.collapse.next();
        };
        AccordionService = __decorate([
            core.Injectable()
        ], AccordionService);
        return AccordionService;
    }());
    var uniqueId = 1;
    var AccordionPanelComponent = /** @class */ (function () {
        function AccordionPanelComponent(accordion) {
            var _this = this;
            this.accordion = accordion;
            this.panelId = "ux-accordion-panel-" + uniqueId++;
            this.headingId = this.panelId + "-heading";
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter();
            accordion.collapse.subscribe(function () { return _this.collapse(); });
        }
        AccordionPanelComponent.prototype.toggle = function () {
            if (this.expanded) {
                this.collapse();
                return;
            }
            // check if we should collapse others
            if (this.accordion.collapseOthers) {
                this.accordion.collapseAll();
            }
            // store the new expanded state
            this.expand();
        };
        AccordionPanelComponent.prototype.expand = function () {
            if (this.disabled === false && this.expanded === false) {
                this.expanded = true;
                this.expandedChange.next(true);
            }
        };
        AccordionPanelComponent.prototype.collapse = function () {
            if (this.disabled === false && this.expanded === true) {
                this.expanded = false;
                this.expandedChange.next(false);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AccordionPanelComponent.prototype, "panelId", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AccordionPanelComponent.prototype, "headingId", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], AccordionPanelComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AccordionPanelComponent.prototype, "heading", void 0);
        __decorate([
            core.Input(), core.HostBinding('class.panel-open'),
            __metadata("design:type", Boolean)
        ], AccordionPanelComponent.prototype, "expanded", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], AccordionPanelComponent.prototype, "expandedChange", void 0);
        AccordionPanelComponent = __decorate([
            core.Component({
                selector: 'ux-accordion-panel',
                template: "<div class=\"panel-heading\"\n      role=\"button\"\n      uxFocusIndicator\n      [tabindex]=\"disabled ? -1 : 0\"\n      [id]=\"headingId\"\n      [attr.aria-expanded]=\"expanded\"\n      [attr.aria-controls]=\"panelId\"\n      (click)=\"toggle()\"\n      (keydown.enter)=\"toggle()\"\n      (keydown.space)=\"toggle(); $event.preventDefault()\"\n      (keydown.spacebar)=\"toggle(); $event.preventDefault()\">\n\n  <div class=\"panel-title\">\n      {{ heading }}\n      <ng-content select=\"ux-accordion-panel-header\"></ng-content>\n  </div>\n</div>\n\n<div [id]=\"panelId\"\n      class=\"panel-collapse collapse\"\n      [class.in]=\"expanded\"\n      role=\"tabpanel\"\n      [attr.aria-labelledby]=\"headingId\">\n\n  <div class=\"panel-body\">\n    <ng-content></ng-content>\n  </div>\n</div>",
                host: {
                    'class': 'panel panel-default',
                    'role': 'tab'
                }
            }),
            __metadata("design:paramtypes", [AccordionService])
        ], AccordionPanelComponent);
        return AccordionPanelComponent;
    }());
    var AccordionComponent = /** @class */ (function () {
        function AccordionComponent(_accordion) {
            this._accordion = _accordion;
        }
        Object.defineProperty(AccordionComponent.prototype, "collapseOthers", {
            set: function (collapseOthers) {
                this._accordion.collapseOthers = collapseOthers;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], AccordionComponent.prototype, "collapseOthers", null);
        AccordionComponent = __decorate([
            core.Component({
                selector: 'ux-accordion',
                template: "<ng-content></ng-content>",
                providers: [AccordionService],
                host: {
                    'class': 'panel-group',
                    'role': 'tablist',
                    'aria-multiselectable': 'true'
                }
            }),
            __metadata("design:paramtypes", [AccordionService])
        ], AccordionComponent);
        return AccordionComponent;
    }());
    var KEPPEL_COLOR_SET = {
        'primary': '#00a7a2',
        'accent': '#7b63a3',
        'secondary': '#fff',
        'alternate1': '#3baa43',
        'alternate2': '#025662',
        'alternate3': '#b08f5c',
        'vibrant1': '#00cceb',
        'vibrant2': '#ff9048',
        'grey1': '#2a2a2a',
        'grey2': '#333',
        'grey3': '#666',
        'grey4': '#999',
        'grey5': '#ccc',
        'grey6': '#eee',
        'grey7': '#f5f5f5',
        'grey8': '#fafafa',
        'chart1': '#00a7a2',
        'chart2': '#7b63a3',
        'chart3': '#3baa43',
        'chart4': '#025662',
        'chart5': '#b08f5c',
        'chart6': '#ccc',
        'ok': '#3baa43',
        'warning': '#ff9048',
        'critical': '#ff454f',
        'partition1': '#635387',
        'partition9': '#4a4066',
        'partition10': '#308935',
        'partition11': '#023e42',
        'partition12': '#91744d',
        'partition13': '#999',
        'partition14': '#294266',
        'social-chart-node': '#00cceb',
        'social-chart-edge': '#00cceb'
    };
    var MICRO_FOCUS_COLOR_SET = {
        'cerulean': '#1668c1',
        'aqua': '#29ceff',
        'aquamarine': '#2fd6c3',
        'fuchsia': '#c6179d',
        'indigo': '#7425ad',
        'dark-blue': '#231ca5',
        'white': '#ffffff',
        'slightly-gray': '#f5f7f8',
        'bright-gray': '#f1f2f3',
        'gray': '#dcdedf',
        'silver': '#bdbec0',
        'dim-gray': '#656668',
        'dark-gray': '#323435',
        'black': '#000000',
        'crimson-negative': '#e5004c',
        'apricot': '#f48b34',
        'yellow': '#fcdb1f',
        'green-positive': '#1aac60',
        'ultramarine': '#3939c6',
        'skyblue': '#00abf3',
        'pale-aqua': '#43e4ff',
        'pale-green': '#1ffbba',
        'lime': '#75da4d',
        'orange': '#ffce00',
        'magenta': '#eb23c2',
        'pale-purple': '#ba47e2',
        'dark-ultramarine': '#271782',
        'steelblue': '#014272',
        'arctic-blue': '#0b8eac',
        'emerald': '#00a989',
        'olive': '#5bba36',
        'goldenrod': '#ffb000',
        'purple': '#9b1e83',
        'pale-eggplant': '#5216ac',
        'red': '#ff454f',
        'pale-amber': '#ffb24d',
        'pale-lemon': '#fde159',
        'pale-emerald': '#33c180',
        'plum': '#b21646',
        'copper': '#e57828',
        'amber': '#ffc002',
        'leaf-green': '#118c4f',
        'forest-green': '#00645a',
        'primary': '#0073e7',
        'accent': '#7425ad',
        'secondary': '#ffffff',
        'alternate1': '#29ceff',
        'alternate2': '#2fd6c3',
        'alternate3': '#c6179d',
        'vibrant1': '#43e4ff',
        'vibrant2': '#ffce00',
        'grey1': '#000000',
        'grey2': '#323435',
        'grey3': '#656668',
        'grey4': '#bdbec0',
        'grey5': '#dcdedf',
        'grey6': '#f1f2f3',
        'grey7': '#f5f7f8',
        'grey8': '#ffffff',
        'chart1': '#3939c6',
        'chart2': '#00abf3',
        'chart3': '#75da4d',
        'chart4': '#ffce00',
        'chart5': '#eb23c2',
        'chart6': '#ba47e2',
        'ok': '#1aac60',
        'warning': '#f48b34',
        'critical': 'e5004c',
        'partition1': '#7425ad',
        'partition9': '#5216ac',
        'partition10': '#5bba36',
        'partition11': '#014272',
        'partition12': '#ffb000',
        'partition13': '#bdbec0',
        'partition14': '#271782',
        'social-chart-node': '#ff00ff',
        'social-chart-edge': '#ff00ff'
    };
    var colorSets = {
        keppel: {
            colorValueSet: KEPPEL_COLOR_SET,
        },
        microFocus: {
            colorValueSet: MICRO_FOCUS_COLOR_SET
        }
    };
    /** Provide a default color set for an application */
    var COLOR_SET_TOKEN = new core.InjectionToken('COLOR_SET_TOKEN');
    var ThemeColor = /** @class */ (function () {
        function ThemeColor(_r, _g, _b, _a) {
            if (_a === void 0) {
                _a = '1';
            }
            this._r = _r;
            this._g = _g;
            this._b = _b;
            this._a = _a;
        }
        /**
         * Create a ThemeColor object from a CSS color string
         * @param value The CSS color string to derive a ThemeColor object from
         */
        ThemeColor.parse = function (value) {
            var r, g, b, a = '1';
            var rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
            var shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            var longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
            var rgbaMatch = value.match(rgbaPattern);
            var shortHexMatch = value.match(shortHexPattern);
            var longHexMatch = value.match(longHexPattern);
            if (rgbaMatch) {
                r = rgbaMatch[1];
                g = rgbaMatch[2];
                b = rgbaMatch[3];
                a = rgbaMatch[4] ? rgbaMatch[4] : '1';
            }
            else if (longHexMatch) {
                r = parseInt(longHexMatch[1], 16).toString();
                g = parseInt(longHexMatch[2], 16).toString();
                b = parseInt(longHexMatch[3], 16).toString();
            }
            else if (shortHexMatch) {
                r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
            }
            else {
                throw new Error("Cannot parse color - " + value + " is not a valid color.");
            }
            return new ThemeColor(r, g, b, a);
        };
        /**
         * Clone a theme color so it can be modified without affecting other places using the color
         * @param themeColor The original theme color to clone
         */
        ThemeColor.from = function (themeColor) {
            return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
        };
        /**
         * Determine if an object is an instance of a theme color.
         * Using a simple instanceof check will not always work in plunker
         * where the ThemeColor is from @ux-aspects/ux-aspects and the color
         * comes from @micro-focus/ux-aspects
         */
        ThemeColor.isInstanceOf = function (themeColor) {
            return typeof themeColor.getRed === 'function' &&
                typeof themeColor.getGreen === 'function' &&
                typeof themeColor.getBlue === 'function' &&
                typeof themeColor.getAlpha === 'function';
        };
        /**
         * Convert the theme color to a CSS hex color code
         */
        ThemeColor.prototype.toHex = function () {
            var red = parseInt(this._r).toString(16);
            var green = parseInt(this._g).toString(16);
            var blue = parseInt(this._b).toString(16);
            if (red.length < 2) {
                red = '0' + red;
            }
            if (green.length < 2) {
                green = '0' + green;
            }
            if (blue.length < 2) {
                blue = '0' + blue;
            }
            return '#' + red + green + blue;
        };
        /**
         * Convert the theme color to a CSS rgb color code
         */
        ThemeColor.prototype.toRgb = function () {
            return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
        };
        /**
         * Convert the theme color to a CSS rgbs color code
         */
        ThemeColor.prototype.toRgba = function () {
            return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
        };
        /**
         * Get the red value from the RGBA color value
         */
        ThemeColor.prototype.getRed = function () {
            return this._r;
        };
        /**
         * Get the green value from the RGBA color value
         */
        ThemeColor.prototype.getGreen = function () {
            return this._g;
        };
        /**
         * Get the blue value from the RGBA color value
         */
        ThemeColor.prototype.getBlue = function () {
            return this._b;
        };
        /**
         * Get the alpha value from the RGBA color value
         */
        ThemeColor.prototype.getAlpha = function () {
            return this._a;
        };
        /**
         * Set the red value from the RGBA color value
         */
        ThemeColor.prototype.setRed = function (red) {
            this._r = red;
            return this;
        };
        /**
         * Set the green value from the RGBA color value
         */
        ThemeColor.prototype.setGreen = function (green) {
            this._g = green;
            return this;
        };
        /**
         * Set the blue value from the RGBA color value
         */
        ThemeColor.prototype.setBlue = function (blue) {
            this._b = blue;
            return this;
        };
        /**
         * Set the alpha value from the RGBA color value
         */
        ThemeColor.prototype.setAlpha = function (alpha) {
            this._a = alpha.toString();
            return this;
        };
        return ThemeColor;
    }());
    var ColorService = /** @class */ (function () {
        /** Allow the color set to be provided in a forRoot function otherwise set it to the Keppel theme by default */
        function ColorService(injector) {
            // Workaround for Angular 7 issues (https://github.com/angular/angular-cli/issues/14888)
            // We can't inject an optional token into the constructor directly or we get a runtime exception
            this._colorSet = injector.get(COLOR_SET_TOKEN, null, core.InjectFlags.Optional);
            // resolve the theme based on the colorset
            this._theme = this.getTheme(this._colorSet);
        }
        /**
         * Get a ThemeColor object from a color name
         * @param colorName The name of the color from the color palette
         */
        ColorService.prototype.getColor = function (colorName) {
            // get the matching ThemeColor from the active theme
            var themeColor = this._theme[this.resolveColorName(colorName)];
            // if there is not a match then throw an error
            if (!themeColor) {
                throw new Error('Color not found: ' + colorName);
            }
            return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
        };
        /**
         * Get the active color set
         */
        ColorService.prototype.getColorSet = function () {
            return this._colorSet;
        };
        /**
         * Define the current color set and produce a Theme from it
         */
        ColorService.prototype.setColorSet = function (colorSet) {
            this._colorSet = colorSet;
            this._theme = this.getTheme(colorSet);
        };
        /**
         * Resolve a color value. This may be the name of a color from the color set
         * or it may simply be a hex or rgb(a) color value. This function will return
         * a CSS color value regardless of which one of these formats it is
         * @param value The color name, hex code or rgb(a) value to resolve
         * @returns If the color is the name of a color in the set, the `rgba` color will be returned, otherwise the original CSS value will be returned.
         */
        ColorService.prototype.resolve = function (value) {
            if (!value) {
                return;
            }
            var colorName = this.resolveColorName(value);
            for (var color in this._theme) {
                if (colorName === color.toLowerCase()) {
                    return this.getColor(colorName).toRgba();
                }
            }
            return value;
        };
        /**
         * Converts a color name to an appropriate ColorSet name. For example
         * a color may be written in lower-camel-case, however color sets are in
         * kebab-case. This will convert to the appropriate naming format
         * @param colorName The color name to resolve
         */
        ColorService.prototype.resolveColorName = function (colorName) {
            if (colorName === void 0) {
                colorName = '';
            }
            return colorName.replace(/\s+/g, '-').toLowerCase();
        };
        /** Determine if the current colorset has a specific color */
        ColorService.prototype.colorExists = function (name) {
            var _this = this;
            return !!Object.keys(this._theme).find(function (colorName) { return colorName === _this.resolveColorName(name); });
        };
        /** Create a theme from a colorset */
        ColorService.prototype.getTheme = function (colorSet) {
            // create a new theme object
            var theme = {};
            // ensure we have a colorset
            if (!colorSet) {
                colorSet = colorSets.keppel;
            }
            // iterate over each hex code and convert it to a theme color
            for (var color in colorSet.colorValueSet) {
                theme[color] = ThemeColor.parse(colorSet.colorValueSet[color]);
            }
            return theme;
        };
        ColorService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [core.Injector])
        ], ColorService);
        return ColorService;
    }());
    var ColorServiceModule = /** @class */ (function () {
        function ColorServiceModule() {
        }
        ColorServiceModule_1 = ColorServiceModule;
        /**
         * The function allows the consuming applications to specify the applications
         * color set once in the app module, eg:
         * ```
         * ColorServiceModule.forRoot(colorSets.microFocus);
         * ```
         * @param colorSet The color set the application should use
         */
        ColorServiceModule.forRoot = function (colorSet) {
            return {
                ngModule: ColorServiceModule_1,
                providers: [
                    { provide: COLOR_SET_TOKEN, useValue: colorSet ? colorSet : colorSets.keppel },
                    ColorService
                ]
            };
        };
        var ColorServiceModule_1;
        ColorServiceModule = ColorServiceModule_1 = __decorate([
            core.NgModule({})
        ], ColorServiceModule);
        return ColorServiceModule;
    }());
    var ContrastService = /** @class */ (function () {
        function ContrastService() {
        }
        /**
         * Calculate the contract ratio between two colors.
         * This uses the official WCAG Color Contrast Ratio
         * Algorithm: https://www.w3.org/TR/WCAG20-TECHS/G17.html
         */
        ContrastService.prototype.getContrastColor = function (backgroundColor, lightColor, darkColor) {
            // get a ThemeColor from the ColorPickerColor
            var themeColor = ThemeColor.parse(backgroundColor.toHex());
            var background = this.getLuminance(themeColor);
            var light = this.getLuminance(lightColor);
            var dark = this.getLuminance(darkColor);
            // determine the contrast for both black and white
            var whiteContrast = (light + 0.05) / (background + 0.05);
            var blackContrast = (background + 0.05) / (dark + 0.05);
            // return the color with the most contrast ratio
            return blackContrast > whiteContrast ? darkColor : lightColor;
        };
        ContrastService.prototype.getLuminance = function (color) {
            // normalize the colors
            var r = +color.getRed() / 255;
            var g = +color.getGreen() / 255;
            var b = +color.getBlue() / 255;
            // calculate the value required for each color component
            r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
            g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
            b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
            // return the luminance
            return (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
        };
        ContrastService = __decorate([
            core.Injectable()
        ], ContrastService);
        return ContrastService;
    }());
    var ColorContrastDirective = /** @class */ (function () {
        function ColorContrastDirective(_colorService, _contrastService) {
            this._colorService = _colorService;
            this._contrastService = _contrastService;
            /** Store the light color as a ThemeColor object */
            this._lightColor = ThemeColor.parse('#fff');
            /** Store the light color as a ThemeColor object */
            this._darkColor = ThemeColor.parse('#000');
        }
        Object.defineProperty(ColorContrastDirective.prototype, "uxColorContrast", {
            /**
             * Define the background color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: function (backgroundColor) {
                this._backgroundColor = ThemeColor.parse(this._colorService.resolve(backgroundColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "lightColor", {
            /**
             * Define the light color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: function (lightColor) {
                this._lightColor = ThemeColor.parse(this._colorService.resolve(lightColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "darkColor", {
            /**
             * Define the dark color for contrast comparison.
             * This can be a CSS color value or the name of a
             * color from the color palette.
             */
            set: function (darkColor) {
                this._darkColor = ThemeColor.parse(this._colorService.resolve(darkColor));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorContrastDirective.prototype, "_color", {
            /** Determine the color to set based on the supplied parameters */
            get: function () {
                return this._backgroundColor ? this._contrastService.getContrastColor(this._backgroundColor, this._lightColor, this._darkColor).toRgba() : null;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], ColorContrastDirective.prototype, "uxColorContrast", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], ColorContrastDirective.prototype, "lightColor", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], ColorContrastDirective.prototype, "darkColor", null);
        __decorate([
            core.HostBinding('style.color'),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [])
        ], ColorContrastDirective.prototype, "_color", null);
        ColorContrastDirective = __decorate([
            core.Directive({
                selector: '[uxColorContrast]'
            }),
            __metadata("design:paramtypes", [ColorService, ContrastService])
        ], ColorContrastDirective);
        return ColorContrastDirective;
    }());
    var ACCESSIBILITY_OPTIONS_TOKEN = new core.InjectionToken('ACCESSIBILITY_OPTIONS');
    var AccessibilityOptionsService = /** @class */ (function () {
        /** Get the user specified options - but handle cases where they may not be specified */
        function AccessibilityOptionsService(_options) {
            if (_options === void 0) {
                _options = {};
            }
            this._options = _options;
            /** Determine the default options */
            this._defaultOptions = {
                mouseFocusIndicator: false,
                touchFocusIndicator: false,
                keyboardFocusIndicator: true,
                programmaticFocusIndicator: false
            };
        }
        Object.defineProperty(AccessibilityOptionsService.prototype, "options", {
            /** Get the complete options populating unspecified options with the default values */
            get: function () {
                return __assign(__assign({}, this._defaultOptions), this._options);
            },
            enumerable: true,
            configurable: true
        });
        AccessibilityOptionsService = __decorate([
            core.Injectable(),
            __param(0, core.Optional()), __param(0, core.Inject(ACCESSIBILITY_OPTIONS_TOKEN)),
            __metadata("design:paramtypes", [Object])
        ], AccessibilityOptionsService);
        return AccessibilityOptionsService;
    }());
    var LocalFocusIndicatorOptions = /** @class */ (function () {
        function LocalFocusIndicatorOptions() {
        }
        return LocalFocusIndicatorOptions;
    }());
    var FocusIndicator = /** @class */ (function () {
        function FocusIndicator(_element, _focusMonitor, _renderer, _options, _focusIndicatorOrigin) {
            this._element = _element;
            this._focusMonitor = _focusMonitor;
            this._renderer = _renderer;
            this._options = _options;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            /** An observable to monitor the focus state */
            this.isFocused$ = new rxjs.BehaviorSubject(false);
            /** An observable to monitor the focus origin */
            this.origin$ = new rxjs.Subject();
            /** Remove all subscriptions on destroy */
            this._onDestroy = new rxjs.Subject();
            // check if the element is already being monitored
            if (!_element.classList.contains('ux-focus-indicator')) {
                this.initialise();
            }
        }
        Object.defineProperty(FocusIndicator.prototype, "isFocused", {
            /** Provide a convenience getter to allow access to focus state without a subscription */
            get: function () {
                return this.isFocused$.value;
            },
            /** Apply a class when the item is focused */
            set: function (isFocused) {
                // update the class on the element
                isFocused ? this._renderer.addClass(this._element, 'ux-focus-indicator-active') :
                    this._renderer.removeClass(this._element, 'ux-focus-indicator-active');
                // emit the focus state
                this.isFocused$.next(isFocused);
            },
            enumerable: true,
            configurable: true
        });
        /** Setup the focus monitoring */
        FocusIndicator.prototype.initialise = function () {
            // add a class to the element to specify we are controlling the focus
            this._renderer.addClass(this._element, 'ux-focus-indicator');
            // watch for any changes to the focus state
            this._focusMonitor.monitor(this._element, this._options.checkChildren)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(this.onFocusChange.bind(this));
        };
        /** Focus the element with a specific origin */
        FocusIndicator.prototype.focus = function (origin, options) {
            this._focusIndicatorOrigin.setOrigin(origin);
            this._element.focus(options);
        };
        /** Tear down the subscriptions */
        FocusIndicator.prototype.destroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this.isFocused$.complete();
            this._focusMonitor.stopMonitoring(this._element);
        };
        /** Allow the options to be updates */
        FocusIndicator.prototype.setOptions = function (options) {
            this._options = __assign(__assign({}, this._options), options);
        };
        /** Monitor changes to an elements focus state */
        FocusIndicator.prototype.onFocusChange = function (origin) {
            // if the origin is null then we blurred
            if (origin === null) {
                this.isFocused = false;
                this.origin$.next(null);
                return;
            }
            // get the origin if there is one
            var syntheticOrigin = this._focusIndicatorOrigin.getOrigin();
            // emit the origin
            this.origin$.next(syntheticOrigin || origin);
            switch (syntheticOrigin || origin) {
                case 'mouse':
                    this.isFocused = this._options.mouseFocusIndicator;
                    break;
                case 'touch':
                    this.isFocused = this._options.touchFocusIndicator;
                    break;
                case 'keyboard':
                    this.isFocused = this._options.keyboardFocusIndicator;
                    break;
                case 'program':
                    this.isFocused = this._options.programmaticFocusIndicator;
                    break;
                default:
                    this.isFocused = false;
            }
        };
        return FocusIndicator;
    }());
    /**
     * This service can be changed to `providedIn: 'root'` whenever
     * Angular 7 support can be dropped. There is an issue with backwards
     * compatibility. We can eventually remove it from the module and make
     * the `_origin` field a class member rather than a static member.
     */
    var FocusIndicatorOriginService = /** @class */ (function () {
        function FocusIndicatorOriginService() {
        }
        /** Store the event source origin */
        FocusIndicatorOriginService.prototype.setOrigin = function (origin) {
            this._origin = origin;
        };
        /** Get the most recent event origin */
        FocusIndicatorOriginService.prototype.getOrigin = function () {
            // get the most recent origin if there is one
            var origin = this._origin;
            // we should clear the origin so this value doesn't cause issues with future focus events
            this._origin = null;
            return origin;
        };
        FocusIndicatorOriginService = __decorate([
            core.Injectable()
        ], FocusIndicatorOriginService);
        return FocusIndicatorOriginService;
    }());
    var FocusIndicatorService = /** @class */ (function () {
        function FocusIndicatorService(_focusMonitor, _globalOptions, _focusIndicatorOrigin, _localOptions, rendererFactory) {
            this._focusMonitor = _focusMonitor;
            this._globalOptions = _globalOptions;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            this._localOptions = _localOptions;
            // programmatically create a renderer as it can't be injected into a service
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /** This is essentially just a factory method to prevent the user having to pass in focus monitor, renderer and global options each time */
        FocusIndicatorService.prototype.monitor = function (element, options) {
            if (options === void 0) {
                options = __assign(__assign(__assign({}, this._globalOptions.options), this._localOptions), { checkChildren: false });
            }
            return new FocusIndicator(element, this._focusMonitor, this._renderer, __assign(__assign(__assign({}, this._globalOptions.options), this._localOptions), options), this._focusIndicatorOrigin);
        };
        FocusIndicatorService = __decorate([
            core.Injectable(),
            __param(3, core.Optional()), __param(3, core.Inject(ACCESSIBILITY_OPTIONS_TOKEN)),
            __metadata("design:paramtypes", [a11y.FocusMonitor,
                AccessibilityOptionsService,
                FocusIndicatorOriginService, Object, core.RendererFactory2])
        ], FocusIndicatorService);
        return FocusIndicatorService;
    }());
    var FocusIndicatorDirective = /** @class */ (function () {
        function FocusIndicatorDirective(_elementRef, _focusIndicatorService, optionsService, _ngZone, localOptions) {
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this.optionsService = optionsService;
            this._ngZone = _ngZone;
            this.localOptions = localOptions;
            /** Emit the latest focus state */
            this.indicator = new core.EventEmitter();
            /** Store a private reference for the checkChildren option */
            this._checkChildren = false;
            /** Store all configuation options*/
            this._options = new Map();
            /** Unsubscribe on component destroy */
            this._onDestroy = new rxjs.Subject();
            // set the inital option values based on global options
            for (var option in (optionsService.options || {})) {
                this._options.set(option, optionsService.options[option]);
            }
            // set the inital option values based on local options (if there are any)
            for (var option in (localOptions || {})) {
                this._options.set(option, localOptions[option]);
            }
        }
        Object.defineProperty(FocusIndicatorDirective.prototype, "checkChildren", {
            /** Specify whether or not we should mark this element as having focus if a child is focused */
            set: function (checkChildren) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                checkChildren = coercion.coerceBooleanProperty(checkChildren);
                if (checkChildren !== null && checkChildren !== undefined) {
                    this._checkChildren = checkChildren;
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "mouseFocusIndicator", {
            /** Indicate whether or not mouse events should cause the focus indicator to appear - will override any global setting */
            set: function (mouseFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                mouseFocusIndicator = coercion.coerceBooleanProperty(mouseFocusIndicator);
                if (mouseFocusIndicator !== null && mouseFocusIndicator !== undefined) {
                    this._options.set('mouseFocusIndicator', mouseFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "touchFocusIndicator", {
            /** Indicate whether or not touch events should cause the focus indicator to appear - will override any global setting */
            set: function (touchFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                touchFocusIndicator = coercion.coerceBooleanProperty(touchFocusIndicator);
                if (touchFocusIndicator !== null && touchFocusIndicator !== undefined) {
                    this._options.set('touchFocusIndicator', touchFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "keyboardFocusIndicator", {
            /** Indicate whether or not keyboard events should cause the focus indicator to appear - will override any global setting */
            set: function (keyboardFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                keyboardFocusIndicator = coercion.coerceBooleanProperty(keyboardFocusIndicator);
                if (keyboardFocusIndicator !== null && keyboardFocusIndicator !== undefined) {
                    this._options.set('keyboardFocusIndicator', keyboardFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorDirective.prototype, "programmaticFocusIndicator", {
            /** Indicate whether or not programmatic events should cause the focus indicator to appear - will override any global setting */
            set: function (programmaticFocusIndicator) {
                // allow a string to be used so we can skip checking a binding for performance benefits
                programmaticFocusIndicator = coercion.coerceBooleanProperty(programmaticFocusIndicator);
                if (programmaticFocusIndicator !== null && programmaticFocusIndicator !== undefined) {
                    this._options.set('programmaticFocusIndicator', programmaticFocusIndicator);
                    this.setOptions();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Setup the focus monitoring */
        FocusIndicatorDirective.prototype.ngOnInit = function () {
            var _this = this;
            // start the focus monitoring
            this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement, {
                checkChildren: this._checkChildren,
                mouseFocusIndicator: this._options.get('mouseFocusIndicator'),
                touchFocusIndicator: this._options.get('touchFocusIndicator'),
                keyboardFocusIndicator: this._options.get('keyboardFocusIndicator'),
                programmaticFocusIndicator: this._options.get('programmaticFocusIndicator')
            });
            // subscribe to the focus state to emit an event on change
            this._focusIndicator.isFocused$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isFocused) {
                // emit the latest value
                _this._ngZone.run(function () { return _this.indicator.emit(isFocused); });
            });
        };
        /** Tear down the directive */
        FocusIndicatorDirective.prototype.ngOnDestroy = function () {
            if (this._focusIndicator) {
                this._focusIndicator.destroy();
            }
            // unsubscribe from all observables
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Focus this element with a specific origin */
        FocusIndicatorDirective.prototype.focus = function (origin, options) {
            this._focusIndicator.focus(origin, options);
        };
        /** Update the focus indicator with the latest options */
        FocusIndicatorDirective.prototype.setOptions = function () {
            if (this._focusIndicator) {
                this._focusIndicator.setOptions({
                    checkChildren: this._checkChildren,
                    mouseFocusIndicator: this._options.get('mouseFocusIndicator'),
                    touchFocusIndicator: this._options.get('touchFocusIndicator'),
                    keyboardFocusIndicator: this._options.get('keyboardFocusIndicator'),
                    programmaticFocusIndicator: this._options.get('programmaticFocusIndicator')
                });
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FocusIndicatorDirective.prototype, "checkChildren", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FocusIndicatorDirective.prototype, "mouseFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FocusIndicatorDirective.prototype, "touchFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FocusIndicatorDirective.prototype, "keyboardFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FocusIndicatorDirective.prototype, "programmaticFocusIndicator", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FocusIndicatorDirective.prototype, "indicator", void 0);
        FocusIndicatorDirective = __decorate([
            core.Directive({
                selector: '[uxFocusIndicator]',
                exportAs: 'ux-focus-indicator'
            }),
            __param(4, core.Optional()),
            __metadata("design:paramtypes", [core.ElementRef,
                FocusIndicatorService,
                AccessibilityOptionsService,
                core.NgZone,
                LocalFocusIndicatorOptions])
        ], FocusIndicatorDirective);
        return FocusIndicatorDirective;
    }());
    /**
     * This directive can be used to target specific elements based on their CSS
     * class so we can control when the focus shows. This will help prevent us
     * polluting the FocusIndicatorDirective with an lot of selectors.
     *
     * If the button has a uxFocusIndicator, uxMenuTriggerFor or uxMenuNavigationToggle directive applied we should skip this
     */
    var DefaultFocusIndicatorDirective = /** @class */ (function (_super) {
        __extends(DefaultFocusIndicatorDirective, _super);
        function DefaultFocusIndicatorDirective(elementRef, focusIndicatorService, optionsService, ngZone, localOptions) {
            var _this = _super.call(this, elementRef, focusIndicatorService, optionsService, ngZone, localOptions) || this;
            // Enable programmatic focus by default
            _this.programmaticFocusIndicator = true;
            return _this;
        }
        DefaultFocusIndicatorDirective = __decorate([
            core.Directive({
                selector: '.btn:not([uxFocusIndicator]):not([uxMenuNavigationToggle]):not([uxMenuTriggerFor]), a[href]:not([uxFocusIndicator]):not([uxMenuNavigationToggle]):not([uxMenuTriggerFor])',
            }),
            __param(4, core.Optional()),
            __metadata("design:paramtypes", [core.ElementRef,
                FocusIndicatorService,
                AccessibilityOptionsService,
                core.NgZone,
                LocalFocusIndicatorOptions])
        ], DefaultFocusIndicatorDirective);
        return DefaultFocusIndicatorDirective;
    }(FocusIndicatorDirective));
    var FocusIndicatorOptionsDirective = /** @class */ (function () {
        function FocusIndicatorOptionsDirective(_options) {
            this._options = _options;
        }
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "mouseFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is clicked on. */
            set: function (mouseFocusIndicator) {
                this._options.mouseFocusIndicator = mouseFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "touchFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is touched. */
            set: function (touchFocusIndicator) {
                this._options.touchFocusIndicator = touchFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "keyboardFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is focused using the keyboard. */
            set: function (keyboardFocusIndicator) {
                this._options.keyboardFocusIndicator = keyboardFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusIndicatorOptionsDirective.prototype, "programmaticFocusIndicator", {
            /** If `true`, this element will receive a focus indicator when the element is programmatically focused. */
            set: function (programmaticFocusIndicator) {
                this._options.programmaticFocusIndicator = programmaticFocusIndicator;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], FocusIndicatorOptionsDirective.prototype, "mouseFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], FocusIndicatorOptionsDirective.prototype, "touchFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], FocusIndicatorOptionsDirective.prototype, "keyboardFocusIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], FocusIndicatorOptionsDirective.prototype, "programmaticFocusIndicator", null);
        FocusIndicatorOptionsDirective = __decorate([
            core.Directive({
                selector: '[uxFocusIndicatorOptions]',
                providers: [LocalFocusIndicatorOptions]
            }),
            __param(0, core.Self()),
            __metadata("design:paramtypes", [LocalFocusIndicatorOptions])
        ], FocusIndicatorOptionsDirective);
        return FocusIndicatorOptionsDirective;
    }());
    /**
     * When working with component host elements
     * we cannot apply directives, eg. FocusIndicatorOriginDirective
     * however we may still want the functionality to be applied to
     * the host element. This class allows the host element to become
     * a focus indicator origin
     */
    var FocusIndicatorOrigin = /** @class */ (function () {
        function FocusIndicatorOrigin(_focusIndicatorOrigin, elementRef, renderer) {
            var _this = this;
            this._focusIndicatorOrigin = _focusIndicatorOrigin;
            /** Store all event handlers */
            this._handlers = [];
            // add event handlers
            this._handlers = [
                renderer.listen(elementRef.nativeElement, 'click', function () { return _this.onClick(); }),
                renderer.listen(elementRef.nativeElement, 'mousedown', function () { return _this.onMouseDown(); }),
                renderer.listen(elementRef.nativeElement, 'keydown', function () { return _this.onKeydown(); })
            ];
        }
        /** Remove all event handlers */
        FocusIndicatorOrigin.prototype.destroy = function () {
            this._handlers.forEach(function (handler) { return handler(); });
        };
        FocusIndicatorOrigin.prototype.onMouseDown = function () {
            this._isMouseEvent = true;
        };
        FocusIndicatorOrigin.prototype.onClick = function () {
            // if the click was triggered after a mousedown event then it is a keyboard event
            this._focusIndicatorOrigin.setOrigin(this._isMouseEvent ? 'mouse' : 'keyboard');
            // reset the mouse event flag
            this._isMouseEvent = false;
        };
        FocusIndicatorOrigin.prototype.onKeydown = function () {
            this._isMouseEvent = false;
            this._focusIndicatorOrigin.setOrigin('keyboard');
        };
        return FocusIndicatorOrigin;
    }());
    var FocusIndicatorOriginDirective = /** @class */ (function () {
        function FocusIndicatorOriginDirective(focusOriginService, elementRef, renderer) {
            this._focusOrigin = new FocusIndicatorOrigin(focusOriginService, elementRef, renderer);
        }
        FocusIndicatorOriginDirective.prototype.ngOnDestroy = function () {
            this._focusOrigin.destroy();
        };
        FocusIndicatorOriginDirective = __decorate([
            core.Directive({
                selector: '[uxFocusIndicatorOrigin]',
            }),
            __metadata("design:paramtypes", [FocusIndicatorOriginService, core.ElementRef, core.Renderer2])
        ], FocusIndicatorOriginDirective);
        return FocusIndicatorOriginDirective;
    }());
    var FocusWithinDirective = /** @class */ (function () {
        /**
         * Note: We used to use @angular/cdk FocusMonitor here instead of manually listening
         * to focus blur events, however this was problematic as any child elements using the FocusMonitor,
         * eg: `uxFocusIndicator` which not get the correct `origin`, they will instead get a programmatic
         * origin even if it was clicked or focused via the keyboard.
         */
        function FocusWithinDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Emits when a child element gains focus */
            this.uxFocusWithin = new core.EventEmitter();
            /** Emits when a child element loses focus */
            this.uxBlurWithin = new core.EventEmitter();
            // We need to listen in capture phase since focus events don't bubble.
            _elementRef.nativeElement.addEventListener('focus', this.onFocus.bind(this), true);
            _elementRef.nativeElement.addEventListener('blur', this.onBlur.bind(this), true);
        }
        FocusWithinDirective.prototype.ngOnDestroy = function () {
            this._elementRef.nativeElement.removeEventListener('focus', this.onFocus.bind(this), true);
            this._elementRef.nativeElement.removeEventListener('blur', this.onBlur.bind(this), true);
        };
        FocusWithinDirective.prototype.onFocus = function () {
            this.uxFocusWithin.emit();
        };
        FocusWithinDirective.prototype.onBlur = function () {
            this.uxBlurWithin.emit();
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FocusWithinDirective.prototype, "uxFocusWithin", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FocusWithinDirective.prototype, "uxBlurWithin", void 0);
        FocusWithinDirective = __decorate([
            core.Directive({
                selector: '[uxFocusWithin],[uxBlurWithin]',
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], FocusWithinDirective);
        return FocusWithinDirective;
    }());
    var ManagedFocusContainerService = /** @class */ (function () {
        function ManagedFocusContainerService(rendererFactory) {
            this._containers = [];
            // programmatically create a renderer as it can't be injected into a service
            this._renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * Create or get an existing object which manages the tabindex of descendants.
         * @param element The element containing focusable descendants.
         * @param component The component requesting the managed focus container.
         */
        ManagedFocusContainerService.prototype.register = function (element, component) {
            // Only create a new instance if no other component has created a container on the same element
            var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
            if (!containerRef) {
                containerRef = new ManagedFocusContainerWithReferences(new ManagedFocusContainer(element, this._renderer));
                this._containers.push(containerRef);
                // Start listening for focus
                containerRef.container.register();
            }
            // Track references to dispose correctly
            if (component) {
                containerRef.addReference(component);
            }
        };
        /**
         * Remove the container object. This will call `unregister` on the container if `component` is the last reference
         * to it.
         * @param element The element containing focusable descendants.
         * @param component The component requesting the managed focus container.
         */
        ManagedFocusContainerService.prototype.unregister = function (element, component) {
            // Remove the container's reference to the source component
            var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
            // technically this function can be called before the register function if ngOnDestroy runs before it
            // is fully initialized so we should stop here if there is no containRef.
            if (!containerRef) {
                return;
            }
            containerRef.removeReference(component);
            if (!containerRef.isAlive()) {
                // Last reference was removed, so unregister the listeners
                containerRef.container.unregister();
                // Clean up the reference tracking array
                this._containers = this._containers.filter(function (c) { return c !== containerRef; });
            }
        };
        /**
         * Get an observable which can be used to determine when the element or one of its descendants has focus.
         * @param element The element containing focusable descendants.
         */
        ManagedFocusContainerService.prototype.hasFocus = function (element) {
            var container = this.getContainer(element);
            return container ? container.hasFocus$.asObservable() : null;
        };
        ManagedFocusContainerService.prototype.getContainer = function (element) {
            var containerRef = this._containers.find(function (ref) { return ref.container.element.isEqualNode(element); });
            return containerRef ? containerRef.container : null;
        };
        ManagedFocusContainerService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [core.RendererFactory2])
        ], ManagedFocusContainerService);
        return ManagedFocusContainerService;
    }());
    var ManagedFocusContainer = /** @class */ (function () {
        function ManagedFocusContainer(element, _renderer) {
            this.element = element;
            this._renderer = _renderer;
            /** Whether the container or one of its descendants has focus. */
            this.hasFocus$ = new rxjs.BehaviorSubject(false);
            this._modifiedElements = [];
            this._unlisten = [];
        }
        /** Start managing the focus of child elements. */
        ManagedFocusContainer.prototype.register = function () {
            var _this = this;
            this._unlisten.push(this._renderer.listen(this.element, 'focusin', this.onFocusIn.bind(this)));
            this._unlisten.push(this._renderer.listen(this.element, 'focusout', this.onFocusOut.bind(this)));
            // Check if the container already has focus
            setTimeout(function () {
                if (!_this.element.contains(document.activeElement)) {
                    _this.removeTabFocus();
                }
            });
        };
        /** Stop managing the focus of child elements. */
        ManagedFocusContainer.prototype.unregister = function () {
            // Dispose the event handlers
            this._unlisten.forEach(function (unlisten) { return unlisten(); });
            this._unlisten = [];
            // Undo any tabindex modifications
            this.restoreTabFocus();
        };
        ManagedFocusContainer.prototype.onFocusIn = function () {
            this.restoreTabFocus();
        };
        ManagedFocusContainer.prototype.onFocusOut = function () {
            this.removeTabFocus();
        };
        ManagedFocusContainer.prototype.removeTabFocus = function () {
            var _this = this;
            this.hasFocus$.next(false);
            // Clear the list of affected elements
            this._modifiedElements = [];
            // Get all focusable children
            var focusable = this.element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            // Remove focusable children from the tab ring
            Array.from(focusable).forEach(function (element) {
                var originalTabIndex = element.getAttribute('tabindex');
                _this._renderer.setAttribute(element, 'tabindex', '-1');
                _this._modifiedElements.push({
                    element: element,
                    tabindex: originalTabIndex
                });
            });
        };
        ManagedFocusContainer.prototype.restoreTabFocus = function () {
            var _this = this;
            this.hasFocus$.next(true);
            // Restore tab focus ability by removing the custom `tabindex` attribute
            this._modifiedElements.forEach(function (elementInfo) {
                if (elementInfo.tabindex === null) {
                    _this._renderer.removeAttribute(elementInfo.element, 'tabindex');
                }
                else {
                    _this._renderer.setAttribute(elementInfo.element, 'tabindex', elementInfo.tabindex);
                }
            });
            // Clear the list of affected elements
            this._modifiedElements = [];
        };
        return ManagedFocusContainer;
    }());
    var ManagedFocusContainerWithReferences = /** @class */ (function () {
        function ManagedFocusContainerWithReferences(container) {
            this.container = container;
            this._components = [];
        }
        ManagedFocusContainerWithReferences.prototype.addReference = function (component) {
            this._components.push(component);
        };
        ManagedFocusContainerWithReferences.prototype.removeReference = function (component) {
            this._components = this._components.filter(function (c) { return c !== component; });
        };
        ManagedFocusContainerWithReferences.prototype.isAlive = function () {
            return this._components.length > 0;
        };
        return ManagedFocusContainerWithReferences;
    }());
    var ManagedFocusContainerDirective = /** @class */ (function () {
        function ManagedFocusContainerDirective(_elementRef, _managedFocusContainerService) {
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
        }
        ManagedFocusContainerDirective.prototype.ngOnInit = function () {
            this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
        };
        ManagedFocusContainerDirective.prototype.ngOnDestroy = function () {
            this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
        };
        ManagedFocusContainerDirective = __decorate([
            core.Directive({
                selector: '[uxManagedFocusContainer]'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                ManagedFocusContainerService])
        ], ManagedFocusContainerDirective);
        return ManagedFocusContainerDirective;
    }());
    var SplitterAccessibilityDirective = /** @class */ (function () {
        function SplitterAccessibilityDirective(_elementRef, _renderer, _platform, _splitter, _focusIndicatorService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._platform = _platform;
            this._splitter = _splitter;
            this._focusIndicatorService = _focusIndicatorService;
            /** Emit an event whenever the gutter is moved using the keyboard */
            this.gutterKeydown = new core.EventEmitter();
            /** Store all the gutter elements */
            this._gutters = [];
            /** Teardown our observables on destroy */
            this._onDestroy = new rxjs.Subject();
            /** Store references to all focus indicators */
            this._focusIndicators = [];
            // update aria values when the a gutter is dragged
            _splitter.dragProgress$
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.updateGutterAttributes(); });
        }
        /** Once initialised make the gutters accessible */
        SplitterAccessibilityDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            // find the gutters
            this.onGutterChange();
            // if the number of split areas change then update the gutters and apply aria properties
            this.areas.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.onGutterChange(); });
            // we can't know when additional split-gutters appear using ContentChildren as the directive class is not exported and selector doesn't work - use mutation observer instead
            if (common.isPlatformBrowser(this._platform)) {
                // create the mutation observer
                this._observer = new MutationObserver(function () { return _this.onGutterChange(); });
                // begin observing the child nodes
                this._observer.observe(this._elementRef.nativeElement, { childList: true });
            }
        };
        /** Destroy all observables and observers */
        SplitterAccessibilityDirective.prototype.ngOnDestroy = function () {
            if (this._observer) {
                this._observer.disconnect();
            }
            this._onDestroy.next();
            this._onDestroy.complete();
            // destroy all existing focus indicators
            this._focusIndicators.forEach(function (indicator) { return indicator.destroy(); });
        };
        /** We should focus the gutter when it is clicked */
        SplitterAccessibilityDirective.prototype.onClick = function (event) {
            if (this.isSplitterGutter(event.target)) {
                event.target.parentElement.focus();
            }
        };
        /** Find all the gutters and set their attributes */
        SplitterAccessibilityDirective.prototype.onGutterChange = function () {
            var _this = this;
            // destroy all existing focus indicators
            this._focusIndicators.forEach(function (indicator) { return indicator.destroy(); });
            // reset the array
            this._focusIndicators = [];
            // get the new gutter elements
            this._gutters = this.getGutters();
            // monitor the focus of each gutter
            this._gutters.forEach(function (gutter) { return _this._focusIndicators.push(_this._focusIndicatorService.monitor(gutter)); });
            // apply all required accessibility attributes to the gutter elements
            this.setGutterAttributes();
        };
        /** Get all the gutter elements */
        SplitterAccessibilityDirective.prototype.getGutters = function () {
            // This function uses DOM accessing properties - which won't work if server side rendered
            if (common.isPlatformBrowser(this._platform)) {
                var gutters = [];
                for (var idx = 0; idx < this._elementRef.nativeElement.children.length; idx++) {
                    var node = this._elementRef.nativeElement.children.item(idx);
                    if (this.isSplitterGutter(node)) {
                        gutters.push(node);
                    }
                }
                return gutters;
            }
            return [];
        };
        /** Set the appropriate attributes on the gutter elements */
        SplitterAccessibilityDirective.prototype.setGutterAttributes = function () {
            var _this = this;
            // apply attribute to every gutter
            this._gutters.forEach(function (gutter) {
                // apply the separator role
                _this._renderer.setAttribute(gutter, 'role', 'separator');
                // make the gutters tabbable
                _this._renderer.setAttribute(gutter, 'tabindex', '0');
                // set the value now aria property
                _this.updateGutterAttributes();
            });
        };
        /** Apply the aria attribute values */
        SplitterAccessibilityDirective.prototype.updateGutterAttributes = function () {
            var _this = this;
            // update the value now properties of each gutter
            this._gutters.forEach(function (gutter, idx) {
                _this.setGutterValueNow(gutter, idx);
                _this.setGutterValueMin(gutter, idx);
                _this.setGutterValueMax(gutter, idx);
            });
        };
        /** Apply the value now aria attribute */
        SplitterAccessibilityDirective.prototype.setGutterValueNow = function (gutter, index) {
            // get the matching split area
            var area = this._splitter.displayedAreas[index];
            // indicate the size
            this._renderer.setAttribute(gutter, 'aria-valuenow', "" + Math.round(area.size));
        };
        /** Apply the value min aria attribute */
        SplitterAccessibilityDirective.prototype.setGutterValueMin = function (gutter, index) {
            // get the matching split area
            var area = this.areas.toArray()[index];
            // indicate the minimum size
            this._renderer.setAttribute(gutter, 'aria-valuemin', "" + Math.round(area.minSize));
        };
        /** Apply the value max aria attribute */
        SplitterAccessibilityDirective.prototype.setGutterValueMax = function (gutter, index) {
            // get every other splitter area
            var availableSize = this.areas
                .filter(function (_area, idx) { return index !== idx; })
                .reduce(function (total, area) { return total + area.minSize; }, 0);
            // indicate the minimum size
            this._renderer.setAttribute(gutter, 'aria-valuemax', "" + (100 - Math.round(availableSize)));
        };
        SplitterAccessibilityDirective.prototype.onKeydown = function (event) {
            if (this.isSplitterGutter(event.target)) {
                this.gutterKeydown.emit(event);
            }
        };
        SplitterAccessibilityDirective.prototype.onIncreaseKey = function (event) {
            // only perform a move if a gutter is focused
            if (this.isSplitterGutter(event.target)) {
                this.setGutterPosition(event.target, -1);
                // stop the browser from scrolling
                event.preventDefault();
            }
        };
        SplitterAccessibilityDirective.prototype.onDecreaseKey = function (event) {
            // only perform a move if a gutter is focused
            if (this.isSplitterGutter(event.target)) {
                this.setGutterPosition(event.target, 1);
                // stop the browser from scrolling
                event.preventDefault();
            }
        };
        SplitterAccessibilityDirective.prototype.onHomeKey = function (event) {
            if (this.isSplitterGutter(event.target)) {
                // get the affected panels
                var areas = this.getAreasFromGutter(event.target);
                // set the previous area to it's minimum size
                var delta = areas.previous.size - areas.previous.minSize;
                // update the sizes accordingly
                this.setGutterPosition(event.target, delta);
                // stop the browser from scrolling
                event.preventDefault();
            }
        };
        SplitterAccessibilityDirective.prototype.onEndKey = function (event) {
            if (this.isSplitterGutter(event.target)) {
                // get the affected panels
                var areas = this.getAreasFromGutter(event.target);
                // set the next area to it's minimum size
                var delta = areas.next.size - areas.next.minSize;
                // update the sizes accordingly
                this.setGutterPosition(event.target, -delta);
                // stop the browser from scrolling
                event.preventDefault();
            }
        };
        /** Determine if an element is a gutter */
        SplitterAccessibilityDirective.prototype.isSplitterGutter = function (element) {
            return element.classList.contains('as-split-gutter') || element.classList.contains('as-split-gutter-icon');
        };
        /** Update the gutter position */
        SplitterAccessibilityDirective.prototype.setGutterPosition = function (gutter, delta) {
            // get the affected panels
            var areas = this.getAreasFromGutter(gutter);
            // ensure we can perform the resize
            if (areas.previous.size - delta < areas.previous.minSize || areas.next.size + delta < areas.next.minSize) {
                return;
            }
            // perform the resize
            areas.previous.size -= delta;
            areas.next.size += delta;
            // update the splitter - this is a private method but we need to call it
            this._splitter.refreshStyleSizes();
            // update the gutter aria values
            this.updateGutterAttributes();
        };
        /** Get the split areas associated with a given gutter */
        SplitterAccessibilityDirective.prototype.getAreasFromGutter = function (gutter) {
            var index = this._gutters.indexOf(gutter);
            return {
                previous: this._splitter.displayedAreas[index],
                next: this._splitter.displayedAreas[index + 1]
            };
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SplitterAccessibilityDirective.prototype, "gutterKeydown", void 0);
        __decorate([
            core.ContentChildren(angularSplit.SplitAreaDirective),
            __metadata("design:type", core.QueryList)
        ], SplitterAccessibilityDirective.prototype, "areas", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onClick", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onKeydown", null);
        __decorate([
            core.HostListener('keydown.ArrowDown', ['$event']),
            core.HostListener('keydown.ArrowRight', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onIncreaseKey", null);
        __decorate([
            core.HostListener('keydown.ArrowUp', ['$event']),
            core.HostListener('keydown.ArrowLeft', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onDecreaseKey", null);
        __decorate([
            core.HostListener('keydown.Home', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onHomeKey", null);
        __decorate([
            core.HostListener('keydown.End', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SplitterAccessibilityDirective.prototype, "onEndKey", null);
        SplitterAccessibilityDirective = __decorate([
            core.Directive({
                selector: 'as-split'
            }),
            __param(2, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2, String, angularSplit.SplitComponent,
                FocusIndicatorService])
        ], SplitterAccessibilityDirective);
        return SplitterAccessibilityDirective;
    }());
    var TabbableListService = /** @class */ (function () {
        function TabbableListService() {
            /** Indicate is this is being using on a hierarchichal set of items */
            this.hierarchy = false;
            /** Determine if we all the alt key */
            this.allowAltModifier = true;
            /** Determine if we all the ctrl key */
            this.allowCtrlModifier = true;
            /** Determine if we allow the Home/End keys */
            this.allowBoundaryKeys = false;
            /** Determine if we should scroll the item into view on focus */
            this.shouldScrollInView = true;
            /** Indicate if we should refocus an item on QueryList change - for use within virtual lists */
            this.shouldFocusOnChange = true;
            /** Emit whenever focus does not change but tabindexes have */
            this.onTabIndexChange = new rxjs.Subject();
            /** Determine if focus is currently within the tabbable list */
            this.isFocused = false;
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        TabbableListService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this.onTabIndexChange.complete();
        };
        TabbableListService.prototype.initialize = function (items, direction, wrap) {
            var _this = this;
            // store the items
            this._items = items;
            // create the new focus key manager
            this.focusKeyManager = new a11y.FocusKeyManager(items);
            // set the direction of the list
            direction === 'vertical' ? this.focusKeyManager.withVerticalOrientation() : this.focusKeyManager.withHorizontalOrientation('ltr');
            this._direction = direction;
            // enable wrapping if required
            if (wrap) {
                this.focusKeyManager.withWrap();
            }
            // make sure the first item in the list is tabbable
            this.setFirstItemTabbable();
            // call the init function on each item
            this._items.forEach(function (item) { return item.onInit(); });
            // if the list changes we need to ensure there is always at least one tabbable item
            this._items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                // call the on init function on any new items
                _this._items.filter(function (item) { return !item.initialized; }).forEach(function (item) { return item.onInit(); });
                // ensure we update the tab indexes
                _this.onTabIndexChange.next();
                // ensure there is at least one item tabbable at all times
                _this.ensureTabbableItem();
            });
        };
        /** Give and item focus or just make it the current tabbable item */
        TabbableListService.prototype.activate = function (item, updateIndexOnly) {
            if (updateIndexOnly === void 0) {
                updateIndexOnly = false;
            }
            if (!item) {
                return;
            }
            // get the item index
            var index = this._items.toArray().indexOf(item);
            this.activateItemAtIndex(index, updateIndexOnly);
        };
        /** Give and item focus or just make it the current tabbable item */
        TabbableListService.prototype.activateItemAtIndex = function (index, updateIndexOnly) {
            if (updateIndexOnly === void 0) {
                updateIndexOnly = false;
            }
            // if we only want to update the index
            if (updateIndexOnly) {
                return this.updateActiveItemIndex(index);
            }
            // update active the item only if it is not already active
            if (this.focusKeyManager.activeItemIndex !== index) {
                this.focusKeyManager.setActiveItem(index);
            }
        };
        TabbableListService.prototype.isItemActive = function (item) {
            // if this is called before the items have been set then do nothing
            if (!this._items) {
                return false;
            }
            // find the index of the item
            var index = this._items.toArray().findIndex(function (_item) { return _item.id === item.id; });
            // check if the item is active (we check against index as it can be updated without setting the activeItem)
            return this.focusKeyManager && this.focusKeyManager.activeItemIndex === index;
        };
        TabbableListService.prototype.setFirstItemTabbable = function () {
            // find the first item that is not disabled
            var first = this._items.toArray().findIndex(function (item) { return !item.disabled; });
            if (first !== -1) {
                this.updateActiveItemIndex(first);
            }
        };
        TabbableListService.prototype.ensureTabbableItem = function () {
            var _this = this;
            // check to see if any item is tabbable
            var active = this._items.find(function (item) { return _this.isItemActive(item); });
            if (!active) {
                this.setFirstItemTabbable();
            }
        };
        TabbableListService.prototype.focusTabbableItem = function () {
            var _this = this;
            if (!this._items) {
                return;
            }
            // find the item in the list with a tab index
            var index = this._items.toArray().findIndex(function (item) { return _this.isItemActive(item); });
            // if an item was found then focus it
            if (index !== -1) {
                this.focusKeyManager.setActiveItem(index);
            }
        };
        TabbableListService.prototype.onKeydown = function (source, event) {
            // prevent anything happening when modifier keys are pressed if they have been disabled
            if (!this.allowAltModifier && event.altKey || !this.allowCtrlModifier && event.ctrlKey) {
                return;
            }
            this.focusKeyManager.onKeydown(event);
            // if the key is a boundary key and boundary keys are enabled
            if (this.allowBoundaryKeys) {
                switch (event.which) {
                    case keycodes.HOME:
                        this.focusKeyManager.setFirstItemActive();
                        event.preventDefault();
                        break;
                    case keycodes.END:
                        this.focusKeyManager.setLastItemActive();
                        event.preventDefault();
                        break;
                }
            }
            if (this.hierarchy) {
                if ((this._direction === 'horizontal' && event.keyCode === keycodes.DOWN_ARROW) ||
                    (this._direction === 'vertical' && event.keyCode === keycodes.RIGHT_ARROW)) {
                    source.keyboardExpanded$.next(true);
                }
                else if ((this._direction === 'horizontal' && event.keyCode === keycodes.UP_ARROW) ||
                    (this._direction === 'vertical' && event.keyCode === keycodes.LEFT_ARROW)) {
                    if (source.children.length > 0 && source.expanded) {
                        source.keyboardExpanded$.next(false);
                    }
                    else if (source.parent) {
                        source.parent.keyboardExpanded$.next(false);
                    }
                }
            }
        };
        TabbableListService.prototype.sortItemsByHierarchy = function (list) {
            var topLevel = [];
            // Populating children - clear previously generated collection
            list.forEach(function (item) { return item.children = []; });
            // Populating children - map from child -> parent relationship
            list.forEach(function (item) {
                if (item.parent) {
                    item.parent.children.push(item);
                }
                else {
                    topLevel.push(item);
                }
            });
            // Flatten the tree to produce the cursor key order
            return this.flattenHierarchy(topLevel);
        };
        /**
         * In a uxVirtualFor list cells can be resused. This means that when we scroll
         * the data associated with a given element may change and not the actual elements. If only the data changes
         * then the QueryList will not emit a change so we may show focus indicatator on the element that previously displayed
         * the correct data but no longer does.
         *
         * We need to handle this correctly here. We already have keys implements to handle virtual elements so we can check
         * if a key changes and use it to update the focused item even if the QueryList doesn't inform us that we have changed.
         */
        TabbableListService.prototype.itemReferenceChange = function (previousKey, origin) {
            // find the item that now has the previously focused key
            var item = this.getItemByKey(previousKey);
            // if no key was found then we should ensure there is a tabbable item
            if (!item) {
                return this.ensureTabbableItem();
            }
            // get the item index
            var index = this._items.toArray().indexOf(item);
            // activate the item without side effects
            this.updateActiveItemIndex(index);
            // focus the item with the same origin that it previously had
            item.focusWithOrigin(origin);
        };
        /** Update the active item without causing focus */
        TabbableListService.prototype.updateActiveItemIndex = function (index) {
            this.focusKeyManager.updateActiveItem(index);
            this.onTabIndexChange.next();
        };
        /** Determine if there is an item with a tabindex of 0 */
        TabbableListService.prototype.hasTabbableItem = function () {
            return this.focusKeyManager && this.focusKeyManager.activeItemIndex >= 0;
        };
        TabbableListService.prototype.getItemByKey = function (key) {
            return this._items.find(function (item) { return item.key === key; });
        };
        TabbableListService.prototype.flattenHierarchy = function (items) {
            var _this = this;
            var flatList = [];
            items.forEach(function (item) {
                item.children.sort(function (a, b) { return a.rank - b.rank; });
                flatList.push.apply(flatList, __spread([item], _this.flattenHierarchy(item.children)));
            });
            return flatList;
        };
        TabbableListService = __decorate([
            core.Injectable()
        ], TabbableListService);
        return TabbableListService;
    }());
    var nextId = 0;
    var uniqueKey = 0;
    var TabbableListItemDirective = /** @class */ (function () {
        function TabbableListItemDirective(
        /** Access the tabbable list service */
        _tabbableList, 
        /** Access the tabbable item element */
        _elementRef, 
        /** Access the service to programmatically control focus indicators */
        focusIndicatorService, 
        /** Access the service responsible for handling focus in child elements */
        _managedFocusContainerService, 
        /** Access the service which can provide us with browser identification */
        _platform, 
        /** Access the change detector to ensure tabindex gets updated as expects */
        _changeDetector, 
        /** Access the focus origin if one is provided */
        _focusOriginService, 
        /** Access the renderer to make manual dom manipulations */
        _renderer) {
            var _this = this;
            this._tabbableList = _tabbableList;
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            this._platform = _platform;
            this._changeDetector = _changeDetector;
            this._focusOriginService = _focusOriginService;
            this._renderer = _renderer;
            this.rank = 0;
            /** Indicate if this item is disabled */
            this.disabled = false;
            /** Indicate if the item is expanded if used as a hierarchical item. */
            this.expanded = false;
            /** Emit when the expanded state changes. */
            this.expandedChange = new core.EventEmitter();
            /** Emit when the element receives focus via the tabbable list. */
            this.activated = new core.EventEmitter();
            /** Give each tabbable item a unique id */
            this.id = nextId++;
            /** Each item in the list needs to be initialised by the service. When the item QueryList changes this is used to identify which items previously existed and which are new */
            this.initialized = false;
            /** Store a list of all child tabbable items */
            this.children = [];
            /** Emit whenever the expanded state changes */
            this.keyboardExpanded$ = new rxjs.Subject();
            /** Automatically unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
            /** Store a default key to use if one is not provided */
            this._defaultKey = "tabbable-list-key-" + uniqueKey++;
            /** Determine if this element has a focus indicator visible */
            this._focusOrigin = null;
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
            // store the most current focus origin
            this._focusIndicator.origin$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (origin) { return _this._focusOrigin = origin; });
            // watch for changes to tabindexes
            this._tabbableList.onTabIndexChange.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.setTabIndex(); });
            this.keyboardExpanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                // Emit event which may alter the DOM
                _this.expandedChange.emit(expanded);
                // Activate the appropriate item
                if (expanded) {
                    if (_this.children.length > 0) {
                        _this._tabbableList.activate(_this.children[0]);
                    }
                }
                else {
                    _this._tabbableList.activate(_this);
                }
            });
        }
        Object.defineProperty(TabbableListItemDirective.prototype, "key", {
            get: function () {
                return this._key || this._defaultKey;
            },
            /** Provide a unique key to help identify items when used in a virtual list */
            set: function (key) {
                // store the previous key
                var previousKey = this._key;
                // check if the key has changed eg. via cell reuse
                var didChangeRef = previousKey && key !== previousKey;
                // update the current key
                this._key = key;
                // if this element was the previously tabbable item then update the reference
                if (didChangeRef && this.isTabbable()) {
                    // allow the virtual scroll to update
                    this._changeDetector.detectChanges();
                    // this item should no longer be tabbable
                    this._tabbableList.focusKeyManager.updateActiveItem(-1);
                    // store the focus origin before we blur
                    var origin_1 = this._focusOrigin;
                    // blur this item
                    this._elementRef.nativeElement.blur();
                    // update the reference
                    this._tabbableList.itemReferenceChange(previousKey, origin_1);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListItemDirective.prototype, "tabindex", {
            get: function () {
                return this._tabbableList.isItemActive(this) ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        TabbableListItemDirective.prototype.onInit = function () {
            this.initialized = true;
            // Watch for focus within the container element and manage tabindex of descendants
            this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
            // ensure the tab index is initially set
            this.setTabIndex();
        };
        TabbableListItemDirective.prototype.ngOnDestroy = function () {
            // check if this is the currently focused item - if so we need to make another item tabbable
            if (this.tabindex === 0) {
                this._tabbableList.setFirstItemTabbable();
            }
            this._onDestroy.next();
            this._onDestroy.complete();
            this._focusIndicator.destroy();
            this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
        };
        TabbableListItemDirective.prototype.focus = function () {
            // check if there are currently any items that are tabbable
            var hasTabbableItem = this._tabbableList.hasTabbableItem();
            // determine the focus origin
            var origin = hasTabbableItem ? this._focusOriginService.getOrigin() || 'keyboard' : 'keyboard';
            // apply focus to the element
            this.focusWithOrigin(origin, !this._tabbableList.shouldScrollInView);
            // ensure the focus key manager updates the active item correctly
            this._tabbableList.activate(this, hasTabbableItem);
            // emit the focus event
            this.activated.emit(origin);
        };
        TabbableListItemDirective.prototype.onFocus = function () {
            // if this item is not currently focused in the focusKeyManager set it as the active item
            if (!this._tabbableList.isItemActive(this)) {
                this._tabbableList.activate(this, true);
            }
            // also inform the service that an item within the list is now focused
            this._tabbableList.isFocused = true;
        };
        TabbableListItemDirective.prototype.onBlur = function () {
            // if this is the current active item and it is blurred then update the isFocused state
            if (this._tabbableList.isItemActive(this)) {
                this._tabbableList.isFocused = false;
            }
        };
        TabbableListItemDirective.prototype.onKeydown = function (event) {
            this._tabbableList.onKeydown(this, event);
        };
        TabbableListItemDirective.prototype.getFocused = function () {
            return this._elementRef.nativeElement === document.activeElement;
        };
        /** We can programmatically focus an element but may want a different origin than 'programmatic' */
        TabbableListItemDirective.prototype.focusWithOrigin = function (origin, preventScroll) {
            if (preventScroll === void 0) {
                preventScroll = true;
            }
            if (origin) {
                var scrollTop = this._tabbableList.containerRef.scrollTop;
                // focus the item with a given origin
                this._focusIndicator.focus(origin, { preventScroll: preventScroll });
                // IE and Firefox don't support prevent scroll
                if (preventScroll && !this._platform.WEBKIT) {
                    this._tabbableList.containerRef.scrollTop = scrollTop;
                }
            }
        };
        TabbableListItemDirective.prototype.isTabbable = function () {
            return this.tabindex === 0;
        };
        TabbableListItemDirective.prototype.setTabIndex = function () {
            // update the tabindex attribute
            this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', this.tabindex.toString());
        };
        __decorate([
            core.Input(),
            __metadata("design:type", TabbableListItemDirective)
        ], TabbableListItemDirective.prototype, "parent", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TabbableListItemDirective.prototype, "rank", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabbableListItemDirective.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabbableListItemDirective.prototype, "expanded", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], TabbableListItemDirective.prototype, "key", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TabbableListItemDirective.prototype, "expandedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TabbableListItemDirective.prototype, "activated", void 0);
        __decorate([
            core.HostListener('focus'),
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TabbableListItemDirective.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TabbableListItemDirective.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], TabbableListItemDirective.prototype, "onKeydown", null);
        TabbableListItemDirective = __decorate([
            core.Directive({
                selector: '[uxTabbableListItem]',
                exportAs: 'ux-tabbable-list-item'
            }),
            __metadata("design:paramtypes", [TabbableListService,
                core.ElementRef,
                FocusIndicatorService,
                ManagedFocusContainerService,
                platform.Platform,
                core.ChangeDetectorRef,
                FocusIndicatorOriginService,
                core.Renderer2])
        ], TabbableListItemDirective);
        return TabbableListItemDirective;
    }());
    var TabbableListDirective = /** @class */ (function () {
        function TabbableListDirective(
        /** Access the tabbable list service */
        _tabbableList, 
        /** Access the native dom element */
        elementRef) {
            this._tabbableList = _tabbableList;
            /** Determine whether the up/down arrows should be used or the left/right arrows */
            this.direction = 'vertical';
            /** Indicate whether or not focus should loop back to the first element after the last */
            this.wrap = true;
            /** Indicate whether or not the first item should receive focus on show - useful for modals and popovers */
            this.focusOnShow = false;
            /** Indicate whether or not focus should be returned to the previous element (only applicable when using focusOnShow) */
            this.returnFocus = false;
            /** Unsubscribe from all observables automatically on destroy */
            this._onDestroy = new rxjs.Subject();
            // store a reference to the container element
            this._tabbableList.containerRef = elementRef.nativeElement;
        }
        Object.defineProperty(TabbableListDirective.prototype, "hierarchy", {
            /** Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property. */
            set: function (value) { this._tabbableList.hierarchy = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowAltModifier", {
            /** Prevent keyboard interaction when alt modifier key is pressed */
            set: function (value) { this._tabbableList.allowAltModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowCtrlModifier", {
            /** Prevent keyboard interaction when ctrl modifier key is pressed */
            set: function (value) { this._tabbableList.allowCtrlModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowBoundaryKeys", {
            /** Focus the first or last item when Home or End keys are pressed */
            set: function (value) { this._tabbableList.allowBoundaryKeys = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "focusKeyManager", {
            get: function () {
                return this._tabbableList.focusKeyManager;
            },
            enumerable: true,
            configurable: true
        });
        TabbableListDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // store the currently focused element
            this._focusedElement = document.activeElement;
            this._orderedItems = new core.QueryList();
            if (this._tabbableList.hierarchy) {
                // Sort items in a hierarchy
                this._orderedItems.reset(this._tabbableList.sortItemsByHierarchy(this.items));
                // Ensure that the child items remain sorted
                this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this._orderedItems.reset(_this._tabbableList.sortItemsByHierarchy(_this.items));
                    _this._orderedItems.notifyOnChanges();
                });
            }
            else {
                // Items are already in order
                this._orderedItems = this.items;
                // Ensure we reselect a selected item after the querylist has changed
                this.items.changes.pipe(operators.filter(function () { return _this._tabbableList.shouldFocusOnChange && _this._tabbableList.isFocused; }), operators.takeUntil(this._onDestroy))
                    .subscribe(function (items) {
                    // check if an item is currently focused
                    var activeItem = _this._tabbableList.focusKeyManager.activeItem;
                    // restore the selected item if there was one and it is still visible
                    if (activeItem) {
                        // find the matching index
                        var index = items.toArray().findIndex(function (item) { return item.key === activeItem.key; });
                        // if the item is still in the list we want to focus it
                        if (index > -1) {
                            // however we are refocusing an item that was focused so we dont want to scroll into view again as this can prevent wheel scrolling
                            _this._tabbableList.shouldScrollInView = false;
                            // refocus the item again
                            _this._tabbableList.activateItemAtIndex(index, !_this._tabbableList.isFocused);
                            // re-enable scrolling into view
                            _this._tabbableList.shouldScrollInView = true;
                        }
                    }
                });
            }
            // Set up the focus monitoring
            this._tabbableList.initialize(this._orderedItems, this.direction, this.wrap);
            // focus the first element if specified
            if (this.focusOnShow) {
                this._tabbableList.focusKeyManager.setFirstItemActive();
            }
        };
        TabbableListDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            if (this.returnFocus && this._focusedElement instanceof HTMLElement) {
                setTimeout(function () { return _this._focusedElement.focus(); });
            }
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        TabbableListDirective.prototype.focus = function () {
            if (this._tabbableList.focusKeyManager && this._tabbableList.focusKeyManager.activeItem) {
                this._tabbableList.focusKeyManager.activeItem.focus();
            }
        };
        TabbableListDirective.prototype.focusTabbableItem = function () {
            this._tabbableList.focusTabbableItem();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TabbableListDirective.prototype, "direction", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabbableListDirective.prototype, "wrap", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabbableListDirective.prototype, "focusOnShow", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabbableListDirective.prototype, "returnFocus", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TabbableListDirective.prototype, "hierarchy", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TabbableListDirective.prototype, "allowAltModifier", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TabbableListDirective.prototype, "allowCtrlModifier", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TabbableListDirective.prototype, "allowBoundaryKeys", null);
        __decorate([
            core.ContentChildren(TabbableListItemDirective, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], TabbableListDirective.prototype, "items", void 0);
        TabbableListDirective = __decorate([
            core.Directive({
                selector: '[uxTabbableList]',
                exportAs: 'ux-tabbable-list',
                providers: [TabbableListService]
            }),
            __metadata("design:paramtypes", [TabbableListService,
                core.ElementRef])
        ], TabbableListDirective);
        return TabbableListDirective;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function FOCUS_ORIGIN_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new FocusIndicatorOriginService();
    }
    var FOCUS_ORIGIN_SERVICE_PROVIDER = {
        provide: FocusIndicatorOriginService,
        deps: [[new core.Optional(), new core.SkipSelf(), FocusIndicatorOriginService]],
        useFactory: FOCUS_ORIGIN_SERVICE_PROVIDER_FACTORY
    };
    var AccessibilityModule = /** @class */ (function () {
        function AccessibilityModule() {
        }
        AccessibilityModule_1 = AccessibilityModule;
        AccessibilityModule.forRoot = function (options) {
            return {
                ngModule: AccessibilityModule_1,
                providers: [
                    { provide: ACCESSIBILITY_OPTIONS_TOKEN, useValue: options }
                ]
            };
        };
        var AccessibilityModule_1;
        AccessibilityModule = AccessibilityModule_1 = __decorate([
            core.NgModule({
                declarations: [
                    DefaultFocusIndicatorDirective,
                    FocusIndicatorDirective,
                    FocusIndicatorOptionsDirective,
                    FocusIndicatorOriginDirective,
                    FocusWithinDirective,
                    ManagedFocusContainerDirective,
                    SplitterAccessibilityDirective,
                    TabbableListDirective,
                    TabbableListItemDirective,
                    FocusIndicatorOriginDirective,
                    ColorContrastDirective
                ],
                imports: [
                    a11y.A11yModule,
                    ColorServiceModule,
                    platform.PlatformModule
                ],
                exports: [
                    DefaultFocusIndicatorDirective,
                    FocusIndicatorDirective,
                    FocusIndicatorOptionsDirective,
                    FocusIndicatorOriginDirective,
                    FocusWithinDirective,
                    ManagedFocusContainerDirective,
                    SplitterAccessibilityDirective,
                    TabbableListDirective,
                    TabbableListItemDirective,
                    FocusIndicatorOriginDirective,
                    ColorContrastDirective
                ],
                providers: [
                    FOCUS_ORIGIN_SERVICE_PROVIDER,
                    AccessibilityOptionsService,
                    ContrastService,
                    FocusIndicatorService,
                    ManagedFocusContainerService,
                ]
            })
        ], AccessibilityModule);
        return AccessibilityModule;
    }());
    var AccordionModule = /** @class */ (function () {
        function AccordionModule() {
        }
        AccordionModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule
                ],
                declarations: [
                    AccordionComponent,
                    AccordionPanelComponent,
                    AccordionPanelHeadingDirective
                ],
                exports: [
                    AccordionComponent,
                    AccordionPanelComponent,
                    AccordionPanelHeadingDirective
                ]
            })
        ], AccordionModule);
        return AccordionModule;
    }());
    var AlertIconDirective = /** @class */ (function () {
        function AlertIconDirective() {
        }
        AlertIconDirective = __decorate([
            core.Directive({
                selector: '[uxAlertIcon]',
            })
        ], AlertIconDirective);
        return AlertIconDirective;
    }());
    var AlertComponent = /** @class */ (function () {
        function AlertComponent(colorService) {
            this.colorService = colorService;
            /** Determine the style of the alert */
            this.type = 'info';
            /** Determine the the alert can be dismissed */
            this.dismissible = false;
            /** Define a custom aria label for the dismiss button */
            this.dismissAriaLabel = 'Dismiss Alert';
            /** Emit when the dismiss button is pressed */
            this.dismiss = new core.EventEmitter();
        }
        Object.defineProperty(AlertComponent.prototype, "_backgroundColor", {
            /** Resolve the background color from the color set */
            get: function () {
                return this.backgroundColor ? this.getColor(this.backgroundColor) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertComponent.prototype, "_foregroundColor", {
            /** Resolve the foreground color from the color set */
            get: function () {
                return this.foregroundColor ? this.getColor(this.foregroundColor) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertComponent.prototype, "_isCustomColor", {
            /** Determine if we are using a prefined type or custom colors */
            get: function () {
                return !!this.backgroundColor && !!this.foregroundColor;
            },
            enumerable: true,
            configurable: true
        });
        AlertComponent.prototype.getColor = function (color) {
            // check if it is a color name from the color palette or just return the CSS color value
            return this.colorService.resolve(color);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AlertComponent.prototype, "type", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], AlertComponent.prototype, "dismissible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AlertComponent.prototype, "backgroundColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AlertComponent.prototype, "foregroundColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], AlertComponent.prototype, "dismissAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], AlertComponent.prototype, "dismiss", void 0);
        __decorate([
            core.ContentChild(AlertIconDirective, { static: false }),
            __metadata("design:type", AlertIconDirective)
        ], AlertComponent.prototype, "icon", void 0);
        AlertComponent = __decorate([
            core.Component({
                selector: 'ux-alert',
                template: "<div class=\"alert-icon\" *ngIf=\"icon\">\n    <ng-content select=\"[uxAlertIcon]\"></ng-content>\n</div>\n\n<div class=\"alert-content\">\n    <ng-content></ng-content>\n</div>\n\n<button *ngIf=\"dismissible\"\n        uxFocusIndicator\n        class=\"alert-close\"\n        type=\"button\"\n        (click)=\"dismiss.emit()\"\n        [attr.aria-label]=\"dismissAriaLabel\">\n    <ux-icon name=\"close\" class=\"alert-close-icon\"></ux-icon>\n</button>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'alert',
                    '[class.ux-alert-info]': 'type === "info" && !_isCustomColor',
                    '[class.ux-alert-error]': 'type === "error" && !_isCustomColor',
                    '[class.ux-alert-warning]': 'type === "warning" && !_isCustomColor',
                    '[class.ux-alert-success]': 'type === "success" && !_isCustomColor',
                    '[class.ux-alert-dark]': 'type === "dark" && !_isCustomColor',
                    '[style.background-color]': '_backgroundColor',
                    '[style.color]': '_foregroundColor'
                }
            }),
            __metadata("design:paramtypes", [ColorService])
        ], AlertComponent);
        return AlertComponent;
    }());
    var ICON_OPTIONS_TOKEN = new core.InjectionToken('ICON_OPTIONS_TOKEN');
    /** AUTOGENERATED: DO NOT MODIFY **/
    var commonIcons = [
        '3d',
        'achievement',
        'action',
        'actions',
        'active',
        'add',
        'advanced-search',
        'aggregate',
        'alarm',
        'alert-filled',
        'alert',
        'analytics',
        'announcement',
        'app',
        'archive',
        'article',
        'ascend',
        'assistant',
        'attachment',
        'bar-chart',
        'blog',
        'book',
        'bookmark-filled',
        'bookmark',
        'bundle',
        'calculator',
        'calendar',
        'camera-filled',
        'camera',
        'capacity',
        'caret-down-filled',
        'caret-down',
        'caret-next-filled',
        'caret-next',
        'caret-previous-filled',
        'caret-previous',
        'caret-up-filled',
        'caret-up',
        'catalog',
        'chapter-add',
        'chapter-next-filled',
        'chapter-next',
        'chapter-previous-filled',
        'chapter-previous',
        'chart-organization',
        'chart-partition',
        'chart-sankey',
        'chat-attachment',
        'chat',
        'checkbox-selected',
        'checkbox',
        'checkmark',
        'chevron-down',
        'chevron-left-double',
        'chevron-left',
        'chevron-right-double',
        'chevron-right',
        'chevron-up',
        'circular-view',
        'clipboard',
        'clone',
        'close',
        'cloud-computer',
        'cloud-download',
        'cloud-software',
        'cloud-upload',
        'cloud',
        'cluster',
        'code',
        'command-line',
        'compare',
        'compass',
        'compliance',
        'computer-personal',
        'configuration-filled',
        'configuration',
        'connect',
        'contact-card',
        'contact-us-filled',
        'contact-us',
        'contract',
        'copy',
        'cube-filled',
        'cube',
        'cubes',
        'cursor-filled',
        'cursor',
        'cut',
        'cycle',
        'dashboard',
        'database',
        'defect',
        'deliver',
        'deployment',
        'descend',
        'desktop',
        'detach',
        'directions',
        'dislike-filled',
        'dislike',
        'divide-four',
        'divide-right',
        'divide-three',
        'divide',
        'document-cloud',
        'document-compress',
        'document-config',
        'document-csv',
        'document-data',
        'document-download',
        'document-excel',
        'document-executable',
        'document-image',
        'document-locked',
        'document-missing',
        'document-notes',
        'document-outlook',
        'document-pdf',
        'document-performance',
        'document-powerpoint',
        'document-rtf',
        'document-sound',
        'document-test',
        'document-text',
        'document-threat',
        'document-time',
        'document-transfer',
        'document-txt',
        'document-update',
        'document-upload',
        'document-user',
        'document-verified',
        'document-video',
        'document-word',
        'document',
        'domain',
        'down',
        'download',
        'drag',
        'drive-cage',
        'duplicate',
        'edit-filled',
        'edit',
        'eject-filled',
        'eject',
        'expand',
        'fan',
        'fast-forward-filled',
        'fast-forward',
        'favorite-filled',
        'favorite',
        'filter-filled',
        'filter',
        'first-aid',
        'flag-filled',
        'flag',
        'folder-cycle',
        'folder-open',
        'folder',
        'gallery-filled',
        'gallery',
        'globe',
        'grid',
        'group',
        'grow',
        'halt',
        'help-circle',
        'help',
        'highlighting-remove',
        'highlighting',
        'history',
        'home-filled',
        'home',
        'host-maintenance',
        'host',
        'image-filled',
        'image',
        'impact',
        'in-progress',
        'inactive',
        'inbox',
        'indicator-filled',
        'indicator',
        'information-filled',
        'information',
        'inherit-filled',
        'inherit',
        'input-to-process',
        'install',
        'integration',
        'iteration-filled',
        'iteration',
        'java-filled',
        'java',
        'language',
        'launch',
        'license-filled',
        'license',
        'like-filled',
        'like',
        'line-chart',
        'link-bottom',
        'link-down',
        'link-next',
        'link-previous',
        'link-top',
        'link-up',
        'link',
        'list',
        'location-filled',
        'location-pin-filled',
        'location-pin',
        'location',
        'lock',
        'login',
        'logout',
        'mail-attachment',
        'mail-filled',
        'mail',
        'manual',
        'map-location',
        'map',
        'menu',
        'microphone-filled',
        'microphone',
        'monitor',
        'more',
        'multiple',
        'navigate',
        'new-window',
        'new',
        'news-aggregation',
        'news-collection',
        'news-content',
        'news',
        'next',
        'notes',
        'notification-filled',
        'notification',
        'optimization',
        'organization',
        'overview',
        'pan',
        'pause-filled',
        'pause',
        'payment-google-wallet',
        'payment-mastercard',
        'payment-paypal',
        'payment-square',
        'payment-visa',
        'pin-filled',
        'pin',
        'plan',
        'platform-apple',
        'platform-chrome',
        'platform-dropbox',
        'platform-edge',
        'platform-firefox',
        'platform-internet-explorer',
        'platform-kubernetes',
        'platform-skype',
        'platform-windows',
        'play-filled',
        'play',
        'power',
        'previous',
        'print',
        'quick-view',
        'radial-selected',
        'radial',
        'redo',
        'refresh',
        'resources',
        'rewind-filled',
        'rewind',
        'risk',
        'rss',
        'satellite',
        'save-filled',
        'save',
        'scale-out-repository',
        'schedule-clone',
        'schedule-new',
        'schedule-play',
        'schedule',
        'scorecard',
        'search',
        'secure',
        'select-left',
        'select',
        'server-cluster',
        'server-started',
        'server',
        'servers',
        'service-business',
        'service-start',
        'share',
        'shield-configure',
        'shield-filled',
        'shield',
        'shift',
        'shop-basket',
        'shop-cart',
        'soa',
        'social-email',
        'social-facebook',
        'social-github',
        'social-instagram',
        'social-linkedin',
        'social-medium',
        'social-pinterest',
        'social-reddit',
        'social-slack',
        'social-tumblr',
        'social-twitter',
        'social-vimeo',
        'social-youtube',
        'sort',
        'stakeholder',
        'star-filled',
        'star-half',
        'star',
        'status-approved-filled',
        'status-error-filled',
        'status-information-filled',
        'status-warning-filled',
        'steps-filled',
        'steps',
        'storage',
        'street-view-filled',
        'street-view',
        'subtitles',
        'subtract',
        'support',
        'sync',
        'system',
        'tab-next',
        'tab-previous',
        'tab-up',
        'table-add',
        'table',
        'tag-filled',
        'tag',
        'target',
        'task',
        'template',
        'test-desktop',
        'test',
        'text-wrap',
        'threats',
        'ticket',
        'tools',
        'tooltip',
        'transaction-filled',
        'transaction',
        'trash-filled',
        'trash',
        'tree',
        'trigger',
        'trophy-filled',
        'trophy',
        'troubleshooting',
        'undo',
        'unlock',
        'up',
        'update',
        'upgrade-filled',
        'upgrade',
        'upload',
        'user-add-filled',
        'user-add',
        'user-admin',
        'user-expert',
        'user-female-filled',
        'user-female',
        'user-filled',
        'user-manager',
        'user-new',
        'user-police',
        'user-settings',
        'user-worker',
        'user',
        'validation-filled',
        'validation',
        'video-filled',
        'video',
        'view-filled',
        'view',
        'virtual-machine',
        'vm-maintenance',
        'volume-filled',
        'volume-low-filled',
        'volume-low',
        'volume-mute-filled',
        'volume-mute',
        'volume',
        'vulnerability',
        'waypoint-filled',
        'waypoint',
        'workshop',
        'zoom-in',
        'zoom-out'
    ];
    /** We generate the iconset definition as hardcoding it increases bundle size by ~40kb per iconset */
    var uxIconset = __spread(commonIcons.map(uxIconMapper));
    function uxIconMapper(icon) {
        return { name: icon, iconset: 'ux-icon', icon: "ux-icon-" + icon };
    }
    var IconService = /** @class */ (function () {
        /** Inject a parent service if one exists */
        function IconService(_iconService, options) {
            this._iconService = _iconService;
            /** Emit whenever the iconset changes */
            this.iconsChanged$ = new rxjs.Subject();
            /** Store a list of all icon */
            this._icons = __spread(uxIconset);
            // if the iconset was defined at the root or child module level apply this configuration
            if (options && options.icons) {
                this.setIcons(options.icons);
            }
        }
        /** Define multiple icon definitions. This will override icon definitions if a name and size collision occurs */
        IconService.prototype.setIcons = function (icons) {
            var _this = this;
            icons.forEach(function (icon) { return _this.setIcon(icon); });
        };
        /** Provide an icon definition which will override if necessary */
        IconService.prototype.setIcon = function (_a) {
            var _this = this;
            var name = _a.name, icon = _a.icon, iconset = _a.iconset, size = _a.size;
            // if there are multiple sizes specified add them all as individual records
            if (Array.isArray(size)) {
                return size.forEach(function (variant) { return _this.setIcon({ name: name, icon: icon, iconset: iconset, size: variant }); });
            }
            // remove any existing definition with the same parameters
            this._icons = this._icons.filter(function (definition) { return !(definition.name === name && definition.size === size); });
            // insert the new definition
            this._icons = __spread(this._icons, [{ name: name, icon: icon, iconset: iconset, size: size }]);
            // emit the icon change
            this.iconsChanged$.next({ name: name, size: size });
        };
        /** Find an icon based on the given name and size if provided */
        IconService.prototype.getIcon = function (name, size) {
            // if no name was specified then do nothing (this can occur if the name input on the component is not initially defined)
            if (!name) {
                return;
            }
            // if there is a size specified then check for an exact match
            if (size) {
                // get an icon definition that matches both name and size
                var sizedIcon = this._icons.find(function (definition) { return definition.name === name && definition.size === size; });
                // if there is a match then return otherwise fallthrough to the default
                if (sizedIcon) {
                    return sizedIcon;
                }
            }
            // find a general match with no size constraint
            var icon = this._icons.find(function (definition) { return definition.name === name && definition.size === undefined; });
            // if no match is found and there is a parent service then we should check it
            if (!icon && this._iconService) {
                return this._iconService.getIcon(name, size);
            }
            else if (!icon) {
                console.warn("Icon '" + name + "' was not found.");
            }
            return icon;
        };
        IconService = __decorate([
            core.Injectable(),
            __param(0, core.Optional()), __param(0, core.SkipSelf()),
            __param(1, core.Optional()), __param(1, core.Inject(ICON_OPTIONS_TOKEN)),
            __metadata("design:paramtypes", [IconService, Object])
        ], IconService);
        return IconService;
    }());
    var IconComponent = /** @class */ (function () {
        function IconComponent(_elementRef, _renderer, _iconService) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._iconService = _iconService;
            /** Store the boolean value of flip vertical */
            this._flipVertical = false;
            /** Store the boolean value of flip horizontal */
            this._flipHorizontal = false;
            /** Automatically unsubscribe from observables */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(IconComponent.prototype, "rotate", {
            get: function () {
                return this._rotate;
            },
            /** The number of degrees to rotate the icon */
            set: function (rotation) {
                this._rotate = coercion.coerceNumberProperty(rotation);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "flipHorizontal", {
            get: function () {
                return this._flipHorizontal;
            },
            /** Define if the icon should be horizontally flipped */
            set: function (flipHorizontal) {
                this._flipHorizontal = coercion.coerceBooleanProperty(flipHorizontal);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "flipVertical", {
            get: function () {
                return this._flipVertical;
            },
            /** Define if the icon should be horizontally flipped */
            set: function (flipVertical) {
                this._flipVertical = coercion.coerceBooleanProperty(flipVertical);
            },
            enumerable: true,
            configurable: true
        });
        /** When inputs change ensure we have the best icon definition */
        IconComponent.prototype.ngOnChanges = function (changes) {
            // if the name or size changes then update the icon
            if (changes.name && changes.name.currentValue !== changes.name.previousValue ||
                changes.size && changes.size.currentValue !== changes.size.previousValue) {
                this.updateIcon();
            }
        };
        /** Watch for changes to the iconset */
        IconComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // watch for changes to the iconset to check if we need to update.
            this._iconService.iconsChanged$.pipe(operators.filter(function (event) { return _this._icon && event.name === _this._icon.name; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.updateIcon(); });
        };
        /** Cleanup on component destroy */
        IconComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** get the icon definition based on the name and size specified */
        IconComponent.prototype.updateIcon = function () {
            // remove the current icon set and icon classes of the old icon.
            // note we are using the renderer and not HostBindings as a HostBinding
            // on the `class` property will override any user added classes which is
            // not desirable.
            if (this._icon) {
                this._renderer.removeClass(this._elementRef.nativeElement, this._icon.iconset);
                this._renderer.removeClass(this._elementRef.nativeElement, this._icon.icon);
            }
            // update the stored icon definition with the best match based on name and size
            this._icon = this._iconService.getIcon(this.name, this.size);
            // add the new icon classes, again using the renderer to avoid overriding user classes
            if (this._icon) {
                this._renderer.addClass(this._elementRef.nativeElement, this._icon.iconset);
                this._renderer.addClass(this._elementRef.nativeElement, this._icon.icon);
            }
            else if (!!this.name) {
                console.warn("The icon " + this.name + " could not be found. Ensure you are using the correct iconset.");
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], IconComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], IconComponent.prototype, "size", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], IconComponent.prototype, "rotate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], IconComponent.prototype, "flipHorizontal", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], IconComponent.prototype, "flipVertical", null);
        IconComponent = __decorate([
            core.Component({
                selector: 'ux-icon',
                template: '',
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    '[style.font-size]': 'size',
                    '[class.ux-flip-horizontal]': 'flipHorizontal',
                    '[class.ux-flip-vertical]': 'flipVertical',
                    '[class.ux-rotate-90]': 'rotate == 90',
                    '[class.ux-rotate-180]': 'rotate == 180',
                    '[class.ux-rotate-270]': 'rotate == 270',
                }
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                IconService])
        ], IconComponent);
        return IconComponent;
    }());
    var IconModule = /** @class */ (function () {
        function IconModule() {
        }
        IconModule_1 = IconModule;
        /** Allow configuration at AppModule level */
        IconModule.forRoot = function (options) {
            return {
                ngModule: IconModule_1,
                providers: [
                    { provide: ICON_OPTIONS_TOKEN, useValue: options }
                ]
            };
        };
        /** Allow configuration at a child module level */
        IconModule.forChild = function (options) {
            // the `forChild` does the same as `forRoot` however this having
            // `forChild` follows the correct conventions as we should never
            // import `forRoot` in a child module
            return IconModule_1.forRoot(options);
        };
        var IconModule_1;
        IconModule = IconModule_1 = __decorate([
            core.NgModule({
                declarations: [
                    IconComponent
                ],
                exports: [
                    IconComponent
                ],
                providers: [
                    IconService
                ]
            })
        ], IconModule);
        return IconModule;
    }());
    /** We generate the iconset definition as hardcoding it increases bundle size by ~40kb per iconset */
    var hpeIconset = __spread(commonIcons.map(hpeIconMapper));
    function hpeIconMapper(icon) {
        return { name: icon, iconset: 'hpe-icon', icon: "hpe-" + icon };
    }
    var AlertModule = /** @class */ (function () {
        function AlertModule() {
        }
        AlertModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule
                ],
                declarations: [
                    AlertComponent,
                    AlertIconDirective
                ],
                exports: [
                    AlertComponent,
                    AlertIconDirective
                ]
            })
        ], AlertModule);
        return AlertModule;
    }());
    var BreadcrumbsComponent = /** @class */ (function () {
        function BreadcrumbsComponent() {
        }
        BreadcrumbsComponent.prototype.clickCrumb = function (event, crumb) {
            if (crumb.onClick) {
                crumb.onClick.call(null, event);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], BreadcrumbsComponent.prototype, "crumbs", void 0);
        BreadcrumbsComponent = __decorate([
            core.Component({
                selector: 'ux-breadcrumbs',
                template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                uxFocusIndicator\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], BreadcrumbsComponent);
        return BreadcrumbsComponent;
    }());
    var BreadcrumbsModule = /** @class */ (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    router.RouterModule
                ],
                exports: [BreadcrumbsComponent],
                declarations: [BreadcrumbsComponent]
            })
        ], BreadcrumbsModule);
        return BreadcrumbsModule;
    }());
    var ResizeService = /** @class */ (function () {
        function ResizeService(_zone) {
            this._zone = _zone;
            this._observer = new ResizeObserver(this.elementDidResize.bind(this));
            this._targets = new WeakMap();
        }
        ResizeService.prototype.ngOnDestroy = function () {
            this._observer.disconnect();
        };
        ResizeService.prototype.addResizeListener = function (target) {
            var _this = this;
            this._zone.runOutsideAngular(function () { return _this._observer.observe(target); });
            if (this._targets.has(target)) {
                return this._targets.get(target);
            }
            else {
                var emitter = new rxjs.ReplaySubject();
                this._targets.set(target, emitter);
                return emitter;
            }
        };
        ResizeService.prototype.removeResizeListener = function (target) {
            this._observer.unobserve(target);
        };
        ResizeService.prototype.elementDidResize = function (entries) {
            var _this = this;
            this._zone.run(function () {
                var e_1, _a;
                try {
                    for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                        var entry = entries_1_1.value;
                        if (_this._targets.has(entry.target)) {
                            var emitter = _this._targets.get(entry.target);
                            emitter.next({ width: entry.target.offsetWidth, height: entry.target.offsetHeight });
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
                            _a.call(entries_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            });
        };
        ResizeService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [core.NgZone])
        ], ResizeService);
        return ResizeService;
    }());
    var ResizeDirective = /** @class */ (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            /** Debounce the resize event emitter */
            this.throttle = 0;
            /** Emits whenever a resize event occurs */
            this.uxResize = new core.EventEmitter();
            /** Remove all subscriptions on component destroy */
            this._onDestroy = new rxjs.Subject();
        }
        ResizeDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._resizeService.addResizeListener(this._elementRef.nativeElement)
                .pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(this.throttle))
                .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
        };
        ResizeDirective.prototype.ngOnDestroy = function () {
            this._resizeService.removeResizeListener(this._elementRef.nativeElement);
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ResizeDirective.prototype, "throttle", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], ResizeDirective.prototype, "uxResize", void 0);
        ResizeDirective = __decorate([
            core.Directive({
                selector: '[uxResize]',
                providers: [ResizeService]
            }),
            __metadata("design:paramtypes", [core.ElementRef, ResizeService, core.NgZone])
        ], ResizeDirective);
        return ResizeDirective;
    }());
    var ResizeModule = /** @class */ (function () {
        function ResizeModule() {
        }
        ResizeModule = __decorate([
            core.NgModule({
                exports: [ResizeDirective],
                declarations: [ResizeDirective],
                providers: [ResizeService]
            })
        ], ResizeModule);
        return ResizeModule;
    }());
    var CardTabContentDirective = /** @class */ (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective = __decorate([
            core.Directive({
                selector: '[uxCardTabContent]'
            })
        ], CardTabContentDirective);
        return CardTabContentDirective;
    }());
    var CardTabsService = /** @class */ (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new rxjs.BehaviorSubject(null);
            this.tabs$ = new rxjs.BehaviorSubject([]);
            this.position$ = new rxjs.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        CardTabsService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        /**
         * Add a tab to the list of tabs
         */
        CardTabsService.prototype.addTab = function (tab) {
            this.tabs$.next(__spread(this.tabs$.value, [tab]));
        };
        /**
         * Remove a tab from the list
         */
        CardTabsService.prototype.removeTab = function (tab) {
            this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
        };
        /**
         * Select the tab
         */
        CardTabsService.prototype.select = function (tab) {
            this.tab$.next(tab);
        };
        /**
         * Set the position of the tab content
         */
        CardTabsService.prototype.setPosition = function (position) {
            this.position$.next(position);
        };
        CardTabsService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [])
        ], CardTabsService);
        return CardTabsService;
    }());
    var CardTabComponent = /** @class */ (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        CardTabComponent.prototype.ngOnDestroy = function () {
            this._tabService.removeTab(this);
        };
        __decorate([
            core.ContentChild(CardTabContentDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], CardTabComponent.prototype, "content", void 0);
        CardTabComponent = __decorate([
            core.Component({
                selector: 'ux-card-tab',
                template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [CardTabsService])
        ], CardTabComponent);
        return CardTabComponent;
    }());
    var CardTabsetComponent = /** @class */ (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: function () {
                return this.tabService.position$.getValue();
            },
            set: function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        CardTabsetComponent.prototype.select = function (tab, element) {
            // select the tab
            this.tabService.select(tab);
            // ensure the tab is moved into view if required
            this.moveIntoView(element);
        };
        CardTabsetComponent.prototype.resize = function (dimensions) {
            this._width = dimensions.width;
            this._innerWidth = this.tablist.nativeElement.scrollWidth;
            this.bounds.lower = 0;
            this.bounds.upper = -(this._innerWidth - this._width);
        };
        CardTabsetComponent.prototype.previous = function () {
            this.offset += this._width;
            // ensure it remains within the allowed bounds
            this.offset = Math.min(this.offset, this.bounds.lower);
        };
        CardTabsetComponent.prototype.next = function () {
            this.offset -= this._width;
            // ensure it remains within the allowed bounds
            this.offset = Math.max(this.offset, this.bounds.upper);
        };
        CardTabsetComponent.prototype.moveIntoView = function (element) {
            // if we dont have the dimensions we cant check
            if (!this._width || !this._innerWidth) {
                return;
            }
            // get the current element bounds
            var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
            var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
            // calculate the visible area
            var viewportStart = Math.abs(this.offset);
            var viewportEnd = viewportStart + this._width;
            var cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
            // if we need to move to the left - figure out how much
            if (offsetLeft < viewportStart) {
                this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
            }
            // if we need to move to the right - figure out how much
            if ((offsetLeft + cardWidth) > viewportEnd) {
                this.offset -= (offsetLeft + cardWidth) - viewportEnd;
            }
        };
        __decorate([
            core.HostBinding('class'),
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], CardTabsetComponent.prototype, "position", null);
        __decorate([
            core.ViewChild('tablist', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], CardTabsetComponent.prototype, "tablist", void 0);
        CardTabsetComponent = __decorate([
            core.Component({
                selector: 'ux-card-tabset',
                template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\n    <ng-content></ng-content>\n</div>\n\n<div class=\"card-tabs\" #tabs>\n\n    <button type=\"button\" class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\n        <ux-icon name=\"previous\"></ux-icon>\n    </button>\n\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\n\n        <div class=\"card-tab\"\n            role=\"tab\"\n            tabindex=\"0\" #card\n            *ngFor=\"let tab of tabService.tabs$ | async\"\n            [ngClass]=\"tabService.position$ | async\"\n            [class.active]=\"tab.active$ | async\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            (click)=\"select(tab, card)\"\n            (focus)=\"tabs.scrollLeft = 0\"\n            (keydown.enter)=\"select(tab, card)\">\n\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\n        </div>\n\n    </div>\n\n    <button type=\"button\" class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\n        <ux-icon name=\"next\"></ux-icon>\n    </button>\n</div>",
                providers: [CardTabsService]
            }),
            __metadata("design:paramtypes", [CardTabsService])
        ], CardTabsetComponent);
        return CardTabsetComponent;
    }());
    var CardTabsModule = /** @class */ (function () {
        function CardTabsModule() {
        }
        CardTabsModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    ResizeModule,
                    IconModule
                ],
                declarations: [
                    CardTabsetComponent,
                    CardTabComponent,
                    CardTabContentDirective
                ],
                exports: [
                    CardTabsetComponent,
                    CardTabComponent,
                    CardTabContentDirective
                ]
            })
        ], CardTabsModule);
        return CardTabsModule;
    }());
    var CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var uniqueCheckboxId = 0;
    var CheckboxComponent = /** @class */ (function () {
        function CheckboxComponent() {
            /** Provide a default unique id value for the checkbox */
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            /** Determines if the checkbox should be checked, unchecked or indeterminate. */
            this.id = this._checkboxId;
            /** Determines if the checkbox should be checked, unchecked or indeterminate. */
            this.value = false;
            /** Specifies the tabindex of the input. */
            this.tabindex = 0;
            /** If set to `true` the checkbox will not toggle state when clicked. */
            this.clickable = true;
            /** If set to `true` the checkbox will be displayed without a border and background. */
            this.simplified = false;
            /**
             * If `value` is set to the indeterminate value specified using this attribute, it will neither
             * display the checkbox as checked or unchecked, and will instead show the indeterminate variation.
             */
            this.indeterminateValue = -1;
            /** Specify if the checkbox should be disabled. */
            this.disabled = false;
            /** Provide an aria label for the checkbox. */
            this.ariaLabel = '';
            /** Provide an aria-labelled by property for the checkbox. */
            this.ariaLabelledby = null;
            /** Emits when `value` has been changed. */
            this.valueChange = new core.EventEmitter();
            /** Determine if the underlying input component has been focused with the keyboard */
            this._focused = false;
            /** Used to inform Angular forms that the component has been touched */
            this.onTouchedCallback = function () { };
            /** Used to inform Angular forms that the component value has changed */
            this.onChangeCallback = function () { };
        }
        /** Toggle the current state of the checkbox */
        CheckboxComponent.prototype.toggle = function () {
            if (this.disabled || !this.clickable) {
                return;
            }
            if (this.value === this.indeterminateValue) {
                this.value = true;
            }
            else {
                // toggle the checked state
                this.value = !this.value;
            }
            // emit the value
            this.valueChange.emit(this.value);
            // update the value if used within a form control
            this.onChangeCallback(this.value);
            // mark the component as touched
            this.onTouchedCallback();
        };
        // Functions required to update ngModel
        CheckboxComponent.prototype.writeValue = function (value) {
            if (value !== this.value) {
                this.value = value;
            }
        };
        /** Allow Angular forms for provide us with a callback for when the input value changes */
        CheckboxComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /** Allow Angular forms for provide us with a callback for when the touched state changes */
        CheckboxComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /** Allow Angular forms to disable the component */
        CheckboxComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], CheckboxComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], CheckboxComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], CheckboxComponent.prototype, "value", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], CheckboxComponent.prototype, "required", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], CheckboxComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], CheckboxComponent.prototype, "clickable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], CheckboxComponent.prototype, "simplified", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], CheckboxComponent.prototype, "indeterminateValue", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], CheckboxComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], CheckboxComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input('aria-labelledby'),
            __metadata("design:type", String)
        ], CheckboxComponent.prototype, "ariaLabelledby", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], CheckboxComponent.prototype, "valueChange", void 0);
        CheckboxComponent = __decorate([
            core.Component({
                selector: 'ux-checkbox',
                template: "<label [attr.for]=\"(id || _checkboxId) + '-input'\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"value === indeterminateValue\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"_focused\">\n\n    <div class=\"ux-checkbox-container\">\n\n        <input type=\"checkbox\"\n               uxFocusIndicator\n               class=\"ux-checkbox-input\"\n               [id]=\"(id || _checkboxId) + '-input'\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"value === indeterminateValue\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"value === indeterminateValue ? 'mixed' : value\"\n               (indicator)=\"_focused = $event\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                providers: [CHECKBOX_VALUE_ACCESSOR],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], CheckboxComponent);
        return CheckboxComponent;
    }());
    var CheckboxModule = /** @class */ (function () {
        function CheckboxModule() {
        }
        CheckboxModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    forms.FormsModule
                ],
                exports: [
                    CheckboxComponent
                ],
                declarations: [
                    CheckboxComponent
                ]
            })
        ], CheckboxModule);
        return CheckboxModule;
    }());
    /**
     * Type representing a color, including its descriptive name.
     */
    var ColorPickerColor = /** @class */ (function () {
        function ColorPickerColor(name, value, inputMode) {
            this.name = name;
            this._color = ThemeColor.parse(value);
            // Preserve the format entered by the user if it's valid
            if (inputMode === 'hex') {
                this._originalHexValue = value;
            }
            else if (inputMode === 'rgba') {
                this._originalRgbaValue = value;
            }
        }
        Object.defineProperty(ColorPickerColor.prototype, "hex", {
            /**
             * Hex value of the color, e.g. `#ffffff`.
             */
            get: function () {
                return this._originalHexValue ? this._originalHexValue : this._color.toHex();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "rgba", {
            /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             */
            get: function () {
                return this._originalRgbaValue ? this._originalRgbaValue : this._color.toRgba();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "r", {
            get: function () {
                return parseInt(this._color.getRed());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "g", {
            get: function () {
                return parseInt(this._color.getGreen());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "b", {
            get: function () {
                return parseInt(this._color.getBlue());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "a", {
            get: function () {
                return parseFloat(this._color.getAlpha());
            },
            enumerable: true,
            configurable: true
        });
        ColorPickerColor.prototype.toString = function () {
            return this._color.toRgba();
        };
        return ColorPickerColor;
    }());
    // Values corresponding to stylesheet
    var BUTTON_MARGIN = 8;
    var BUTTON_WIDTHS = {
        'sm': 26,
        'md': 32,
        'lg': 40
    };
    var uniqueId$1 = 0;
    var ColorPickerComponent = /** @class */ (function () {
        function ColorPickerComponent() {
            this.id = "ux-color-picker-" + uniqueId$1++;
            /** The style of the color swatch buttons. */
            this.buttonStyle = 'circle';
            /** Whether to show tooltips above the color swatch buttons. These contain the color name if provided; otherwise the color hex/RGBA value. */
            this.showTooltips = false;
            /** Whether to show the hex/RGBA input panel. */
            this.showInput = false;
            /** The default input mode to display in the input panel. The user can switch modes using the toggle button. */
            this.inputMode = 'hex';
            /** Defines a function that returns an aria-label for ColorPickerColor. */
            this.colorAriaLabel = this.getColorAriaLabel;
            /** Defines a function that returns an aria-label for the button that switches input modes. */
            this.switchModeAriaLabel = this.getSwitchModeAriaLabel;
            /** Define a function that returns an aria-label for the input control. */
            this.inputAriaLabel = this.getInputAriaLabel;
            /** Emitted when the user changes the selected color, either by clicking a color swatch button, or entering a valid color value into the input panel text field. */
            this.selectedChange = new core.EventEmitter();
            /** Emitted when the user presses enter in the input panel text field. This can be used to commit a color change and/or close a popup. */
            this.inputSubmit = new core.EventEmitter();
            this.cssWidth = 'auto';
            this.colors = [];
            this.selected$ = new rxjs.BehaviorSubject(null);
            this.columns$ = new rxjs.BehaviorSubject(-1);
            this.buttonSize$ = new rxjs.BehaviorSubject('md');
            this.inputPatterns = {
                'hex': /^#(?:[\da-fA-F]{3}){1,2}$/,
                'rgba': /^(?:rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))|(?:rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*\d(\.\d+)?\))$/
            };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(ColorPickerComponent.prototype, "inputColors", {
            /**
             * The collection of colors to display in the color swatch.
             *
             * Colors can be specified either as a string, which is the hex or RGBA value of the color; or as a `ColorPickerColor` object,
             * which allows a name to be associated with the color. See below for details of the `ColorPickerColor` class.
             * This property is either a one-dimensional or two-dimensional array. If a two-dimensional array is provided,
             * the colors will be split into rows, providing more control over the appearance of the swatch.
             */
            set: function (colors) {
                var normalizedColors;
                // If it's a 1d array, convert it to 2d
                if (colors.length === 0 || !Array.isArray(colors[0])) {
                    normalizedColors = [colors];
                }
                else {
                    normalizedColors = colors;
                }
                // Convert any string colors to ColorPickerColor
                this.colors = normalizedColors.map(function (row) {
                    return row.map(function (color) { return color instanceof ColorPickerColor ? color : new ColorPickerColor(color, color); });
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "selected", {
            /**
             * The currently selected color. If this is one of the `colors` in the colors collection, it will be visually
             * highlighted in the swatch. It will also be shown in the input panel, if enabled (see showInput).
             * Note that this will always be a `ColorPickerColor` object, even if plain strings are provided to the colors property.
             * See below for details of the `ColorPickerColor` class.
             */
            set: function (selected) {
                this.selected$.next(selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "columns", {
            /**
             * The number of columns to display in the color swatch. Set this to -1 if the width should be specified by a stylesheet
             * instead, e.g. to provide a responsive layout.
             */
            set: function (columns) {
                this.columns$.next(columns);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "buttonSize", {
            /** The size of the color swatch buttons. Three size variants are currently supported. */
            set: function (buttonSize) {
                this.buttonSize$.next(buttonSize);
            },
            enumerable: true,
            configurable: true
        });
        ColorPickerComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Skip emitting the initial selectedChange
            this.selected$.pipe(operators.pairwise(), operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                if (prev) {
                    _this.selectedChange.emit(curr);
                }
            });
            // Set the width based on column count and button size
            rxjs.combineLatest(this.columns$, this.buttonSize$)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), columns = _b[0], buttonSize = _b[1];
                if (columns > 0) {
                    var w = columns * (BUTTON_WIDTHS[buttonSize] + (2 * BUTTON_MARGIN));
                    _this.cssWidth = w + "px";
                }
                else {
                    _this.cssWidth = 'auto';
                }
            });
        };
        ColorPickerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        ColorPickerComponent.prototype.updateColorValue = function (input, mode) {
            if (this.inputPatterns[mode].test(input)) {
                this.selected$.next(new ColorPickerColor('Custom', input, mode));
            }
        };
        ColorPickerComponent.prototype.toggleColorEntryType = function () {
            this.inputMode = (this.inputMode === 'hex') ? 'rgba' : 'hex';
        };
        ColorPickerComponent.prototype.getColorAriaLabel = function (color) {
            return "Select color " + color.name;
        };
        ColorPickerComponent.prototype.getSwitchModeAriaLabel = function (mode) {
            return "Switch input mode to " + (mode === 'hex' ? 'RGBA' : 'hex');
        };
        ColorPickerComponent.prototype.getInputAriaLabel = function (mode) {
            return "Edit " + mode + " color value";
        };
        __decorate([
            core.Input(),
            core.HostBinding('attr.id'),
            __metadata("design:type", String)
        ], ColorPickerComponent.prototype, "id", void 0);
        __decorate([
            core.Input('colors'),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], ColorPickerComponent.prototype, "inputColors", null);
        __decorate([
            core.Input(),
            __metadata("design:type", ColorPickerColor),
            __metadata("design:paramtypes", [ColorPickerColor])
        ], ColorPickerComponent.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], ColorPickerComponent.prototype, "columns", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ColorPickerComponent.prototype, "buttonStyle", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], ColorPickerComponent.prototype, "buttonSize", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ColorPickerComponent.prototype, "showTooltips", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ColorPickerComponent.prototype, "showInput", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ColorPickerComponent.prototype, "inputMode", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], ColorPickerComponent.prototype, "colorAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], ColorPickerComponent.prototype, "switchModeAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], ColorPickerComponent.prototype, "inputAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColorPickerComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColorPickerComponent.prototype, "inputSubmit", void 0);
        __decorate([
            core.HostBinding('style.width'),
            __metadata("design:type", Object)
        ], ColorPickerComponent.prototype, "cssWidth", void 0);
        ColorPickerComponent = __decorate([
            core.Component({
                selector: 'ux-color-picker',
                exportAs: 'ux-color-picker',
                template: "<div class=\"ux-color-picker\" uxTabbableList direction=\"horizontal\">\n    <div class=\"ux-color-picker-swatch\">\n        <div *ngFor=\"let row of colors\" class=\"ux-color-picker-swatch-row\">\n\n            <div *ngFor=\"let color of row\"\n                class=\"ux-color-picker-color\"\n                [class.ux-small]=\"(buttonSize$ | async) === 'sm'\"\n                [class.ux-large]=\"(buttonSize$ | async) === 'lg'\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"\n                [class.ux-selected]=\"color === (selected$ | async)\">\n\n                <button type=\"button\"\n                    uxFocusIndicator\n                    [attr.aria-label]=\"colorAriaLabel(color)\"\n                    aria-selected=\"color === (selected$ | async)\"\n                    class=\"btn btn-icon\"\n                    [uxColorContrast]=\"color.hex\"\n                    [style.background-color]=\"color.rgba\"\n                    (click)=\"selected$.next(color)\"\n                    uxTabbableListItem\n                    [uxTooltip]=\"color.name\"\n                    [tooltipDisabled]=\"!showTooltips\">\n\n                    <ux-icon name=\"checkmark\"></ux-icon>\n                </button>\n\n            </div>\n        </div>\n    </div>\n\n    <div *ngIf=\"showInput\" class=\"ux-color-picker-input-panel\">\n        <div class=\"ux-color-picker-input-header\">\n\n            <div class=\"ux-color-picker-preview\"\n                [style.background-color]=\"(selected$ | async).rgba\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\">\n            </div>\n\n            <label *ngIf=\"inputMode === 'hex'\" attr.for=\"{{ id }}-input-field\">HEX</label>\n            <label *ngIf=\"inputMode === 'rgba'\" attr.for=\"{{ id }}-input-field\">RGBA</label>\n\n            <button type=\"button\"\n                [attr.aria-label]=\"switchModeAriaLabel(inputMode)\"\n                class=\"btn btn-link btn-icon button-secondary ux-color-picker-input-toggle\"\n                (click)=\"toggleColorEntryType(); $event.stopPropagation()\">\n                <ux-icon name=\"chevron-right\"></ux-icon>\n            </button>\n        </div>\n\n        <div class=\"ux-color-picker-input\"\n            [class.has-error]=\"inputField.errors\"\n            [class.has-feedback]=\"inputField.errors\">\n\n            <input type=\"text\"\n                attr.id=\"{{id}}-input-field\"\n                [attr.aria-description]=\"inputAriaLabel(inputMode)\"\n                class=\"form-control\"\n                #inputField=\"ngModel\"\n                [ngModel]=\"(selected$ | async)[inputMode]\"\n                (ngModelChange)=\"updateColorValue($event, inputMode)\"\n                [pattern]=\"inputPatterns[inputMode].source\"\n                (keyup.enter)=\"inputSubmit.emit()\">\n\n                <ux-icon class=\"form-control-feedback\" name=\"alert\"></ux-icon>\n        </div>\n    </div>\n</div>\n"
            })
        ], ColorPickerComponent);
        return ColorPickerComponent;
    }());
    var uniqueId$2 = 0;
    var NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = /** @class */ (function () {
        function NumberPickerComponent(_changeDetector, _formGroup) {
            this._changeDetector = _changeDetector;
            this._formGroup = _formGroup;
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            this._touchedChange = function () { };
            /** Sets the id of the number picker. The child input will have this value with a -input suffix as its id. */
            this.id = "ux-number-picker-" + uniqueId$2++;
            /** @deprecated - Use reactive form validation instead.
            * Can be used to show a red outline around the input to indicate an invalid value. By default the error state will appear if the user enters a number below the minimum value or above the maximum value. */
            this.valid = true;
            /** Define the precision of floating point values */
            this.precision = 6;
            /** If two way binding is used this value will be updated any time the number picker value changes. */
            this.valueChange = new core.EventEmitter();
            /** Store the current valid state */
            this._valid = true;
            /** This is a flag to indicate when the component has been destroyed to avoid change detection being made after the component
             *  is no longer instantiated. A workaround for Angular Forms bug (https://github.com/angular/angular/issues/27803) */
            this._isDestroyed = false;
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            /** Sets the value displayed in the number picker component. */
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    this._valid = this.isValid();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            /** Defines the minimum value the number picker can set. */
            get: function () {
                return this._min;
            },
            set: function (value) {
                this._min = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            /** Defines the maximum value the number picker can set. */
            get: function () {
                return this._max;
            },
            set: function (value) {
                this._max = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            /** Defines the amount the number picker should increase or decrease when the buttons or arrow keys are used. */
            get: function () {
                return this._step;
            },
            set: function (value) {
                this._step = coercion.coerceNumberProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            /** Indicate if the number picker is disabled or not. */
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "inputId", {
            get: function () {
                return this.id + '-input';
            },
            enumerable: true,
            configurable: true
        });
        NumberPickerComponent.prototype.ngOnChanges = function () {
            this._valid = this.isValid();
        };
        NumberPickerComponent.prototype.ngOnDestroy = function () {
            this._isDestroyed = true;
        };
        NumberPickerComponent.prototype.increment = function (event) {
            if (event) {
                event.preventDefault();
            }
            if (!this.disabled) {
                this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                // account for javascripts terrible handling of floating point numbers
                this.value = parseFloat(this.value.toPrecision(this.precision));
                // emit the value to the Output and Angular forms
                this._emitValueChange(this.value);
            }
        };
        NumberPickerComponent.prototype.decrement = function (event) {
            if (event) {
                event.preventDefault();
            }
            if (!this.disabled) {
                this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                // account for javascripts terrible handling of floating point numbers
                this.value = parseFloat(this.value.toPrecision(this.precision));
                // emit the value to the Output and Angular forms
                this._emitValueChange(this.value);
            }
        };
        NumberPickerComponent.prototype.isValid = function () {
            if (this.value < this.min || this.value > this.max) {
                return false;
            }
            return this.valid;
        };
        NumberPickerComponent.prototype.onScroll = function (event) {
            // get the distance scrolled
            var scrollValue = event.deltaY || event.wheelDelta;
            // increment or decrement accordingly
            scrollValue < 0 ? this.increment(event) : this.decrement(event);
        };
        NumberPickerComponent.prototype.writeValue = function (value) {
            if (value !== undefined) {
                this._value = value;
                this._valid = this.isValid();
                // if the component is not destroyed then run change detection
                // workaround for Angular bug (https://portal.digitalsafe.net/browse/EL-3694)
                if (!this._isDestroyed) {
                    this._changeDetector.detectChanges();
                }
            }
        };
        NumberPickerComponent.prototype.registerOnChange = function (fn) {
            this._propagateChange = fn;
        };
        NumberPickerComponent.prototype.registerOnTouched = function (fn) {
            this._touchedChange = fn;
        };
        NumberPickerComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** Set the value and emit the change to the output and Angular forms. */
        NumberPickerComponent.prototype._emitValueChange = function (value) {
            // This is a workaround for angular bug https://github.com/angular/angular/issues/12540
            if (value === this._lastValue) {
                return;
            }
            this._lastValue = value;
            this.valueChange.emit(value);
            this._propagateChange(value);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NumberPickerComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NumberPickerComponent.prototype, "valid", void 0);
        __decorate([
            core.Input('aria-labelledby'),
            __metadata("design:type", String)
        ], NumberPickerComponent.prototype, "labelledBy", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NumberPickerComponent.prototype, "precision", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], NumberPickerComponent.prototype, "valueChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], NumberPickerComponent.prototype, "value", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Object])
        ], NumberPickerComponent.prototype, "min", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Object])
        ], NumberPickerComponent.prototype, "max", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Object])
        ], NumberPickerComponent.prototype, "step", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Object])
        ], NumberPickerComponent.prototype, "disabled", null);
        NumberPickerComponent = __decorate([
            core.Component({
                selector: 'ux-number-picker, ux-number-picker-inline',
                template: "<input type=\"number\"\n    [id]=\"inputId\"\n    role=\"spinbutton\"\n    class=\"form-control number-picker-input\"\n    [(ngModel)]=\"value\"\n    (ngModelChange)=\"_emitValueChange($event)\"\n    [min]=\"min\"\n    [max]=\"max\"\n    (focus)=\"_touchedChange()\"\n    (keydown.ArrowDown)=\"decrement($event)\"\n    (keydown.ArrowUp)=\"increment($event)\"\n    (wheel)=\"onScroll($event)\"\n    step=\"any\"\n    [disabled]=\"disabled\"\n    [attr.aria-valuemin]=\"min\"\n    [attr.aria-valuenow]=\"value\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-labelledby]=\"labelledBy\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control number-picker-control-up\"\n         (click)=\"increment($event)\"\n         (focus)=\"_touchedChange()\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <ux-icon name=\"up\"></ux-icon>\n    </div>\n\n    <div class=\"number-picker-control number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         (focus)=\"_touchedChange()\"\n         [class.disabled]=\"disabled || value <= min\">\n\n         <ux-icon name=\"down\"></ux-icon>\n    </div>\n\n</div>",
                providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                host: {
                    '[class.ux-number-picker-invalid]': '!_valid && !disabled && !_formGroup'
                }
            }),
            __param(1, core.Optional()),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                forms.FormGroupDirective])
        ], NumberPickerComponent);
        return NumberPickerComponent;
    }());
    var NumberPickerModule = /** @class */ (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    IconModule,
                    forms.FormsModule
                ],
                exports: [NumberPickerComponent],
                declarations: [NumberPickerComponent]
            })
        ], NumberPickerModule);
        return NumberPickerModule;
    }());
    var uniqueTooltipId = 0;
    var TooltipComponent = /** @class */ (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /** Define a unique id for each tooltip */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /** Define the tooltip role */
            this.role = 'tooltip';
            /** Allow a custom class to be added to the tooltip to allow custom styling */
            this.customClass = '';
            /** Emit when the tooltip need to update it's position */
            this.reposition$ = new rxjs.Subject();
        }
        Object.defineProperty(TooltipComponent.prototype, "isTemplateRef", {
            /** Indicates whether or not the content is a string or a TemplateRef */
            get: function () {
                return this.content instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /** Cleanup after the component is destroyed */
        TooltipComponent.prototype.ngOnDestroy = function () {
            this.reposition$.complete();
        };
        /** Inform the parent directive that it needs to recalulate the position */
        TooltipComponent.prototype.reposition = function () {
            this.reposition$.next();
        };
        /** This will update the content of the tooltip and trigger change detection */
        TooltipComponent.prototype.setContent = function (content) {
            this.content = content;
            this._changeDetectorRef.markForCheck();
        };
        /** This will update the tooltip placement and trigger change detection */
        TooltipComponent.prototype.setPlacement = function (placement) {
            if (!placement) {
                return;
            }
            this.placement = placement;
            this._changeDetectorRef.markForCheck();
        };
        /** This will update the tooltip alignment and trigger change detection */
        TooltipComponent.prototype.setAlignment = function (alignment) {
            if (!alignment) {
                return;
            }
            this.alignment = alignment;
            this._changeDetectorRef.markForCheck();
        };
        /** This will set a custom class on the tooltip and trigger change detection */
        TooltipComponent.prototype.setClass = function (customClass) {
            if (!customClass) {
                return;
            }
            this.customClass = customClass;
            this._changeDetectorRef.markForCheck();
        };
        /** Updates the context used by the TemplateRef */
        TooltipComponent.prototype.setContext = function (context) {
            if (!context) {
                return;
            }
            this.context = context;
            this._changeDetectorRef.markForCheck();
        };
        /** Specify the tooltip role attribute */
        TooltipComponent.prototype.setRole = function (role) {
            if (!role) {
                return;
            }
            this.role = role;
            this._changeDetectorRef.markForCheck();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TooltipComponent.prototype, "content", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TooltipComponent.prototype, "context", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TooltipComponent.prototype, "placement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TooltipComponent.prototype, "alignment", void 0);
        TooltipComponent = __decorate([
            core.Component({
                selector: 'ux-tooltip',
                template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef])
        ], TooltipComponent);
        return TooltipComponent;
    }());
    var TooltipService = /** @class */ (function () {
        function TooltipService() {
            this.shown$ = new rxjs.Subject();
        }
        TooltipService = __decorate([
            core.Injectable()
        ], TooltipService);
        return TooltipService;
    }());
    var TooltipDirective = /** @class */ (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /** All the user to add a custom class to the tooltip */
            this.customClass = '';
            /** All the user to add a role to the tooltip - default is tooltip */
            this.role = 'tooltip';
            /** Provide the TemplateRef a context object */
            this.context = {};
            /** Delay the showing of the tooltip by a number of miliseconds */
            this.delay = 0;
            /** Programmatically show and hide the tooltip */
            this.isOpen = false;
            /** Customize how the tooltip should be positioned relative to the element */
            this.placement = 'top';
            /** Customize the position of the callout */
            this.alignment = 'center';
            /** Specify which events should show the tooltip */
            this.showTriggers = ['mouseenter', 'focus'];
            /** Specify which events should hide the tooltip */
            this.hideTriggers = ['mouseleave', 'blur'];
            /** Emits an event when the tooltip is shown */
            this.shown = new core.EventEmitter();
            /** Emits a event when the tooltip is hidden */
            this.hidden = new core.EventEmitter();
            /** Allow two way binding to track the visibility of the tooltip */
            this.isOpenChange = new core.EventEmitter();
            /** Keep track of the tooltip visibility */
            this.isVisible = false;
            /** Define the overlay class */
            this._overlayClass = 'ux-tooltip-pane';
            /** This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically */
            this._onDestroy = new rxjs.Subject();
            /** Store the timeout interval for cancelation */
            this._showTimeoutId = null;
            /** Internally store the type of this component - usual for distinctions when extending this class */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        TooltipDirective.prototype.ngOnInit = function () {
            var _this = this;
            // set up show and hide event triggers
            rxjs.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
            rxjs.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
            rxjs.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
            rxjs.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
            rxjs.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
            // when any other tooltips open hide this one
            this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip) { return tooltip !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
            // if the tooltip should be initially visible then open it
            if (this.isOpen) {
                this.show();
            }
        };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        TooltipDirective.prototype.ngOnChanges = function (changes) {
            // we can ignore the first change as it's handled in ngOnInit
            if (changes.isOpen && !changes.isOpen.firstChange && changes.isOpen.currentValue !== this.isVisible) {
                changes.isOpen.currentValue ? this.show() : this.hide();
            }
            // destroy the overlay ref so a new correctly positioned instance will be created next time
            if (changes.placement) {
                this.destroyOverlay();
            }
            if (this._instance && changes.placement) {
                this._instance.setPlacement(changes.placement.currentValue);
            }
            if (this._instance && changes.alignment) {
                this._instance.setAlignment(changes.alignment.currentValue);
            }
            if (this._instance && changes.content) {
                this._instance.setContent(changes.content.currentValue);
            }
            if (this._instance && changes.customClass) {
                this._instance.setClass(changes.customClass.currentValue);
            }
            if (this._instance && changes.context) {
                this._instance.setContext(changes.context.currentValue);
            }
            if (this._instance && changes.role) {
                this._instance.setContext(changes.role.currentValue);
            }
        };
        /** Ensure we clean up after ourselves */
        TooltipDirective.prototype.ngOnDestroy = function () {
            // ensure we close the tooltip when the host is destroyed
            if (this._overlayRef) {
                this._overlayRef.dispose();
                this._instance = null;
            }
            // clear any pending timeouts
            this.cancelTooltip();
            // emit this event to automatically unsubscribe from all subscriptions
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Make the tooltip open */
        TooltipDirective.prototype.show = function () {
            var _this = this;
            // if the tooltip is disabled then do nothing
            if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                return;
            }
            // delay the show by the delay amount
            this._showTimeoutId = window.setTimeout(function () {
                // create the tooltip and get the overlay ref
                var overlayRef = _this.createOverlay();
                // create the portal to create the tooltip component
                _this._portal = _this.createPortal();
                _this._instance = _this.createInstance(overlayRef);
                // watch for any changes to the content
                _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                // store the visible state
                _this.isVisible = true;
                // ensure the overlay has the correct initial position
                _this.reposition();
                // emit the show events
                _this.shown.emit();
                _this.isOpenChange.next(true);
                // clear the interval id
                _this._showTimeoutId = null;
                // emit the show event to close any other tooltips
                _this._tooltipService.shown$.next(_this._instance);
                // ensure change detection is run
                _this._changeDetectorRef.detectChanges();
            }, this.delay);
        };
        /** If a tooltip exists and is visible, hide it */
        TooltipDirective.prototype.hide = function () {
            // if we are waiting to show a tooltip then cancel the pending timeout
            if (this._showTimeoutId) {
                window.clearTimeout(this._showTimeoutId);
                this._showTimeoutId = null;
                return;
            }
            if (this._overlayRef && this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
            }
            this.setAriaDescribedBy(null);
            this._instance = null;
            // store the visible state
            this.isVisible = false;
            // emit the hide events
            this.hidden.emit();
            this.isOpenChange.next(false);
            // ensure change detection is run
            this._changeDetectorRef.detectChanges();
        };
        /** Toggle the visibility of the tooltip */
        TooltipDirective.prototype.toggle = function () {
            this.isVisible ? this.hide() : this.show();
        };
        /** Recalculate the position of the popover */
        TooltipDirective.prototype.reposition = function () {
            if (this.isVisible && this._overlayRef) {
                this._overlayRef.updatePosition();
            }
        };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        TooltipDirective.prototype.createInstance = function (overlayRef) {
            var instance = overlayRef.attach(this._portal).instance;
            // supply the tooltip with the correct properties
            instance.setContent(this.content);
            instance.setPlacement(this.placement);
            instance.setAlignment(this.alignment);
            instance.setClass(this.customClass);
            instance.setContext(this.context);
            instance.setRole(this.role);
            // Update the aria-describedby attribute
            this.setAriaDescribedBy(instance.id);
            return instance;
        };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        TooltipDirective.prototype.createPortal = function () {
            return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
        };
        /** Create the overlay and set up the scroll handling behavior */
        TooltipDirective.prototype.createOverlay = function () {
            // if the tooltip has already been created then just return the existing instance
            if (this._overlayRef) {
                return this._overlayRef;
            }
            // configure the tooltip
            var strategy = this._overlay.position()
                .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
            // correctly handle scrolling
            var scrollableAncestors = this._scrollDispatcher
                .getAncestorScrollContainers(this._elementRef);
            strategy.withScrollableContainers(scrollableAncestors);
            this._overlayRef = this._overlay.create({
                positionStrategy: strategy,
                panelClass: this._overlayClass,
                scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                hasBackdrop: false
            });
            return this._overlayRef;
        };
        /** Recreate the overlay ref using the updated origin and overlay positions */
        TooltipDirective.prototype.destroyOverlay = function () {
            // destroy the existing overlay
            if (this._overlayRef && this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
            }
            if (this._overlayRef) {
                this._overlayRef.dispose();
                this._overlayRef = null;
            }
            this.isVisible = false;
        };
        /** Get the origin position based on the specified tooltip placement */
        TooltipDirective.prototype.getOrigin = function () {
            // ensure placement is defined
            this.placement = this.placement || 'top';
            if (this.placement === 'top' || this.placement === 'bottom') {
                return { originX: this.alignment, originY: this.placement };
            }
            if (this.placement === 'left') {
                return { originX: 'start', originY: this.getVerticalAlignment() };
            }
            if (this.placement === 'right') {
                return { originX: 'end', originY: this.getVerticalAlignment() };
            }
        };
        /** Calculate the overlay position based on the specified tooltip placement */
        TooltipDirective.prototype.getOverlayPosition = function () {
            // ensure placement is defined
            this.placement = this.placement || 'top';
            if (this.placement === 'top') {
                return { overlayX: this.alignment, overlayY: 'bottom' };
            }
            if (this.placement === 'bottom') {
                return { overlayX: this.alignment, overlayY: 'top' };
            }
            if (this.placement === 'left') {
                return { overlayX: 'end', overlayY: this.getVerticalAlignment() };
            }
            if (this.placement === 'right') {
                return { overlayX: 'start', overlayY: this.getVerticalAlignment() };
            }
        };
        /** Convert the alignment property to a valid CDK alignment value */
        TooltipDirective.prototype.getVerticalAlignment = function () {
            switch (this.alignment) {
                case 'start':
                    return 'top';
                case 'end':
                    return 'bottom';
                default:
                    return this.alignment;
            }
        };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        TooltipDirective.prototype.includes = function (array, value) {
            return Array.isArray(array) && !!array.find(function (item) { return item === value; });
        };
        /** Handle the click event - show or hide accordingly */
        TooltipDirective.prototype.onClick = function (_) {
            // if its not visible and click is a show trigger open it
            if (!this.isVisible && this.includes(this.showTriggers, 'click') && this._showTimeoutId === null) {
                return this.show();
            }
            // if its visible and click is a hide trigger close it
            if (this.isVisible && this.includes(this.hideTriggers, 'click') && this._showTimeoutId === null) {
                return this.hide();
            }
            // if its not visible and click is a hide trigger close it and there is a pending tooltip
            if (!this.isVisible && this.includes(this.hideTriggers, 'click') && this._showTimeoutId !== null) {
                return this.cancelTooltip();
            }
        };
        /** Handle the mouse enter event - show or hide accordingly */
        TooltipDirective.prototype.onMouseEnter = function (_) {
            // this is an show only trigger - if already open or it isn't a trigger do nothing
            if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                return;
            }
            // otherwise open the tooltip
            this.show();
        };
        /** Handle the mouse leave event - show or hide accordingly */
        TooltipDirective.prototype.onMouseLeave = function (_) {
            // If the tooltip is pending then cancel showing it
            if (!this.isVisible && this.includes(this.hideTriggers, 'mouseleave') && this._showTimeoutId !== null) {
                return this.cancelTooltip();
            }
            // if the tooltip is not visible or mouseleave isn't a hide trigger then do nothing
            if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                return;
            }
            // otherwise close the tooltip
            this.hide();
        };
        /** Handle the focus event - show or hide accordingly */
        TooltipDirective.prototype.onFocus = function (_) {
            // this is an show only trigger - if already open or it isn't a trigger do nothing
            if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                return;
            }
            // otherwise open the tooltip
            this.show();
        };
        /** Handle the blur event - show or hide accordingly */
        TooltipDirective.prototype.onBlur = function (_) {
            // If the tooltip is pending then cancel showing it
            if (!this.isVisible && this.includes(this.hideTriggers, 'blur') && this._showTimeoutId !== null) {
                return this.cancelTooltip();
            }
            // this is an hide only trigger - if not open or it isn't a trigger do nothing
            if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                return;
            }
            // otherwise close the tooltip
            this.hide();
        };
        /** Programmatically update the aria-describedby property */
        TooltipDirective.prototype.setAriaDescribedBy = function (id) {
            if (id === null) {
                this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
            }
            else {
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
            }
        };
        /** Cancel any pending tooltip (waiting on delay ellapsing) */
        TooltipDirective.prototype.cancelTooltip = function () {
            if (this._showTimeoutId !== null) {
                window.clearTimeout(this._showTimeoutId);
                this._showTimeoutId = null;
            }
        };
        __decorate([
            core.Input('uxTooltip'),
            __metadata("design:type", Object)
        ], TooltipDirective.prototype, "content", void 0);
        __decorate([
            core.Input('tooltipDisabled'),
            __metadata("design:type", Boolean)
        ], TooltipDirective.prototype, "disabled", void 0);
        __decorate([
            core.Input('tooltipClass'),
            __metadata("design:type", String)
        ], TooltipDirective.prototype, "customClass", void 0);
        __decorate([
            core.Input('tooltipRole'),
            __metadata("design:type", String)
        ], TooltipDirective.prototype, "role", void 0);
        __decorate([
            core.Input('tooltipContext'),
            __metadata("design:type", Object)
        ], TooltipDirective.prototype, "context", void 0);
        __decorate([
            core.Input('tooltipDelay'),
            __metadata("design:type", Number)
        ], TooltipDirective.prototype, "delay", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TooltipDirective.prototype, "isOpen", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TooltipDirective.prototype, "placement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TooltipDirective.prototype, "alignment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TooltipDirective.prototype, "showTriggers", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TooltipDirective.prototype, "hideTriggers", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TooltipDirective.prototype, "shown", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TooltipDirective.prototype, "hidden", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TooltipDirective.prototype, "isOpenChange", void 0);
        TooltipDirective = __decorate([
            core.Directive({
                selector: '[uxTooltip]',
                exportAs: 'ux-tooltip'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.ViewContainerRef,
                overlay.Overlay,
                overlay.ScrollDispatcher,
                core.ChangeDetectorRef,
                core.Renderer2,
                TooltipService])
        ], TooltipDirective);
        return TooltipDirective;
    }());
    var TooltipModule = /** @class */ (function () {
        function TooltipModule() {
        }
        TooltipModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    overlay.OverlayModule,
                    observers.ObserversModule
                ],
                exports: [TooltipDirective, TooltipComponent],
                declarations: [TooltipComponent, TooltipDirective],
                providers: [TooltipService],
                entryComponents: [TooltipComponent]
            })
        ], TooltipModule);
        return TooltipModule;
    }());
    var ColorPickerModule = /** @class */ (function () {
        function ColorPickerModule() {
        }
        ColorPickerModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    NumberPickerModule,
                    TooltipModule,
                    IconModule
                ],
                exports: [
                    ColorPickerComponent
                ],
                declarations: [
                    ColorPickerComponent
                ],
            })
        ], ColorPickerModule);
        return ColorPickerModule;
    }());
    var ColumnSortingDirective = /** @class */ (function () {
        function ColumnSortingDirective() {
            /** Emit the current sort state for all columns within the table */
            this.events = new rxjs.Subject();
            /** Store the current sort state for all columns within the table */
            this.order = [];
        }
        ColumnSortingDirective.prototype.ngOnDestroy = function () {
            this.events.complete();
        };
        /** Toggle the sorting state of a column */
        ColumnSortingDirective.prototype.toggleColumn = function (sorting) {
            // apply sorting based on the single or multiple sort
            this.order = this.singleSort ? this.toggleSingleColumn(sorting) : this.toggleMultipleColumn(sorting);
            // emit the latest order
            this.events.next(this.order);
            return this.order;
        };
        /** Explicitly set the column state */
        ColumnSortingDirective.prototype.setColumnState = function (key, state) {
            // check if the sorting has actually changed
            if (this.order.find(function (column) { return column.key === key && column.state === state; })) {
                return;
            }
            // if only one column can be sorted and the current column has a sort direction remove all others
            if (this.singleSort && state !== exports.ColumnSortingState.NoSort) {
                this.order = [];
            }
            else {
                // remove the item from the state if present
                this.order = this.order.filter(function (column) { return column.key !== key; });
            }
            // if the column has active sorting then we should add it to the array again
            if (state === exports.ColumnSortingState.Ascending || state === exports.ColumnSortingState.Descending) {
                this.order = __spread(this.order, [{ key: key, state: state }]);
            }
        };
        /** Toggle the sorting state of a column when using single select */
        ColumnSortingDirective.prototype.toggleSingleColumn = function (sorting) {
            return sorting.state === exports.ColumnSortingState.NoSort ? [] : [{ key: sorting.key, state: sorting.state }];
        };
        /** Toggle the sorting state of a column when using multiple select */
        ColumnSortingDirective.prototype.toggleMultipleColumn = function (sorting) {
            // reorder columns here
            var idx = this.order.findIndex(function (column) { return column.key === sorting.key; });
            // if wasn't previously selected add to list and it is being sorted
            if (idx === -1 && sorting.state !== exports.ColumnSortingState.NoSort) {
                return __spread(this.order, [{ key: sorting.key, state: sorting.state }]);
            }
            // if we are sorting it change the sorting order
            if (sorting.state === exports.ColumnSortingState.Ascending || sorting.state === exports.ColumnSortingState.Descending) {
                return __spread(this.order.filter(function (_column) { return _column.key !== sorting.key; }), [{ key: sorting.key, state: sorting.state }]);
            }
            // Otherwise remove the item
            return this.order.filter(function (_column) { return _column.key !== sorting.key; });
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ColumnSortingDirective.prototype, "singleSort", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnSortingDirective.prototype, "sortIndicator", void 0);
        ColumnSortingDirective = __decorate([
            core.Directive({
                selector: '[uxColumnSorting]'
            })
        ], ColumnSortingDirective);
        return ColumnSortingDirective;
    }());
    (function (ColumnSortingState) {
        ColumnSortingState["Ascending"] = "ascending";
        ColumnSortingState["Descending"] = "descending";
        ColumnSortingState["NoSort"] = "none";
    })(exports.ColumnSortingState || (exports.ColumnSortingState = {}));
    var ColumnSortingComponent = /** @class */ (function () {
        function ColumnSortingComponent(_sorter, _changeDetector) {
            this._sorter = _sorter;
            this._changeDetector = _changeDetector;
            /** Defines the sorting order of a column: `NoSort`, `Ascending` or `Descending`. */
            this.state = exports.ColumnSortingState.NoSort;
            /** Determine if a column can have a `NoSort` state */
            this.allowNoSort = true;
            /**
             * Changes the state of the sorting on the column between `NoSort`, `Ascending` and `Descending`.
             * This returns an array of objects for each column being sorted containing `key: string` and `state: ColumnSortingState`.
             * State can be used to find the current sorting state of the column eg. `(state === ColumnSortingState.Ascending)`.
             * The `ColumnSortingOrder` interface has been provided for objects in the array.
             */
            this.stateChange = new core.EventEmitter();
            /** Emit whenever the order changes */
            this.orderChange = new core.EventEmitter();
            /** Expose the sorting state enum to the view */
            this.ColumnSortingState = exports.ColumnSortingState;
            /** Unsubscribe from all observables on component destroy */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(ColumnSortingComponent.prototype, "_sortIndicator", {
            /** Access the custom sort indicator if one was provided */
            get: function () {
                return this._sorter.sortIndicator;
            },
            enumerable: true,
            configurable: true
        });
        ColumnSortingComponent.prototype.ngOnInit = function () {
            var _this = this;
            // listen for changes triggered by the directive
            this._sorter.events.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function (columns) { return _this.updateState(columns); });
        };
        ColumnSortingComponent.prototype.ngOnChanges = function (changes) {
            // if the state input is changed then apply the change
            if (changes.state && changes.state.currentValue !== changes.state.previousValue) {
                this._sorter.setColumnState(this.key, this.state);
            }
        };
        ColumnSortingComponent.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        /** Toggle the sorting state of a column - this is designed to be programmatically called by the consuming component */
        ColumnSortingComponent.prototype.changeState = function () {
            switch (this.state) {
                case exports.ColumnSortingState.Ascending:
                    this.state = exports.ColumnSortingState.Descending;
                    break;
                case exports.ColumnSortingState.Descending:
                    this.state = this.allowNoSort ? exports.ColumnSortingState.NoSort : exports.ColumnSortingState.Ascending;
                    break;
                default:
                    this.state = exports.ColumnSortingState.Ascending;
            }
            // change detection should be run
            this._changeDetector.markForCheck();
            // inform parent (internally we use a ReadonlyArray but are returning a standard array to prevent breaking changes to the public API)
            return this._sorter.toggleColumn({ key: this.key, state: this.state });
        };
        /** Update the state based on column order */
        ColumnSortingComponent.prototype.updateState = function (columns) {
            var _this = this;
            // if we are sorting this column then find the matching data
            var columnIdx = columns.findIndex(function (_column) { return _column.key === _this.key; });
            // if we are not sorting this column then mark it as NoSort
            if (columnIdx === -1) {
                this.state = exports.ColumnSortingState.NoSort;
            }
            // only store the number if we have 2 or more columns being sorted
            this.order = columns.length < 2 || columnIdx === -1 ? null : columnIdx + 1;
            // emit the latest order value
            if (typeof this.order === 'number') {
                this.orderChange.emit(this.order);
            }
            // change detection should be run
            this._changeDetector.markForCheck();
            // Emit the latest change
            this.stateChange.emit(this.state);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ColumnSortingComponent.prototype, "state", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ColumnSortingComponent.prototype, "key", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ColumnSortingComponent.prototype, "order", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ColumnSortingComponent.prototype, "allowNoSort", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColumnSortingComponent.prototype, "stateChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColumnSortingComponent.prototype, "orderChange", void 0);
        ColumnSortingComponent = __decorate([
            core.Component({
                selector: 'ux-column-sorting',
                template: "<div class=\"ux-column-sorting\">\n\n    <!-- The default sort indicator -->\n    <ng-container *ngIf=\"!_sortIndicator\">\n\n        <ux-icon\n            class=\"ux-column-sorting-icon\"\n            [class.column-sorting-icon-hidden]=\"state === ColumnSortingState.NoSort\"\n            [name]=\"state === ColumnSortingState.Ascending ? 'ascend' : 'descend'\">\n        </ux-icon>\n\n        <p class=\"ux-column-sorting-number\" aria-hidden=\"true\">{{ order }}</p>\n    </ng-container>\n\n    <!-- Custom sort indicator -->\n    <ng-container\n        *ngIf=\"_sortIndicator\"\n        [ngTemplateOutlet]=\"_sortIndicator\"\n        [ngTemplateOutletContext]=\"{ state: state, order: order }\">\n    </ng-container>\n\n</div>",
                exportAs: 'ux-column-sorting',
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [ColumnSortingDirective,
                core.ChangeDetectorRef])
        ], ColumnSortingComponent);
        return ColumnSortingComponent;
    }());
    var ColumnSortingModule = /** @class */ (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    IconModule
                ],
                exports: [
                    ColumnSortingComponent,
                    ColumnSortingDirective
                ],
                declarations: [
                    ColumnSortingComponent,
                    ColumnSortingDirective
                ]
            })
        ], ColumnSortingModule);
        return ColumnSortingModule;
    }());
    var ConduitSubject = /** @class */ (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new rxjs.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        ConduitSubject.prototype.getInitialValue = function () {
            var _this = this;
            // if we do not accept inputs then do nothing
            if (this.conduit.acceptsInput === false) {
                return;
            }
            // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
            var subjects = this._zone.getSubjects().filter(function (subject) {
                // If this is itself or if it has not value to give us then do nothing
                if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                    return false;
                }
                // if acceptsInput is true then we return every time
                if (_this.conduit.acceptsInput === true) {
                    return true;
                }
                if (Array.isArray(_this.conduit.acceptsInput)) {
                    return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                }
            });
            // if there are no matches then do nothing
            if (subjects.length === 0) {
                return;
            }
            // otherwise sort by the last modified field
            subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
            // get the most recent value
            this._subject.next(subjects[0].conduit.currentValue);
        };
        /** This will be triggered when a conduits value has changed */
        ConduitSubject.prototype.onInput = function (event) {
            // if we dont accept input or we emitted this value then do nothing
            if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                return;
            }
            // check if the conduit produces output - if not we only do something if we are in the same zone
            if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                return;
            }
            // check if we only accept inputs from specific zones
            if (Array.isArray(this.conduit.acceptsInput)) {
                // check if the event came from an acceptable zone
                if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                    return;
                }
            }
            // if required transform the value
            var outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
            // update the subject
            this._subject.next(outputValue);
        };
        /** This will be fired when this conduit emits a new value */
        ConduitSubject.prototype.onOutput = function (value) {
            // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
            this.conduit.currentValue = value;
            this.conduit.lastModified = new Date();
            // check if this should produce output
            if (this.conduit.producesOutput) {
                this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
            }
        };
        /** Unsubscribe once this subject is destroyed */
        ConduitSubject.prototype.destroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        return ConduitSubject;
    }());
    var ConduitZone = /** @class */ (function () {
        function ConduitZone() {
        }
        ConduitZone_1 = ConduitZone;
        ConduitZone.prototype.ngOnDestroy = function () {
            var _this = this;
            // find all conduit subjects that are part of this zone
            ConduitZone_1.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
        };
        /** Store reference to the repository and begin watching for and emitting changes */
        ConduitZone.prototype.registerConduit = function (conduit) {
            ConduitZone_1.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
        };
        /** Destroy a conduit */
        ConduitZone.prototype.unregisterConduit = function (conduit) {
            var subject = this.getConduitSubject(conduit.subject);
            if (subject) {
                // remove the subject from the internal list of conduit subjects
                ConduitZone_1.subjects = ConduitZone_1.subjects.filter(function (_subject) { return _subject !== subject; });
                // perform all unsubscriptions
                subject.destroy();
            }
        };
        /** Provide the zone with an ID */
        ConduitZone.prototype.setZoneId = function (zoneId) {
            this._zoneId = zoneId;
        };
        /** Emit a value to all zones for checking */
        ConduitZone.prototype.emit = function (event) {
            ConduitZone_1.events.next(event);
        };
        /** Retrieve a conduit subsject object from the rxjs subject */
        ConduitZone.prototype.getConduitSubject = function (subject) {
            return ConduitZone_1.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
        };
        /** Get all subjects from all zones */
        ConduitZone.prototype.getSubjects = function () {
            return ConduitZone_1.subjects;
        };
        /** Alter the properties of a conduit dynamically */
        ConduitZone.prototype.setConduitProperties = function (subject, properties) {
            // find the conduit with the matching subject
            var conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
            // if a match was found update the properties
            if (conduitSubject) {
                // update each specified property
                for (var prop in properties) {
                    conduitSubject.conduit[prop] = properties[prop];
                }
            }
        };
        /** Programmatically create a conduit at runtime */
        ConduitZone.prototype.createConduit = function (subject, properties) {
            // register the conduit with the zone
            this.registerConduit(__assign(__assign({}, properties), { subject: subject }));
        };
        /** Register all conduits in a component */
        ConduitZone.prototype.registerConduits = function (component) {
            var _this = this;
            if (Array.isArray(component._conduits)) {
                component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign(__assign({}, conduit), { subject: component[conduit.propertyKey] })); });
            }
        };
        /** Register all conduits in a component */
        ConduitZone.prototype.unregisterConduits = function (component) {
            var _this = this;
            if (Array.isArray(component._conduits)) {
                component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
            }
        };
        /** Return the global event stream */
        ConduitZone.prototype.getEvents = function () {
            return ConduitZone_1.events;
        };
        var ConduitZone_1;
        /** Create a global subject store */
        ConduitZone.subjects = [];
        /** Expose an event stream of new values */
        ConduitZone.events = new rxjs.Subject();
        ConduitZone = ConduitZone_1 = __decorate([
            core.Injectable()
        ], ConduitZone);
        return ConduitZone;
    }());
    var ConduitComponent = /** @class */ (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
        }
        /** We need to register the conduits with the zone when the component is initialised */
        ConduitComponent.prototype.ngOnInit = function () {
            // register the conduit in the zone and ensure it gets the correct instance of the target
            this._zone.registerConduits(this);
        };
        /** We need to unregister the conduits when the component is destroyed */
        ConduitComponent.prototype.ngOnDestroy = function () {
            this._zone.unregisterConduits(this);
        };
        /** Alter the properties of a conduit dynamically */
        ConduitComponent.prototype.setConduitProperties = function (subject, properties) {
            this._zone.setConduitProperties(subject, properties);
        };
        /** Programmatically create a conduit at runtime */
        ConduitComponent.prototype.createConduit = function (subject, properties) {
            this._zone.createConduit(subject, properties);
        };
        ConduitComponent = __decorate([
            core.Directive({
                selector: 'ux-conduit'
            }),
            __param(0, core.Optional()),
            __metadata("design:paramtypes", [ConduitZone])
        ], ConduitComponent);
        return ConduitComponent;
    }());
    var ConduitZoneComponent = /** @class */ (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ConduitZoneComponent.prototype.ngOnInit = function () {
            this._zone.setZoneId(this.zoneId);
            _super.prototype.ngOnInit.call(this);
        };
        ConduitZoneComponent = __decorate([
            core.Directive({
                selector: 'ux-conduit-zone'
            })
        ], ConduitZoneComponent);
        return ConduitZoneComponent;
    }(ConduitComponent));
    var defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };
    /** Expose the property that conduits will be stored in */
    var CONDUITS = '_conduits';
    /** Create the conduit property decorator */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(__assign(__assign(__assign({}, defaultConduitProps), properties), { target: target, propertyKey: propertyKey }));
        };
    }
    /**
     * This module is not required to be imported but is required
     * by the Angular compiler, otherwise it will complain that
     * ConduitZoneComponent is not part of an NgModule and will
     * fail to build
     */
    var ConduitModule = /** @class */ (function () {
        function ConduitModule() {
        }
        ConduitModule = __decorate([
            core.NgModule({
                declarations: [
                    ConduitComponent,
                    ConduitZoneComponent // Any is required as this is an abstract class
                ]
            })
        ], ConduitModule);
        return ConduitModule;
    }());
    var DragService = /** @class */ (function () {
        function DragService() {
            /** Emit when dragging begins */
            this.onDragStart = new rxjs.Subject();
            /** Emit when dragging moves */
            this.onDrag = new rxjs.Subject();
            /** Emit when dragging ends */
            this.onDragEnd = new rxjs.Subject();
            /** Emit when the user is dragging over the drop area */
            this.onDropEnter = new rxjs.Subject();
            /** Emit when the user is dragging out of the drop area */
            this.onDropLeave = new rxjs.Subject();
            /** Emit when a drop occurs */
            this.onDrop = new rxjs.Subject();
        }
        /** Destroy all observables */
        DragService.prototype.ngOnDestroy = function () {
            this.onDragStart.complete();
            this.onDrag.complete();
            this.onDragEnd.complete();
            this.onDrop.complete();
            this.onDropEnter.complete();
            this.onDropLeave.complete();
        };
        DragService = __decorate([
            core.Injectable()
        ], DragService);
        return DragService;
    }());
    var DragDirective = /** @class */ (function () {
        function DragDirective(_elementRef, _ngZone, _renderer, _drag) {
            var _this = this;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            this._drag = _drag;
            /** Detemine if we should show a clone when dragging */
            this.clone = false;
            /** Allow the dragging to be enabled/disabled */
            this.draggable = true;
            /** Emit an event when dragging starts */
            this.onDragStart = new core.EventEmitter();
            /** Emit an event when the mouse moves while dragging */
            this.onDrag = new core.EventEmitter();
            /** Emit an event when the dragging finishes */
            this.onDragEnd = new core.EventEmitter();
            /** Emit when the user drops an item in a drop area */
            this.onDrop = new core.EventEmitter();
            /** Emit when the user drags over a drop area */
            this.onDropEnter = new core.EventEmitter();
            /** Emit when the user drags out of a drop area */
            this.onDropLeave = new core.EventEmitter();
            /** Store the dragging state */
            this._isDragging = false;
            /** Create an observable from the mouse down event */
            this._mousedown$ = rxjs.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /** Create an observable from the mouse move event */
            this._mousemove$ = rxjs.fromEvent(document, 'mousemove');
            /** Create an observable from the mouse up event */
            this._mouseup$ = rxjs.fromEvent(document, 'mouseup');
            /** Use an observable to unsubscribe from all subscriptions */
            this._onDestroy = new rxjs.Subject();
            // ensure all mouse down events on the object are captured
            this._mousedown$.pipe(operators.filter(function () { return _this.draggable; }), operators.takeUntil(this._onDestroy))
                .subscribe(this.dragStart.bind(this));
            // emit the outputs when drag events occur
            _drag.onDragStart.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (dragEvent) { return _this.onDragStart.emit(dragEvent.event); });
            _drag.onDrag.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (dragEvent) { return _this.onDrag.emit(dragEvent.event); });
            _drag.onDragEnd.pipe(operators.filter(function (event) { return _this._isDragging || (_this.model && _this.model === event.data); }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDragEnd.emit(); });
            _drag.onDrop.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this.onDrop.emit(event); });
            _drag.onDropEnter.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDropEnter.emit(); });
            _drag.onDropLeave.pipe(operators.filter(function () { return _this._isDragging; }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onDropLeave.emit(); });
        }
        /** Emit events and create clone when drag starts */
        DragDirective.prototype.dragStart = function (event) {
            var _this = this;
            event.preventDefault();
            if (this.clone) {
                // clone the node
                this.cloneNode(event);
            }
            // apply a class to the element being dragged
            this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
            // store the dragging state
            this._isDragging = true;
            // emit the drag start event
            this._ngZone.run(function () { return _this._drag.onDragStart.next({ event: event, group: _this.group, data: _this.model }); });
            this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                .subscribe(this.dragMove.bind(this));
            // When dragging stops emit the drag end
            this._mouseup$.pipe(operators.first()).subscribe(this.dragEnd.bind(this));
        };
        /** Emit event and update clone position when dragging moves */
        DragDirective.prototype.dragMove = function (event) {
            var _this = this;
            event.preventDefault();
            if (this._clone) {
                this.updateNodePosition(event);
            }
            // emit the drag start event
            this._ngZone.run(function () { return _this._drag.onDrag.next({ event: event, group: _this.group, data: _this.model }); });
        };
        /** Emit event and destroy clone when dragging ends */
        DragDirective.prototype.dragEnd = function () {
            var _this = this;
            // if there was a clone, remove it
            if (this._clone) {
                this._renderer.removeChild(document.body, this._clone);
                this._clone = null;
            }
            // remove the dragging class
            this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
            // emit the on drag end output
            this._ngZone.run(function () { return _this._drag.onDragEnd.next({ group: _this.group, data: _this.model }); });
            // store the dragging state
            this._isDragging = false;
        };
        /** Create an exact clone of an element */
        DragDirective.prototype.cloneNode = function (event) {
            // duplicate the node
            this._clone = this._elementRef.nativeElement.cloneNode(true);
            // store the position within the draggable element
            var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left, width = _a.width;
            this._offset = { x: event.clientX - left, y: event.clientY - top };
            // inline all styles so it looks identical regardless of its position in the DOM
            this.inlineStyles(this._elementRef.nativeElement, this._clone);
            // IE doesn't always calculate the correct width value using getComputedStyles... use bounding client value instead
            this._renderer.setStyle(this._clone, 'width', width + 'px');
            // ensure we can easily position the node an it is above all other elements
            this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
            this._renderer.setStyle(this._clone, 'position', 'absolute');
            this._renderer.setStyle(this._clone, 'z-index', '99999');
            // apply a class to allow custom styling
            this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
            // insert the cloned element
            this._renderer.appendChild(document.body, this._clone);
            // set the cloned element initial position
            this.updateNodePosition(event);
        };
        /** Position the clone relative to the mouse */
        DragDirective.prototype.updateNodePosition = function (event) {
            this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
            this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
        };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        DragDirective.prototype.inlineStyles = function (source, target) {
            // get all the computed styles from the source element
            var styles = getComputedStyle(source);
            // inline every specified style
            for (var idx = 0; idx < styles.length; idx++) {
                var style = styles.item(idx);
                if (style !== undefined) {
                    this._renderer.setStyle(target, styles[idx], styles[style]);
                }
            }
            // ensure we dont capture any move events
            this._renderer.setStyle(target, 'pointer-events', 'none');
            // do the same for all the child elements
            for (var idx = 0; idx < source.children.length; idx++) {
                this.inlineStyles(source.children[idx], target.children[idx]);
            }
        };
        /** Unsubscribe from all subscriptions */
        DragDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DragDirective.prototype, "clone", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DragDirective.prototype, "group", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "model", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DragDirective.prototype, "draggable", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDragStart", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDrag", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDragEnd", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDrop", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDropEnter", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DragDirective.prototype, "onDropLeave", void 0);
        DragDirective = __decorate([
            core.Directive({
                selector: '[uxDrag]'
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.NgZone, core.Renderer2, DragService])
        ], DragDirective);
        return DragDirective;
    }());
    var DropDirective = /** @class */ (function () {
        function DropDirective(_dragService) {
            var _this = this;
            this._dragService = _dragService;
            /** Define whether or not dropping is enabled */
            this.dropDisabled = false;
            /** Emit the model of the item dropped */
            this.onDrop = new core.EventEmitter();
            /** Determine whether or not the mouse is within the drop region */
            this.isMouseOver = false;
            /** Determine whether or not we are currently dragging an item */
            this.isDragging = false;
            /** Ensure we destroy all subscriptions */
            this._onDestroy = new rxjs.Subject();
            // subscribe to drag events
            _dragService.onDragStart.pipe(operators.tap(function (event) { return _this._group = event.group; }), operators.filter(function (event) { return _this.isDropAllowed(event.group); }), operators.takeUntil(this._onDestroy))
                .subscribe(this.onDragStart.bind(this));
            _dragService.onDragEnd.pipe(operators.filter(function (event) { return _this.isDropAllowed(event.group); }), operators.takeUntil(this._onDestroy))
                .subscribe(this.onDragEnd.bind(this));
        }
        DropDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Update the mouse over state */
        DropDirective.prototype.onMouseOver = function () {
            if (this.isDropAllowed(this._group)) {
                this.isMouseOver = true;
                // emit that we are over a drop area
                this._dragService.onDropEnter.next();
            }
        };
        /** Update the mouse over state */
        DropDirective.prototype.onMouseLeave = function () {
            // always ensure this value is reset
            this.isMouseOver = false;
            // only emit the dropd leave event when appropriate
            if (this.isDropAllowed(this._group)) {
                this._dragService.onDropLeave.next();
            }
        };
        /** Update the dragging state */
        DropDirective.prototype.onDragStart = function () {
            this.isDragging = true;
        };
        /** Update the dragging state */
        DropDirective.prototype.onDragEnd = function (event) {
            // update the dragging state
            this.isDragging = false;
            // clear the cached group
            this._group = null;
            // if the mouse is over and it is in an allowed group emit the dop event
            if (this.isMouseOver && this.isDropAllowed(event.group)) {
                this.onDrop.emit(event.data);
                this._dragService.onDrop.next(event.data);
            }
        };
        /** Determine whether or not the event is part of the specified groups */
        DropDirective.prototype.isDropAllowed = function (group) {
            // if dropping is disabled then it is never allowed
            if (this.dropDisabled) {
                return false;
            }
            // if no group specified allow all groups
            if (!this.group) {
                return true;
            }
            // if it is an array then ensure it is allowed
            if (Array.isArray(this.group)) {
                return !!this.group.find(function (_group) { return _group === group; });
            }
            return this.group === group;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DropDirective.prototype, "group", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DropDirective.prototype, "dropDisabled", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DropDirective.prototype, "onDrop", void 0);
        __decorate([
            core.HostListener('mouseenter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], DropDirective.prototype, "onMouseOver", null);
        __decorate([
            core.HostListener('mouseleave'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], DropDirective.prototype, "onMouseLeave", null);
        DropDirective = __decorate([
            core.Directive({
                selector: '[uxDrop]',
                host: {
                    '[class.ux-drop-hover]': 'isMouseOver && isDragging && !dropDisabled'
                }
            }),
            __metadata("design:paramtypes", [DragService])
        ], DropDirective);
        return DropDirective;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function DRAG_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new DragService();
    }
    var DRAG_SERVICE_PROVIDER = {
        provide: DragService,
        deps: [[new core.Optional(), new core.SkipSelf(), DragService]],
        useFactory: DRAG_SERVICE_PROVIDER_FACTORY
    };
    var DragModule = /** @class */ (function () {
        function DragModule() {
        }
        DragModule = __decorate([
            core.NgModule({
                exports: [DragDirective, DropDirective],
                declarations: [DragDirective, DropDirective],
                providers: [DRAG_SERVICE_PROVIDER]
            })
        ], DragModule);
        return DragModule;
    }());
    var DashboardStackMode;
    (function (DashboardStackMode) {
        DashboardStackMode[DashboardStackMode["Regular"] = 0] = "Regular";
        DashboardStackMode[DashboardStackMode["Stacked"] = 1] = "Stacked";
        /** Determine the mode automatically based on dashboard width. */
        DashboardStackMode[DashboardStackMode["Auto"] = 2] = "Auto";
    })(DashboardStackMode || (DashboardStackMode = {}));
    var DashboardService = /** @class */ (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new rxjs.BehaviorSubject([]);
            this.options$ = new rxjs.BehaviorSubject(defaultOptions);
            this.dimensions$ = new rxjs.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(tick(), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new rxjs.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new rxjs.Subject();
            this.stacked$ = new rxjs.BehaviorSubject(false);
            this.isDragging$ = new rxjs.BehaviorSubject(null);
            this.isGrabbing$ = new rxjs.BehaviorSubject(null);
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
            this.layout$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        DashboardService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        DashboardService.prototype.addWidget = function (widget) {
            this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
        };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        DashboardService.prototype.removeWidget = function (widget) {
            this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
        };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        DashboardService.prototype.setDimensions = function (width, height) {
            if (width === void 0) {
                width = this.dimensions.width;
            }
            if (height === void 0) {
                height = this.dimensions.height;
            }
            if (this.dimensions.width !== width || this.dimensions.height !== height) {
                this.dimensions$.next({ width: width, height: height });
            }
        };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        DashboardService.prototype.getLayoutData = function () {
            return this.widgets.map(function (widget) {
                return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
            });
        };
        /**
         * Position widgets programatically
         */
        DashboardService.prototype.setLayoutData = function (widgets) {
            var _this = this;
            // iterate through each widget data and find a match
            widgets.forEach(function (widget) {
                // find the matching widget
                var target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                if (target) {
                    target.setColumn(widget.col);
                    target.setRow(widget.row);
                    target.setColumnSpan(widget.colSpan);
                    target.setRowSpan(widget.rowSpan);
                }
            });
        };
        /**
         * Update the positions and sizes of the widgets
         */
        DashboardService.prototype.renderDashboard = function () {
            var _this = this;
            // get the dimensions of the dashboard
            this._rowHeight = this.options.rowHeight || this.columnWidth;
            // ensure the column width is not below the min widths
            this.stacked$.next(this.columnWidth < this.options.minWidth);
            // ensure the row height is not below the min widths
            if (this._rowHeight < this.options.minWidth) {
                this._rowHeight = this.options.minWidth;
            }
            this.setDashboardLayout();
            // iterate through each widget and set the size - except the one being resized
            this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                .forEach(function (widget) { return widget.render(); });
        };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        DashboardService.prototype.setDashboardLayout = function () {
            var _this = this;
            // find any widgets that do not currently have a position set
            this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                .forEach(function (widget) { return _this.setWidgetPosition(widget); });
            this.setDashboardHeight();
        };
        DashboardService.prototype.updateWhenStacked = function () {
            // iterate through each widget set it's stacked state and retain the rowSpan
            this.getWidgetsByOrder().forEach(function (widget, idx, widgets) {
                var widgetsAbove = widgets.slice(0, idx);
                var row = widgetsAbove.reduce(function (currentRow, _widget) { return currentRow + _widget.getRowSpan(); }, 0);
                widget.setColumn(0);
                widget.setRow(row);
            });
        };
        /** Get widgets in the order they visually appear as the widgets array order does not reflect this */
        DashboardService.prototype.getWidgetsByOrder = function () {
            var _this = this;
            return __spread(this.widgets).sort(function (w1, w2) {
                var w1Position = w1.getColumn(DashboardStackMode.Regular) + (w1.getRow(DashboardStackMode.Regular) * _this.options.columns);
                var w2Position = w2.getColumn(DashboardStackMode.Regular) + (w2.getRow(DashboardStackMode.Regular) * _this.options.columns);
                if (w1Position < w2Position) {
                    return -1;
                }
                if (w1Position > w2Position) {
                    return 1;
                }
                return 0;
            });
        };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        DashboardService.prototype.setWidgetPosition = function (widget) {
            // find a position for the widget
            var position = 0;
            var success = false;
            // repeat until a space is found
            while (!success) {
                // get a position to try
                var column = position % this.options.columns;
                var row = Math.floor(position / this.options.columns);
                // check the current position
                if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                    success = true;
                    widget.setColumn(column);
                    widget.setRow(row);
                    return;
                }
                if (column === 0 && widget.colSpan > this.options.columns) {
                    throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                }
                position++;
            }
        };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        DashboardService.prototype.getPositionAvailable = function (column, row, columnSpan, rowSpan, ignoreWidget) {
            // get a list of grid spaces that are populated
            var spaces = this.getOccupiedSpaces();
            // check if the block would still be in bounds
            if (column + columnSpan > this.options.columns) {
                return false;
            }
            var _loop_1 = function (x) {
                var _loop_2 = function (y) {
                    if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                        return { value: false };
                    }
                };
                for (var y = row; y < row + rowSpan; y++) {
                    var state_2 = _loop_2(y);
                    if (typeof state_2 === "object")
                        return state_2;
                }
            };
            // check each required position
            for (var x = column; x < column + columnSpan; x++) {
                var state_1 = _loop_1(x);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return true;
        };
        DashboardService.prototype.getOccupiedSpaces = function () {
            var _this = this;
            // find all spaces that are currently occupied
            return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                .reduce(function (value, widget) {
                _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                return value;
            }, []);
        };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        DashboardService.prototype.onResizeStart = function (action) {
            // store the mouse event
            this._event = action.event;
            this._actionWidget = action;
            // bring the widget to the font
            this.bringToFront(action.widget);
        };
        DashboardService.prototype.onResizeDrag = function (action) {
            var mousePosX = this._event.pageX - pageXOffset;
            var mousePosY = this._event.pageY - pageYOffset;
            // if there was no movement then do nothing
            if (action.event.x === mousePosX && action.event.y === mousePosY) {
                return;
            }
            // update the stored mouse event
            this._event = action.event;
            // get handle for direction
            var handle = action.handle;
            // get the bounds of the handle
            var bounds = handle.getBoundingClientRect();
            // get the center of the handle
            var centerX = bounds.left + (bounds.width / 2);
            var centerY = bounds.top + (bounds.height / 2);
            // get the current mouse position
            var mouseX = mousePosX - centerX;
            var mouseY = mousePosY - centerY;
            // store the new proposed dimensions for the widget
            var dimensions = {
                x: action.widget.x,
                y: action.widget.y,
                width: action.widget.width,
                height: action.widget.height
            };
            // update widget based on the handle being dragged
            switch (action.direction) {
                case exports.ActionDirection.Right:
                    dimensions.width += mouseX;
                    break;
                case exports.ActionDirection.Left:
                    dimensions.x += mouseX;
                    dimensions.width -= mouseX;
                    if (dimensions.width < this.options.minWidth) {
                        var difference = this.options.minWidth - dimensions.width;
                        dimensions.x -= difference;
                        dimensions.width += difference;
                    }
                    break;
                case exports.ActionDirection.Bottom:
                    dimensions.height += mouseY;
                    break;
                case exports.ActionDirection.Top:
                    dimensions.y += mouseY;
                    dimensions.height -= mouseY;
                    if (dimensions.height < this.options.minHeight) {
                        var difference = this.options.minHeight - dimensions.height;
                        dimensions.y -= difference;
                        dimensions.height += difference;
                    }
                    break;
                // Support resizing on multiple axis simultaneously
                case exports.ActionDirection.TopLeft:
                    dimensions.x += mouseX;
                    dimensions.width -= mouseX;
                    if (dimensions.width < this.options.minWidth) {
                        var difference = this.options.minWidth - dimensions.width;
                        dimensions.x -= difference;
                        dimensions.width += difference;
                    }
                    dimensions.y += mouseY;
                    dimensions.height -= mouseY;
                    if (dimensions.height < this.options.minHeight) {
                        var difference = this.options.minHeight - dimensions.height;
                        dimensions.y -= difference;
                        dimensions.height += difference;
                    }
                    break;
                case exports.ActionDirection.TopRight:
                    dimensions.width += mouseX;
                    dimensions.y += mouseY;
                    dimensions.height -= mouseY;
                    if (dimensions.height < this.options.minHeight) {
                        var difference = this.options.minHeight - dimensions.height;
                        dimensions.y -= difference;
                        dimensions.height += difference;
                    }
                    break;
                case exports.ActionDirection.BottomLeft:
                    dimensions.height += mouseY;
                    dimensions.x += mouseX;
                    dimensions.width -= mouseX;
                    if (dimensions.width < this.options.minWidth) {
                        var difference = this.options.minWidth - dimensions.width;
                        dimensions.x -= difference;
                        dimensions.width += difference;
                    }
                    break;
                case exports.ActionDirection.BottomRight:
                    dimensions.height += mouseY;
                    dimensions.width += mouseX;
                    break;
            }
            var currentWidth = action.widget.x + action.widget.width;
            var currentHeight = action.widget.y + action.widget.height;
            // ensure values are within the dashboard bounds
            if (dimensions.x < 0) {
                dimensions.x = 0;
                dimensions.width = currentWidth;
            }
            if (dimensions.y < 0) {
                dimensions.y = 0;
                dimensions.height = currentHeight;
            }
            if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                dimensions.width = this.dimensions.width - dimensions.x;
            }
            // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
            if (dimensions.width < this.options.minWidth) {
                dimensions.x = action.widget.x;
                dimensions.width = this.options.minWidth;
            }
            // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
            if (dimensions.height < this.options.minHeight) {
                dimensions.y = action.widget.y;
                dimensions.height = this.options.minHeight;
            }
            // update the widget actual values
            action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // update placeholder position and value
            this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // show the widget positions if the current positions and sizes were to persist
            this.updateWidgetPositions(action.widget);
        };
        DashboardService.prototype.onResizeEnd = function () {
            var placeholder = this.placeholder$.getValue();
            // commit resize changes
            this.commitWidgetChanges();
            // hide placeholder
            placeholder.visible = false;
            // update the placeholder
            this.placeholder$.next(placeholder);
            this._actionWidget = null;
            this._event = null;
            // ensure any vacant upper spaces are filled where required
            this.shiftWidgetsUp();
            // update dashboard height
            this.setDashboardHeight();
            // emit information about the layout
            this.layout$.next(this.getLayoutData());
        };
        DashboardService.prototype.onDragStart = function (action) {
            this.onResizeStart(action);
            // store the starting placeholder position
            this.setWidgetOrigin();
            this.cacheWidgets();
            // emit the widget we are dragging
            this.isDragging$.next(action.widget);
        };
        DashboardService.prototype.onDragEnd = function () {
            this.onResizeEnd();
            this._widgetOrigin = {};
            this.isDragging$.next(null);
        };
        DashboardService.prototype.onDrag = function (action) {
            // if there was no movement then do nothing
            if (action.event.pageX === this._event.pageX && action.event.pageY === this._event.pageY) {
                return;
            }
            // get the current mouse position
            var mouseX = action.event.pageX - this._event.pageX;
            var mouseY = action.event.pageY - this._event.pageY;
            // store the latest event
            this._event = action.event;
            var dimensions = {
                x: action.widget.x + mouseX,
                y: action.widget.y + mouseY,
                width: action.widget.width,
                height: action.widget.height
            };
            this.restoreWidgets(true);
            // update widget position
            action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // update placeholder position and value
            this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // show the widget positions if the current positions and sizes were to persist
            this.shiftWidgets();
            this.setDashboardHeight();
        };
        DashboardService.prototype.getRowHeight = function () {
            return this._rowHeight;
        };
        DashboardService.prototype.cacheWidgets = function () {
            this._cache = this.widgets.map(function (widget) {
                return ({
                    id: widget.id,
                    column: widget.getColumn(),
                    row: widget.getRow(),
                    columnSpan: widget.getColumnSpan(),
                    rowSpan: widget.getRowSpan(),
                });
            });
            // return a new array of the cache for custom caching
            return __spread(this._cache);
        };
        DashboardService.prototype.restoreWidgets = function (ignoreActionWidget, cache, restoreSize) {
            var _this = this;
            if (ignoreActionWidget === void 0) {
                ignoreActionWidget = false;
            }
            if (cache === void 0) {
                cache = this._cache;
            }
            if (restoreSize === void 0) {
                restoreSize = false;
            }
            cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                var match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                if (match) {
                    match.setColumn(widget.column);
                    match.setRow(widget.row);
                    if (restoreSize) {
                        match.setColumnSpan(widget.columnSpan);
                        match.setRowSpan(widget.rowSpan);
                    }
                }
            });
        };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        DashboardService.prototype.shiftWidgets = function () {
            var _this = this;
            var widgetsToMove = [];
            var placeholder = this.placeholder$.getValue();
            var _loop_3 = function (row) {
                var _loop_4 = function (column) {
                    // store reference to any widgets that need moved
                    this_1.getOccupiedSpaces()
                        .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                        .forEach(function (space) { return widgetsToMove.push(space.widget); });
                };
                for (var column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    _loop_4(column);
                }
            };
            var this_1 = this;
            // check if there are any widgets under the placeholder
            for (var row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                _loop_3(row);
            }
            // remove any duplicates
            widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
            // if no widgets need moved then we can stop here
            if (widgetsToMove.length === 0) {
                return;
            }
            // create a duplicate we can use to keep track of which have been moved
            var unmovedWidgets = widgetsToMove.slice();
            // attempt to move any widgets to the previous widget position
            widgetsToMove.forEach(function (widget) {
                // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                var grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                // iterate each free block
                for (var row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                    for (var column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                        // determine if the block can fit in this space
                        var requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                        // check if widget would fit in space
                        var available = requiredSpaces.every(function (space) {
                            return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                        });
                        if (available) {
                            widget.setColumn(column);
                            widget.setRow(row);
                            unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                            return;
                        }
                    }
                }
                // if we get to here then we can't simply swap the positions - next try moving right
                if (_this.canWidgetMoveRight(widget, true)) {
                    // after the shift check if placeholder position is still valid
                    _this.validatePlaceholderPosition(exports.ActionDirection.Right);
                    return;
                }
                // next try moving left
                if (_this.canWidgetMoveLeft(widget, true)) {
                    // after the shift check if placeholder position is still valid
                    _this.validatePlaceholderPosition(exports.ActionDirection.Left);
                    return;
                }
                // determine the distance that the widget needs to be moved down
                var distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                // as a last resort move the widget downwards
                _this.moveWidgetDown(widget, distance);
            });
        };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        DashboardService.prototype.validatePlaceholderPosition = function (shiftDirection) {
            var placeholder = this.placeholder$.getValue();
            // check if the placeholder is over a widget
            if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                // move the placeholder the opposite direction
                switch (shiftDirection) {
                    case exports.ActionDirection.Left:
                        this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                        break;
                    case exports.ActionDirection.Right:
                        this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                        break;
                }
                // validate this new position again
                this.validatePlaceholderPosition(shiftDirection);
            }
        };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        DashboardService.prototype.canWidgetMoveLeft = function (widget, performMove) {
            var _this = this;
            if (performMove === void 0) {
                performMove = false;
            }
            // check if the widget is the action widget or occupies the first column
            if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                return false;
            }
            // find the positions required
            var targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
            });
            // check if any of the target spaces are out of bounds
            if (targetSpaces.find(function (space) { return space.column < 0; })) {
                return false;
            }
            // check if there are widget in the required positions and if so, can they move right?
            var moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
            if (performMove && moveable) {
                // move all widgets to the left
                targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                // find the target column
                var column = targetSpaces.reduce(function (target, space) { return Math.min(target, space.column); }, Infinity);
                // move current widget to the left
                if (column !== Infinity) {
                    widget.setColumn(column);
                }
            }
            return moveable;
        };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        DashboardService.prototype.canWidgetMoveRight = function (widget, performMove) {
            var _this = this;
            if (performMove === void 0) {
                performMove = false;
            }
            // check if the widget is the dragging widget or the widget occupies the final column
            if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                return false;
            }
            // find the positions required
            var targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
            });
            // check if any of the target spaces are out of bounds
            if (targetSpaces.find(function (space) { return space.column >= _this.getColumnCount(); })) {
                return false;
            }
            // check if there are widget in the required positions and if so, can they move right?
            var moveable = targetSpaces.every(function (space) {
                return _this.getWidgetsAtPosition(space.column, space.row)
                    .filter(function (wgt) { return wgt !== space.widget; })
                    .every(function (wgt) { return _this.canWidgetMoveRight(wgt); });
            });
            if (performMove && moveable) {
                // move all widgets to the right
                targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                // move current widget to the right
                widget.setColumn(widget.getColumn() + 1);
            }
            return moveable;
        };
        /**
         * Store the initial position of the widget being dragged
         */
        DashboardService.prototype.setWidgetOrigin = function () {
            this._widgetOrigin = {
                column: this._actionWidget.widget.getColumn(),
                row: this._actionWidget.widget.getRow(),
                columnSpan: this._actionWidget.widget.getColumnSpan(),
                rowSpan: this._actionWidget.widget.getRowSpan()
            };
        };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        DashboardService.prototype.getRequiredSpacesFromPoint = function (widget, column, row) {
            var spaces = [];
            for (var y = row; y < row + widget.getRowSpan(); y++) {
                for (var x = column; x < column + widget.getColumnSpan(); x++) {
                    spaces.push({ column: x, row: y, widget: widget });
                }
            }
            return spaces;
        };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        DashboardService.prototype.updateWidgetPositions = function (widget) {
            var _this = this;
            var placeholder = this.placeholder$.getValue();
            // check all spaces the placeholder will occupy and move any widget currently in them down
            for (var column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                for (var row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                }
            }
            // update the height of the dashboard
            this.setDashboardHeight();
            // if we arent dragging the top handle then fill spaces
            if (this._actionWidget.direction !== exports.ActionDirection.Top &&
                this._actionWidget.direction !== exports.ActionDirection.TopLeft &&
                this._actionWidget.direction !== exports.ActionDirection.TopRight) {
                this.shiftWidgetsUp();
            }
        };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        DashboardService.prototype.getWidgetsAtPosition = function (column, row, ignoreResizing) {
            var _this = this;
            if (ignoreResizing === void 0) {
                ignoreResizing = false;
            }
            return this.getOccupiedSpaces()
                .filter(function (space) { return space.column === column && space.row === row; })
                .filter(function (space) { return _this._actionWidget && space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                .map(function (space) { return space.widget; });
        };
        /**
         * Update the placeholder visibility, position and size
         */
        DashboardService.prototype.setPlaceholderBounds = function (visible, x, y, width, height) {
            var _this = this;
            var placeholder = this.placeholder$.getValue();
            placeholder.visible = visible;
            placeholder.column = this.getPlaceholderColumn(x, width);
            placeholder.row = this.getPlaceholderRow(y, height);
            placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
            placeholder.rowSpan = this.getPlaceholderRowSpan(height);
            // calculate the maximum number of rows
            var rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            // constrain maximum placeholder row
            placeholder.row = Math.min(placeholder.row, rowCount);
            placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
            placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
            placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
            placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
            // set the values of the widget to match the values of the placeholder - however do not render the changes
            this._actionWidget.widget.setColumn(placeholder.column, false);
            this._actionWidget.widget.setRow(placeholder.row, false);
            this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
            this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
            // update the placeholder
            this.placeholder$.next(placeholder);
        };
        /**
         * Get the placeholder column position
         */
        DashboardService.prototype.getPlaceholderColumn = function (x, width) {
            var column = this.getColumnFromPx(x, this._actionWidget.direction === exports.ActionDirection.Move ? exports.Rounding.RoundUpOverHalf : exports.Rounding.RoundDown);
            var columnSpan = Math.floor(width / this.getColumnWidth());
            var upperLimit = this.getColumnCount() - columnSpan;
            // if we arent dragging left then just return the column
            if (this._actionWidget.direction !== exports.ActionDirection.Left &&
                this._actionWidget.direction !== exports.ActionDirection.TopLeft &&
                this._actionWidget.direction !== exports.ActionDirection.BottomLeft) {
                return Math.max(Math.min(column, upperLimit), 0);
            }
            // get any overflow
            var overflow = width % this.getColumnWidth();
            return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                Math.max(Math.min(column, upperLimit), 0) :
                Math.max(Math.min(column + 1, upperLimit), 0);
        };
        /**
         * Get the column span of the placeholder
         */
        DashboardService.prototype.getPlaceholderColumnSpan = function (width) {
            var columnSpan = this.getColumnFromPx(width);
            // if we arent dragging right or left then just return the column span
            if (this._actionWidget.direction !== exports.ActionDirection.Right &&
                this._actionWidget.direction !== exports.ActionDirection.TopRight &&
                this._actionWidget.direction !== exports.ActionDirection.BottomRight &&
                this._actionWidget.direction !== exports.ActionDirection.Left &&
                this._actionWidget.direction !== exports.ActionDirection.TopLeft &&
                this._actionWidget.direction !== exports.ActionDirection.BottomLeft) {
                return Math.max(columnSpan, 1);
            }
            // get the current column span and any overflow
            var overflow = width % this.getColumnWidth();
            return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
        };
        /**
         * Get the row position of the placeholder
         */
        DashboardService.prototype.getPlaceholderRow = function (y, height) {
            var row = this.getRowFromPx(y, this._actionWidget.direction === exports.ActionDirection.Move ? exports.Rounding.RoundUpOverHalf : exports.Rounding.RoundDown);
            var rowSpan = Math.ceil(height / this._rowHeight);
            // if we arent dragging up then just return the row
            if (this._actionWidget.direction !== exports.ActionDirection.Top &&
                this._actionWidget.direction !== exports.ActionDirection.TopLeft &&
                this._actionWidget.direction !== exports.ActionDirection.TopRight) {
                return Math.max(row, 0);
            }
            // get any overflow
            var overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
            return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
        };
        /**
         * Get the row span of the placeholder
         */
        DashboardService.prototype.getPlaceholderRowSpan = function (height) {
            var rowSpan = this.getRowFromPx(height);
            // if we arent dragging up or down then just return the column span
            if (this._actionWidget.direction !== exports.ActionDirection.Top &&
                this._actionWidget.direction !== exports.ActionDirection.TopLeft &&
                this._actionWidget.direction !== exports.ActionDirection.TopRight &&
                this._actionWidget.direction !== exports.ActionDirection.Bottom &&
                this._actionWidget.direction !== exports.ActionDirection.BottomLeft &&
                this._actionWidget.direction !== exports.ActionDirection.BottomRight) {
                return Math.max(rowSpan, 1);
            }
            // get the current column span and any overflow
            var overflow = height % this._rowHeight;
            return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
        };
        DashboardService.prototype.getColumnFromPx = function (x, rounding) {
            if (rounding === void 0) {
                rounding = exports.Rounding.RoundDown;
            }
            var column = Math.floor(x / Math.floor(this.getColumnWidth()));
            var overflow = (x % Math.floor(this.getColumnWidth()));
            var half = this.getColumnWidth() / 2;
            switch (rounding) {
                case exports.Rounding.RoundDown:
                    return column;
                case exports.Rounding.RoundDownBelowHalf:
                    return overflow < half ? column : column + 1;
                case exports.Rounding.RoundUpOverHalf:
                    return overflow > half ? column + 1 : column;
                case exports.Rounding.RoundUp:
                    return overflow > 0 ? column + 1 : column;
            }
        };
        DashboardService.prototype.getRowFromPx = function (y, rounding) {
            if (rounding === void 0) {
                rounding = exports.Rounding.RoundDown;
            }
            var row = Math.floor(y / Math.floor(this._rowHeight));
            var overflow = (y % Math.floor(this._rowHeight));
            var half = this._rowHeight / 2;
            switch (rounding) {
                case exports.Rounding.RoundDown:
                    return row;
                case exports.Rounding.RoundDownBelowHalf:
                    return overflow < half ? row : row + 1;
                case exports.Rounding.RoundUpOverHalf:
                    return overflow > half ? row + 1 : row;
                case exports.Rounding.RoundUp:
                    return overflow > 0 ? row + 1 : row;
            }
        };
        DashboardService.prototype.commitWidgetChanges = function () {
            var placeholder = this.placeholder$.getValue();
            // check that we have all the values we need
            if (placeholder.column === undefined || placeholder.row === undefined ||
                placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                return;
            }
            if (this._actionWidget) {
                this._actionWidget.widget.setColumn(placeholder.column);
                this._actionWidget.widget.setRow(placeholder.row);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
            }
            // reset all placeholder values
            placeholder.column = undefined;
            placeholder.row = undefined;
            placeholder.columnSpan = undefined;
            placeholder.rowSpan = undefined;
            // emit the new placeholder values
            this.placeholder$.next(placeholder);
        };
        /**
         * Get the current column width
         */
        DashboardService.prototype.getColumnWidth = function () {
            return Math.floor(this.columnWidth);
        };
        /**
         * Calculate the number of rows populated with widgets
         */
        DashboardService.prototype.getRowCount = function () {
            return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
        };
        /**
         * Set the height of the dashboard container element
         */
        DashboardService.prototype.setDashboardHeight = function () {
            // size the dashboard container to ensure all rows fit
            var rowCount = this.getRowCount();
            // if we should show an empty row increment the row count by 1
            if (this.options.emptyRow) {
                rowCount++;
            }
            this.setDimensions(undefined, rowCount * this._rowHeight);
        };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        DashboardService.prototype.bringToFront = function (widget) {
            this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
        };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        DashboardService.prototype.moveWidgetDown = function (widget, distance) {
            var _this = this;
            if (distance === void 0) {
                distance = 1;
            }
            // move the widget down one position
            widget.setRow((widget.getRow(DashboardStackMode.Auto)) + distance);
            // check every space the widget occupies for collisions
            this.forEachBlock(widget, function (column, row) {
                return _this.getWidgetsAtPosition(column, row, true)
                    .filter(function (wgt) { return wgt !== widget; })
                    .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
            });
        };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        DashboardService.prototype.shiftWidgetsUp = function () {
            var _this = this;
            // check whether or not changes have been made - if so we need to repeat until stable
            var stable = true;
            // iterate each widget and
            this.widgets.forEach(function (widget) {
                // if widget is already on the top row then do nothing
                if (widget.getRow() === 0) {
                    return;
                }
                // if we are currently dragging and this is the dragging widget then skip
                if (_this._actionWidget && _this._actionWidget.widget === widget) {
                    return;
                }
                if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                    widget.setRow(widget.getRow() - 1);
                    stable = false;
                }
            });
            // if changes occurred then we should repeat the process
            if (!stable) {
                this.shiftWidgetsUp();
            }
        };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        DashboardService.prototype.forEachBlock = function (widget, callback) {
            for (var row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                for (var column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                    callback.call(widget, column, row);
                }
            }
        };
        DashboardService.prototype.getWidgetBelow = function (widget) {
            var target = this.getWidgetsAtPosition(widget.getColumn(), widget.getRow() + widget.getRowSpan(), true);
            return target.length > 0 ? target[0] : null;
        };
        /**
         * Returns the number of columns available
         */
        DashboardService.prototype.getColumnCount = function () {
            return this.stacked ? 1 : this.options.columns;
        };
        DashboardService.prototype.onShiftStart = function (widget) {
            this.onDragStart({ direction: exports.ActionDirection.Move, widget: widget });
        };
        /** Programmatically move a widget in a given direction */
        DashboardService.prototype.onShift = function (widget, direction) {
            // get the current mouse position
            var deltaX = 0, deltaY = 0;
            // move based on the direction
            switch (direction) {
                case exports.ActionDirection.Top:
                    deltaY = -this.getRowHeight();
                    break;
                case exports.ActionDirection.Right:
                    deltaX = this.getColumnWidth();
                    break;
                case exports.ActionDirection.Bottom: {
                    deltaY = this.getRowHeight();
                    break;
                }
                case exports.ActionDirection.Left:
                    deltaX = -this.getColumnWidth();
                    break;
            }
            var dimensions = {
                x: widget.x + deltaX,
                y: widget.y + deltaY,
                width: widget.width,
                height: widget.height
            };
            // update placeholder position and value
            this.setPlaceholderBounds(false, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // update widget position
            var _a = this.placeholder$.value, x = _a.x, y = _a.y;
            // move the widget to the placeholder position
            widget.setBounds(x - this.options.padding, y - this.options.padding, dimensions.width, dimensions.height);
            // update the height of the dashboard
            this.setDashboardHeight();
        };
        DashboardService.prototype.onShiftEnd = function () {
            // show the widget positions if the current positions and sizes were to persist
            this.shiftWidgets();
            // the height of the dashboard may have changed after moving widgets
            this.setDashboardHeight();
            // reset all properties
            this.onDragEnd();
        };
        /** Programmatically resize a widget in a given direction */
        DashboardService.prototype.onResize = function (widget, direction) {
            // do not perform resizing if we are in stacked mode
            if (this.stacked) {
                return;
            }
            // perform the resizing
            var deltaX = 0, deltaY = 0;
            // move based on the direction
            switch (direction) {
                case exports.ActionDirection.Top:
                    deltaY = -this.getRowHeight();
                    break;
                case exports.ActionDirection.Right:
                    deltaX = this.getColumnWidth();
                    break;
                case exports.ActionDirection.Bottom:
                    deltaY = this.getRowHeight();
                    break;
                case exports.ActionDirection.Left:
                    deltaX = -this.getColumnWidth();
                    break;
            }
            var dimensions = {
                x: widget.x,
                y: widget.y,
                width: widget.width + deltaX,
                height: widget.height + deltaY
            };
            var currentWidth = widget.x + widget.width;
            var currentHeight = widget.y + widget.height;
            // ensure values are within the dashboard bounds
            if (dimensions.x < 0) {
                dimensions.x = 0;
                dimensions.width = currentWidth;
            }
            if (dimensions.y < 0) {
                dimensions.y = 0;
                dimensions.height = currentHeight;
            }
            if ((dimensions.x + dimensions.width) > this.getColumnWidth() * this.getColumnCount()) {
                dimensions.width = widget.width;
            }
            // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
            if (dimensions.width < this.getColumnWidth()) {
                dimensions.x = widget.x;
                dimensions.width = this.getColumnWidth();
            }
            // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
            if (dimensions.height < this.getRowHeight()) {
                dimensions.y = widget.y;
                dimensions.height = this.getRowHeight();
            }
            // move the widget to the placeholder position
            widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // update placeholder position and value
            this.setPlaceholderBounds(false, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
            // the height of the dashboard may have changed after moving widgets
            this.setDashboardHeight();
        };
        DashboardService.prototype.getSurroundingWidgets = function (widget, direction) {
            var widgets = [];
            for (var column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                switch (direction) {
                    case exports.ActionDirection.Top:
                        widgets = __spread(widgets, this.getWidgetsAtPosition(column, widget.getRow() - 1));
                        break;
                    case exports.ActionDirection.Bottom:
                        widgets = __spread(widgets, this.getWidgetsAtPosition(column, widget.getRow() + widget.getRowSpan()));
                        break;
                }
            }
            return widgets;
        };
        DashboardService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [])
        ], DashboardService);
        return DashboardService;
    }());
    var defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    (function (ActionDirection) {
        ActionDirection[ActionDirection["Top"] = 0] = "Top";
        ActionDirection[ActionDirection["TopRight"] = 1] = "TopRight";
        ActionDirection[ActionDirection["Right"] = 2] = "Right";
        ActionDirection[ActionDirection["BottomRight"] = 3] = "BottomRight";
        ActionDirection[ActionDirection["Bottom"] = 4] = "Bottom";
        ActionDirection[ActionDirection["BottomLeft"] = 5] = "BottomLeft";
        ActionDirection[ActionDirection["Left"] = 6] = "Left";
        ActionDirection[ActionDirection["TopLeft"] = 7] = "TopLeft";
        ActionDirection[ActionDirection["Move"] = 8] = "Move";
    })(exports.ActionDirection || (exports.ActionDirection = {}));
    (function (Rounding) {
        Rounding[Rounding["RoundDown"] = 0] = "RoundDown";
        Rounding[Rounding["RoundDownBelowHalf"] = 1] = "RoundDownBelowHalf";
        Rounding[Rounding["RoundUp"] = 2] = "RoundUp";
        Rounding[Rounding["RoundUpOverHalf"] = 3] = "RoundUpOverHalf";
    })(exports.Rounding || (exports.Rounding = {}));
    var DashboardWidgetComponent = /** @class */ (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            /** Defines the number of columns this widget should occupy. */
            this.colSpan = 1;
            /** Defines the number of rows this widget should occupy. */
            this.rowSpan = 1;
            /** Defines whether or not this widget can be resized. */
            this.resizable = false;
            /** Defines a function that returns an aria label for the widget */
            this.widgetAriaLabel = this.getDefaultAriaLabel;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this.isDragging = false;
            this.isGrabbing = false;
            this.isResizing = false;
            this.isDraggable = false;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._onDestroy = new rxjs.Subject();
            // subscribe to option changes
            dashboardService.options$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.update(); });
            // every time the layout changes we want to update the aria label
            dashboardService.layout$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.ariaLabel = _this.getAriaLabel(); });
            // allow widget movements to be animated
            dashboardService.isDragging$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return widget === _this; }))
                .subscribe(function (isDragging) { return _this.isDragging = isDragging; });
            // allow widget movements to be animated
            dashboardService.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return widget === _this; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        DashboardWidgetComponent.prototype.ngOnInit = function () {
            this._columnSpan.regular = this.colSpan;
            this._rowSpan.regular = this.rowSpan;
            this._rowSpan.stacked = this.rowSpan;
            if (!this.id) {
                console.warn('Dashboard Widget is missing an ID.');
                // set random id - keeps things working but prevents exporting of positions
                this.id = Math.floor(Math.random() * 100000).toString();
            }
        };
        DashboardWidgetComponent.prototype.ngAfterViewInit = function () {
            // add the widget to the dashboard
            this.dashboardService.addWidget(this);
            // apply the current options
            this.update();
        };
        /**
         * If component is removed, then unregister it from the service
         */
        DashboardWidgetComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this.dashboardService.removeWidget(this);
        };
        /**
         * Apply the current dashboard options
         */
        DashboardWidgetComponent.prototype.update = function () {
            // get the current options at the time
            var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
            this.padding = padding;
            this._columnSpan.stacked = columns;
        };
        /**
         * Set the actual position and size values
         */
        DashboardWidgetComponent.prototype.render = function () {
            this.x = this.getColumn() * this.dashboardService.getColumnWidth();
            this.y = this.getRow() * this.dashboardService.getRowHeight();
            this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
            this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
        };
        DashboardWidgetComponent.prototype.getColumn = function (mode) {
            if (mode === void 0) {
                mode = DashboardStackMode.Auto;
            }
            switch (mode) {
                case DashboardStackMode.Auto:
                    return this.getStackableValue(this._column);
                case DashboardStackMode.Regular:
                    return this._column.regular;
                case DashboardStackMode.Stacked:
                    return this._column.stacked;
            }
        };
        DashboardWidgetComponent.prototype.getRow = function (mode) {
            if (mode === void 0) {
                mode = DashboardStackMode.Auto;
            }
            switch (mode) {
                case DashboardStackMode.Auto:
                    return this.getStackableValue(this._row);
                case DashboardStackMode.Regular:
                    return this._row.regular;
                case DashboardStackMode.Stacked:
                    return this._row.stacked;
            }
        };
        DashboardWidgetComponent.prototype.setColumn = function (column, render) {
            if (render === void 0) {
                render = true;
            }
            this.setStackableValue(this._column, column);
            if (render) {
                this.render();
            }
        };
        DashboardWidgetComponent.prototype.setRow = function (row, render) {
            if (render === void 0) {
                render = true;
            }
            this.setStackableValue(this._row, row);
            if (render) {
                this.render();
            }
        };
        DashboardWidgetComponent.prototype.getColumnSpan = function () {
            return this.getStackableValue(this._columnSpan);
        };
        DashboardWidgetComponent.prototype.getRowSpan = function () {
            return this.getStackableValue(this._rowSpan);
        };
        DashboardWidgetComponent.prototype.setColumnSpan = function (columnSpan, render) {
            if (render === void 0) {
                render = true;
            }
            this.setStackableValue(this._columnSpan, columnSpan);
            if (render) {
                this.render();
            }
        };
        DashboardWidgetComponent.prototype.setRowSpan = function (rowSpan, render) {
            if (render === void 0) {
                render = true;
            }
            this.setStackableValue(this._rowSpan, rowSpan);
            if (render) {
                this.render();
            }
        };
        DashboardWidgetComponent.prototype.bringToFront = function () {
            this.zIndex = 1;
        };
        DashboardWidgetComponent.prototype.sendToBack = function () {
            this.zIndex = 0;
        };
        DashboardWidgetComponent.prototype.setBounds = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        };
        DashboardWidgetComponent.prototype.dragstart = function (handle, event, direction) {
            this.isResizing = true;
            this.dashboardService.isGrabbing$.next(null);
            this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
        };
        DashboardWidgetComponent.prototype.drag = function (handle, event, direction) {
            this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
        };
        DashboardWidgetComponent.prototype.dragend = function () {
            this.isResizing = false;
            this.dashboardService.onResizeEnd();
        };
        DashboardWidgetComponent.prototype.getAriaLabel = function () {
            if (this.widgetAriaLabel && typeof this.widgetAriaLabel === 'string') {
                return this.widgetAriaLabel;
            }
            else if (this.widgetAriaLabel && typeof this.widgetAriaLabel === 'function') {
                return this.widgetAriaLabel(this);
            }
            return this.ariaLabel;
        };
        DashboardWidgetComponent.prototype.getDefaultAriaLabel = function (widget) {
            var options = '';
            if (widget.resizable && widget.isDraggable) {
                options = 'It can be moved and resized.';
            }
            else if (widget.resizable) {
                options = 'It can be resized.';
            }
            else if (widget.isDraggable) {
                options = 'It can be moved.';
            }
            return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. " + options;
        };
        /**
         * Allows automatic setting of stackable value
         * @param property The current StackableValue object
         * @param value The value to set in the appropriate field
         */
        DashboardWidgetComponent.prototype.setStackableValue = function (property, value) {
            if (this.dashboardService.stacked) {
                property.stacked = value;
            }
            else {
                property.regular = value;
            }
        };
        /**
         * Return the appropriate value from a stackable value
         * @param property The Stackable value object
         */
        DashboardWidgetComponent.prototype.getStackableValue = function (property) {
            return this.dashboardService.stacked ? property.stacked : property.regular;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DashboardWidgetComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DashboardWidgetComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "col", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "row", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "colSpan", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "rowSpan", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DashboardWidgetComponent.prototype, "resizable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardWidgetComponent.prototype, "widgetAriaLabel", void 0);
        __decorate([
            core.HostBinding('style.left.px'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "x", void 0);
        __decorate([
            core.HostBinding('style.top.px'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "y", void 0);
        __decorate([
            core.HostBinding('style.width.px'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "width", void 0);
        __decorate([
            core.HostBinding('style.height.px'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "height", void 0);
        __decorate([
            core.HostBinding('style.padding.px'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "padding", void 0);
        __decorate([
            core.HostBinding('style.z-index'),
            __metadata("design:type", Number)
        ], DashboardWidgetComponent.prototype, "zIndex", void 0);
        __decorate([
            core.HostBinding('attr.aria-label'),
            __metadata("design:type", String)
        ], DashboardWidgetComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('class.dragging'),
            __metadata("design:type", Boolean)
        ], DashboardWidgetComponent.prototype, "isDragging", void 0);
        __decorate([
            core.HostBinding('class.grabbing'),
            __metadata("design:type", Boolean)
        ], DashboardWidgetComponent.prototype, "isGrabbing", void 0);
        __decorate([
            core.HostBinding('class.resizing'),
            __metadata("design:type", Boolean)
        ], DashboardWidgetComponent.prototype, "isResizing", void 0);
        DashboardWidgetComponent = __decorate([
            core.Component({
                selector: 'ux-dashboard-widget',
                template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag\n     #handleTop\n     class=\"resizer-handle handle-top\"\n     (onDragStart)=\"dragstart(handleTop, $event, 0)\"\n     (onDrag)=\"drag(handleTop, $event, 0)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleTopRight\n     class=\"resizer-handle handle-top-right\"\n     (onDragStart)=\"dragstart(handleTopRight, $event, 1)\"\n     (onDrag)=\"drag(handleTopRight, $event, 1)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleRight\n     class=\"resizer-handle handle-right\"\n     (onDragStart)=\"dragstart(handleRight, $event, 2)\"\n     (onDrag)=\"drag(handleRight, $event, 2)\"\n     (onDragEnd)=\"dragend()\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottomRight\n     class=\"resizer-handle handle-bottom-right\"\n     (onDragStart)=\"dragstart(handleBottomRight, $event, 3)\"\n     (onDrag)=\"drag(handleBottomRight, $event, 3)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottom\n     class=\"resizer-handle handle-bottom\"\n     (onDragStart)=\"dragstart(handleBottom, $event, 4)\"\n     (onDrag)=\"drag(handleBottom, $event, 4)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleBottomLeft\n     class=\"resizer-handle handle-bottom-left\"\n     (onDragStart)=\"dragstart(handleBottomLeft, $event, 5)\"\n     (onDrag)=\"drag(handleBottomLeft, $event, 5)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleLeft\n     class=\"resizer-handle handle-left\"\n     (onDragStart)=\"dragstart(handleLeft, $event, 6)\"\n     (onDrag)=\"drag(handleLeft, $event, 6)\"\n     (onDragEnd)=\"dragend()\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleTopLeft\n     class=\"resizer-handle handle-top-left\"\n     (onDragStart)=\"dragstart(handleTopLeft, $event, 7)\"\n     (onDrag)=\"drag(handleTopLeft, $event, 7)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
            }),
            __metadata("design:paramtypes", [DashboardService])
        ], DashboardWidgetComponent);
        return DashboardWidgetComponent;
    }());
    var DashboardGrabHandleService = /** @class */ (function () {
        function DashboardGrabHandleService(_dashboard) {
            var _this = this;
            this._dashboard = _dashboard;
            /** Self-registered drag handles in the dashboard. */
            this._handles = [];
            /** Automatically unsubscribe from all observables when destroyed */
            this._onDestroy = new rxjs.Subject();
            // if a drag is performed by the mouse we should update the focusable item to be the first again
            _dashboard.layout$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return !_this._dashboard.isGrabbing$.value; }))
                .subscribe(function () { return _this.setFirstItemFocusable(); });
        }
        /** Perform unsubscriptions */
        DashboardGrabHandleService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Register a new grab handle. */
        DashboardGrabHandleService.prototype.addHandle = function (handle) {
            var _this = this;
            this._handles = this.getHandlesInOrder(__spread(this._handles, [handle]));
            // we want to make the first item focusable (raf to avoid expression changed error)
            requestAnimationFrame(function () { return _this.ensureFocusable(); });
        };
        /** Unregister a removed grab handle. */
        DashboardGrabHandleService.prototype.removeHandle = function (handle) {
            this._handles = this._handles.filter(function (h) { return h !== handle; });
            // Make sure there is still a focusable handle
            this.ensureFocusable();
        };
        /** Make the first visual item in the list focusable */
        DashboardGrabHandleService.prototype.setFirstItemFocusable = function () {
            this.setItemFocus(0, false);
        };
        /** Set an item at a given index focused */
        DashboardGrabHandleService.prototype.setItemFocus = function (index, focusElement) {
            if (focusElement === void 0) {
                focusElement = true;
            }
            // if the list is empty then do nothing
            if (!this._handles || this._handles.length === 0) {
                return;
            }
            // check if the index is out of bounds
            if (index < 0) {
                return this.setItemFocus(0);
            }
            if (index > this._handles.length - 1) {
                return this.setItemFocus(this._handles.length - 1);
            }
            // try focusing a specific index
            this.getHandlesInOrder().forEach(function (handle, idx) { return idx === index ? handle.focus(focusElement) : handle.blur(); });
            // for safety we want to ensure one of the items is definitely still focusabled
            this.ensureFocusable();
        };
        /** Focus the previous grab handle */
        DashboardGrabHandleService.prototype.setPreviousItemFocus = function (handle) {
            this.setItemFocus(this.getHandleIndex(handle) - 1);
        };
        /** Focus the next grab handle */
        DashboardGrabHandleService.prototype.setNextItemFocus = function (handle) {
            this.setItemFocus(this.getHandleIndex(handle) + 1);
        };
        /** Focus the grab handle on the widget above */
        DashboardGrabHandleService.prototype.setSiblingItemFocus = function (widget, direction) {
            var _this = this;
            // find all widgets that are directly above and have grab handles
            var target = this._dashboard.getSurroundingWidgets(widget, direction)
                .map(function (_widget) { return _this._handles.find(function (handle) { return handle.widget === _widget; }); })
                .filter(function (handle) { return !!handle; })
                .reduce(function (handle, current) { return !handle || current.widget.getColumn() > handle.widget.getColumn() ? current : handle; }, null);
            // ensure we have a target before focusing
            if (!target) {
                return;
            }
            // get the index of the target handle
            var index = this.getHandleIndex(target);
            // focus the item
            this.setItemFocus(index);
        };
        /** Get handles in the order they appear rather than the order they are in the DOM */
        DashboardGrabHandleService.prototype.getHandlesInOrder = function (handles) {
            if (handles === void 0) {
                handles = this._handles;
            }
            var widgets = this._dashboard.getWidgetsByOrder();
            // sort the handles according to the position of the widget it belongs to
            return handles.sort(function (handleOne, handleTwo) { return widgets.indexOf(handleOne.widget) - widgets.indexOf(handleTwo.widget); });
        };
        DashboardGrabHandleService.prototype.getHandleIndex = function (handle) {
            return this.getHandlesInOrder().findIndex(function (_handle) { return _handle === handle; });
        };
        /** If the current focusable handle is removed we need to make another one focusable */
        DashboardGrabHandleService.prototype.ensureFocusable = function () {
            if (!this._handles.find(function (handle) { return handle.tabIndex === 0; })) {
                this.setFirstItemFocusable();
            }
        };
        DashboardGrabHandleService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [DashboardService])
        ], DashboardGrabHandleService);
        return DashboardGrabHandleService;
    }());
    var DashboardGrabHandleDirective = /** @class */ (function () {
        function DashboardGrabHandleDirective(widget, _dashboard, _handle, _elementRef, _announcer) {
            var _this = this;
            this.widget = widget;
            this._dashboard = _dashboard;
            this._handle = _handle;
            this._elementRef = _elementRef;
            this._announcer = _announcer;
            /** Specify whether or not this handle can be used to perform moving */
            this.uxGrabAllowMove = true;
            /** Specify whether or not this handle can be used to perform resizing */
            this.uxGrabAllowResize = true;
            /** The aria label for the grab handle */
            this.uxGrabAriaLabel = this.getDefaultAriaLabel.bind(this);
            /** Customize the announcement that is made whenever an item has successfully been moved or resized */
            this.uxGrabChangeSuccessAnnouncement = this.getChangeSuccessAnnouncement.bind(this);
            /** Customize the announcement that is made whenever an item enters 'grab' mode */
            this.uxGrabStartAnnouncement = this.getStartAnnouncement.bind(this);
            /** Customize the announcement thqt is made whenever an item cannot be moved */
            this.uxGrabMoveFailAnnouncement = this.getMoveFailAnnouncement.bind(this);
            /** Customize the announcement thqt is made whenever an item cannot be resized */
            this.uxGrabResizeFailAnnouncement = this.getResizeFailAnnouncement.bind(this);
            /** Customize the announcement made whenever the moving/resizing is commited */
            this.uxGrabConfirmAnnouncement = this.getConfirmAnnouncement.bind(this);
            /** Customize the announcement made whenever the moving/resizing is cancelled */
            this.uxGrabCancelAnnouncement = this.getCancellationAnnouncement.bind(this);
            /** We must programmatically control the focus of the drag handles */
            this.tabIndex = -1;
            /** Store the current dragging state */
            this.isGrabbing = false;
            /** Emit when the directive is destroyed to unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
            if (!widget) {
                throw new Error('uxDashboardGrabHandle must be used within a dashboard widget');
            }
            _handle.addHandle(this);
            // subscribe to changes to the current grab state
            _dashboard.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (_widget) { return _widget === widget; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        /** Set the initial aria label and subscribe to layout changes */
        DashboardGrabHandleDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.widget.name) {
                console.warn("Dashboard widget " + this.widget.id + " must have a valid 'name' to use uxDashboardGrabHandle");
            }
            // set the initial aria label
            this.ariaLabel = this.getAnnouncement(this.uxGrabAriaLabel);
            // update the aria label when layout changes occur
            this._dashboard.layout$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.ariaLabel = _this.getAnnouncement(_this.uxGrabAriaLabel); });
        };
        /** Unsubscribe from all observables */
        DashboardGrabHandleDirective.prototype.ngOnDestroy = function () {
            this._handle.removeHandle(this);
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Begin drag mode and cache initial state */
        DashboardGrabHandleDirective.prototype.enableDragMode = function () {
            if (!this.isGrabbing) {
                // cache the widgets so we can restore when escape is pressed
                this._cache = this._lastMovement = this._dashboard.cacheWidgets();
                // store the current widget being grabbed
                this._dashboard.isGrabbing$.next(this.widget);
                this._dashboard.onShiftStart(this.widget);
                // announce the grab start
                this._announcer.announce(this.getAnnouncement(this.uxGrabStartAnnouncement));
            }
        };
        /** Finish drag mode and commit the current state */
        DashboardGrabHandleDirective.prototype.disableDragMode = function () {
            if (this.isGrabbing) {
                this._dashboard.isGrabbing$.next(null);
                this._lastMovement = null;
                this._dashboard.onShiftEnd();
                // announce the confirmation
                this._announcer.announce(this.getAnnouncement(this.uxGrabConfirmAnnouncement));
            }
        };
        /** Finish the drag mode and restore the original state */
        DashboardGrabHandleDirective.prototype.cancelDragMode = function () {
            if (this.isGrabbing) {
                this._dashboard.onShiftEnd();
                this._dashboard.restoreWidgets(false, this._cache, true);
                this._dashboard.setDashboardHeight();
                this._dashboard.layout$.next(this._dashboard.getLayoutData());
                this._dashboard.isGrabbing$.next(null);
                // announce the cancellation
                this._announcer.announce(this.getAnnouncement(this.uxGrabCancelAnnouncement));
            }
        };
        /** Toggle the drag mode state */
        DashboardGrabHandleDirective.prototype.toggleDragMode = function () {
            this.isGrabbing ? this.disableDragMode() : this.enableDragMode();
        };
        /** Set the tab index and optionally focus the DOM element */
        DashboardGrabHandleDirective.prototype.focus = function (focusElement) {
            if (focusElement === void 0) {
                focusElement = true;
            }
            this.tabIndex = 0;
            if (focusElement) {
                this._elementRef.nativeElement.focus();
            }
        };
        /** Make this item non-tabbable */
        DashboardGrabHandleDirective.prototype.blur = function () {
            this.tabIndex = -1;
        };
        /** When the grab handle loses focus then exit 'grab' mode */
        DashboardGrabHandleDirective.prototype.onBlur = function () {
            this.disableDragMode();
        };
        /** Handle key events */
        DashboardGrabHandleDirective.prototype.onKeydown = function (event, key, ctrlKey) {
            switch (key) {
                case keycodes.ESCAPE:
                    this.cancelDragMode();
                    break;
                case keycodes.SPACE:
                case keycodes.ENTER:
                    this.toggleDragMode();
                    event.preventDefault();
                    event.stopPropagation();
                    break;
                case keycodes.UP_ARROW:
                case keycodes.RIGHT_ARROW:
                case keycodes.DOWN_ARROW:
                case keycodes.LEFT_ARROW:
                    if (this.isGrabbing) {
                        ctrlKey ? this.resizeWidget(event, key) : this.moveWidget(event, key);
                    }
                    else {
                        this.moveFocus(event, key);
                    }
            }
        };
        /** Get an announcement from the inputs - they may be a string or a function so handle both */
        DashboardGrabHandleDirective.prototype.getAnnouncement = function (announcement) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return typeof announcement === 'function' ? announcement.apply(void 0, __spread([this.widget], args)) : announcement;
        };
        /** Move the widget in a given direction based on arrow keys */
        DashboardGrabHandleDirective.prototype.moveWidget = function (event, key) {
            // check if moving is allowed
            if (!this.widget.isDraggable || !this.uxGrabAllowMove) {
                return;
            }
            // attempt to perform the move
            this._dashboard.onShift(this.widget, this.getDirectionFromKey(key));
            // get the announcable diff
            var changes = this.getLayoutDiff();
            // if there were changes then announce them
            if (changes.length > 0) {
                this._announcer.announce(this.getAnnouncement(this.uxGrabChangeSuccessAnnouncement, changes));
            }
            else {
                this._announcer.announce(this.getAnnouncement(this.uxGrabMoveFailAnnouncement, this.getDirectionFromKey(key)));
            }
            this._lastMovement = this._dashboard.cacheWidgets();
            event.preventDefault();
            event.stopPropagation();
        };
        /** Resize the widgets accordingly based on the arrow keys */
        DashboardGrabHandleDirective.prototype.resizeWidget = function (event, key) {
            // check if resizing is allowed
            if (!this.widget.resizable || !this.uxGrabAllowResize) {
                return;
            }
            this._dashboard.onResize(this.widget, this.getDirectionFromKey(key));
            // get the announcable diff
            var changes = this.getLayoutDiff();
            // if there were changes then announce them
            if (changes.length > 0) {
                this._announcer.announce(this.getAnnouncement(this.uxGrabChangeSuccessAnnouncement, changes));
            }
            else {
                this._announcer.announce(this.getAnnouncement(this.uxGrabResizeFailAnnouncement, this.getDirectionFromKey(key)));
            }
            this._lastMovement = this._dashboard.cacheWidgets();
            event.preventDefault();
            event.stopPropagation();
        };
        /** Shift focus between the variour grab handles */
        DashboardGrabHandleDirective.prototype.moveFocus = function (event, key) {
            switch (key) {
                case keycodes.UP_ARROW:
                    this._handle.setSiblingItemFocus(this.widget, exports.ActionDirection.Top);
                    break;
                case keycodes.RIGHT_ARROW:
                    this._handle.setNextItemFocus(this);
                    break;
                case keycodes.DOWN_ARROW:
                    this._handle.setSiblingItemFocus(this.widget, exports.ActionDirection.Bottom);
                    break;
                case keycodes.LEFT_ARROW:
                    this._handle.setPreviousItemFocus(this);
                    break;
            }
            event.preventDefault();
            event.stopPropagation();
        };
        /** Convert an arrow key code into an ActionDirection enum */
        DashboardGrabHandleDirective.prototype.getDirectionFromKey = function (key) {
            switch (key) {
                case keycodes.UP_ARROW:
                    return exports.ActionDirection.Top;
                case keycodes.RIGHT_ARROW:
                    return exports.ActionDirection.Right;
                case keycodes.DOWN_ARROW:
                    return exports.ActionDirection.Bottom;
                case keycodes.LEFT_ARROW:
                    return exports.ActionDirection.Left;
            }
        };
        /** Supply the default grab handle aria label based on the provided constraints */
        DashboardGrabHandleDirective.prototype.getDefaultAriaLabel = function (widget) {
            if (widget.resizable && this.uxGrabAllowResize && widget.isDraggable && this.uxGrabAllowMove) {
                return "Press space to move and resize the " + widget.name + " panel.";
            }
            else if (widget.resizable && this.uxGrabAllowResize) {
                return "Press space to resize the " + widget.name + " panel.";
            }
            else if (widget.isDraggable && this.uxGrabAllowMove) {
                return "Press space to move the " + widget.name + " panel.";
            }
        };
        /** Get the default announcement whenever a movement or resize was successful */
        DashboardGrabHandleDirective.prototype.getChangeSuccessAnnouncement = function () {
            return this.getDiffAnnouncements().join(' ') + " Use the cursor keys to continue moving and resizing, enter to commit, or escape to cancel.";
        };
        DashboardGrabHandleDirective.prototype.getDiffAnnouncements = function () {
            // map the differences to strings
            return this.getLayoutDiff().map(function (diff) {
                var changes = [];
                // Handle movement strings
                if (diff.isMovedHorizontally && diff.isMovedVertically) {
                    changes.push("moved to row " + diff.currentRow + ", column " + diff.currentColumn);
                }
                else if (diff.isMovedDown) {
                    changes.push("moved down to row " + diff.currentRow + ", column " + diff.currentColumn);
                }
                else if (diff.isMovedUp) {
                    changes.push("moved up to row " + diff.currentRow + ", column " + diff.currentColumn);
                }
                else if (diff.isMovedLeft) {
                    changes.push("moved left to row " + diff.currentRow + ", column " + diff.currentColumn);
                }
                else if (diff.isMovedRight) {
                    changes.push("moved right to row " + diff.currentRow + ", column " + diff.currentColumn);
                }
                // handle resize strings
                if (diff.isResized) {
                    changes.push("resized to " + diff.currentColumnSpan + " columns wide and " + diff.currentRowSpan + " rows high");
                }
                return diff.widget.name + " panel is " + changes.join(' and ') + ".";
            });
        };
        /** Get the default announcement whenever a movement is not possible due to dashboard boundaries */
        DashboardGrabHandleDirective.prototype.getMoveFailAnnouncement = function (widget, direction) {
            switch (direction) {
                case exports.ActionDirection.Top:
                    return "Cannot move the " + widget.name + " panel up, because it is at the top edge of the dashboard";
                case exports.ActionDirection.Bottom:
                    return "Cannot move the " + widget.name + " panel down, because it is at the bottom edge of the dashboard";
                case exports.ActionDirection.Right:
                    return "Cannot move the " + widget.name + " panel right, because it is at the right edge of the dashboard";
                case exports.ActionDirection.Left:
                    return "Cannot move the " + widget.name + " panel left, because it is at the left edge of the dashboard";
            }
        };
        /** Get the default announcement whenever a resize is not possible due to either widget constraints of dashboard bounds */
        DashboardGrabHandleDirective.prototype.getResizeFailAnnouncement = function (widget, direction) {
            switch (direction) {
                case exports.ActionDirection.Top:
                    return "Cannot make the " + widget.name + " panel shorter, because it is currently at its minimum height.";
                case exports.ActionDirection.Bottom:
                    return "Cannot make the " + widget.name + " panel taller, because it is currently at its maximum height.";
                case exports.ActionDirection.Right:
                    return "Cannot make the " + widget.name + " panel wider, because it is at the right edge of the dashboard.";
                case exports.ActionDirection.Left:
                    return "Cannot make the " + widget.name + " panel narrower, because it is currently at its minimum width.";
            }
        };
        /** Get the default announcement whenever we enter 'grab' mode */
        DashboardGrabHandleDirective.prototype.getStartAnnouncement = function (widget) {
            if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + " and is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. Use the cursor keys to move the widget and the cursor keys with the control modifier to resize the widget. Press enter to commit changes and press escape to cancel changes.";
            }
            else if (widget.isDraggable && this.uxGrabAllowMove) {
                return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + ". Use the cursor keys to move the widget. Press enter to commit changes and press escape to cancel changes.";
            }
            else if (widget.resizable && this.uxGrabAllowResize) {
                return widget.name + " panel is currently on row " + widget.getRow() + ", column " + widget.getColumn() + " and is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high. Use the cursor keys with the control modifier to resize the widget. Press enter to commit changes and press escape to cancel changes.";
            }
        };
        /** Get the default announcement whenever grab mode is exited after a movement or resize */
        DashboardGrabHandleDirective.prototype.getConfirmAnnouncement = function (widget) {
            if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                return "Moving and resizing complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
            else if (widget.isDraggable && this.uxGrabAllowMove) {
                return "Moving complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
            else if (widget.resizable && this.uxGrabAllowResize) {
                return "Resizing complete. " + this.getDiffAnnouncements().join(' ') + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
        };
        /** Get the default announcement whenever grab mode is exited after being cancelled */
        DashboardGrabHandleDirective.prototype.getCancellationAnnouncement = function (widget) {
            if (widget.isDraggable && widget.resizable && this.uxGrabAllowMove && this.uxGrabAllowResize) {
                return "Moving and resizing cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
            else if (widget.isDraggable && this.uxGrabAllowMove) {
                return "Moving cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
            else if (widget.resizable && this.uxGrabAllowResize) {
                return "Resizing cancelled. " + this.getDashboardAriaLabel() + " " + this.getAnnouncement(this.uxGrabAriaLabel);
            }
        };
        /** Get a description of all dashboard widgets, their positions and sizes */
        DashboardGrabHandleDirective.prototype.getDashboardAriaLabel = function () {
            return "Dashboard with " + this._dashboard.options.columns + " columns, containing " + this._dashboard.widgets.length + " panels. " + this._dashboard.widgets.map(this.getWidgetAriaLabel).join(' ');
        };
        /** Get a description of a given widget */
        DashboardGrabHandleDirective.prototype.getWidgetAriaLabel = function (widget) {
            return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high.";
        };
        /** Get an object describing all the changes that have been made to all widgets since the last change */
        DashboardGrabHandleDirective.prototype.getLayoutDiff = function () {
            var _this = this;
            // find all changes
            var diffs = this._dashboard.getLayoutData().map(function (layout) {
                // get the most recent cache
                var cache = _this._lastMovement || _this._cache;
                // get the actual widget
                var widget = _this._dashboard.widgets.find(function (_widget) { return _widget.id === layout.id; });
                // get previous position
                var previousLayout = cache.find(function (_widget) { return _widget.id === layout.id; });
                // ensure they are all numbers
                layout.row = Number(layout.row);
                layout.rowSpan = Number(layout.rowSpan);
                layout.col = Number(layout.col);
                layout.colSpan = Number(layout.colSpan);
                previousLayout.row = Number(previousLayout.row);
                previousLayout.rowSpan = Number(previousLayout.rowSpan);
                previousLayout.column = Number(previousLayout.column);
                previousLayout.columnSpan = Number(previousLayout.columnSpan);
                return {
                    widget: widget,
                    currentRow: layout.row,
                    currentColumn: layout.col,
                    currentRowSpan: layout.rowSpan,
                    currentColumnSpan: layout.colSpan,
                    previousColumn: previousLayout.column,
                    previousRow: previousLayout.row,
                    previousColumnSpan: previousLayout.columnSpan,
                    previousRowSpan: previousLayout.rowSpan,
                    isMovedLeft: layout.col < previousLayout.column,
                    isMovedRight: layout.col > previousLayout.column,
                    isMovedUp: layout.row < previousLayout.row,
                    isMovedDown: layout.row > previousLayout.row,
                    isMovedHorizontally: layout.col !== previousLayout.column,
                    isMovedVertically: layout.row !== previousLayout.row,
                    isMoved: layout.col !== previousLayout.column || layout.row !== previousLayout.row,
                    isResized: previousLayout.columnSpan !== layout.colSpan || previousLayout.rowSpan !== layout.rowSpan
                };
            });
            // get the order the widgets appear visually
            var order = this._handle.getHandlesInOrder().map(function (handle) { return handle.widget; });
            // only return items that have been repositioned or resized
            return diffs.filter(function (diff) { return diff.isMoved || diff.isResized; }).sort(function (diffOne, diffTwo) {
                // sort this so that the item that the user moved is first in the list, and the remainder are in their new order as seen in the dashboard
                if (diffOne.widget === _this.widget) {
                    return -1;
                }
                if (diffTwo.widget === _this.widget) {
                    return 1;
                }
                // otherwise sort based on their visual order
                return order.indexOf(diffOne.widget) < order.indexOf(diffTwo.widget) ? -1 : 1;
            });
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DashboardGrabHandleDirective.prototype, "uxGrabAllowMove", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DashboardGrabHandleDirective.prototype, "uxGrabAllowResize", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabChangeSuccessAnnouncement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabStartAnnouncement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabMoveFailAnnouncement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabResizeFailAnnouncement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabConfirmAnnouncement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DashboardGrabHandleDirective.prototype, "uxGrabCancelAnnouncement", void 0);
        __decorate([
            core.HostBinding('attr.aria-label'),
            __metadata("design:type", String)
        ], DashboardGrabHandleDirective.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('tabIndex'),
            __metadata("design:type", Number)
        ], DashboardGrabHandleDirective.prototype, "tabIndex", void 0);
        __decorate([
            core.HostListener('blur'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], DashboardGrabHandleDirective.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown', ['$event', '$event.which', '$event.ctrlKey']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent, Number, Boolean]),
            __metadata("design:returntype", void 0)
        ], DashboardGrabHandleDirective.prototype, "onKeydown", null);
        DashboardGrabHandleDirective = __decorate([
            core.Directive({
                selector: '[uxDashboardGrabHandle]',
                exportAs: 'ux-dashboard-grab-handle'
            }),
            __metadata("design:paramtypes", [DashboardWidgetComponent,
                DashboardService,
                DashboardGrabHandleService,
                core.ElementRef,
                a11y.LiveAnnouncer])
        ], DashboardGrabHandleDirective);
        return DashboardGrabHandleDirective;
    }());
    var DashboardComponent = /** @class */ (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.isGrabbing = false;
            this.customAriaLabel = this.getDefaultAriaLabel;
            /** Emits when layout has been changed. */
            this.layoutChange = new core.EventEmitter();
            /** Ensure we unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
            dashboardService.layout$.pipe(operators.takeUntil(this._onDestroy), operators.tap(function () { return _this.ariaLabel = _this.getAriaLabel(); }))
                .subscribe(function (layout) { return _this.layoutChange.emit(layout); });
            // subscribe to changes to the grab mode
            dashboardService.isGrabbing$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (widget) { return !!widget; }))
                .subscribe(function (isGrabbing) { return _this.isGrabbing = isGrabbing; });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            /** If defined or changed this will set the positions of the widgets within the dashboard. This is a two way binding that will be updated with the current layout when it changes. */
            set: function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            /** Configures the options for the dashboard, if an option is not specified the default value will be used. */
            set: function (options) {
                this.dashboardService.options$.next(__assign(__assign({}, defaultOptions), options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        DashboardComponent.prototype.ngAfterViewInit = function () {
            // set the initial dimensions
            this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
        };
        DashboardComponent.prototype.ngOnChanges = function () {
            this.dashboardService.renderDashboard();
        };
        DashboardComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        DashboardComponent.prototype.onResize = function (event) {
            this.dashboardService.setDimensions(event.width, event.height);
        };
        DashboardComponent.prototype.getAriaLabel = function () {
            if (this.customAriaLabel && typeof this.customAriaLabel === 'string') {
                return this.customAriaLabel;
            }
            else if (this.customAriaLabel && typeof this.customAriaLabel === 'function') {
                return this.customAriaLabel(this.dashboardService.widgets, this.dashboardService.options);
            }
            return this.ariaLabel;
        };
        DashboardComponent.prototype.getDefaultAriaLabel = function (widgets, options) {
            return "Dashboard with " + options.columns + " columns, containing " + widgets.length + " panels. " + widgets.map(this.getWidgetAriaLabel).join(' ');
        };
        DashboardComponent.prototype.getWidgetAriaLabel = function (widget) {
            return widget.name + " panel in row " + widget.getRow() + ", column " + widget.getColumn() + ", is " + widget.getColumnSpan() + " columns wide and " + widget.getRowSpan() + " rows high.";
        };
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", Function)
        ], DashboardComponent.prototype, "customAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DashboardComponent.prototype, "layout", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], DashboardComponent.prototype, "options", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DashboardComponent.prototype, "layoutChange", void 0);
        __decorate([
            core.HostBinding('attr.aria-label'),
            __metadata("design:type", String)
        ], DashboardComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.ViewChild('dashboard', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], DashboardComponent.prototype, "dashboardElement", void 0);
        __decorate([
            core.ContentChildren(DashboardGrabHandleDirective, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], DashboardComponent.prototype, "handles", void 0);
        DashboardComponent = __decorate([
            core.Component({
                selector: 'ux-dashboard',
                template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n\n    <!-- Wrap with ngIf so we only have one subscription rather than one for each property -->\n    <ng-container *ngIf=\"dashboardService.placeholder$ | async; let placeholder\">\n        <div class=\"position-indicator\"\n            *ngIf=\"placeholder.visible\"\n            [style.left.px]=\"placeholder.x\"\n            [style.top.px]=\"placeholder.y\"\n            [style.width.px]=\"placeholder.width\"\n            [style.height.px]=\"placeholder.height\">\n        </div>\n    </ng-container>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [
                    DashboardService,
                    DashboardGrabHandleService
                ]
            }),
            __metadata("design:paramtypes", [DashboardService])
        ], DashboardComponent);
        return DashboardComponent;
    }());
    var DashboardDragHandleDirective = /** @class */ (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer, drag) {
            var _this = _super.call(this, elementRef, ngZone, renderer, drag) || this;
            // inform the widget that it can be dragged
            widget.isDraggable = true;
            _this.onDragStart.pipe(operators.takeUntil(_this._onDestroy), operators.tap(function () { return dashboardService.isGrabbing$.next(null); }))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: exports.ActionDirection.Move, event: event }); });
            _this.onDrag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: exports.ActionDirection.Move, event: event }); });
            _this.onDragEnd.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective = __decorate([
            core.Directive({
                selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
            }),
            __metadata("design:paramtypes", [DashboardWidgetComponent, DashboardService, core.ElementRef,
                core.NgZone, core.Renderer2, DragService])
        ], DashboardDragHandleDirective);
        return DashboardDragHandleDirective;
    }(DragDirective));
    var DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective,
        DashboardGrabHandleDirective
    ];
    var DashboardModule = /** @class */ (function () {
        function DashboardModule() {
        }
        DashboardModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    common.CommonModule,
                    ResizeModule,
                    DragModule
                ],
                exports: DECLARATIONS,
                declarations: DECLARATIONS,
                providers: [DashboardService],
            })
        ], DashboardModule);
        return DashboardModule;
    }());
    /**
     * Convert a single dimension array to a double dimension array
     * @param items the single dimension array to convert
     * @param columns the number of items each array should have
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        var grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param start the lower limit
     * @param end the upper limit
     */
    function range(start, end) {
        var list = [];
        for (var idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param start the date to start the array
     * @param end the date to end the array
     */
    function dateRange(start, end) {
        // don't alter the start date object
        start = new Date(start);
        var dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param day1 the first date to compare
     * @param day2 the second date to compare
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     */
    function dateComparator(dateOne, dateTwo) {
        if (!dateOne && dateTwo || dateOne && !dateTwo) {
            return false;
        }
        if (!dateOne && !dateTwo) {
            return true;
        }
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Calculate the number of days between two dates
     * @param start The start date
     * @param end The end date
     * @param fullDay Whether or not we should take from 00:00 on the start date and 23:59 on the end date
     */
    function differenceBetweenDates(start, end, fullDay) {
        if (fullDay === void 0) {
            fullDay = true;
        }
        if (!start || !end) {
            return null;
        }
        var millisecondsInDay = 86400000;
        var startDay = new Date(start.getTime() < end.getTime() ? start : end);
        var endDay = new Date(start.getTime() > end.getTime() ? start : end);
        // get the start of day
        if (fullDay) {
            startDay.setHours(0, 0, 0, 0);
            endDay.setHours(23, 59, 59, 0);
        }
        return Math.round((endDay.getTime() - startDay.getTime()) / millisecondsInDay);
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Get a date object with the time of the start of the given day
     * @param date The date to get the start of day
     */
    function getStartOfDay(date) {
        var startOfDay = new Date(date);
        startOfDay.setHours(0, 0, 0, 0);
        return startOfDay;
    }
    function isDateAfter(date, after, isEqual) {
        if (isEqual === void 0) {
            isEqual = false;
        }
        return isEqual ? getStartOfDay(date).getTime() >= getStartOfDay(after).getTime() : getStartOfDay(date).getTime() > getStartOfDay(after).getTime();
    }
    function isDateBefore(date, before, isEqual) {
        if (isEqual === void 0) {
            isEqual = false;
        }
        return isEqual ? getStartOfDay(date).getTime() <= getStartOfDay(before).getTime() : getStartOfDay(date).getTime() < getStartOfDay(before).getTime();
    }
    /**
     * Export an array of all the available months
     */
    var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var monthsShort = getShortMonthNames();
    function getShortMonthNames() {
        return months.map(function (month) { return month.substring(0, 3); });
    }
    /**
     * Export an array of all the available days of the week
     */
    var weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var weekdaysShort = getShortWeekdayNames();
    var meridians = ['AM', 'PM'];
    function getShortWeekdayNames() {
        return weekdays.map(function (weekday) { return weekday.substring(0, 3); });
    }
    /** Export the default set of time zone */
    var timezones = [
        { name: 'GMT-11', offset: 660 },
        { name: 'GMT-10', offset: 600 },
        { name: 'GMT-9', offset: 540 },
        { name: 'GMT-8', offset: 480 },
        { name: 'GMT-7', offset: 420 },
        { name: 'GMT-6', offset: 360 },
        { name: 'GMT-5', offset: 300 },
        { name: 'GMT-4', offset: 240 },
        { name: 'GMT-3', offset: 180 },
        { name: 'GMT-2', offset: 120 },
        { name: 'GMT-1', offset: 60 },
        { name: 'GMT', offset: 0 },
        { name: 'GMT+1', offset: -60 },
        { name: 'GMT+2', offset: -120 },
        { name: 'GMT+3', offset: -180 },
        { name: 'GMT+4', offset: -240 },
        { name: 'GMT+5', offset: -300 },
        { name: 'GMT+6', offset: -360 },
        { name: 'GMT+7', offset: -420 },
        { name: 'GMT+8', offset: -480 },
        { name: 'GMT+9', offset: -540 },
        { name: 'GMT+10', offset: -600 },
        { name: 'GMT+11', offset: -660 },
        { name: 'GMT+12', offset: -720 }
    ];
    var DateRangeService = /** @class */ (function () {
        function DateRangeService() {
            /** Indicate whether we want to show a date range */
            this.isRange = false;
            /** Specify the direction of the selection */
            this.direction = exports.DateRangePicker.Start;
            /** Emit whenever the start date changes */
            this.onStartChange = new rxjs.Subject();
            /** Emit whenever the end date changes */
            this.onEndChange = new rxjs.Subject();
            /** Emit whenever the range has changed */
            this.onRangeChange = new rxjs.Subject();
            /** Emit whenever the hover date changes */
            this.onHoverChange = new rxjs.Subject();
            /** Emit whenever the range is cleared */
            this.onClear = new rxjs.Subject();
            /** Indicate if we should show time */
            this.showTime = false;
            /** Defines the aria label for the range start picker */
            this.startPickerAriaLabel = 'Selecting the start date';
            /** Defines the aria label for the range end picker */
            this.endPickerAriaLabel = 'Selecting the end date';
            /** Indicate if we are currently changing the time */
            this.isChangingTime = false;
            /** Store the current start time */
            this.startTime = { hours: 0, minutes: 0, seconds: 0 };
            /** Store the current end time */
            this.endTime = { hours: 23, minutes: 59, seconds: 59 };
        }
        DateRangeService.prototype.setStartDate = function (date) {
            // if the start date is after the end date the clear the end date
            if (date && this.end && isDateAfter(date, this.end)) {
                this.clear();
            }
            this.start = date;
            this.onStartChange.next(this.start);
            this.onRangeChange.next();
        };
        DateRangeService.prototype.setEndDate = function (date) {
            // if the end date is before the start date the clear the start date
            if (date && this.start && isDateBefore(date, this.start)) {
                this.clear();
            }
            this.end = date;
            this.onEndChange.next(this.end);
            this.onRangeChange.next();
        };
        DateRangeService.prototype.clear = function () {
            this.setStartDate(null);
            this.setEndDate(null);
            this.onClear.next();
        };
        DateRangeService.prototype.setDateMouseEnter = function (date) {
            this.hover = date;
            this.onHoverChange.next();
        };
        DateRangeService.prototype.setDateMouseLeave = function (date) {
            if (date && this.hover && compareDays(date, this.hover)) {
                this.setDateMouseEnter(null);
            }
        };
        return DateRangeService;
    }());
    (function (DateRangePicker) {
        DateRangePicker["Start"] = "start";
        DateRangePicker["End"] = "end";
    })(exports.DateRangePicker || (exports.DateRangePicker = {}));
    var DateRangePickerComponent = /** @class */ (function () {
        function DateRangePickerComponent(rangeService) {
            var _this = this;
            this.rangeService = rangeService;
            /** Defines whether or not the time picker should allow the user to specify seconds. */
            this.showSeconds = false;
            /** Defines whether or not the time picker should show an AM/PM button, or time should be represented in 24hr format instead. */
            this.showMeridian = true;
            /** Defines whether or not the time picker should allow the user to select the time using spinners. */
            this.showSpinners = true;
            /** If defined will override the weekday names displayed. */
            this.weekdays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            /** Specify whether or not the show now button should be visible */
            this.showNowBtn = false;
            /** Defines the title to display above the start picker. */
            this.selectStartTitle = 'Select Start Date';
            /** Defines the title to display above the end picker. */
            this.selectEndTitle = 'Select End Date';
            /** Define the aria label for the now button */
            this.nowBtnAriaLabel = 'Set date to now';
            /**
             * Defines the list of available timezones. The `DateTimePickerTimezone` interface specifies that each timezone should
             * be an object with a `name` property that represents the timezone, eg. `GMT+2`, and an `offset` property that represents
             * the number of minutes relative to GMT the timezone is.
             */
            this.timezones = timezones;
            /** Will set the selected start timezone. */
            this.startTimezone = this.getCurrentTimezone();
            /** Will set the selected end timezone. */
            this.endTimezone = this.getCurrentTimezone();
            /** Defines the day of the week that should appear in the first column. `WeekDay` is an enumeration available in `@angular/common`. */
            this.startOfWeek = common.WeekDay.Sunday;
            /** Define a function to return the number of days within the selected range */
            this.durationTitle = this.getDurationTitle;
            /** Emit when the start date changes */
            this.startChange = new core.EventEmitter();
            /** Emit when the end date changes */
            this.endChange = new core.EventEmitter();
            /** Emit when the start timezone changes. */
            this.startTimezoneChange = new core.EventEmitter();
            /** Emit when the end timezone changes. */
            this.endTimezoneChange = new core.EventEmitter();
            /** Use an observable to debounce rapid start changes */
            this.startChange$ = new rxjs.Subject();
            /** Use an observable to debounce rapid end changes */
            this.endChange$ = new rxjs.Subject();
            /** Unsubscribe from all observables private  */
            this._onDestroy = new rxjs.Subject();
            this.startChange$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (date) { return _this.onStartChange(date); });
            this.endChange$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (date) { return _this.onEndChange(date); });
        }
        Object.defineProperty(DateRangePickerComponent.prototype, "start", {
            /** The selected start date to be displayed in the component. */
            set: function (start) {
                this.rangeService.start = start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "end", {
            /** The selected end date to be displayed in the component. */
            set: function (end) {
                this.rangeService.end = end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "startPickerAriaLabel", {
            /** Defines the aria label for the range start picker */
            set: function (label) {
                this.rangeService.startPickerAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "endPickerAriaLabel", {
            /** Defines the aria label for the range end picker */
            set: function (label) {
                this.rangeService.endPickerAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "showTime", {
            get: function () {
                return this.rangeService.showTime;
            },
            /** Defines whether or not the time picker should be visible. */
            set: function (showTime) {
                this.rangeService.showTime = showTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateRangePickerComponent.prototype, "_duration", {
            /** Calculate the number of days between the start and end date */
            get: function () {
                if (this.rangeService.start && this.rangeService.end) {
                    return differenceBetweenDates(this.rangeService.start, this.rangeService.end, false);
                }
                if (this.rangeService.start && !this.rangeService.end && this.rangeService.hover) {
                    // apply the time from the time picker
                    var hoverDate = new Date(this.rangeService.hover);
                    hoverDate.setHours(this.rangeService.endTime.hours, this.rangeService.endTime.minutes, this.rangeService.endTime.seconds);
                    return this.rangeService.start.getTime() <= hoverDate.getTime() ? differenceBetweenDates(this.rangeService.start, hoverDate, false) : null;
                }
                // if we only have one selected date and have a hover date
                if (this.rangeService.end && !this.rangeService.start && this.rangeService.hover) {
                    // apply the time from the time picker
                    var hoverDate = new Date(this.rangeService.hover);
                    hoverDate.setHours(this.rangeService.startTime.hours, this.rangeService.startTime.minutes, this.rangeService.startTime.seconds);
                    return this.rangeService.end.getTime() >= hoverDate.getTime() ? differenceBetweenDates(this.rangeService.end, hoverDate, false) : null;
                }
            },
            enumerable: true,
            configurable: true
        });
        DateRangePickerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Clear the selected date range */
        DateRangePickerComponent.prototype.clear = function () {
            this.rangeService.clear();
        };
        /** Get the timezone based on the machine timezone */
        DateRangePickerComponent.prototype.getCurrentTimezone = function () {
            return this.timezones.find(function (timezone) { return timezone.offset === new Date().getTimezoneOffset(); });
        };
        DateRangePickerComponent.prototype.onStartChange = function (date) {
            this.rangeService.setStartDate(date);
            this.startChange.emit(date);
        };
        DateRangePickerComponent.prototype.onEndChange = function (date) {
            this.rangeService.setEndDate(date);
            this.endChange.emit(date);
        };
        /** Get the text to display to indicate the duration */
        DateRangePickerComponent.prototype.getDurationTitle = function (days) {
            return days + ' ' + (days > 1 ? 'days' : 'day');
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], DateRangePickerComponent.prototype, "start", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], DateRangePickerComponent.prototype, "end", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "dateFormat", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "timeFormat", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date)
        ], DateRangePickerComponent.prototype, "min", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date)
        ], DateRangePickerComponent.prototype, "max", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DateRangePickerComponent.prototype, "showTimezone", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DateRangePickerComponent.prototype, "showSeconds", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DateRangePickerComponent.prototype, "showMeridian", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DateRangePickerComponent.prototype, "showSpinners", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], DateRangePickerComponent.prototype, "weekdays", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], DateRangePickerComponent.prototype, "months", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], DateRangePickerComponent.prototype, "monthsShort", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], DateRangePickerComponent.prototype, "meridians", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DateRangePickerComponent.prototype, "nowBtnText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], DateRangePickerComponent.prototype, "showNowBtn", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DateRangePickerComponent.prototype, "selectStartTitle", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DateRangePickerComponent.prototype, "selectEndTitle", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DateRangePickerComponent.prototype, "nowBtnAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], DateRangePickerComponent.prototype, "startPickerAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], DateRangePickerComponent.prototype, "endPickerAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateRangePickerComponent.prototype, "showTime", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], DateRangePickerComponent.prototype, "timezones", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "startTimezone", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "endTimezone", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], DateRangePickerComponent.prototype, "startOfWeek", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], DateRangePickerComponent.prototype, "durationTitle", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "startChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], DateRangePickerComponent.prototype, "endChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], DateRangePickerComponent.prototype, "startTimezoneChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], DateRangePickerComponent.prototype, "endTimezoneChange", void 0);
        DateRangePickerComponent = __decorate([
            core.Component({
                selector: 'ux-date-range-picker',
                template: "<div class=\"range-header\">\n\n    <div class=\"header-section\">\n        <div *ngIf=\"!rangeService.start\" class=\"select-header\">{{ selectStartTitle }}</div>\n        <div *ngIf=\"rangeService.start\" class=\"date-header\">\n            {{ rangeService.start | formatDate: dateFormat || 'd MMMM y' }}\n        </div>\n        <div [style.visibility]=\"rangeService.start && showTime ? 'visible' : 'hidden'\" class=\"time-header\">\n            {{ rangeService.start | formatDate: timeFormat || (showMeridian ? 'shortTime' : 'HH:mm') }}\n        </div>\n    </div>\n\n    <div class=\"header-separator\">\n        <ux-icon name=\"link-next\"></ux-icon>\n        <p class=\"duration\"\n           [style.visibility]=\"_duration !== null && _duration !== undefined ? 'visible' : 'hidden'\">\n            {{ durationTitle(_duration || 0) }}\n        </p>\n    </div>\n\n    <div class=\"header-section\">\n        <div *ngIf=\"!rangeService.end\" class=\"select-header\">{{ selectEndTitle }}</div>\n        <div *ngIf=\"rangeService.end\" class=\"date-header\">\n            {{ rangeService.end | formatDate: dateFormat || 'd MMMM y'}}\n        </div>\n        <div [style.visibility]=\"rangeService.end && showTime ? 'visible' : 'hidden'\" class=\"time-header\">\n            {{ rangeService.end | formatDate: timeFormat || (showMeridian ? 'shortTime' : 'HH:mm') }}\n        </div>\n    </div>\n\n</div>\n\n<div class=\"content\">\n    <ux-date-time-picker\n        uxDateRangePicker\n        picker=\"start\"\n        class=\"start-date-picker\"\n        [date]=\"rangeService.start\"\n        (dateChange)=\"startChange$.next($event)\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [weekdays]=\"weekdays\"\n        [startOfWeek]=\"startOfWeek\"\n        [showTime]=\"showTime\"\n        [showTimezone]=\"showTimezone\"\n        [showSeconds]=\"showSeconds\"\n        [showMeridian]=\"showMeridian\"\n        [showSpinners]=\"showSpinners\"\n        [months]=\"months\"\n        [monthsShort]=\"monthsShort\"\n        [meridians]=\"meridians\"\n        [nowBtnText]=\"nowBtnText\"\n        [showNowBtn]=\"showNowBtn\"\n        [nowBtnAriaLabel]=\"nowBtnAriaLabel\"\n        [timezones]=\"timezones\"\n        [(timezone)]=\"startTimezone\"\n        (timezoneChange)=\"startTimezoneChange.emit($event)\">\n    </ux-date-time-picker>\n\n    <ux-date-time-picker\n        uxDateRangePicker\n        picker=\"end\"\n        class=\"end-date-picker\"\n        [date]=\"rangeService.end\"\n        (dateChange)=\"endChange$.next($event)\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [weekdays]=\"weekdays\"\n        [startOfWeek]=\"startOfWeek\"\n        [showTime]=\"showTime\"\n        [showTimezone]=\"showTimezone\"\n        [showSeconds]=\"showSeconds\"\n        [showMeridian]=\"showMeridian\"\n        [showSpinners]=\"showSpinners\"\n        [months]=\"months\"\n        [monthsShort]=\"monthsShort\"\n        [meridians]=\"meridians\"\n        [nowBtnText]=\"nowBtnText\"\n        [showNowBtn]=\"showNowBtn\"\n        [nowBtnAriaLabel]=\"nowBtnAriaLabel\"\n        [timezones]=\"timezones\"\n        [(timezone)]=\"endTimezone\"\n        (timezoneChange)=\"endTimezoneChange.emit($event)\">\n    </ux-date-time-picker>\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [DateRangeService]
            }),
            __metadata("design:paramtypes", [DateRangeService])
        ], DateRangePickerComponent);
        return DateRangePickerComponent;
    }());
    var DateRangeOptions = /** @class */ (function () {
        function DateRangeOptions() {
            this.picker = exports.DateRangePicker.Start;
        }
        return DateRangeOptions;
    }());
    var DateRangePickerDirective = /** @class */ (function () {
        function DateRangePickerDirective(_options) {
            this._options = _options;
        }
        Object.defineProperty(DateRangePickerDirective.prototype, "picker", {
            /** Specify whether this is the start or end picker */
            set: function (picker) {
                this._options.picker = picker;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], DateRangePickerDirective.prototype, "picker", null);
        DateRangePickerDirective = __decorate([
            core.Directive({
                selector: '[uxDateRangePicker]',
                providers: [DateRangeOptions]
            }),
            __param(0, core.Self()),
            __metadata("design:paramtypes", [DateRangeOptions])
        ], DateRangePickerDirective);
        return DateRangePickerDirective;
    }());
    var DateFormatterPipe = /** @class */ (function () {
        function DateFormatterPipe() {
        }
        DateFormatterPipe.prototype.transform = function (value, formatter) {
            // we may not initially have  a value
            if (!value) {
                return '';
            }
            return typeof formatter === 'function' ? formatter(value) : common.formatDate(value, formatter, navigator.language);
        };
        DateFormatterPipe = __decorate([
            core.Pipe({
                name: 'formatDate'
            })
        ], DateFormatterPipe);
        return DateFormatterPipe;
    }());
    var DateFormatterPipeModule = /** @class */ (function () {
        function DateFormatterPipeModule() {
        }
        DateFormatterPipeModule = __decorate([
            core.NgModule({
                exports: [DateFormatterPipe],
                declarations: [DateFormatterPipe]
            })
        ], DateFormatterPipeModule);
        return DateFormatterPipeModule;
    }());
    /**
     * Add a config service to allow an application
     * to customize the date time picker default settings
     * across the entire application
     */
    var DateTimePickerConfig = /** @class */ (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.showNowBtn = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = timezones;
            this.months = months;
            this.monthsShort = monthsShort;
            this.meridians = meridians;
            this.min = null;
            this.max = null;
        }
        DateTimePickerConfig = __decorate([
            core.Injectable()
        ], DateTimePickerConfig);
        return DateTimePickerConfig;
    }());
    var DateTimePickerService = /** @class */ (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new rxjs.BehaviorSubject(exports.DatePickerMode.Day);
            this.date$ = new rxjs.BehaviorSubject(new Date());
            this.timezone$ = new rxjs.BehaviorSubject(null);
            this.selected$ = new rxjs.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new rxjs.BehaviorSubject(new Date().getMonth());
            this.year$ = new rxjs.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new rxjs.BehaviorSubject(this._config ? this._config.showDate : true);
            this.showTime$ = new rxjs.BehaviorSubject(this._config ? this._config.showTime : true);
            this.showTimezone$ = new rxjs.BehaviorSubject(this._config ? this._config.showTimezone : true);
            this.showSeconds$ = new rxjs.BehaviorSubject(this._config ? this._config.showSeconds : false);
            this.showMeridian$ = new rxjs.BehaviorSubject(this._config ? this._config.showMeridian : true);
            this.showSpinners$ = new rxjs.BehaviorSubject(this._config ? this._config.showSpinners : true);
            this.showNowBtn$ = new rxjs.BehaviorSubject(this._config ? this._config.showNowBtn : true);
            this.weekdays$ = new rxjs.BehaviorSubject(this._config ? this._config.weekdays : weekdaysShort);
            this.nowBtnText$ = new rxjs.BehaviorSubject(this._config ? this._config.nowBtnText : 'Today');
            this.timezones$ = new rxjs.BehaviorSubject(this._config ? this._config.timezones : timezones);
            this.min$ = new rxjs.BehaviorSubject(this._config ? this._config.min : null);
            this.max$ = new rxjs.BehaviorSubject(this._config ? this._config.max : null);
            this.header$ = new rxjs.BehaviorSubject(null);
            this.headerEvent$ = new rxjs.Subject();
            this.modeDirection = exports.ModeDirection.None;
            this.startOfWeek$ = new rxjs.BehaviorSubject(common.WeekDay.Sunday);
            this.months = this._config ? this._config.months : months;
            this.monthsShort = this._config ? this._config.monthsShort : monthsShort;
            this.meridians = this._config ? this._config.meridians : meridians;
            /**
             * Store whether or not the component has fully initialised or not. We use this to prevent initial
             * focus on the end date range picker when the popover is first opened
             */
            this.initialised = false;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                if (date instanceof Date) {
                    _this.setViewportMonth(date.getMonth());
                    _this.setViewportYear(date.getFullYear());
                }
                // emit the new date to the component host but only if they are different
                if (!dateComparator(date, _this.selected$.value)) {
                    _this.date$.next(date);
                }
            });
        }
        DateTimePickerService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        DateTimePickerService.prototype.setViewportMonth = function (month) {
            if (month < 0) {
                this.month$.next(11);
                this.year$.next(this.year$.value - 1);
            }
            else if (month > 11) {
                this.month$.next(0);
                this.year$.next(this.year$.value + 1);
            }
            else {
                this.month$.next(month);
            }
        };
        DateTimePickerService.prototype.setViewportYear = function (year) {
            this.year$.next(year);
        };
        DateTimePickerService.prototype.setDate = function (day, month, year, hours, minutes, seconds) {
            var date = new Date(this.selected$.value);
            date.setFullYear(year);
            date.setMonth(month);
            date.setDate(day);
            if (hours !== undefined) {
                date.setHours(hours);
            }
            if (minutes !== undefined) {
                date.setMinutes(minutes);
            }
            if (seconds !== undefined) {
                date.setSeconds(seconds);
            }
            if (this.isInRange(date)) {
                this.selected$.next(date);
            }
        };
        DateTimePickerService.prototype.setDateToNow = function () {
            var now = new Date();
            if (this.isInRange(now)) {
                this.selected$.next(now);
            }
        };
        DateTimePickerService.prototype.setViewportMode = function (mode) {
            this.mode$.next(mode);
        };
        DateTimePickerService.prototype.goToChildMode = function () {
            this.modeDirection = exports.ModeDirection.Descend;
            switch (this.mode$.value) {
                case exports.DatePickerMode.Year:
                    return this.setViewportMode(exports.DatePickerMode.Month);
                case exports.DatePickerMode.Month:
                    return this.setViewportMode(exports.DatePickerMode.Day);
            }
        };
        DateTimePickerService.prototype.goToParentMode = function () {
            this.modeDirection = exports.ModeDirection.Ascend;
            switch (this.mode$.value) {
                case exports.DatePickerMode.Day:
                    return this.setViewportMode(exports.DatePickerMode.Month);
                case exports.DatePickerMode.Month:
                    return this.setViewportMode(exports.DatePickerMode.Year);
            }
        };
        DateTimePickerService.prototype.goToNext = function () {
            this.headerEvent$.next(exports.DatePickerHeaderEvent.Next);
        };
        DateTimePickerService.prototype.goToPrevious = function () {
            this.headerEvent$.next(exports.DatePickerHeaderEvent.Previous);
        };
        DateTimePickerService.prototype.setHeader = function (header) {
            this.header$.next(header);
        };
        DateTimePickerService.prototype.isTimezoneAvailable = function (timezone) {
            if (!timezone || !this.timezones$.value) {
                return false;
            }
            return this.timezones$.value.findIndex(function (_timezone) { return _timezone.offset === timezone.offset && _timezone.name === timezone.name; }) !== -1;
        };
        DateTimePickerService.prototype.getDefaultTimezone = function () {
            var offset = new Date().getTimezoneOffset();
            var matchingZone = this.timezones$.value.find(function (_timezone) { return _timezone.offset === offset; });
            return matchingZone || this.timezones$.value.find(function (_timezone) { return _timezone.offset === 0; }) || { name: 'GMT', offset: 0 };
        };
        DateTimePickerService.prototype.isInRange = function (date) {
            return (!this.min$.value || date >= this.min$.value) && (!this.max$.value || date <= this.max$.value);
        };
        DateTimePickerService = __decorate([
            core.Injectable(),
            __param(0, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerConfig])
        ], DateTimePickerService);
        return DateTimePickerService;
    }());
    (function (DatePickerMode) {
        DatePickerMode[DatePickerMode["Day"] = 0] = "Day";
        DatePickerMode[DatePickerMode["Month"] = 1] = "Month";
        DatePickerMode[DatePickerMode["Year"] = 2] = "Year";
    })(exports.DatePickerMode || (exports.DatePickerMode = {}));
    (function (ModeDirection) {
        ModeDirection[ModeDirection["None"] = 0] = "None";
        ModeDirection[ModeDirection["Ascend"] = 1] = "Ascend";
        ModeDirection[ModeDirection["Descend"] = 2] = "Descend";
    })(exports.ModeDirection || (exports.ModeDirection = {}));
    (function (DatePickerHeaderEvent) {
        DatePickerHeaderEvent[DatePickerHeaderEvent["Previous"] = 0] = "Previous";
        DatePickerHeaderEvent[DatePickerHeaderEvent["Next"] = 1] = "Next";
    })(exports.DatePickerHeaderEvent || (exports.DatePickerHeaderEvent = {}));
    var DateTimePickerComponent = /** @class */ (function () {
        function DateTimePickerComponent(datepicker, _rangeService, _rangeOptions) {
            var _this = this;
            this.datepicker = datepicker;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            /** Define the aria label for the now button */
            this.nowBtnAriaLabel = 'Set date to now';
            /** Emits an event when the date is changed using the component. */
            this.dateChange = new core.EventEmitter();
            /** If not defined the picker will try to use the user's timezone. If that is not available, it will revert to GMT. */
            this.timezoneChange = new core.EventEmitter();
            // expose enum to view
            this.DatePickerMode = exports.DatePickerMode;
            this._onDestroy = new rxjs.Subject();
            datepicker.selected$.pipe(operators.distinctUntilChanged(dateComparator), operators.takeUntil(this._onDestroy))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            /** Defines whether or not the date picker should be visible. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showDate$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            /** Defines whether or not the time picker should be visible. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showTime$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            /** Defines whether or not the time picker should allow the user to choose a timezone. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showTimezone$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            /** Defines whether or not the time picker should allow the user to specify seconds. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showSeconds$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            /** Defines whether or not the time picker should show an AM/PM button, or time should be represented in 24hr format instead. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showMeridian$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            /** Defines whether or not the time picker should allow the user to select the time using spinners. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showSpinners$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            /** If defined will override the weekday names displayed. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.weekdays$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "months", {
            /** Defines the names of the months. */
            set: function (months) {
                if (months !== undefined) {
                    this.datepicker.months = months;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "monthsShort", {
            /** Defines the short names of each month. */
            set: function (months) {
                if (months !== undefined) {
                    this.datepicker.monthsShort = months;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "meridians", {
            /** Defines the labels to show in the meridian (AM/PM) selector. */
            set: function (meridians) {
                if (meridians !== undefined) {
                    this.datepicker.meridians = meridians;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            /** Defines the text to be displayed in the button used to set the selected time to the current time. */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.nowBtnText$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showNowBtn", {
            /** Specify whether or not to show the show now button */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.showNowBtn$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            /**
             * Defines the list of available timezones. The `DateTimePickerTimezone` interface specifies that each timezone should
             * be an object with a `name` property that represents the timezone, eg. `GMT+2`, and an `offset` property that represents
             * the number of minutes relative to GMT the timezone is.
             */
            set: function (value) {
                if (value !== undefined) {
                    this.datepicker.timezones$.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "startOfWeek", {
            /** Defines the day of the week that should appear in the first column. `WeekDay` is an enumeration available in `@angular/common`. */
            set: function (startOfWeek) {
                if (startOfWeek !== undefined) {
                    this.datepicker.startOfWeek$.next(startOfWeek);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            /** The selected date to be displayed in the component. */
            set: function (value) {
                if (value && !dateComparator(value, this.datepicker.date$.value)) {
                    if (this._isRangeMode) {
                        this.datepicker.date$.next(new Date(value));
                        this.datepicker.selected$.next(new Date(value));
                    }
                    else {
                        this.datepicker.selected$.next(new Date(value));
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            /** Will set the selected timezone. */
            set: function (value) {
                this.setTimezone(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "min", {
            /** The earliest selectable date. */
            set: function (value) {
                this.datepicker.min$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "max", {
            /** The latest selectable date. */
            set: function (value) {
                this.datepicker.max$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "_isTodayDisabled", {
            /** Determine if the today button is disabled */
            get: function () {
                var min = this.datepicker.min$.value;
                var max = this.datepicker.max$.value;
                if (!min && !max) {
                    return false;
                }
                if (min && !max) {
                    return isDateBefore(new Date(), min);
                }
                if (!min && max) {
                    return isDateAfter(new Date(), max);
                }
                return isDateBefore(new Date(), min) || isDateAfter(new Date(), max);
            },
            enumerable: true,
            configurable: true
        });
        DateTimePickerComponent.prototype.ngOnInit = function () {
            this.setTimezone(this.datepicker.timezone$.value);
        };
        DateTimePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () { return _this.datepicker.initialised = true; });
        };
        DateTimePickerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Change the date to the current date and time
         */
        DateTimePickerComponent.prototype.setToNow = function () {
            if (this._isRangeMode) {
                var date = new Date();
                if (this._isRangeStart && !this._rangeService.showTime) {
                    this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 0, 0, 0);
                }
                else if (this._isRangeEnd && !this._rangeService.showTime) {
                    this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 23, 59, 59);
                }
                else {
                    this.datepicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), this.datepicker.hours, this.datepicker.minutes, this.datepicker.seconds);
                }
            }
            else {
                // set the date to the current moment
                this.datepicker.setDateToNow();
            }
        };
        DateTimePickerComponent.prototype._onTimezoneChange = function (timezone) {
            if (!timezoneComparator(this.datepicker.timezone$.value, timezone)) {
                this.timezoneChange.emit(timezone);
            }
        };
        /**
         * Update the service with the new timezone value, falling back on the default if it is undefined or
         * not present in `timezones`.
         */
        DateTimePickerComponent.prototype.setTimezone = function (timezone) {
            // if the user does not provide a timezone, set it to the current timezone and emit the change
            if (!timezone) {
                this.datepicker.timezone$.next(this.datepicker.getDefaultTimezone());
                this.timezoneChange.emit(this.datepicker.timezone$.value);
                return;
            }
            // Check if the timezone is available in the timezones list; if not, get the default timezone
            if (this.datepicker.isTimezoneAvailable(timezone)) {
                this.datepicker.timezone$.next(timezone);
            }
            else {
                // This is probably an unintended state so emit a warning
                console.warn("ux-date-time-picker: specified timezone " + JSON.stringify(timezone) + " is not present in the timezones array.");
                // Fall back on the default timezone
                var defaultTimezone = this.datepicker.getDefaultTimezone();
                if (!this.datepicker.timezone$.value || !timezoneComparator(defaultTimezone, this.datepicker.timezone$.value)) {
                    this.datepicker.timezone$.next(defaultTimezone);
                    this.timezoneChange.emit(defaultTimezone);
                }
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showTime", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showTimezone", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showSeconds", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showMeridian", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showSpinners", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DateTimePickerComponent.prototype, "weekdays", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DateTimePickerComponent.prototype, "months", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DateTimePickerComponent.prototype, "monthsShort", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DateTimePickerComponent.prototype, "meridians", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], DateTimePickerComponent.prototype, "nowBtnText", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], DateTimePickerComponent.prototype, "showNowBtn", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], DateTimePickerComponent.prototype, "timezones", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], DateTimePickerComponent.prototype, "startOfWeek", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], DateTimePickerComponent.prototype, "nowBtnAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], DateTimePickerComponent.prototype, "dateChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], DateTimePickerComponent.prototype, "timezoneChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], DateTimePickerComponent.prototype, "date", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], DateTimePickerComponent.prototype, "timezone", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], DateTimePickerComponent.prototype, "min", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], DateTimePickerComponent.prototype, "max", null);
        DateTimePickerComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker',
                template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n        <!-- Display days in the current month -->\n        <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n        <!-- Display the months in the current year -->\n        <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n        <!-- Display a decade -->\n        <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view (timezoneChange)=\"_onTimezoneChange($event)\"\n                                 *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button type=\"button\"\n    *ngIf=\"datepicker.showNowBtn$ | async\"\n    uxFocusIndicator\n    class=\"now-button\"\n    [attr.aria-label]=\"nowBtnAriaLabel\"\n    [disabled]=\"_isTodayDisabled\"\n    (click)=\"setToNow()\">\n    {{ datepicker.nowBtnText$ | async }}\n</button>",
                providers: [DateTimePickerService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Optional()),
            __param(2, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                DateRangeService,
                DateRangeOptions])
        ], DateTimePickerComponent);
        return DateTimePickerComponent;
    }());
    var FocusIfDirective = /** @class */ (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** The delay that should ellapse before focussing the element */
            this.focusIfDelay = 0;
            /** Determine if we should scroll the element into view when focused */
            this.focusIfScroll = true;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            /** Focus when the boolean value is true */
            set: function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus({ preventScroll: !_this.focusIfScroll });
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        FocusIfDirective.prototype.ngOnDestroy = function () {
            if (this._timeout !== null) {
                clearTimeout(this._timeout);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], FocusIfDirective.prototype, "focusIfDelay", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FocusIfDirective.prototype, "focusIfScroll", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], FocusIfDirective.prototype, "focusIf", null);
        FocusIfDirective = __decorate([
            core.Directive({
                selector: '[focusIf]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], FocusIfDirective);
        return FocusIfDirective;
    }());
    var FocusIfModule = /** @class */ (function () {
        function FocusIfModule() {
        }
        FocusIfModule = __decorate([
            core.NgModule({
                exports: [FocusIfDirective],
                declarations: [FocusIfDirective]
            })
        ], FocusIfModule);
        return FocusIfModule;
    }());
    var SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = /** @class */ (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.maxLength = Infinity;
            this.valueChange = new core.EventEmitter();
            this.increment = new core.EventEmitter();
            this.decrement = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this._regexKeypress = RegExp(/^[0-9.,-]+$/);
            this._regexPaste = RegExp(/^\-?\d+(\.\d+)?$/);
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        SpinButtonComponent.prototype.scroll = function (event) {
            if (!this.scrolling) {
                return;
            }
            if (event.deltaY > 0) {
                this.triggerDecrement();
            }
            else {
                this.triggerIncrement();
            }
            event.preventDefault();
        };
        SpinButtonComponent.prototype.triggerIncrement = function () {
            if (!this.disabled) {
                this.increment.emit();
            }
        };
        SpinButtonComponent.prototype.triggerDecrement = function () {
            if (!this.disabled) {
                this.decrement.emit();
            }
        };
        SpinButtonComponent.prototype.writeValue = function (value) {
            this.value = value;
        };
        SpinButtonComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        SpinButtonComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        SpinButtonComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        SpinButtonComponent.prototype.onKeypress = function (event) {
            // we only need to perform checks if the type is number
            if (this.type !== 'number') {
                return;
            }
            if (!this._regexKeypress.test(event.key)) {
                return false;
            }
            return true;
        };
        SpinButtonComponent.prototype.onPaste = function (event) {
            // we only need to perform checks if the type is number
            if (this.type !== 'number') {
                return;
            }
            // get the value being pasted
            var value = event.clipboardData.getData('text');
            // check if it contains the character
            if (!this._regexPaste.test(value)) {
                // inset the numeric value only if there is one
                var numericValue = parseFloat(value);
                if (!isNaN(numericValue)) {
                    this.value = numericValue;
                }
                event.stopPropagation();
                event.preventDefault();
            }
        };
        SpinButtonComponent.prototype.onValueChange = function (input, value) {
            // ensure the value is not longer than the maxLength (verify value is a string in case it is
            // null or undefined, before trying to check the length.
            if (typeof value === 'string' && value.length > this.maxLength) {
                // if the type specified is a number then it may begin with a 0
                // e.g. "02", in which case if we add a second digit we should drop
                // the leading "0" and allow the non-zero number to be added
                if (this.type === 'number') {
                    value = parseFloat(value).toString();
                }
                // remove any characters over the max length
                value = value.substring(0, this.maxLength);
                // We must manually update the input value in this case rather than relying
                // on Angular, as if value was previously "11" and we add an additional digit
                // e.g. "112", after performing the substring, the outputted value would again
                // be "11" which Angular would not recognize as having changed so it will not
                // update the value displayed in the input.
                input.value = value;
            }
            // emit the value after all length checks
            this.valueChange.emit(value);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SpinButtonComponent.prototype, "value", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SpinButtonComponent.prototype, "type", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SpinButtonComponent.prototype, "min", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SpinButtonComponent.prototype, "max", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SpinButtonComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SpinButtonComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SpinButtonComponent.prototype, "spinners", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SpinButtonComponent.prototype, "readOnly", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SpinButtonComponent.prototype, "scrolling", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SpinButtonComponent.prototype, "arrowkeys", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SpinButtonComponent.prototype, "maxLength", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SpinButtonComponent.prototype, "incrementAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SpinButtonComponent.prototype, "inputAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SpinButtonComponent.prototype, "decrementAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SpinButtonComponent.prototype, "valueChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SpinButtonComponent.prototype, "increment", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SpinButtonComponent.prototype, "decrement", void 0);
        SpinButtonComponent = __decorate([
            core.Component({
                selector: 'ux-spin-button',
                template: "<button type=\"button\"\n        uxFocusIndicator\n        class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n    <ux-icon name=\"up\" class=\"spin-button-up-icon\"></ux-icon>\n</button>\n\n<input #input\n       type=\"text\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"onValueChange(input, $event)\"\n       (wheel)=\"scroll($event)\"\n       (keypress)=\"onKeypress($event)\"\n       (paste)=\"onPaste($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button type=\"button\"\n        uxFocusIndicator\n        class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n    <ux-icon name=\"down\" class=\"spin-button-down-icon\"></ux-icon>\n</button>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [SPIN_BUTTON_VALUE_ACCESSOR]
            })
        ], SpinButtonComponent);
        return SpinButtonComponent;
    }());
    var SpinButtonModule = /** @class */ (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    IconModule,
                ],
                exports: [SpinButtonComponent],
                declarations: [SpinButtonComponent]
            })
        ], SpinButtonModule);
        return SpinButtonModule;
    }());
    var TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = /** @class */ (function () {
        function TimePickerComponent() {
            /** Whether the arrow keys can be used to increment or decrement the selected time component. */
            this.arrowkeys = true;
            /** Whether the mouse scroll wheel can be used to increment or decrement the selected time component. */
            this.mousewheel = true;
            /** Whether the control is disabled. */
            this.disabled = false;
            /** Whether the control is readonly. */
            this.readOnly = false;
            /** Whether to show the meridian (AM/PM) selector. If this is false, the 24-hour clock will be used. */
            this.showMeridian = false;
            /** Whether to show the hour selector. */
            this.showHours = true;
            /** Whether to show the minute selector. */
            this.showMinutes = true;
            /** Whether to show the second selector. */
            this.showSeconds = false;
            /** Whether to show increment and decrement buttons in the time picker. */
            this.showSpinners = true;
            /** The number of hours to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel. */
            this.hourStep = 1;
            /** The number of minutes to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel. */
            this.minuteStep = 1;
            /** The number of seconds to increment or decrement by when using the spinner buttons, arrow keys, or mouse scroll wheel. */
            this.secondStep = 1;
            /** An array containing the labels to show in the meridian selector. */
            this.meridians = ['AM', 'PM'];
            /** Emitted when the `value` changes. */
            this.valueChange = new core.EventEmitter();
            /** Emitted when the validity of the control changes. */
            this.isValid = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this._value = new Date();
            this._isValid = true;
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: function () {
                return new Date(this._value);
            },
            /** The value to display. */
            set: function (value) {
                this._value = new Date(value);
                this.valueChange.emit(this._value);
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimePickerComponent.prototype, "_meridian", {
            get: function () {
                return this._value.getHours() < 12 ? this.meridians[0] : this.meridians[1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimePickerComponent.prototype, "_valid", {
            get: function () {
                return this.checkValidity(this._value);
            },
            enumerable: true,
            configurable: true
        });
        TimePickerComponent.prototype.writeValue = function (value) {
            this.value = value;
        };
        TimePickerComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        TimePickerComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        TimePickerComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        TimePickerComponent.prototype.getMeridianTime = function (hour) {
            return hour > 12 ? hour - 12 : hour;
        };
        TimePickerComponent.prototype.setHour = function (hour) {
            var date = this.value;
            date.setHours(hour ? hour : 0);
            this.value = date;
        };
        TimePickerComponent.prototype.setMinute = function (minute) {
            var date = this.value;
            date.setMinutes(minute ? minute : 0);
            this.value = date;
        };
        TimePickerComponent.prototype.setSeconds = function (seconds) {
            var date = this.value;
            date.setSeconds(seconds ? seconds : 0);
            this.value = date;
        };
        TimePickerComponent.prototype.incrementHour = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setHour(this.value.getHours() + this.hourStep);
        };
        TimePickerComponent.prototype.decrementHour = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setHour(this.value.getHours() - this.hourStep);
        };
        TimePickerComponent.prototype.incrementMinute = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setMinute(this.value.getMinutes() + this.minuteStep);
        };
        TimePickerComponent.prototype.decrementMinute = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setMinute(this.value.getMinutes() - this.minuteStep);
        };
        TimePickerComponent.prototype.incrementSecond = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setSeconds(this.value.getSeconds() + this.secondStep);
        };
        TimePickerComponent.prototype.decrementSecond = function (arrowkey) {
            if (arrowkey === void 0) {
                arrowkey = false;
            }
            if (this.disabled || arrowkey && !this.arrowkeys) {
                return;
            }
            this.setSeconds(this.value.getSeconds() - this.secondStep);
        };
        TimePickerComponent.prototype.selectMeridian = function (meridian) {
            // get the current time
            var hour = this.value.getHours();
            // if we have selected AM
            if (meridian === this.meridians[0]) {
                if (hour >= 12) {
                    this.setHour(hour - 12);
                }
            }
            // if we have selected PM
            if (meridian === this.meridians[1]) {
                if (hour < 12) {
                    this.setHour(hour + 12);
                }
            }
        };
        TimePickerComponent.prototype.checkValidity = function (date) {
            var valid = true;
            // Fix min and max date components in order to compare time only
            var min = this.normalizeDate(this.min, date);
            var max = this.normalizeDate(this.max, date);
            if ((min && date.getTime() < min.getTime()) || (max && date.getTime() > max.getTime())) {
                valid = false;
            }
            // if the valid state has changed then emit the isValid output
            if (valid !== this._isValid) {
                this._isValid = valid;
                this.isValid.emit(valid);
            }
            return valid;
        };
        TimePickerComponent.prototype.hourChange = function (value) {
            // if the value is empty then emit nothing
            if (value && value.trim() === '') {
                return;
            }
            // convert the string to a number
            var hour = parseInt(value);
            // ensure the hours is valid
            if (!isNaN(hour)) {
                if (hour < 0) {
                    hour = 0;
                }
                if (hour > (this.showMeridian ? 12 : 23)) {
                    hour = this.showMeridian ? 12 : 23;
                }
            }
            var currentHour = this.value.getHours();
            // if the value hasn't changed, do nothing
            if (hour === currentHour) {
                return;
            }
            hour = isNaN(hour) ? currentHour : hour;
            if (this.showMeridian) {
                // if the number is invalid then restore it to the previous value
                if (this._meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        hour -= 12;
                    }
                }
                // if we have selected PM
                if (this._meridian === this.meridians[1]) {
                    if (hour < 12) {
                        hour += 12;
                    }
                }
            }
            this.setHour(hour);
        };
        TimePickerComponent.prototype.minuteChange = function (value) {
            // convert the string to a number
            var minute = parseInt(value);
            var currentMinute = this.value.getMinutes();
            // if the value hasn't changed, do nothing
            if (minute === currentMinute) {
                return;
            }
            // ensure the hours is valid
            if (!isNaN(minute)) {
                if (minute < 0) {
                    minute = 59;
                }
                if (minute > 59) {
                    minute = 0;
                }
            }
            // if the number is invalid then restore it to the previous value
            this.setMinute(isNaN(minute) ? currentMinute : minute);
        };
        TimePickerComponent.prototype.secondChange = function (value) {
            // convert the string to a number
            var second = parseInt(value);
            var currentSecond = this.value.getSeconds();
            // if the value hasn't changed, do nothing
            if (second === currentSecond) {
                return;
            }
            // ensure the hours is valid
            if (!isNaN(second)) {
                if (second < 0) {
                    second = 0;
                }
                if (second > 59) {
                    second = 59;
                }
            }
            // if the number is invalid then restore it to the previous value
            this.setSeconds(isNaN(second) ? currentSecond : second);
        };
        /** Normalise a date's year/month/date components. */
        TimePickerComponent.prototype.normalizeDate = function (date, reference) {
            if (!date) {
                return null;
            }
            var normalized = new Date(date);
            normalized.setFullYear(reference.getFullYear());
            normalized.setMonth(reference.getMonth());
            normalized.setDate(reference.getDate());
            return normalized;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "arrowkeys", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "mousewheel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "readOnly", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "showMeridian", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "showHours", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "showMinutes", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "showSeconds", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TimePickerComponent.prototype, "showSpinners", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TimePickerComponent.prototype, "hourStep", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TimePickerComponent.prototype, "minuteStep", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TimePickerComponent.prototype, "secondStep", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date)
        ], TimePickerComponent.prototype, "min", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date)
        ], TimePickerComponent.prototype, "max", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TimePickerComponent.prototype, "meridians", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Date),
            __metadata("design:paramtypes", [Date])
        ], TimePickerComponent.prototype, "value", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TimePickerComponent.prototype, "valueChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TimePickerComponent.prototype, "isValid", void 0);
        TimePickerComponent = __decorate([
            core.Component({
                selector: 'ux-time-picker',
                template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"value | date: showMeridian ? 'h' : 'HH'\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"value | date: 'mm'\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!_valid\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"SS\"\n            [maxLength]=\"2\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"value | date: 'ss'\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button type=\"button\"\n                class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === _meridian\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === _meridian\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [TIME_PICKER_VALUE_ACCESSOR],
                host: {
                    'aria-label': 'Time Picker'
                }
            })
        ], TimePickerComponent);
        return TimePickerComponent;
    }());
    var TimePickerModule = /** @class */ (function () {
        function TimePickerModule() {
        }
        TimePickerModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    SpinButtonModule
                ],
                exports: [TimePickerComponent],
                declarations: [TimePickerComponent],
            })
        ], TimePickerModule);
        return TimePickerModule;
    }());
    var DayViewService = /** @class */ (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._subscription = rxjs.combineLatest(_datepicker.month$, _datepicker.year$, _datepicker.startOfWeek$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        DayViewService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        DayViewService.prototype.setFocus = function (day, month, year) {
            this.focused$.next({ day: day, month: month, year: year });
            // update the date picker to show the required month and year
            this._datepicker.setViewportMonth(month);
            this._datepicker.setViewportYear(year);
        };
        DayViewService.prototype.createDayGrid = function (month, year) {
            var _this = this;
            // update the header
            this._datepicker.setHeader(this._datepicker.months[month] + ' ' + year);
            // find the lower and upper boundaries
            var start = new Date(year, month, 1);
            var end = new Date(year, month + 1, 0);
            // ensure the startOfWeek value is between 0-6 to prevent any infinite loop
            var startOfWeek = Math.min(common.WeekDay.Saturday, Math.max(common.WeekDay.Sunday, this._datepicker.startOfWeek$.value));
            // we always want to show from the specified start of week - this may include showing some dates from the previous month
            while (start.getDay() !== startOfWeek) {
                start.setDate(start.getDate() - 1);
            }
            // we also want to make sure that the range ends on a saturday
            end.setDate(end.getDate() + (6 - end.getDay()));
            // create an array of all the days to display
            var dates = dateRange(start, end).map(function (date) {
                return ({
                    day: date.getDate(),
                    month: date.getMonth(),
                    year: date.getFullYear(),
                    date: date,
                    isToday: _this.isToday(date),
                    isActive: _this.isActive(date),
                    isCurrentMonth: date.getMonth() === month
                });
            });
            // turn the dates into a grid
            var items = gridify(dates, 7);
            this.grid$.next(items);
            // if no item has yet been focused then focus the first day of the month
            if ((this._datepicker.modeDirection === exports.ModeDirection.None || this._datepicker.modeDirection === exports.ModeDirection.Descend) && this.focused$.value === null) {
                // check if the selected item is visible
                var selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                if (selectedDay) {
                    this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                }
                else {
                    // find the first day of the month
                    var first = dates.find(function (date) { return date.day === 1; });
                    // focus the date
                    this.setFocus(first.day, first.month, first.year);
                }
            }
        };
        /**
       * Determine whether or not a specific date is today
       * @param date The date to check
       */
        DayViewService.prototype.isToday = function (date) {
            return compareDays(new Date(), date);
        };
        /**
         * Determines whether or not a specific date is the selected one
         * @param date the date to check
         */
        DayViewService.prototype.isActive = function (date) {
            return this._datepicker.selected$.value ? compareDays(this._datepicker.selected$.value, date) : false;
        };
        DayViewService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [DateTimePickerService])
        ], DayViewService);
        return DayViewService;
    }());
    var DayViewComponent = /** @class */ (function () {
        function DayViewComponent(datePicker, dayService, _changeDetector, _focusOrigin, _liveAnnouncer, _rangeService, _rangeOptions) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._changeDetector = _changeDetector;
            this._focusOrigin = _focusOrigin;
            this._liveAnnouncer = _liveAnnouncer;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            datePicker.headerEvent$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return event === exports.DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
            // if we are a range picker then we also want to subscribe to range changes
            if (_rangeService) {
                rxjs.merge(_rangeService.onRangeChange, _rangeService.onHoverChange).pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _changeDetector.detectChanges(); });
                // subscribe to changes to the start date
                _rangeService.onStartChange
                    .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (date) { return !!date && _this._isRangeEnd && _this.datePicker.initialised; }), operators.delay(0))
                    .subscribe(function (date) { return _this.onRangeChange(date); });
                // subscribe to changes to the end date
                _rangeService.onEndChange
                    .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (date) { return !!date && _this._isRangeStart && _this.datePicker.initialised; }), operators.delay(0))
                    .subscribe(function (date) { return _this.onRangeChange(date); });
                // when the range is cleared reset the selected date so we can click on the same date again if we want to
                _rangeService.onClear.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.datePicker.selected$.next(null); });
            }
        }
        Object.defineProperty(DayViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_rangeStart", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DayViewComponent.prototype, "_rangeEnd", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        DayViewComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // update when there are changes to the min/max values
            rxjs.merge(this.datePicker.min$, this.datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._changeDetector.detectChanges(); });
            // if we open and the range start is already selected, ensure that we move the end picker to a month with options
            if (!this.datePicker.initialised && this._rangeStart && !this._rangeEnd && this._isRangeEnd) {
                this.onRangeChange(this._rangeStart);
            }
            // if we open and the range end is already selected, ensure that we move the start picker to a month with options
            if (!this.datePicker.initialised && this._rangeEnd && !this._rangeStart && this._isRangeStart) {
                this.onRangeChange(this._rangeEnd);
            }
        };
        DayViewComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Navigate to the previous page of dates
         */
        DayViewComponent.prototype.previous = function () {
            this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
        };
        /**
         * Navigate to the next page of dates
         */
        DayViewComponent.prototype.next = function () {
            this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
        };
        /**
         * Select a particular date
         * @param date the date to select
         */
        DayViewComponent.prototype.select = function (date) {
            // if we are range picking, and have no dates selected clear the range (if we select the current day initially it won't get selected)
            if (this._isRangeMode && !this._rangeStart && !this._rangeEnd) {
                this._rangeService.clear();
            }
            // if we are the start range picker and we click the already selected day deselect it
            if (this._isRangeMode && this._isRangeStart && this._rangeStart && compareDays(this._rangeStart, date)) {
                this._rangeService.setStartDate(null);
                this.datePicker.selected$.next(null);
                return;
            }
            // if we are the end range picker and we click the already selected day deselect it
            if (this._isRangeMode && this._isRangeEnd && this._rangeEnd && compareDays(this._rangeEnd, date)) {
                this._rangeService.setEndDate(null);
                this.datePicker.selected$.next(null);
                return;
            }
            // if we are in range mode ensure we include the time from the time picker
            if (this._isRangeMode) {
                // update the current date object
                if (this._isRangeStart && !this._rangeService.showTime) {
                    this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 0, 0, 0);
                }
                else if (this._isRangeEnd && !this._rangeService.showTime) {
                    this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), 23, 59, 59);
                }
                else {
                    this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear(), this.datePicker.hours, this.datePicker.minutes, this.datePicker.seconds);
                }
            }
            else {
                // update the current date object
                this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
            }
            // focus the newly selected date
            this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
            // if we select a start date that is after the end date then clear the end date
            if (this._isRangeMode && this._isRangeStart && this._rangeStart && this._rangeEnd) {
                if (this._rangeStart.getTime() > this._rangeEnd.getTime()) {
                    this._rangeService.setEndDate(null);
                }
            }
            // if we select a end date that is before the start date then clear the start date
            if (this._isRangeMode && this._isRangeEnd && this._rangeStart && this._rangeEnd) {
                if (this._rangeEnd.getTime() < this._rangeStart.getTime()) {
                    this._rangeService.setStartDate(null);
                }
            }
        };
        DayViewComponent.prototype.trackWeekByFn = function (index) {
            return index;
        };
        DayViewComponent.prototype.trackDayByFn = function (_index, item) {
            return item.day + " " + item.month + " " + item.year;
        };
        DayViewComponent.prototype.focusDate = function (item, dayOffset) {
            // determine the date of the day
            var target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
            // we should force the origin to be keyboard
            this._focusOrigin.setOrigin('keyboard');
            // identify which date should be focused
            this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
        };
        DayViewComponent.prototype.getTabbable = function (item) {
            var e_1, _a, e_2, _b;
            var focused = this.dayService.focused$.value;
            var grid = this.dayService.grid$.value;
            var month = this.datePicker.month$.value;
            // if there is a focused month check if this is it
            if (focused) {
                // check if the focused day is visible
                var isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year && _item.month === month; }); });
                if (isFocusedDayVisible) {
                    return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                }
            }
            // if there is no focusable day then check if there is a selected day
            var isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
            if (isSelectedDayVisible) {
                return item.isActive;
            }
            try {
                // find the first non disabled day that is part of the current month
                for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                    var row = grid_1_1.value;
                    try {
                        for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                            var column = row_1_1.value;
                            if (column === item && column.month === month && !this.getDisabled(column.date)) {
                                return true;
                            }
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                _b.call(row_1);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (grid_1_1 && !grid_1_1.done && (_a = grid_1.return))
                        _a.call(grid_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            return false;
        };
        DayViewComponent.prototype.getDisabled = function (date) {
            // if we are not in range mode then it will always be enabled
            if (this._isRangeMode) {
                // if we are range start and dates are after the range end then they should also be disabled
                if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, this._rangeEnd)) {
                    return true;
                }
                // if we are range end and dates are before the range start then they should also be disabled
                if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, this._rangeStart)) {
                    return true;
                }
            }
            if (this.datePicker.min$.value && isDateBefore(date, this.datePicker.min$.value)) {
                return true;
            }
            if (this.datePicker.max$.value && isDateAfter(date, this.datePicker.max$.value)) {
                return true;
            }
            return false;
        };
        DayViewComponent.prototype.isRangeStartDate = function (date) {
            return this._isRangeMode && this._rangeStart && compareDays(date, this._rangeStart);
        };
        DayViewComponent.prototype.isRangeEndDate = function (date) {
            return this._isRangeMode && this._rangeEnd && compareDays(date, this._rangeEnd);
        };
        DayViewComponent.prototype.isWithinRange = function (date) {
            return this._isRangeMode && this._rangeStart && isDateAfter(date, this._rangeStart) && isDateBefore(date, this._rangeEnd);
        };
        DayViewComponent.prototype.isDateHovered = function (date) {
            // if we are not in range mode or both start and end dates are selected then dont show range hover
            if (!this._isRangeMode || !this._rangeService.hover || this._rangeStart && this._rangeEnd) {
                return;
            }
            return this._rangeStart && isDateAfter(date, this._rangeStart) && isDateBefore(date, this._rangeService.hover, true) ||
                this._rangeEnd && isDateBefore(date, this._rangeEnd) && isDateAfter(date, this._rangeService.hover, true);
        };
        DayViewComponent.prototype.isItemActive = function (date, isActive) {
            if (!this._isRangeMode) {
                return isActive;
            }
            return this._isRangeStart && this._rangeStart && compareDays(this._rangeStart, date) ||
                this._isRangeEnd && this._rangeEnd && compareDays(this._rangeEnd, date);
        };
        DayViewComponent.prototype.onRangeMouseEnter = function (date) {
            if (this._isRangeMode) {
                this._rangeService.setDateMouseEnter(date);
            }
        };
        DayViewComponent.prototype.onRangeMouseLeave = function (date) {
            if (this._isRangeMode) {
                this._rangeService.setDateMouseLeave(date);
            }
        };
        /** Announce the date when we focus on a date */
        DayViewComponent.prototype.announceRangeMode = function () {
            if (this._isRangeMode) {
                this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
            }
        };
        /** Determine if we should focus a date */
        DayViewComponent.prototype.shouldFocus = function (item) {
            // if we are opening the popover initially we never want to focus a date in the range end picker
            if (!this.datePicker.initialised && this._isRangeEnd || this._rangeService && this._rangeService.isChangingTime) {
                return false;
            }
            // extract the current focused dates
            var _a = this.dayService.focused$.value, day = _a.day, month = _a.month, year = _a.year;
            // check if the current date is the focused date and it is in the viewport date
            return day === item.day && month === item.month && year === item.year && item.isCurrentMonth;
        };
        /** Update the viewport when the range changes to ensure focus is present on a valid item */
        DayViewComponent.prototype.onRangeChange = function (date) {
            if (!(this._isRangeStart && !this._rangeStart || this._isRangeEnd && !this._rangeEnd)) {
                return;
            }
            // get the month showing on the other date range picker
            var currentDate = new Date(this.datePicker.year$.value, this.datePicker.month$.value);
            // if we are the start date and we are after the end date - ONLY then should be change the visible month the match the end date
            var startShouldUpdate = this._isRangeStart && !this._rangeStart && (currentDate.getFullYear() > date.getFullYear() || currentDate.getFullYear() === date.getFullYear() && currentDate.getMonth() > date.getMonth());
            // if we are the end date and we are before the start date - ONLY then should be change the visible month the match the start date
            var endShouldUpdate = this._isRangeEnd && !this._rangeEnd && (currentDate.getFullYear() < date.getFullYear() || currentDate.getFullYear() === date.getFullYear() && currentDate.getMonth() < date.getMonth());
            if (startShouldUpdate || endShouldUpdate) {
                this.datePicker.setViewportMonth(date.getMonth());
                this.datePicker.setViewportYear(date.getFullYear());
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
                this._changeDetector.detectChanges();
            }
        };
        DayViewComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker-day-view',
                template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async | weekDaySort: (datePicker.startOfWeek$ | async)\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button type=\"button\"\n                        uxFocusIndicator\n                        uxFocusIndicatorOrigin\n                        class=\"date-button\"\n                        [class.range-start]=\"isRangeStartDate(item.date)\"\n                        [class.range-between]=\"isWithinRange(item.date) || isDateHovered(item.date)\"\n                        [class.range-end]=\"isRangeEndDate(item.date)\"\n                        [focusIf]=\"shouldFocus(item)\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"isItemActive(item.date, item.isActive)\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"isItemActive(item.date, item.isActive) && !getDisabled(item.date)\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        [disabled]=\"getDisabled(item.date)\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (mouseenter)=\"onRangeMouseEnter(item.date)\"\n                        (mouseleave)=\"onRangeMouseLeave(item.date)\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\"\n                        (focus)=\"announceRangeMode()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                providers: [DayViewService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(5, core.Optional()),
            __param(6, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                DayViewService,
                core.ChangeDetectorRef,
                FocusIndicatorOriginService,
                a11y.LiveAnnouncer,
                DateRangeService,
                DateRangeOptions])
        ], DayViewComponent);
        return DayViewComponent;
    }());
    var HeaderComponent = /** @class */ (function () {
        function HeaderComponent(datepicker, _changeDetector, _rangeService, _rangeOptions) {
            this.datepicker = datepicker;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== exports.DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case exports.DatePickerMode.Day:
                        return 'Day';
                    case exports.DatePickerMode.Month:
                        return 'Month';
                    case exports.DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case exports.DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case exports.DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case exports.DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case exports.DatePickerMode.Day:
                        return 'Previous month';
                    case exports.DatePickerMode.Month:
                        return 'Previous year';
                    case exports.DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case exports.DatePickerMode.Day:
                        return 'Next month';
                    case exports.DatePickerMode.Month:
                        return 'Next year';
                    case exports.DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
            /** Unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
            if (this._rangeService) {
                // delay required to allow all ui to update elsewhere
                this._rangeService.onRangeChange.pipe(operators.delay(100), operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _changeDetector.detectChanges(); });
            }
        }
        Object.defineProperty(HeaderComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_rangeStart", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderComponent.prototype, "_rangeEnd", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        HeaderComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // update on min/max changes
            rxjs.merge(this.datepicker.min$, this.datepicker.max$).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._changeDetector.detectChanges(); });
        };
        HeaderComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Navigate to the previous day, month or year */
        HeaderComponent.prototype.previous = function () {
            this.datepicker.goToPrevious();
        };
        /** Navigate to the larger scale, eg. Days -> Months, Months -> Years */
        HeaderComponent.prototype.ascend = function () {
            this.datepicker.goToParentMode();
        };
        /** Navigate to the previous day, month or year */
        HeaderComponent.prototype.next = function () {
            this.datepicker.goToNext();
        };
        /** Determine if the previous button is enabled */
        HeaderComponent.prototype.isPreviousDisabled = function () {
            var min = this.datepicker.min$.value;
            if (min && this._isBeforeView(min)) {
                return true;
            }
            // if we are not in range mode or there are no disabled items then we can navigate back
            if (!this._isRangeMode || this._rangeStart && this._rangeEnd ||
                !this._rangeStart && !this._rangeEnd || this._isRangeStart
                || this._isRangeEnd && this._rangeEnd) {
                return false;
            }
            if (this._isBeforeView(this._rangeStart)) {
                return true;
            }
            return false;
        };
        /** Determine if the previous button is enabled */
        HeaderComponent.prototype.isNextDisabled = function () {
            var max = this.datepicker.max$.value;
            if (max && this._isAfterView(max)) {
                return true;
            }
            // if we are not in range mode or there are no disabled items then we can navigate back
            if (!this._isRangeMode || this._rangeStart && this._rangeEnd ||
                !this._rangeStart && !this._rangeEnd || this._isRangeStart && this._rangeStart
                || this._isRangeEnd) {
                return false;
            }
            if (this._isAfterView(this._rangeEnd)) {
                return true;
            }
            return false;
        };
        HeaderComponent.prototype._isBeforeView = function (date) {
            var month = this.datepicker.month$.value;
            var year = this.datepicker.year$.value;
            var mode = this.datepicker.mode$.value;
            var yearRange = this.datepicker.yearRange;
            if (mode === exports.DatePickerMode.Day) {
                return year <= date.getFullYear() && month <= date.getMonth();
            }
            if (mode === exports.DatePickerMode.Month) {
                return year <= date.getFullYear();
            }
            if (mode === exports.DatePickerMode.Year) {
                return yearRange.start <= date.getFullYear();
            }
        };
        HeaderComponent.prototype._isAfterView = function (date) {
            var month = this.datepicker.month$.value;
            var year = this.datepicker.year$.value;
            var mode = this.datepicker.mode$.value;
            var yearRange = this.datepicker.yearRange;
            if (mode === exports.DatePickerMode.Day) {
                return year >= date.getFullYear() && month >= date.getMonth();
            }
            if (mode === exports.DatePickerMode.Month) {
                return year >= date.getFullYear();
            }
            if (mode === exports.DatePickerMode.Year) {
                return yearRange.end >= date.getFullYear();
            }
        };
        HeaderComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker-header',
                template: "<header class=\"header\">\n\n  <button type=\"button\"\n          uxFocusIndicator\n          [disabled]=\"isPreviousDisabled()\"\n          class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <ux-icon name=\"previous\" class=\"header-navigation-previous-icon\"></ux-icon>\n  </button>\n\n  <button type=\"button\"\n          uxFocusIndicator\n          class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button type=\"button\"\n          uxFocusIndicator\n          [disabled]=\"isNextDisabled()\"\n          class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <ux-icon name=\"next\" class=\"header-navigation-next-icon\"></ux-icon>\n  </button>\n</header>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                core.ChangeDetectorRef,
                DateRangeService,
                DateRangeOptions])
        ], HeaderComponent);
        return HeaderComponent;
    }());
    var MonthViewService = /** @class */ (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        MonthViewService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        MonthViewService.prototype.setFocus = function (month, year) {
            this.focused$.next({ month: month, year: year });
            // update the viewport to ensure focused month is visible
            this._datepicker.setViewportYear(year);
        };
        MonthViewService.prototype.createMonthGrid = function (year) {
            var _this = this;
            // update the header
            this._datepicker.setHeader(year.toString());
            // get the current year and month
            var currentMonth = new Date().getMonth();
            var currentYear = new Date().getFullYear();
            // get the currently selected month
            var activeMonth = this._datepicker.selected$.value ? this._datepicker.selected$.value.getMonth() : null;
            var activeYear = this._datepicker.selected$.value ? this._datepicker.selected$.value.getFullYear() : null;
            // create a 4x3 grid of month numbers
            var months = range(0, 11).map(function (month) {
                return {
                    name: _this._datepicker.monthsShort[month],
                    month: month,
                    year: year,
                    isCurrentMonth: year === currentYear && month === currentMonth,
                    isActiveMonth: year === activeYear && month === activeMonth
                };
            });
            // map these to the appropriate format
            var items = gridify(months, 4);
            // update the grid
            this.grid$.next(items);
            // if there is no focused month select the first one
            if (this._datepicker.modeDirection === exports.ModeDirection.Descend && this.focused$.value === null) {
                // check if the selected month is in view
                var selectedMonth = months.find(function (month) { return month.isActiveMonth; });
                this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
            }
        };
        MonthViewService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [DateTimePickerService])
        ], MonthViewService);
        return MonthViewService;
    }());
    var MonthViewComponent = /** @class */ (function () {
        function MonthViewComponent(_datePicker, monthService, _liveAnnouncer, _changeDetector, _rangeService, _rangeOptions) {
            var e_1, _a, e_2, _b;
            var _this = this;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            _datePicker.headerEvent$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return event === exports.DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
            if (this._rangeService) {
                this._rangeService.onRangeChange.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _changeDetector.detectChanges(); });
            }
            // if the currently focused item is disabled then choose a month that isn't disabled
            if (this.monthService.focused$.value) {
                if (this.getDisabled(this.monthService.focused$.value)) {
                    try {
                        for (var _c = __values(this.monthService.grid$.value), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var row = _d.value;
                            try {
                                for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                    var column = row_1_1.value;
                                    if (!this.getDisabled(column)) {
                                        this.monthService.setFocus(column.month, column.year);
                                        return;
                                    }
                                }
                            }
                            catch (e_2_1) {
                                e_2 = { error: e_2_1 };
                            }
                            finally {
                                try {
                                    if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                        _b.call(row_1);
                                }
                                finally {
                                    if (e_2)
                                        throw e_2.error;
                                }
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return))
                                _a.call(_c);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                }
            }
        }
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_rangeStart", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_rangeEnd", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_minMonth", {
            get: function () {
                return this._datePicker.min$.value ? new Date(this._datePicker.min$.value.getFullYear(), this._datePicker.min$.value.getMonth()) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MonthViewComponent.prototype, "_maxMonth", {
            get: function () {
                return this._datePicker.max$.value ? new Date(this._datePicker.max$.value.getFullYear(), this._datePicker.max$.value.getMonth()) : null;
            },
            enumerable: true,
            configurable: true
        });
        MonthViewComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // update on min/max changes
            rxjs.merge(this._datePicker.min$, this._datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._changeDetector.detectChanges(); });
        };
        MonthViewComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Get the disabled state of a month */
        MonthViewComponent.prototype.getDisabled = function (item) {
            var date = new Date(item.year, item.month);
            // if we are not in range mode then it will always be enabled
            if (this._isRangeMode) {
                // if we are range start and dates are after the range end then they should also be disabled
                if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, new Date(this._rangeEnd.getFullYear(), this._rangeEnd.getMonth()))) {
                    return true;
                }
                // if we are range end and dates are before the range start then they should also be disabled
                if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, new Date(this._rangeStart.getFullYear(), this._rangeStart.getMonth()))) {
                    return true;
                }
            }
            if (this._minMonth && isDateBefore(date, this._minMonth)) {
                return true;
            }
            if (this._maxMonth && isDateAfter(date, this._maxMonth)) {
                return true;
            }
            return false;
        };
        /**
         * Go to the previous year
         */
        MonthViewComponent.prototype.previous = function () {
            this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
        };
        /**
         * Go to the next year
         */
        MonthViewComponent.prototype.next = function () {
            this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
        };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        MonthViewComponent.prototype.select = function (month) {
            this._datePicker.setViewportMonth(month);
            // show the day picker
            this._datePicker.goToChildMode();
        };
        MonthViewComponent.prototype.focusMonth = function (item, monthOffset) {
            var targetMonth = item.month + monthOffset;
            var targetYear = item.year;
            if (targetMonth < 0) {
                targetMonth += 12;
                targetYear -= 1;
            }
            if (targetMonth >= 12) {
                targetMonth -= 12;
                targetYear += 1;
            }
            this.monthService.setFocus(targetMonth, targetYear);
        };
        MonthViewComponent.prototype.trackRowByFn = function (index) {
            return index;
        };
        MonthViewComponent.prototype.trackMonthByFn = function (_index, item) {
            return item.month + " " + item.year;
        };
        MonthViewComponent.prototype.getTabbable = function (item) {
            var e_3, _a, e_4, _b;
            var focused = this.monthService.focused$.value;
            var grid = this.monthService.grid$.value;
            // if there is a focused month check if this is it
            if (focused) {
                // check if the focused month is visible
                var isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                if (isFocusedMonthVisible) {
                    return focused.month === item.month && focused.year === item.year;
                }
            }
            // if there is no focusable month then check if there is a selected month
            var isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
            if (isSelectedMonthVisible) {
                return item.isActiveMonth;
            }
            try {
                // otherwise find the first non-disabled month
                for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                    var row = grid_1_1.value;
                    try {
                        for (var row_2 = (e_4 = void 0, __values(row)), row_2_1 = row_2.next(); !row_2_1.done; row_2_1 = row_2.next()) {
                            var column = row_2_1.value;
                            if (!this.getDisabled(column)) {
                                return item === column;
                            }
                        }
                    }
                    catch (e_4_1) {
                        e_4 = { error: e_4_1 };
                    }
                    finally {
                        try {
                            if (row_2_1 && !row_2_1.done && (_b = row_2.return))
                                _b.call(row_2);
                        }
                        finally {
                            if (e_4)
                                throw e_4.error;
                        }
                    }
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (grid_1_1 && !grid_1_1.done && (_a = grid_1.return))
                        _a.call(grid_1);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            return false;
        };
        /** Announce the date when we focus on a date */
        MonthViewComponent.prototype.announceRangeMode = function () {
            if (this._isRangeMode) {
                this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
            }
        };
        MonthViewComponent.prototype.shouldFocus = function (item) {
            var focused = this.monthService.focused$.value;
            if (focused) {
                return focused.month === item.month && focused.year === item.year;
            }
        };
        MonthViewComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker-month-view',
                template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button type=\"button\"\n         uxFocusIndicator\n         uxFocusIndicatorOrigin\n         [programmaticFocusIndicator]=\"true\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"shouldFocus(item)\"\n         [disabled]=\"getDisabled(item)\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth && !getDisabled(item)\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (focus)=\"announceRangeMode()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                providers: [MonthViewService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(4, core.Optional()),
            __param(5, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                MonthViewService,
                a11y.LiveAnnouncer,
                core.ChangeDetectorRef,
                DateRangeService,
                DateRangeOptions])
        ], MonthViewComponent);
        return MonthViewComponent;
    }());
    var WeekDaySortPipe = /** @class */ (function () {
        function WeekDaySortPipe() {
        }
        WeekDaySortPipe.prototype.transform = function (value, startOfWeek) {
            // ensure start of week is in range
            startOfWeek = Math.max(common.WeekDay.Sunday, Math.min(common.WeekDay.Saturday, startOfWeek));
            // create a new array to avoid altering the original
            var weekdays = __spread(value);
            for (var idx = 0; idx < startOfWeek; idx++) {
                weekdays.push(weekdays.shift());
            }
            return weekdays;
        };
        WeekDaySortPipe = __decorate([
            core.Pipe({
                name: 'weekDaySort'
            })
        ], WeekDaySortPipe);
        return WeekDaySortPipe;
    }());
    var TimeViewComponent = /** @class */ (function () {
        function TimeViewComponent(datepicker, _changeDetector, _rangeService, _rangeOptions) {
            var _this = this;
            this.datepicker = datepicker;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            /** Earliest time permitted on the time picker. */
            this.min = null;
            /** Latest time permitted on the time picker. */
            this.max = null;
            /** Emit when the timezone changes. */
            this.timezoneChange = new core.EventEmitter();
            this._onDestroy = new rxjs.Subject();
            // when the date changes we should update the value
            datepicker.date$.pipe(operators.filter(function (date) { return date && _this.value instanceof Date; }), operators.takeUntil(this._onDestroy)).subscribe(function (date) {
                _this.value = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
                _changeDetector.detectChanges();
            });
            if (!this._isRangeMode) {
                datepicker.selected$.pipe(operators.filter(function (date) { return !!date; }), operators.takeUntil(this._onDestroy))
                    .subscribe(function (date) { return _this.value = new Date(date); });
            }
            if (this._isRangeMode && this._isRangeStart) {
                this.value = new Date();
                if (!this._rangeStart) {
                    this.value.setHours(0, 0, 0, 0);
                }
                else {
                    this.value.setHours(this._rangeStart.getHours(), this._rangeStart.getMinutes(), this._rangeStart.getSeconds());
                }
            }
            if (this._isRangeMode && this._isRangeEnd) {
                this.value = new Date();
                if (!this._rangeEnd) {
                    this.value.setHours(23, 59, 59, 0);
                }
                else {
                    this.value.setHours(this._rangeEnd.getHours(), this._rangeEnd.getMinutes(), this._rangeEnd.getSeconds());
                }
            }
        }
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_rangeStart", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeViewComponent.prototype, "_rangeEnd", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        TimeViewComponent.prototype.ngOnInit = function () {
            var _this = this;
            // min should only apply if it's on the same day as the selected date
            rxjs.combineLatest(this.datepicker.min$, this.datepicker.date$).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                var _b = __read(_a, 2), min = _b[0], date = _b[1];
                _this.min = (min && date && compareDays(date, min)) ? min : null;
                _this._changeDetector.detectChanges();
            });
            // max should only apply if it's on the same day as the selected date
            rxjs.combineLatest(this.datepicker.max$, this.datepicker.date$).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                var _b = __read(_a, 2), max = _b[0], date = _b[1];
                _this.max = (max && date && compareDays(date, max)) ? max : null;
                _this._changeDetector.detectChanges();
            });
        };
        TimeViewComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        TimeViewComponent.prototype.onTimeChange = function (time) {
            if (this._isRangeMode) {
                this.datepicker.hours = time.getHours();
                this.datepicker.minutes = time.getMinutes();
                this.datepicker.seconds = time.getSeconds();
                // update the time in the range picker service
                if (this._isRangeStart) {
                    this._rangeService.startTime = { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() };
                }
                else {
                    this._rangeService.endTime = { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() };
                }
                // if a date is currently selected we should update it
                if (this._isRangeStart && this._rangeStart) {
                    var start = new Date(this._rangeStart);
                    start.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                    this._rangeService.setStartDate(start);
                }
                if (this._isRangeEnd && this._rangeEnd) {
                    var end = new Date(this._rangeEnd);
                    end.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                    this._rangeService.setEndDate(end);
                }
                return;
            }
            // if the selected time is null then do nothing
            if (!this.datepicker.selected$.value) {
                return;
            }
            // otherwise set the time
            var date = new Date(this.datepicker.selected$.value);
            // update the time
            date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
            // emit the time
            this.datepicker.selected$.next(date);
        };
        TimeViewComponent.prototype.selectTimezone = function (name) {
            var timezones = this.datepicker.timezones$.value;
            // find matching timezone
            var timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
            if (timezone) {
                this.timezoneChange.emit(timezone);
            }
        };
        TimeViewComponent.prototype.incrementTimezone = function () {
            var timezone = this.datepicker.timezone$.value;
            var timezones = this.datepicker.timezones$.value;
            var currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
            // try to get the previous zone
            this.timezoneChange.emit(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
        };
        TimeViewComponent.prototype.decrementTimezone = function () {
            var timezone = this.datepicker.timezone$.value;
            var timezones = this.datepicker.timezones$.value;
            var currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
            // try to get the previous zone
            this.timezoneChange.emit(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
        };
        TimeViewComponent.prototype.onFocusWithin = function () {
            if (this._isRangeMode) {
                this._rangeService.isChangingTime = true;
            }
        };
        TimeViewComponent.prototype.onFocusOut = function () {
            if (this._isRangeMode) {
                this._rangeService.isChangingTime = false;
            }
        };
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], TimeViewComponent.prototype, "timezoneChange", void 0);
        __decorate([
            core.HostListener('focusin'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TimeViewComponent.prototype, "onFocusWithin", null);
        __decorate([
            core.HostListener('focusout'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TimeViewComponent.prototype, "onFocusOut", null);
        TimeViewComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker-time-view',
                template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"value\"\n    (valueChange)=\"onTimeChange($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\"\n    [meridians]=\"datepicker.meridians\"\n    [min]=\"min\"\n    [max]=\"max\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async)?.name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async)?.name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async)?.name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async)?.name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                core.ChangeDetectorRef,
                DateRangeService,
                DateRangeOptions])
        ], TimeViewComponent);
        return TimeViewComponent;
    }());
    var YearViewService = /** @class */ (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new rxjs.BehaviorSubject([[]]);
            this.focused$ = new rxjs.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new rxjs.Subscription();
            var year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            var event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === exports.DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        YearViewService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        YearViewService.prototype.setFocus = function (year) {
            this.focused$.next(year);
            this.createYearGrid(year);
        };
        YearViewService.prototype.goToPreviousDecade = function () {
            this.createYearGrid(this._year - 10);
        };
        YearViewService.prototype.goToNextDecade = function () {
            this.createYearGrid(this._year + 10);
        };
        YearViewService.prototype.createYearGrid = function (year) {
            var _this = this;
            if (year === void 0) {
                year = this._year;
            }
            this._year = year;
            // get the years to display
            var decade = this.getDecade(year);
            var currentYear = new Date().getFullYear();
            // produce items in the correct format
            var items = decade.range.map(function (_year) {
                return {
                    year: _year,
                    isCurrentYear: _year === currentYear,
                    isActiveYear: _year === _this._datepicker.year$.value
                };
            });
            // update the header text
            this._datepicker.setHeader(decade.start + ' - ' + decade.end);
            // create the grid
            this.grid$.next(gridify(items, 4));
        };
        /**
         * Get the years in the current decade to display
         */
        YearViewService.prototype.getDecade = function (year) {
            // figure the start and end points
            var start = (year - (year % 10));
            var end = start + 9;
            this._datepicker.yearRange = { start: start, end: end, range: range(start, end) };
            // create an array containing all the numbers between the start and end points
            return this._datepicker.yearRange;
        };
        YearViewService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [DateTimePickerService])
        ], YearViewService);
        return YearViewService;
    }());
    var YearViewComponent = /** @class */ (function () {
        function YearViewComponent(_datePicker, yearService, _liveAnnouncer, _changeDetector, _rangeService, _rangeOptions) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetector = _changeDetector;
            this._rangeService = _rangeService;
            this._rangeOptions = _rangeOptions;
            this._onDestroy = new rxjs.Subject();
            if (this._rangeService) {
                this._rangeService.onRangeChange.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _changeDetector.detectChanges(); });
            }
        }
        Object.defineProperty(YearViewComponent.prototype, "_isRangeMode", {
            /** Determine if we are in range selection mode */
            get: function () {
                return !!this._rangeOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_isRangeStart", {
            /** Determine if this picker is the start picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.Start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_isRangeEnd", {
            /** Determine if this picker is the end picker */
            get: function () {
                return this._isRangeMode && this._rangeOptions.picker === exports.DateRangePicker.End;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_rangeStart", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.start : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_rangeEnd", {
            get: function () {
                return this._isRangeMode && this._rangeService ? this._rangeService.end : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_minYear", {
            get: function () {
                return this._datePicker.min$.value ? new Date(this._datePicker.min$.value.getFullYear(), 0) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(YearViewComponent.prototype, "_maxYear", {
            get: function () {
                return this._datePicker.max$.value ? new Date(this._datePicker.max$.value.getFullYear(), 0) : null;
            },
            enumerable: true,
            configurable: true
        });
        YearViewComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // update on min/max changes
            rxjs.merge(this._datePicker.min$, this._datePicker.max$).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._changeDetector.detectChanges(); });
        };
        YearViewComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        YearViewComponent.prototype.select = function (year) {
            this._datePicker.setViewportYear(year);
            // show the month picker
            this._datePicker.goToChildMode();
        };
        /** Get the disabled state of a month */
        YearViewComponent.prototype.getDisabled = function (item) {
            var date = new Date(item.year, 0);
            // if we are not in range mode then it will always be enabled
            if (this._isRangeMode) {
                // if we are range start and dates are after the range end then they should also be disabled
                if (this._isRangeStart && !this._rangeStart && this._rangeEnd && isDateAfter(date, new Date(this._rangeEnd.getFullYear(), 0))) {
                    return true;
                }
                // if we are range end and dates are before the range start then they should also be disabled
                if (this._isRangeEnd && !this._rangeEnd && this._rangeStart && isDateBefore(date, new Date(this._rangeStart.getFullYear(), 0))) {
                    return true;
                }
            }
            if (this._minYear && isDateBefore(date, this._minYear)) {
                return true;
            }
            if (this._maxYear && isDateAfter(date, this._maxYear)) {
                return true;
            }
            return false;
        };
        YearViewComponent.prototype.focusYear = function (item, yearOffset) {
            this.yearService.setFocus(item.year + yearOffset);
        };
        YearViewComponent.prototype.trackRowByFn = function (index) {
            return index;
        };
        YearViewComponent.prototype.trackYearByFn = function (_index, item) {
            return item.year;
        };
        YearViewComponent.prototype.getTabbable = function (item) {
            var e_1, _a, e_2, _b;
            var focused = this.yearService.focused$.value;
            var grid = this.yearService.grid$.value;
            // if there is a focused year check if this is it
            if (focused) {
                // check if the focused year is visible
                var isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                if (isFocusedYearVisible) {
                    return focused === item.year;
                }
            }
            // if there is no focusable year then check if there is a selected year
            var isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
            if (isSelectedYearVisible) {
                return item.isActiveYear;
            }
            try {
                // otherwise find the first non-disabled month
                for (var _c = __values(this.yearService.grid$.value), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var row = _d.value;
                    try {
                        for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                            var column = row_1_1.value;
                            if (!this.getDisabled(column)) {
                                return item === column;
                            }
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (row_1_1 && !row_1_1.done && (_b = row_1.return))
                                _b.call(row_1);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        _a.call(_c);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            // otherwise make the first month tabbable
            return false;
        };
        /** Announce the date when we focus on a date */
        YearViewComponent.prototype.announceRangeMode = function () {
            if (this._isRangeMode) {
                this._liveAnnouncer.announce(this._isRangeStart ? this._rangeService.startPickerAriaLabel : this._rangeService.endPickerAriaLabel);
            }
        };
        YearViewComponent = __decorate([
            core.Component({
                selector: 'ux-date-time-picker-year-view',
                template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         uxFocusIndicator\n         uxFocusIndicatorOrigin\n         [programmaticFocusIndicator]=\"true\"\n         type=\"button\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear && !getDisabled(item)\"\n         [disabled]=\"getDisabled(item)\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (focus)=\"announceRangeMode()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                providers: [YearViewService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(4, core.Optional()),
            __param(5, core.Optional()),
            __metadata("design:paramtypes", [DateTimePickerService,
                YearViewService,
                a11y.LiveAnnouncer,
                core.ChangeDetectorRef,
                DateRangeService,
                DateRangeOptions])
        ], YearViewComponent);
        return YearViewComponent;
    }());
    var DateTimePickerModule = /** @class */ (function () {
        function DateTimePickerModule() {
        }
        DateTimePickerModule_1 = DateTimePickerModule;
        DateTimePickerModule.forRoot = function () {
            return {
                ngModule: DateTimePickerModule_1,
                providers: [
                    DateTimePickerConfig
                ]
            };
        };
        var DateTimePickerModule_1;
        DateTimePickerModule = DateTimePickerModule_1 = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    FocusIfModule,
                    forms.FormsModule,
                    IconModule,
                    SpinButtonModule,
                    TimePickerModule,
                ],
                exports: [DateTimePickerComponent],
                declarations: [
                    DateTimePickerComponent,
                    HeaderComponent,
                    DayViewComponent,
                    MonthViewComponent,
                    YearViewComponent,
                    TimeViewComponent,
                    WeekDaySortPipe
                ]
            })
        ], DateTimePickerModule);
        return DateTimePickerModule;
    }());
    var DateRangePickerModule = /** @class */ (function () {
        function DateRangePickerModule() {
        }
        DateRangePickerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    DateTimePickerModule,
                    IconModule,
                    DateFormatterPipeModule
                ],
                declarations: [
                    DateRangePickerComponent,
                    DateRangePickerDirective,
                ],
                exports: [
                    DateRangePickerComponent
                ]
            })
        ], DateRangePickerModule);
        return DateRangePickerModule;
    }());
    var EboxComponent = /** @class */ (function () {
        function EboxComponent() {
        }
        EboxComponent = __decorate([
            core.Component({
                selector: 'ux-ebox',
                template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], EboxComponent);
        return EboxComponent;
    }());
    var EboxHeaderDirective = /** @class */ (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective = __decorate([
            core.Directive({
                selector: 'ux-ebox-header'
            })
        ], EboxHeaderDirective);
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = /** @class */ (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective = __decorate([
            core.Directive({
                selector: 'ux-ebox-content'
            })
        ], EboxContentDirective);
        return EboxContentDirective;
    }());
    var EboxModule = /** @class */ (function () {
        function EboxModule() {
        }
        EboxModule = __decorate([
            core.NgModule({
                exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
            })
        ], EboxModule);
        return EboxModule;
    }());
    var FacetHeaderComponent = /** @class */ (function () {
        function FacetHeaderComponent(focusIndicatorService, elementRef) {
            /** Defines whether or not clicking on the header will toggle the expanded state. */
            this.canExpand = true;
            /** Can be used to set the initial expanded state. */
            this.expanded = true;
            /** If two-way binding is used it will be updated when the expanded state changes. */
            this.expandedChange = new core.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        FacetHeaderComponent.prototype.ngOnDestroy = function () {
            this._focusIndicator.destroy();
        };
        FacetHeaderComponent.prototype.toggleExpand = function () {
            // if not expandable then do nothing
            if (this.canExpand) {
                this.expanded = !this.expanded;
                this.expandedChange.emit(this.expanded);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetHeaderComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetHeaderComponent.prototype, "canExpand", void 0);
        __decorate([
            core.Input(), core.HostBinding('class.expanded'),
            __metadata("design:type", Boolean)
        ], FacetHeaderComponent.prototype, "expanded", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FacetHeaderComponent.prototype, "expandedChange", void 0);
        FacetHeaderComponent = __decorate([
            core.Component({
                selector: 'ux-facet-header',
                template: "<span class=\"facet-header-title\">{{ header }}</span>\n<ux-icon *ngIf=\"canExpand\" [name]=\"expanded ? 'down' : 'previous'\" class=\"facet-header-icon\"></ux-icon>\n",
                host: {
                    'role': 'button',
                    'tabindex': '0',
                    '(click)': 'toggleExpand()',
                    '(keyup.enter)': 'toggleExpand()',
                    '[attr.aria-expanded]': 'expanded',
                    '[attr.aria-label]': 'header + \' Facet: Activate to \' + (expanded ? \'collapse\' : \'expand\')'
                }
            }),
            __metadata("design:paramtypes", [FocusIndicatorService, core.ElementRef])
        ], FacetHeaderComponent);
        return FacetHeaderComponent;
    }());
    var FacetSelect = /** @class */ (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = /** @class */ (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = /** @class */ (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());
    var FacetService = /** @class */ (function () {
        function FacetService() {
            /** The list of active facets */
            this.facets$ = new rxjs.BehaviorSubject([]);
            /** Emit all the events when they occur */
            this.events$ = new rxjs.Subject();
        }
        FacetService.prototype.select = function (facet) {
            // if the facet is already selected or disabled then do nothing
            if (this.isSelected(facet) || facet.disabled) {
                return;
            }
            // update the list of active facets
            this.facets$.next(__spread(this.facets$.value, [facet]));
            // emit the event
            this.events$.next(new FacetSelect(facet));
        };
        FacetService.prototype.deselect = function (facet) {
            // if the facet is not selected then do nothing
            if (!this.isSelected(facet)) {
                return;
            }
            // update the list of active facets
            this.facets$.next(this.facets$.value.filter(function (_facet) { return _facet !== facet; }));
            // emit the event
            this.events$.next(new FacetDeselect(facet));
        };
        FacetService.prototype.deselectAll = function () {
            // empty the list of active facets
            this.facets$.next([]);
            // emit the event
            this.events$.next(new FacetDeselectAll());
        };
        FacetService.prototype.toggle = function (facet) {
            this.isSelected(facet) ? this.deselect(facet) : this.select(facet);
        };
        FacetService.prototype.isSelected = function (facet) {
            return this.facets$.value.indexOf(facet) > -1;
        };
        FacetService = __decorate([
            core.Injectable()
        ], FacetService);
        return FacetService;
    }());
    var Facet = /** @class */ (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());
    var FacetCheckListItemComponent = /** @class */ (function () {
        function FacetCheckListItemComponent() {
            this.facet = null;
            this.selected = false;
            this.tabbable = false;
            this.simplified = false;
            this.selectedChange = new core.EventEmitter();
            this.itemFocus = new core.EventEmitter();
            this.itemBlur = new core.EventEmitter();
        }
        Object.defineProperty(FacetCheckListItemComponent.prototype, "disabled", {
            get: function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        FacetCheckListItemComponent.prototype.getLabel = function () {
            return this.facet ? this.facet.title : '';
        };
        FacetCheckListItemComponent.prototype.focus = function () {
            this.option.nativeElement.focus();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Facet)
        ], FacetCheckListItemComponent.prototype, "facet", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListItemComponent.prototype, "selected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListItemComponent.prototype, "tabbable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListItemComponent.prototype, "simplified", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetCheckListItemComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetCheckListItemComponent.prototype, "itemFocus", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetCheckListItemComponent.prototype, "itemBlur", void 0);
        __decorate([
            core.ViewChild('option', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], FacetCheckListItemComponent.prototype, "option", void 0);
        FacetCheckListItemComponent = __decorate([
            core.Component({
                selector: 'ux-facet-check-list-item',
                template: "<div #option\n    uxFocusIndicator\n    class=\"facet-check-list-item\"\n    [class.facet-active]=\"selected\"\n    [attr.aria-checked]=\"selected\"\n    role=\"option\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (blur)=\"itemBlur.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    [class.disabled]=\"facet?.disabled\">\n\n    <!-- Show check icon to indicate the state -->\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-check-list-item-title\">{{ facet?.title }}</span>\n        <span *ngIf=\"facet?.count !== undefined\" class=\"facet-check-list-item-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], FacetCheckListItemComponent);
        return FacetCheckListItemComponent;
    }());
    var FacetCheckListComponent = /** @class */ (function () {
        function FacetCheckListComponent(facetService) {
            var _this = this;
            this.facetService = facetService;
            /** Defines the complete list of facets that can be selected. */
            this.facets = [];
            /** If `false` the list will grow to display all possible facets. If `true` a scrollbar will appear to prevent the list from growing too large. */
            this.scrollbar = true;
            /** Defines whether or not the checkboxes will appear in simplified form. */
            this.simplified = false;
            /** Defines whether or not the Facet Check List should be initially expanded or not. */
            this.expanded = true;
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property (deselect all will not contain affected facets).
             */
            this.events = new rxjs.Subject();
            /** If two-way binding is used this array will get updated any time the selected facets change. */
            this.selectedChange = new core.EventEmitter();
            this.isFocused = false;
            this.activeIndex = 0;
            this._onDestroy = new rxjs.Subject();
            facetService.events$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // deselect all events should always be emitted
                if (event instanceof FacetDeselectAll) {
                    _this.events.next(event);
                    _this.selectedChange.next([]);
                }
                // selection and deselection events should only be emitted when the facet belongs to this component
                if ((event instanceof FacetSelect || event instanceof FacetDeselect) && _this.isOwnFacet(event.facet)) {
                    _this.events.next(event);
                    _this.selectedChange.next(_this.getSelectedFacets());
                }
            });
        }
        Object.defineProperty(FacetCheckListComponent.prototype, "selected", {
            /** This will allow you to define an initial set of selected facets. */
            set: function (selection) {
                var _this = this;
                if (Array.isArray(selection)) {
                    selection.forEach(function (facet) { return _this.facetService.select(facet); });
                }
            },
            enumerable: true,
            configurable: true
        });
        FacetCheckListComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._focusKeyManager = new a11y.FocusKeyManager(this.options)
                .withVerticalOrientation();
            this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
        };
        FacetCheckListComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        FacetCheckListComponent.prototype.onFocus = function (index) {
            if (this._focusKeyManager.activeItemIndex === -1) {
                this._focusKeyManager.setActiveItem(index);
            }
        };
        FacetCheckListComponent.prototype.onKeydown = function (event) {
            this._focusKeyManager.onKeydown(event);
        };
        FacetCheckListComponent.prototype.toggleFacet = function (index, facet) {
            this.facetService.toggle(facet);
            this._focusKeyManager.setActiveItem(index);
        };
        FacetCheckListComponent.prototype.getSelectedFacets = function () {
            var _this = this;
            return this.facetService.facets$.value.filter(function (facet) { return _this.isOwnFacet(facet); });
        };
        FacetCheckListComponent.prototype.isOwnFacet = function (facet) {
            return this.facets.indexOf(facet) !== -1;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], FacetCheckListComponent.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], FacetCheckListComponent.prototype, "facets", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetCheckListComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListComponent.prototype, "scrollbar", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListComponent.prototype, "simplified", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetCheckListComponent.prototype, "expanded", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", rxjs.Subject)
        ], FacetCheckListComponent.prototype, "events", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FacetCheckListComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.ViewChildren(FacetCheckListItemComponent),
            __metadata("design:type", core.QueryList)
        ], FacetCheckListComponent.prototype, "options", void 0);
        FacetCheckListComponent = __decorate([
            core.Component({
                selector: 'ux-facet-check-list',
                template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\"\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [class.facet-check-list-scrollbar]=\"scrollbar\"\n    [class.facet-check-list-scrollbar-focused]=\"isFocused\"\n    *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <ux-facet-check-list-item *ngFor=\"let facet of facets; let index = index\"\n        [facet]=\"facet\"\n        [simplified]=\"simplified\"\n        [tabbable]=\"activeIndex === index\"\n        [selected]=\"facetService.isSelected(facet)\"\n        (selectedChange)=\"toggleFacet(index, facet)\"\n        (keydown)=\"onKeydown($event)\"\n        (itemFocus)=\"isFocused = true; onFocus(index)\"\n        (itemBlur)=\"isFocused = false\">\n    </ux-facet-check-list-item>\n\n</div>"
            }),
            __metadata("design:paramtypes", [FacetService])
        ], FacetCheckListComponent);
        return FacetCheckListComponent;
    }());
    var FacetClearButtonDirective = /** @class */ (function () {
        function FacetClearButtonDirective() {
        }
        FacetClearButtonDirective = __decorate([
            core.Directive({
                selector: '[uxFacetClearButton]'
            })
        ], FacetClearButtonDirective);
        return FacetClearButtonDirective;
    }());
    var FacetContainerComponent = /** @class */ (function () {
        function FacetContainerComponent(_announcer, facetService) {
            var _this = this;
            this._announcer = _announcer;
            this.facetService = facetService;
            /** Defines the text displayed at the top of the Facet Container. */
            this.header = 'Selected';
            /** Defines the text to display in the tooltip when hovering over the clear all button. */
            this.clearTooltip = 'Clear All';
            /** Defines the text to display when there are no selected facets. */
            this.emptyText = 'No Items';
            /** Determines if the facets can be reordered. */
            this.facetsReorderable = false;
            /** Defines the aria-label for the clear all button. */
            this.clearAriaLabel = 'Clear All';
            /** Defines the aria-label for the deselect facet button.. */
            this.deselectFacetAriaLabel = 'Deselect Facet';
            /** If using two-way binding this array will update when the selected facets change. */
            this.facetsChange = new core.EventEmitter();
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property
             * (deselect all will not contain affected facets). */
            this.events = new core.EventEmitter();
            this._onDestroy = new rxjs.Subject();
            facetService.facets$.subscribe(function (facets) { return _this.facetsChange.next(facets); });
            facetService.events$.subscribe(function (event) { return _this.triggerEvent(event); });
            // announce deselection
            facetService.events$.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }))
                .subscribe(function (event) { return _this._announcer.announce("Option " + event.facet.title + " deselected.", 'assertive'); });
        }
        Object.defineProperty(FacetContainerComponent.prototype, "facets", {
            get: function () {
                return this.facetService.facets$.value;
            },
            /** Allows a predefined set of Facets to be displayed. */
            set: function (facets) {
                this.facetService.facets$.next(facets);
            },
            enumerable: true,
            configurable: true
        });
        FacetContainerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        FacetContainerComponent.prototype.selectFacet = function (facet) {
            this.facetService.select(facet);
        };
        FacetContainerComponent.prototype.deselectFacet = function (facet, tag) {
            // find the index of the item in the selected array
            var idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
            // if match there was no match then finish
            if (idx === -1) {
                return;
            }
            // remove the last item
            this.facetService.deselect(facet);
            // announce the facet removal
            this._announcer.announce("Option " + facet.title + " deselected.", 'assertive');
            // focus another tag if there is one
            if (tag) {
                var sibling = tag.previousElementSibling || tag.nextElementSibling;
                // if there is a sibling then focus it
                if (sibling) {
                    sibling.focus();
                }
            }
        };
        FacetContainerComponent.prototype.deselectAllFacets = function () {
            // empty the selected array
            this.facetService.deselectAll();
            // announce the facet removal
            this._announcer.announce("All options deselected.", 'assertive');
        };
        FacetContainerComponent.prototype.trackBy = function (_index, facet) {
            return facet.id || facet.title;
        };
        FacetContainerComponent.prototype.shiftRight = function (facet, element) {
            // only move the item if reordering is allowed
            if (this.facetsReorderable === false) {
                return;
            }
            // perform the movement
            this.shiftFacet(facet, 1);
            // the item may become unfocused during the reorder so we should refocus it
            requestAnimationFrame(function () { return element.focus(); });
            // announce the move
            this._announcer.announce("Option " + facet.title + " moved down.");
        };
        FacetContainerComponent.prototype.shiftLeft = function (facet, element) {
            // only move the item if reordering is allowed
            if (this.facetsReorderable === false) {
                return;
            }
            // perform the movement
            this.shiftFacet(facet, -1);
            // the item may become unfocused during the reorder so we should refocus it
            requestAnimationFrame(function () { return element.focus(); });
            // announce the move
            this._announcer.announce("Option " + facet.title + " moved up.");
        };
        FacetContainerComponent.prototype.shiftFacet = function (facet, distance) {
            var index = this.facets.indexOf(facet);
            var target = index + distance;
            // Ensure the move is valid
            if (target < 0 || target === this.facets.length) {
                return;
            }
            // Perform the move
            this.facets.splice(index, 1);
            this.facets.splice(target, 0, facet);
        };
        FacetContainerComponent.prototype.triggerEvent = function (event) {
            this.events.next(event);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetContainerComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetContainerComponent.prototype, "clearTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetContainerComponent.prototype, "emptyText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetContainerComponent.prototype, "facetsReorderable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], FacetContainerComponent.prototype, "facets", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetContainerComponent.prototype, "clearAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetContainerComponent.prototype, "deselectFacetAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FacetContainerComponent.prototype, "facetsChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FacetContainerComponent.prototype, "events", void 0);
        __decorate([
            core.ContentChild(FacetClearButtonDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], FacetContainerComponent.prototype, "clearButton", void 0);
        FacetContainerComponent = __decorate([
            core.Component({
                selector: 'ux-facet-container',
                template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <ng-container *ngIf=\"(facetService.facets$ | async).length > 0\" [ngTemplateOutlet]=\"clearButton || clearButtonDefault\"></ng-container>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\"\n        uxReorderable\n        role=\"list\"\n        [reorderingDisabled]=\"!facetsReorderable\"\n        [(reorderableModel)]=\"facets\"\n        (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div #tag\n            class=\"facet-selected-tag\"\n            role=\"listitem\"\n            tabindex=\"0\"\n            uxReorderableHandle\n            *ngFor=\"let facet of (facetService.facets$ | async); trackBy: trackBy\"\n            [attr.aria-label]=\"facet.title\"\n            [uxReorderableModel]=\"facet\"\n            (mousedown)=\"tag.focus()\"\n            (touchmove)=\"$event.preventDefault()\"\n            (keydown.ArrowRight)=\"shiftRight(facet, tag)\"\n            (keydown.ArrowLeft)=\"shiftLeft(facet, tag)\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\">{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <button type=\"button\"\n                uxFocusIndicator\n                class=\"facet-selected-remove-btn\"\n                [attr.aria-label]=\"deselectFacetAriaLabel\"\n                (click)=\"deselectFacet(facet, tag)\">\n\n                <ux-icon name=\"close\"></ux-icon>\n            </button>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && (facetService.facets$ | async).length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>\n\n<ng-template #clearButtonDefault>\n    <button type=\"button\"\n            class=\"btn btn-link btn-icon button-secondary\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"clearAriaLabel\"\n            [uxTooltip]=\"clearTooltip\"\n            placement=\"left\"\n            (click)=\"deselectAllFacets()\">\n\n            <svg class=\"facets-selected-clear-graphic\" focusable=\"false\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </button>\n</ng-template>",
                providers: [FacetService]
            }),
            __metadata("design:paramtypes", [a11y.LiveAnnouncer, FacetService])
        ], FacetContainerComponent);
        return FacetContainerComponent;
    }());
    var TypeaheadOptionEvent = /** @class */ (function () {
        function TypeaheadOptionEvent(option, origin) {
            this.option = option;
            this.origin = origin;
        }
        return TypeaheadOptionEvent;
    }());
    var TypeaheadKeyService = /** @class */ (function () {
        function TypeaheadKeyService() {
        }
        TypeaheadKeyService.prototype.handleKey = function (event, typeahead) {
            if (!typeahead) {
                return;
            }
            switch (event.keyCode) {
                case keycodes.UP_ARROW:
                    if (!typeahead.open) {
                        typeahead.open = true;
                    }
                    else {
                        typeahead.moveHighlight(-1);
                    }
                    event.preventDefault();
                    break;
                case keycodes.DOWN_ARROW:
                    if (!typeahead.open) {
                        typeahead.open = true;
                    }
                    else {
                        typeahead.moveHighlight(1);
                    }
                    event.preventDefault();
                    break;
                case keycodes.ESCAPE:
                    typeahead.open = false;
                    break;
                case keycodes.ENTER:
                    if (typeahead.selectOnEnter) {
                        typeahead.selectHighlighted();
                    }
            }
        };
        TypeaheadKeyService = __decorate([
            core.Injectable()
        ], TypeaheadKeyService);
        return TypeaheadKeyService;
    }());
    var TypeaheadService = /** @class */ (function () {
        function TypeaheadService() {
            this.open$ = new rxjs.BehaviorSubject(false);
            this.highlightedElement$ = new rxjs.BehaviorSubject(null);
        }
        TypeaheadService = __decorate([
            core.Injectable()
        ], TypeaheadService);
        return TypeaheadService;
    }());
    var PopoverOrientationService = /** @class */ (function () {
        function PopoverOrientationService(elementRef, _resizeService, _viewportRuler) {
            this.elementRef = elementRef;
            this._resizeService = _resizeService;
            this._viewportRuler = _viewportRuler;
        }
        PopoverOrientationService.prototype.createPopoverOrientationListener = function (element, parentElement) {
            var nativeElement = element instanceof core.ElementRef ? element.nativeElement : element;
            var nativeElementParent = parentElement instanceof core.ElementRef ? parentElement.nativeElement : element;
            return new PopoverOrientationListener(nativeElement, nativeElementParent, this._resizeService, this._viewportRuler);
        };
        PopoverOrientationService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [core.ElementRef,
                ResizeService,
                scrolling.ViewportRuler])
        ], PopoverOrientationService);
        return PopoverOrientationService;
    }());
    var PopoverOrientationListener = /** @class */ (function () {
        function PopoverOrientationListener(_element, _elementParent, _resizeService, _viewportRuler) {
            var _this = this;
            this._element = _element;
            this._elementParent = _elementParent;
            this._resizeService = _resizeService;
            this._viewportRuler = _viewportRuler;
            /** Allow subscribing to state changes */
            this.orientation$ = new rxjs.BehaviorSubject(1);
            this._onDestroy = new rxjs.Subject();
            // watch for changes to the typeahead size
            this._resizeService.addResizeListener(this._element).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () {
                _this.onScrollOrResize();
            });
            // watch for changes to the typeahead position when scrolling
            rxjs.fromEvent(window, 'scroll', { passive: true }).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.onScrollOrResize(); });
        }
        PopoverOrientationListener.prototype.destroy = function () {
            this.orientation$.complete();
            this._onDestroy.next();
            this._onDestroy.complete();
            this._resizeService.removeResizeListener(this._element);
        };
        PopoverOrientationListener.prototype.onScrollOrResize = function () {
            this._rect = this._elementParent ? this._elementParent.parentElement.getBoundingClientRect() : this._element.parentElement.getBoundingClientRect();
            var itemHeight = this._element.offsetHeight;
            var viewportSize = this._viewportRuler.getViewportSize();
            var bottomSpaceAvailable = viewportSize.height - this._rect.bottom - itemHeight;
            this.orientation$.next(bottomSpaceAvailable <= 0 ? 0 /* Up */ : 1 /* Down */);
        };
        return PopoverOrientationListener;
    }());
    var uniqueId$3 = 0;
    var TypeaheadComponent = /** @class */ (function () {
        function TypeaheadComponent(typeaheadElement, _changeDetector, popoverOrientation, _service, _viewportRuler, _renderer, _resizeService) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._changeDetector = _changeDetector;
            this._service = _service;
            this._viewportRuler = _viewportRuler;
            this._renderer = _renderer;
            this._resizeService = _resizeService;
            /** Define a unique id for the typeahead */
            this.id = "ux-typeahead-" + ++uniqueId$3;
            /** Specify the drop direction */
            this.dropDirection = 'down';
            /** Specify the max height of the dropdown */
            this.maxHeight = '250px';
            /** Specify the aria multi selectable attribute value */
            this.multiselectable = false;
            /** Specify if the dropdown should appear when the filter appears */
            this.openOnFilterChange = true;
            /** Specify the page size */
            this.pageSize = 20;
            /** Specify if we should select the first item by default */
            this.selectFirst = true;
            /** Specify if we should select an item on enter key press */
            this.selectOnEnter = false;
            /** Specify the loading state */
            this.loading = false;
            /** Maximum number of displayed recently selected options. */
            this.recentOptionsMaxCount = 5;
            /** Emit when the open state changes */
            this.openChange = new core.EventEmitter();
            /** Emit when an option is selected */
            this.optionSelected = new core.EventEmitter();
            /** Emit whenever a highlighted item changes */
            this.highlightedChange = new core.EventEmitter();
            /** Emit the highlighted element when it changes */
            this.highlightedElementChange = new core.EventEmitter();
            /** Emits when recently selected options change.*/
            this.recentOptionsChange = new core.EventEmitter();
            this.activeKey = null;
            this.clicking = false;
            this.hasBeenOpened = false;
            this.highlighted$ = new rxjs.BehaviorSubject(null);
            this.visibleOptions$ = new rxjs.BehaviorSubject([]);
            this.visibleRecentOptions$ = new rxjs.BehaviorSubject([]);
            this.allVisibleOptions = [];
            this._onDestroy = new rxjs.Subject();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    var arrayOrPromise = _this.options(pageNum, pageSize, filter);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return _this.getVisibleOptions(newOptions, '');
                    });
                }
                return null;
            };
            this._service.open$
                .pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy))
                .subscribe(function (isOpen) {
                _this.openChange.emit(isOpen);
                if (isOpen) {
                    _this.hasBeenOpened = true;
                    _this.initOptions();
                }
            });
            this._popoverOrientationListener = popoverOrientation.createPopoverOrientationListener(this.typeaheadElement.nativeElement, this.typeaheadElement.nativeElement.parentElement);
            this._popoverOrientationListener.orientation$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (direction) {
                if (_this.dropDirection === 'auto') {
                    _this.dropUp = direction === 0 /* Up */;
                }
            });
            this.highlighted$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.highlightedChange.emit(next ? next.value : null);
            });
            rxjs.combineLatest([this.visibleOptions$, this.visibleRecentOptions$])
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), visibleOptions = _b[0], visibleRecentOptions = _b[1];
                _this.allVisibleOptions = __spread(visibleRecentOptions, visibleOptions);
            });
            rxjs.combineLatest([
                this._service.open$,
                this._service.highlightedElement$,
                this.visibleOptions$
            ])
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            });
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            /** Specify if the typeahead is open */
            get: function () {
                return this._service.open$.getValue();
            },
            set: function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "active", {
            /** Specify the currently active item */
            set: function (item) {
                this.activeKey = this.getKey(item);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: function () {
                var value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            // Open the dropdown if the filter value updates
            if (changes.filter) {
                if (this.openOnFilterChange && changes.filter.currentValue && changes.filter.currentValue.length > 0) {
                    // if the dropdown item was just selected, and we set the filter value to match the
                    // selected value then open will have also just been set to `false`, in which case we do
                    // not want to set open to `true`
                    if (changes.open &&
                        changes.open.previousValue === true &&
                        changes.open.currentValue === false) {
                        return;
                    }
                    // show the dropdown
                    this.open = true;
                }
            }
            // Cut off recentOptions at recentOptionsMaxCount
            if (changes.recentOptions || changes.recentOptionsMaxCount) {
                this._recentOptions = this.recentOptions
                    ? this.recentOptions.slice(0, this.recentOptionsMaxCount)
                    : undefined;
                if (changes.recentOptionsMaxCount) {
                    // Avoid ExpressionChangedAfterChecked error
                    setTimeout(function () {
                        _this.recentOptionsChange.emit(_this._recentOptions);
                    });
                }
            }
            if (changes.dropDirection) {
                if (changes.dropDirection.currentValue === 'auto') {
                    this.dropUp = this._popoverOrientationListener.orientation$.getValue() === 0 /* Up */;
                }
                else {
                    this.dropUp = changes.dropDirection.currentValue === 'up';
                }
            }
            // Re-filter visibleOptions
            this.updateOptions();
        };
        TypeaheadComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this._popoverOrientationListener.destroy();
        };
        TypeaheadComponent.prototype.mousedownHandler = function () {
            this.clicking = true;
        };
        TypeaheadComponent.prototype.mouseupHandler = function () {
            this.clicking = false;
        };
        TypeaheadComponent.prototype.optionMousedownHandler = function (event) {
            // Workaround to prevent focus changing when an option is clicked
            event.preventDefault();
        };
        TypeaheadComponent.prototype.optionClickHandler = function (_event, option) {
            this.select(option, 'mouse');
        };
        /**
         * Returns the unique key value of the given option.
         */
        TypeaheadComponent.prototype.getKey = function (option) {
            if (typeof this.key === 'function') {
                return this.key(option);
            }
            if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                return option[this.key];
            }
            return this.getDisplay(option);
        };
        /**
         * Returns the display value of the given option.
         */
        TypeaheadComponent.prototype.getDisplay = function (option) {
            if (typeof this.display === 'function') {
                return this.display(option);
            }
            if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                return option[this.display];
            }
            if (typeof option === 'string') {
                return option;
            }
        };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        TypeaheadComponent.prototype.getDisplayHtml = function (option) {
            var displayText = this.getDisplay(option)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            var displayHtml = displayText;
            if (this.filter) {
                var length_1 = this.filter.length;
                var matchIndex = displayText
                    .toLowerCase()
                    .indexOf(this.filter.toLowerCase());
                if (matchIndex >= 0) {
                    var highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                    displayHtml =
                        displayText.substr(0, matchIndex) +
                            highlight +
                            displayText.substr(matchIndex + length_1);
                }
            }
            return displayHtml;
        };
        /**
         * Returns true if the infinite scroll component should load
         */
        TypeaheadComponent.prototype.isInfiniteScroll = function () {
            return typeof this.options === 'function';
        };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        TypeaheadComponent.prototype.select = function (option, origin) {
            if (!option.isDisabled) {
                this.optionSelected.emit(new TypeaheadOptionEvent(option.value, origin));
                this.highlighted$.next(null);
                this.open = false;
                this.addToRecentOptions(option.value);
            }
        };
        TypeaheadComponent.prototype.addToRecentOptions = function (value) {
            if (this._recentOptions) {
                this._recentOptions = __spread([
                    value
                ], this._recentOptions.filter(function (recentOption) { return recentOption !== value; })).slice(0, this.recentOptionsMaxCount);
                this.recentOptionsChange.emit(this._recentOptions);
            }
        };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        TypeaheadComponent.prototype.isDisabled = function (option) {
            var _this = this;
            if (this.disabledOptions && Array.isArray(this.disabledOptions)) {
                var result = this.disabledOptions.find(function (selectedOption) {
                    return _this.getKey(selectedOption) === _this.getKey(option);
                });
                return result !== undefined;
            }
            return false;
        };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        TypeaheadComponent.prototype.highlight = function (option) {
            if (!option.isDisabled) {
                this.highlighted$.next(option);
                this._changeDetector.detectChanges();
            }
        };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        TypeaheadComponent.prototype.moveHighlight = function (d) {
            var highlightIndex = this.indexOfVisibleOption(this.highlighted$.getValue());
            var newIndex = highlightIndex;
            var disabled = true;
            var inBounds = true;
            do {
                newIndex = newIndex + d;
                inBounds = newIndex >= 0 && newIndex < this.allVisibleOptions.length;
                disabled = inBounds && this.allVisibleOptions[newIndex].isDisabled;
            } while (inBounds && disabled);
            if (!disabled && inBounds) {
                this.highlight(this.allVisibleOptions[newIndex]);
            }
            return this.highlighted;
        };
        TypeaheadComponent.prototype.selectHighlighted = function () {
            if (this.highlighted$.getValue()) {
                this.select(this.highlighted$.getValue(), 'keyboard');
            }
        };
        /**
         * Set up the options before the dropdown is displayed.
         */
        TypeaheadComponent.prototype.initOptions = function () {
            // Clear previous highlight
            this.highlighted$.next(null);
            if (this.selectFirst) {
                // This will highlight the first non-disabled option.
                this.moveHighlight(1);
            }
        };
        /**
         * Display the first item as highlighted when there are several pages
         */
        TypeaheadComponent.prototype.onLoadedHighlight = function (event) {
            if (this.selectFirst && this.options && event.pageNumber === 0) {
                // This will highlight the first non-disabled option.
                this.moveHighlight(1);
            }
        };
        /**
         * Update the visibleOptions and visibleRecentOptions arrays with the current filter.
         */
        TypeaheadComponent.prototype.updateOptions = function () {
            var normalisedInput = (this.filter || '').toLowerCase();
            // Create new visibleOptions only if `options` is not a function
            if (typeof this.options === 'object') {
                this.visibleOptions$.next(this.getVisibleOptions(this.options, normalisedInput));
            }
            this.visibleRecentOptions$.next(this.getVisibleOptions(this._recentOptions, normalisedInput, true));
            this.initOptions();
            this._changeDetector.detectChanges();
        };
        /**
         * Convert a set of raw options into a filtered list of `TypeaheadVisibleOption` objects.
         * @param options Set of raw options
         * @param filter The filter expression
         * @param isRecentOptions Whether `options` is a set of recent options
         */
        TypeaheadComponent.prototype.getVisibleOptions = function (options, filter, isRecentOptions) {
            var _this = this;
            if (filter === void 0) {
                filter = '';
            }
            if (isRecentOptions === void 0) {
                isRecentOptions = false;
            }
            if (options) {
                return options
                    .filter(function (option) { return _this.getDisplay(option).toLowerCase().indexOf(filter) >= 0; })
                    .map(function (value) {
                    return ({
                        value: value,
                        key: _this.getKey(value),
                        isDisabled: _this.isDisabled(value),
                        isRecentOption: isRecentOptions
                    });
                });
            }
            return [];
        };
        /**
         * Return the index of the given option in the allVisibleOptions array.
         * Returns -1 if the option is not currently visible.
         */
        TypeaheadComponent.prototype.indexOfVisibleOption = function (option) {
            if (option) {
                return this.allVisibleOptions.findIndex(function (el) {
                    return (el.key === option.key &&
                        el.isRecentOption === option.isRecentOption);
                });
            }
            return -1;
        };
        __decorate([
            core.Input(), core.HostBinding('attr.id'),
            __metadata("design:type", String)
        ], TypeaheadComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "options", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TypeaheadComponent.prototype, "filter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TypeaheadComponent.prototype, "open", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], TypeaheadComponent.prototype, "display", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], TypeaheadComponent.prototype, "key", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TypeaheadComponent.prototype, "disabledOptions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TypeaheadComponent.prototype, "dropDirection", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TypeaheadComponent.prototype, "maxHeight", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-multiselectable'),
            __metadata("design:type", Boolean)
        ], TypeaheadComponent.prototype, "multiselectable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TypeaheadComponent.prototype, "openOnFilterChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TypeaheadComponent.prototype, "pageSize", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TypeaheadComponent.prototype, "selectFirst", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TypeaheadComponent.prototype, "selectOnEnter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "loading", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TypeaheadComponent.prototype, "loadingTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TypeaheadComponent.prototype, "optionTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TypeaheadComponent.prototype, "noOptionsTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], TypeaheadComponent.prototype, "active", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TypeaheadComponent.prototype, "recentOptions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TypeaheadComponent.prototype, "recentOptionsMaxCount", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "openChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "optionSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "highlightedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "highlightedElementChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadComponent.prototype, "recentOptionsChange", void 0);
        __decorate([
            core.HostBinding('class.drop-up'),
            __metadata("design:type", Boolean)
        ], TypeaheadComponent.prototype, "dropUp", void 0);
        __decorate([
            core.HostListener('mousedown'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TypeaheadComponent.prototype, "mousedownHandler", null);
        __decorate([
            core.HostListener('mouseup'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TypeaheadComponent.prototype, "mouseupHandler", null);
        TypeaheadComponent = __decorate([
            core.Component({
                selector: 'ux-typeahead',
                template: "<div class=\"ux-typeahead-options\"\n     [uxInfiniteScroll]=\"loadOptionsCallback\"\n     [collection]=\"visibleOptions$ | async\"\n     (collectionChange)=\"visibleOptions$.next($event)\"\n     [enabled]=\"hasBeenOpened && isInfiniteScroll()\"\n     [filter]=\"filter\"\n     [loadOnScroll]=\"true\"\n     [pageSize]=\"pageSize\"\n     [scrollElement]=\"typeaheadElement\"\n     (loading)=\"loading = true\"\n     (loaded)=\"loading = false; onLoadedHighlight($event)\">\n\n     <!-- Recent options -->\n    <ux-typeahead-options-list\n        *ngIf=\"(visibleRecentOptions$ | async).length > 0\"\n        class=\"ux-typeahead-recent-options\"\n        [id]=\"id\"\n        [options]=\"visibleRecentOptions$ | async\"\n        [highlighted]=\"highlighted$ | async\"\n        [activeKey]=\"activeKey\"\n        [disabledOptions]=\"disabledOptions\"\n        [isMultiselectable]=\"multiselectable\"\n        [optionTemplate]=\"optionTemplate || defaultOptionTemplate\"\n        [optionApi]=\"optionApi\"\n        [typeaheadElement]=\"typeaheadElement\"\n        (optionMouseover)=\"highlight($event.option)\"\n        (optionMousedown)=\"optionMousedownHandler($event.event)\"\n        (optionClick)=\"optionClickHandler($event.event, $event.option)\"\n    ></ux-typeahead-options-list>\n\n    <!-- All options -->\n    <ux-typeahead-options-list\n        *ngIf=\"(visibleOptions$ | async).length > 0\"\n        class=\"ux-typeahead-all-options\"\n        [id]=\"id\"\n        [startIndex]=\"(visibleRecentOptions$ | async).length\"\n        [options]=\"visibleOptions$ | async\"\n        [highlighted]=\"highlighted$ | async\"\n        [activeKey]=\"activeKey\"\n        [disabledOptions]=\"disabledOptions\"\n        [isMultiselectable]=\"multiselectable\"\n        [optionTemplate]=\"optionTemplate || defaultOptionTemplate\"\n        [optionApi]=\"optionApi\"\n        [typeaheadElement]=\"typeaheadElement\"\n        (optionMouseover)=\"highlight($event.option)\"\n        (optionMousedown)=\"optionMousedownHandler($event.event)\"\n        (optionClick)=\"optionClickHandler($event.event, $event.option)\"\n    ></ux-typeahead-options-list>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n    <div *ngIf=\"isInfiniteScroll() === false && (visibleOptions$ | async).length === 0 && loading\">\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate || defaultNoOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                providers: [TypeaheadService, PopoverOrientationService],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'listbox',
                    '[class.open]': 'open',
                    '[style.maxHeight]': 'maxHeight'
                }
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.ChangeDetectorRef,
                PopoverOrientationService,
                TypeaheadService,
                scrolling.ViewportRuler,
                core.Renderer2,
                ResizeService])
        ], TypeaheadComponent);
        return TypeaheadComponent;
    }());
    var InfiniteScrollLoadButtonDirective = /** @class */ (function () {
        function InfiniteScrollLoadButtonDirective(_template, _viewContainer, _renderer) {
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new rxjs.Subject();
            this.loading = this._load.asObservable();
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                if (value !== this._visible) {
                    if (value) {
                        var viewRef = this._viewContainer.createEmbeddedView(this._template);
                        this._renderer.listen(viewRef.rootNodes[0], 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadButtonDirective.prototype.onClick = function (event) {
            this._load.next(event);
        };
        __decorate([
            core.Input('uxInfiniteScrollLoadButton'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], InfiniteScrollLoadButtonDirective.prototype, "visible", null);
        __decorate([
            core.Output(),
            __metadata("design:type", rxjs.Observable)
        ], InfiniteScrollLoadButtonDirective.prototype, "loading", void 0);
        InfiniteScrollLoadButtonDirective = __decorate([
            core.Directive({
                selector: '[uxInfiniteScrollLoadButton]'
            }),
            __metadata("design:paramtypes", [core.TemplateRef,
                core.ViewContainerRef,
                core.Renderer2])
        ], InfiniteScrollLoadButtonDirective);
        return InfiniteScrollLoadButtonDirective;
    }());
    var InfiniteScrollLoadingDirective = /** @class */ (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('uxInfiniteScrollLoading'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], InfiniteScrollLoadingDirective.prototype, "visible", null);
        InfiniteScrollLoadingDirective = __decorate([
            core.Directive({
                selector: '[uxInfiniteScrollLoading]'
            }),
            __metadata("design:paramtypes", [core.TemplateRef,
                core.ViewContainerRef])
        ], InfiniteScrollLoadingDirective);
        return InfiniteScrollLoadingDirective;
    }());
    var InfiniteScrollDirective = /** @class */ (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new core.EventEmitter();
            this.loadingEvent = new core.EventEmitter();
            this.loadedEvent = new core.EventEmitter();
            this.loadErrorEvent = new core.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new rxjs.Subject();
            this._isLoading = new rxjs.BehaviorSubject(false);
            this._isExhausted = new rxjs.BehaviorSubject(false);
            this._loadButtonEnabled = new rxjs.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new rxjs.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: function () {
                return this._collection;
            },
            set: function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: function (element) {
                this._scrollElement = element instanceof core.ElementRef ? element : new core.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollDirective.prototype.ngOnInit = function () {
            if (!this._scrollElement) {
                this._scrollElement = this._element;
            }
            this._loadButtonEnabled.next(!this.loadOnScroll);
        };
        InfiniteScrollDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // There are two kinds of update requests: check and load.
            // Check requests are throttled and will only cause an update if more data is required
            // to fill the scrolling view, and it isn't already loading some.
            // Load requests are not throttled and always request a page of data.
            this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
            this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
            if (this.enabled) {
                // Subscribe to scroll events and DOM changes.
                this.attachEventHandlers();
            }
            // Connect the Load More button visible state.
            this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                _this._loadButtonQuery.forEach(function (loadButton) {
                    loadButton.visible = canLoad;
                });
            });
            // Connect the loading indicator visible state.
            this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                _this._loadingIndicatorQuery.forEach(function (loading) {
                    loading.visible = isLoading;
                });
            });
            // Link the Load More button click event to trigger an update.
            this.attachLoadButtonEvents();
            this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.attachLoadButtonEvents();
            });
            // Initial update.
            if (this.loadOnInit) {
                this.loadNextPage();
            }
        };
        InfiniteScrollDirective.prototype.ngOnChanges = function (changes) {
            var check = true;
            if (changes.enabled && changes.enabled.currentValue !== changes.enabled.previousValue) {
                if (changes.enabled.currentValue) {
                    this.attachEventHandlers();
                    this.reset();
                    check = false;
                }
                else {
                    this.detachEventHandlers();
                }
            }
            if (this.enabled) {
                if (changes.filter && this.coerceFilter(changes.filter.currentValue) !== this.coerceFilter(changes.filter.previousValue)) {
                    this.reset();
                    check = false;
                }
                if (changes.loadOnScroll) {
                    this._loadButtonEnabled.next(!changes.loadOnScroll.currentValue);
                }
                if (changes.pageSize && changes.pageSize.currentValue !== changes.pageSize.previousValue) {
                    this.reset();
                    check = false;
                }
                this._updateRequests.next({
                    check: check,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.coerceFilter(this.filter)
                });
            }
        };
        InfiniteScrollDirective.prototype.ngOnDestroy = function () {
            this.detachEventHandlers();
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Request an additional page of data.
         */
        InfiniteScrollDirective.prototype.loadNextPage = function () {
            if (!this.enabled) {
                return;
            }
            this._updateRequests.next({
                check: false,
                pageNumber: this._nextPageNum,
                pageSize: this.pageSize,
                filter: this.coerceFilter(this.filter)
            });
        };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        InfiniteScrollDirective.prototype.check = function () {
            if (!this.enabled) {
                return;
            }
            this._updateRequests.next({
                check: true,
                pageNumber: this._nextPageNum,
                pageSize: this.pageSize,
                filter: this.coerceFilter(this.filter)
            });
        };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        InfiniteScrollDirective.prototype.reset = function () {
            if (!this.enabled) {
                return;
            }
            // Reset the page counter.
            this._nextPageNum = 0;
            this._pages = [];
            // Clear the collection (without changing the reference).
            if (this.collection) {
                this.collection.length = 0;
            }
            // Reset the exhausted flag, allowing the Load More button to appear.
            this._isExhausted.next(false);
            // Cancel any pending requests
            if (this._subscriptions) {
                this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
            }
        };
        /**
         * Reload the data without clearing the view.
         */
        InfiniteScrollDirective.prototype.reload = function () {
            var _this = this;
            this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
        };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        InfiniteScrollDirective.prototype.reloadPage = function (pageNum) {
            if (!this.enabled) {
                return;
            }
            this._updateRequests.next({
                check: false,
                pageNumber: pageNum,
                pageSize: this.pageSize,
                filter: this.coerceFilter(this.filter),
                reload: true
            });
        };
        /** A filter value of null or undefined should be considered the same as an empty string */
        InfiniteScrollDirective.prototype.coerceFilter = function (value) {
            return value === undefined || value === null ? '' : value;
        };
        /**
         * Attach scroll event handler and DOM observer.
         */
        InfiniteScrollDirective.prototype.attachEventHandlers = function () {
            // if the scrollElement is documentElement we must watch for a scroll event on the document
            var target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
            // Subscribe to the scroll event on the target element.
            this._scrollEventSub = rxjs.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
            // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
            // required after the initial load.
            this._domObserver = new MutationObserver(this.check.bind(this));
            this._domObserver.observe(this._scrollElement.nativeElement, {
                childList: true,
                subtree: true
            });
        };
        /**
         * Detach scroll event handler and DOM observer.
         */
        InfiniteScrollDirective.prototype.detachEventHandlers = function () {
            if (this._scrollEventSub) {
                this._scrollEventSub.unsubscribe();
                this._scrollEventSub = null;
            }
            if (this._domObserver) {
                this._domObserver.disconnect();
                this._domObserver = null;
            }
        };
        /**
         * Remove any existing event subscriptions for the load button `loading` event, then attach
         * subscriptions
         * for any in the query.
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents = function () {
            var _this = this;
            this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
            this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.loading.subscribe(_this.loadNextPage.bind(_this)); });
        };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         */
        InfiniteScrollDirective.prototype.doRequest = function (request) {
            var _this = this;
            // Load a new page if the scroll position is beyond the threshhold and if the client code did not
            // cancel.
            if (this.needsData(request) && this.beginLoading(request)) {
                // Invoke the callback load function, which returns a promose or plain data.
                var loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                var observable = Array.isArray(loadResult) ? rxjs.of(loadResult) : rxjs.from(loadResult);
                var completed_1 = false;
                var subscription_1;
                // subscription needs to be a let here if subscription completes right away the complete function can be called
                // before the assignment. While browsers will ignore this currently as we transpile
                // all const/let statements to var, when this is no longer the case (or we are running in a test environment)
                // const will be used and this can throw an error if we try to access a const variable before it is assigned
                subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                    // Make sure that the parameters have not changed since the load started;
                    // otherwise discard the results.
                    if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                        if (items && items.length) {
                            _this.setPageItems(request.pageNumber, items);
                        }
                        // Emit the loaded event
                        _this.endLoading(request, items);
                    }
                }, function (reason) {
                    // Emit the loadError event
                    _this.endLoadingWithError(request, reason);
                }, function () {
                    // remove this request from the list
                    _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    completed_1 = true;
                });
                // only add the subscription to the list of requests if it isnt complete.
                if (!completed_1) {
                    this._subscriptions.push(subscription_1);
                }
            }
        };
        /**
         * Returns true if the request should be fulfilled.
         */
        InfiniteScrollDirective.prototype.needsData = function (request) {
            if (!this.enabled) {
                return false;
            }
            // Always load for a load request
            if (!request.check) {
                return true;
            }
            // Ignore a check request when the end of data has been detected, or if data is currently loading.
            if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                return false;
            }
            // Load if the remaining scroll area is <= the element height.
            if (this._scrollElement && this.loadOnScroll) {
                var element = this._scrollElement.nativeElement;
                var remainingScroll = element.scrollHeight -
                    (element.scrollTop + element.clientHeight);
                return remainingScroll <= element.clientHeight;
            }
            return false;
        };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         */
        InfiniteScrollDirective.prototype.beginLoading = function (request) {
            var event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
            this.loadingEvent.emit(event);
            this._isLoading.next(!event.defaultPrevented());
            return !event.defaultPrevented();
        };
        InfiniteScrollDirective.prototype.setPageItems = function (pageNum, items) {
            this._pages[pageNum] = items;
            this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
        };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         */
        InfiniteScrollDirective.prototype.endLoading = function (request, data) {
            this._isLoading.next(false);
            var isExhausted = !!(data && data.length < this.pageSize);
            this._isExhausted.next(isExhausted);
            this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
            if (!request.reload) {
                this._nextPageNum += 1;
            }
        };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         */
        InfiniteScrollDirective.prototype.endLoadingWithError = function (request, error) {
            this._isLoading.next(false);
            this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
        };
        __decorate([
            core.Input('uxInfiniteScroll'),
            __metadata("design:type", Function)
        ], InfiniteScrollDirective.prototype, "load", void 0);
        __decorate([
            core.Input('collection'),
            __metadata("design:type", Array)
        ], InfiniteScrollDirective.prototype, "_collection", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], InfiniteScrollDirective.prototype, "scrollElement", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InfiniteScrollDirective.prototype, "enabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], InfiniteScrollDirective.prototype, "filter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InfiniteScrollDirective.prototype, "loadOnInit", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InfiniteScrollDirective.prototype, "loadOnScroll", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], InfiniteScrollDirective.prototype, "pageSize", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], InfiniteScrollDirective.prototype, "collectionChange", void 0);
        __decorate([
            core.Output('loading'),
            __metadata("design:type", Object)
        ], InfiniteScrollDirective.prototype, "loadingEvent", void 0);
        __decorate([
            core.Output('loaded'),
            __metadata("design:type", Object)
        ], InfiniteScrollDirective.prototype, "loadedEvent", void 0);
        __decorate([
            core.Output('loadError'),
            __metadata("design:type", Object)
        ], InfiniteScrollDirective.prototype, "loadErrorEvent", void 0);
        __decorate([
            core.ContentChildren(InfiniteScrollLoadButtonDirective),
            __metadata("design:type", core.QueryList)
        ], InfiniteScrollDirective.prototype, "_loadButtonQuery", void 0);
        __decorate([
            core.ContentChildren(InfiniteScrollLoadingDirective),
            __metadata("design:type", core.QueryList)
        ], InfiniteScrollDirective.prototype, "_loadingIndicatorQuery", void 0);
        InfiniteScrollDirective = __decorate([
            core.Directive({
                selector: '[uxInfiniteScroll]',
                exportAs: 'uxInfiniteScroll'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], InfiniteScrollDirective);
        return InfiniteScrollDirective;
    }());
    /**
     * The internal data associated with a load/check request.
     */
    var InfiniteScrollRequest = /** @class */ (function () {
        function InfiniteScrollRequest() {
        }
        return InfiniteScrollRequest;
    }());
    /**
     * Event raised before the `loading` function is called.
     */
    var InfiniteScrollLoadingEvent = /** @class */ (function () {
        function InfiniteScrollLoadingEvent(
        /**
         * The index of the requested page, starting from 0.
         */
        pageNumber, 
        /**
         * The number of items requested.
         */
        pageSize, 
        /**
         * The filter details as provided via the `filter` binding.
         */
        filter) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault = function () {
            this._defaultPrevented = true;
        };
        InfiniteScrollLoadingEvent.prototype.defaultPrevented = function () {
            return this._defaultPrevented;
        };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */
    var InfiniteScrollLoadedEvent = /** @class */ (function () {
        function InfiniteScrollLoadedEvent(
        /**
         * The index of the requested page, starting from 0.
         */
        pageNumber, 
        /**
         * The number of items requested.
         */
        pageSize, 
        /**
         * The filter details as provided via the `filter` binding.
         */
        filter, 
        /**
         * The result of the promise returned from the loading function.
         */
        data, 
        /**
         * True if the data is considered exhausted (number of items returned less than `pageSize`).
         */
        exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     */
    var InfiniteScrollLoadErrorEvent = /** @class */ (function () {
        function InfiniteScrollLoadErrorEvent(
        /**
         * The index of the requested page, starting from 0.
         */
        pageNumber, 
        /**
         * The number of items requested.
         */
        pageSize, 
        /**
         * The filter details as provided via the `filter` binding.
         */
        filter, 
        /**
         * The object provided when rejecting the promise.
         */
        error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());
    var InfiniteScrollModule = /** @class */ (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule = __decorate([
            core.NgModule({
                imports: [],
                exports: [
                    InfiniteScrollDirective,
                    InfiniteScrollLoadButtonDirective,
                    InfiniteScrollLoadingDirective
                ],
                declarations: [
                    InfiniteScrollDirective,
                    InfiniteScrollLoadButtonDirective,
                    InfiniteScrollLoadingDirective
                ],
                providers: [],
            })
        ], InfiniteScrollModule);
        return InfiniteScrollModule;
    }());
    var ScrollIntoViewService = /** @class */ (function () {
        function ScrollIntoViewService() {
        }
        ScrollIntoViewService.prototype.scrollIntoView = function (elem, scrollParent) {
            var offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
            if (offsetTop < scrollParent.scrollTop) {
                scrollParent.scrollTop = offsetTop;
            }
            else {
                var offsetBottom = offsetTop + elem.offsetHeight;
                if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                    scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                }
            }
        };
        ScrollIntoViewService = __decorate([
            core.Injectable()
        ], ScrollIntoViewService);
        return ScrollIntoViewService;
    }());
    var ScrollIntoViewIfDirective = /** @class */ (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        ScrollIntoViewIfDirective.prototype.ngOnChanges = function () {
            var _this = this;
            if (this.condition) {
                setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
            }
        };
        __decorate([
            core.Input('uxScrollIntoViewIf'),
            __metadata("design:type", Object)
        ], ScrollIntoViewIfDirective.prototype, "condition", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", HTMLElement)
        ], ScrollIntoViewIfDirective.prototype, "scrollParent", void 0);
        ScrollIntoViewIfDirective = __decorate([
            core.Directive({
                selector: '[uxScrollIntoViewIf]',
                providers: [ScrollIntoViewService]
            }),
            __metadata("design:paramtypes", [core.ElementRef, ScrollIntoViewService])
        ], ScrollIntoViewIfDirective);
        return ScrollIntoViewIfDirective;
    }());
    var ScrollIntoViewDirective = /** @class */ (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Allow a condition around whether or not this should scroll into view */
            this.uxScrollIntoView = true;
            /** Allow user to provide the browser supported options */
            this.scrollIntoViewOptions = true;
        }
        ScrollIntoViewDirective.prototype.ngAfterViewInit = function () {
            if (this.uxScrollIntoView) {
                this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ScrollIntoViewDirective.prototype, "uxScrollIntoView", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], ScrollIntoViewDirective.prototype, "scrollIntoViewOptions", void 0);
        ScrollIntoViewDirective = __decorate([
            core.Directive({
                selector: '[uxScrollIntoView]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ScrollIntoViewDirective);
        return ScrollIntoViewDirective;
    }());
    var ScrollModule = /** @class */ (function () {
        function ScrollModule() {
        }
        ScrollModule = __decorate([
            core.NgModule({
                exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
            })
        ], ScrollModule);
        return ScrollModule;
    }());
    var TypeaheadHighlightDirective = /** @class */ (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('uxTypeaheadHighlight'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TypeaheadHighlightDirective.prototype, "highlight", null);
        TypeaheadHighlightDirective = __decorate([
            core.Directive({
                selector: '[uxTypeaheadHighlight]'
            }),
            __metadata("design:paramtypes", [TypeaheadService, core.ElementRef])
        ], TypeaheadHighlightDirective);
        return TypeaheadHighlightDirective;
    }());
    var TypeaheadOptionsListComponent = /** @class */ (function () {
        function TypeaheadOptionsListComponent() {
            this.startIndex = 0;
            this.isMultiselectable = false;
            this.optionMouseover = new core.EventEmitter();
            this.optionMousedown = new core.EventEmitter();
            this.optionClick = new core.EventEmitter();
        }
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TypeaheadOptionsListComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TypeaheadOptionsListComponent.prototype, "startIndex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TypeaheadOptionsListComponent.prototype, "options", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TypeaheadOptionsListComponent.prototype, "highlighted", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TypeaheadOptionsListComponent.prototype, "activeKey", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TypeaheadOptionsListComponent.prototype, "disabledOptions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TypeaheadOptionsListComponent.prototype, "isMultiselectable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TypeaheadOptionsListComponent.prototype, "optionTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TypeaheadOptionsListComponent.prototype, "optionApi", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.ElementRef)
        ], TypeaheadOptionsListComponent.prototype, "typeaheadElement", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadOptionsListComponent.prototype, "optionMouseover", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadOptionsListComponent.prototype, "optionMousedown", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TypeaheadOptionsListComponent.prototype, "optionClick", void 0);
        TypeaheadOptionsListComponent = __decorate([
            core.Component({
                selector: 'ux-typeahead-options-list',
                template: "<ol>\n\n    <li *ngFor=\"let option of options; let i = index\"\n        [attr.id]=\"id + '-option-' + (i + startIndex)\"\n        [class.disabled]=\"option.isDisabled\"\n        [class.highlighted]=\"highlighted?.key === option.key && highlighted?.isRecentOption === option.isRecentOption\"\n        [class.active]=\"activeKey === option.key && !option.isRecentOption\"\n        [attr.aria-selected]=\"isMultiselectable ? option.isDisabled : (activeKey === option.key ? true : null)\"\n        [uxTypeaheadHighlight]=\"highlighted?.key === option.key && highlighted?.isRecentOption === option.isRecentOption\"\n        [uxScrollIntoViewIf]=\"highlighted?.key === option.key && highlighted?.isRecentOption === option.isRecentOption\"\n        [scrollParent]=\"typeaheadElement.nativeElement\"\n        (mouseover)=\"optionMouseover.emit({ option: option, event: $event })\"\n        (mousedown)=\"optionMousedown.emit({ option: option, event: $event })\"\n        (click)=\"optionClick.emit({ option: option, event: $event })\">\n\n        <ng-container [ngTemplateOutlet]=\"optionTemplate\"\n            [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n        </ng-container>\n\n    </li>\n\n</ol>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], TypeaheadOptionsListComponent);
        return TypeaheadOptionsListComponent;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function TYPEAHEAD_KEY_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new TypeaheadKeyService();
    }
    var TYPEAHEAD_KEY_SERVICE_PROVIDER = {
        provide: TypeaheadKeyService,
        deps: [[new core.Optional(), new core.SkipSelf(), TypeaheadKeyService]],
        useFactory: TYPEAHEAD_KEY_SERVICE_PROVIDER_FACTORY
    };
    var TypeaheadModule = /** @class */ (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    InfiniteScrollModule,
                    ResizeModule,
                    ScrollModule
                ],
                exports: [TypeaheadComponent],
                declarations: [
                    TypeaheadComponent,
                    TypeaheadHighlightDirective,
                    TypeaheadOptionsListComponent
                ],
                providers: [
                    PopoverOrientationService,
                    TYPEAHEAD_KEY_SERVICE_PROVIDER
                ]
            })
        ], TypeaheadModule);
        return TypeaheadModule;
    }());
    var FacetTypeaheadListItemComponent = /** @class */ (function () {
        function FacetTypeaheadListItemComponent() {
            this.selected = false;
            this.simplified = false;
            this.tabbable = false;
            this.itemFocus = new core.EventEmitter();
            this.selectedChange = new core.EventEmitter();
        }
        Object.defineProperty(FacetTypeaheadListItemComponent.prototype, "disabled", {
            get: function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        FacetTypeaheadListItemComponent.prototype.getLabel = function () {
            return this.facet ? this.facet.title : null;
        };
        FacetTypeaheadListItemComponent.prototype.focus = function () {
            this.option.nativeElement.focus();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Facet)
        ], FacetTypeaheadListItemComponent.prototype, "facet", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetTypeaheadListItemComponent.prototype, "selected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetTypeaheadListItemComponent.prototype, "simplified", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetTypeaheadListItemComponent.prototype, "tabbable", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetTypeaheadListItemComponent.prototype, "itemFocus", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetTypeaheadListItemComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.ViewChild('option', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], FacetTypeaheadListItemComponent.prototype, "option", void 0);
        FacetTypeaheadListItemComponent = __decorate([
            core.Component({
                selector: 'ux-facet-typeahead-list-item',
                template: "<div #option\n    uxFocusIndicator\n    role=\"option\"\n    class=\"facet-typeahead-list-selected-option\"\n    [attr.aria-checked]=\"selected\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\">\n\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-typeahead-list-selected-option-title\">{{ facet?.title }}</span>\n        <span *ngIf=\"facet?.count !== undefined\" class=\"facet-typeahead-list-selected-option-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], FacetTypeaheadListItemComponent);
        return FacetTypeaheadListItemComponent;
    }());
    var uniqueId$4 = 1;
    var FacetTypeaheadListComponent = /** @class */ (function () {
        function FacetTypeaheadListComponent(typeaheadKeyService, facetService, _announcer) {
            this.typeaheadKeyService = typeaheadKeyService;
            this.facetService = facetService;
            this._announcer = _announcer;
            /** Defines whether or not the Facet Typeahead List should be initially expanded or not. */
            this.expanded = true;
            /** Defines a list of facets which will be displayed above the typeahead to allow the user to quickly select some facets. */
            this.suggestions = [];
            /** Defines whether or not the checkboxes displayed alongside suggestions will appear in simplified form. */
            this.simplified = true;
            /** Emits the current query when the value of the input field changes. */
            this.queryChange = new core.EventEmitter();
            /**
             * This will be triggered when a facet is selected, deselected or all facets are deselected.
             * The event will be an instance of either `FacetSelect`, `FacetDeselect` or `FacetDeselectAll` and
             * will contain the facet being selected or deselected in a `facet` property (deselect all will not contain affected facets).
             */
            this.events = new rxjs.Subject();
            /** If two-way binding is used this array will get updated any time the selected facets change. */
            this.selectedChange = new core.EventEmitter();
            this.query$ = new rxjs.BehaviorSubject('');
            this.loading = false;
            this.activeIndex = 0;
            this.typeaheadId = "ux-facet-typeahead-" + uniqueId$4++;
            this.typeaheadOpen = false;
            this.typeaheadOptions = [];
            this._facets = [];
            this._selected = [];
            this._onDestroy = new rxjs.Subject();
            this._config = { placeholder: '', maxResults: 50, minCharacters: 1 };
        }
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "selected", {
            /** This will allow you to define an initial set of selected facets. */
            set: function (selection) {
                var _this = this;
                if (Array.isArray(selection)) {
                    selection.forEach(function (facet) { return _this.facetService.select(facet); });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "query", {
            /** Defines the query displayed in the input field. */
            set: function (query) {
                if (query !== this.query$.value) {
                    this.query$.next(query);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "typeaheadConfig", {
            get: function () {
                return this._config;
            },
            /**
             * Allows configuration of the typeahead control. The possible values are:
             * - `placeholder` - **string** - Sets the placeholder of the typeahead.
             * - `minCharacters` - **number** - Defines the minimum number of characters that are required before results will be shown. **Default**: `1`.
             * - `maxResults` - **number** - Sets the maximum number of results to display. **Default**: `50`.
             * - `delay` - **number** - Defines the number of milliseconds to wait before the results are filtered. **Default**: `0`.
             */
            set: function (config) {
                this._config = __assign({ placeholder: '', maxResults: 50, minCharacters: 1 }, config);
            },
            enumerable: true,
            configurable: true
        });
        FacetTypeaheadListComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.facetService.events$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // deselect all events should always be emitted
                if (event instanceof FacetDeselectAll) {
                    _this.events.next(event);
                    _this._selected = [];
                    _this.selectedChange.next(_this._selected);
                }
                // if deselected remove the facet from our internal list of selected facets
                if (event instanceof FacetDeselect && _this.isOwnFacet(event.facet)) {
                    if (_this._selected.indexOf(event.facet) !== -1) {
                        _this.events.next(event);
                        _this._selected = _this._selected.filter(function (_facet) { return _facet !== event.facet; });
                        _this.selectedChange.next(_this._selected);
                    }
                }
                // selection and deselection events should only be emitted when the facet belongs to this component
                if (event instanceof FacetSelect && _this.isOwnFacet(event.facet)) {
                    if (_this._selected.indexOf(event.facet) === -1) {
                        _this.events.next(event);
                        _this._selected = __spread(_this._selected, [event.facet]);
                        _this.selectedChange.next(_this._selected);
                    }
                }
            });
            // store the original list of all possible facets
            this.getFacetObservable().pipe(operators.first()).subscribe(function (facets) { return _this._facets = facets; });
        };
        FacetTypeaheadListComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // emit the latest query whenever it changes
            this.query$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged())
                .subscribe(function (query) { return _this.queryChange.emit(query); });
            // set up search query subscription
            this.query$.pipe(operators.takeUntil(this._onDestroy), tick(), operators.tap(function () {
                _this.loading = true;
                _this.typeaheadOptions = [];
            }), operators.mergeMap(function () {
                return _this.getFacetObservable().pipe(operators.map(function (facets) {
                    return facets.filter(function (facet) { return !facet.disabled && !_this.facetService.facets$.value.find(function (selectedFacet) { return selectedFacet === facet; }); })
                        .slice(0, _this._config.maxResults);
                }));
            })).subscribe(function (facets) {
                _this.loading = false;
                _this.typeaheadOptions = facets;
            });
            this._focusKeyManager = new a11y.FocusKeyManager(this.options).withVerticalOrientation();
            this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
        };
        FacetTypeaheadListComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        FacetTypeaheadListComponent.prototype.onKeydown = function (event) {
            this._focusKeyManager.onKeydown(event);
        };
        FacetTypeaheadListComponent.prototype.onFocus = function (index) {
            if (this._focusKeyManager.activeItemIndex === -1) {
                this._focusKeyManager.setActiveItem(index);
            }
        };
        FacetTypeaheadListComponent.prototype.toggleFacet = function (index, facet) {
            // toggle selection
            this.facetService.isSelected(facet) ? this.facetService.deselect(facet) : this.facetService.select(facet);
            // focus the correct item
            this._focusKeyManager.setActiveItem(index);
        };
        /** Only show typeahead if we have enough characters */
        FacetTypeaheadListComponent.prototype.updateTypeahead = function (query) {
            if (query === void 0) {
                query = '';
            }
            this.typeaheadOpen = query.length >= this._config.minCharacters;
        };
        FacetTypeaheadListComponent.prototype.getFacetObservable = function () {
            return rxjs.isObservable(this.facets) ? this.facets : rxjs.of(this.facets);
        };
        FacetTypeaheadListComponent.prototype.select = function (event) {
            // check to make sure that the item is not currently selected
            if (this.facetService.isSelected(event.option)) {
                return;
            }
            // select the facet
            this.facetService.select(event.option);
            // clear the typeahead
            this.query$.next('');
            // announce the selected facet
            this._announcer.announce(event.option.title + " selected.");
        };
        FacetTypeaheadListComponent.prototype.isOwnFacet = function (facet) {
            return this._facets ? this._facets.indexOf(facet) !== -1 : false;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], FacetTypeaheadListComponent.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FacetTypeaheadListComponent.prototype, "facets", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FacetTypeaheadListComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetTypeaheadListComponent.prototype, "expanded", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], FacetTypeaheadListComponent.prototype, "suggestions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FacetTypeaheadListComponent.prototype, "simplified", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], FacetTypeaheadListComponent.prototype, "query", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FacetTypeaheadListComponent.prototype, "queryChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", rxjs.Subject)
        ], FacetTypeaheadListComponent.prototype, "events", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FacetTypeaheadListComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FacetTypeaheadListComponent.prototype, "typeaheadConfig", null);
        __decorate([
            core.ViewChildren(FacetTypeaheadListItemComponent),
            __metadata("design:type", core.QueryList)
        ], FacetTypeaheadListComponent.prototype, "options", void 0);
        FacetTypeaheadListComponent = __decorate([
            core.Component({
                selector: 'ux-facet-typeahead-list',
                template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" role=\"listbox\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" tabindex=\"-1\" *ngIf=\"suggestions?.length > 0\">\n\n        <ux-facet-typeahead-list-item\n            *ngFor=\"let facet of suggestions; let index = index\"\n            [facet]=\"facet\"\n            [tabbable]=\"activeIndex === index\"\n            [selected]=\"facetService.isSelected(facet)\"\n            (selectedChange)=\"toggleFacet(index, facet)\"\n            (keydown)=\"onKeydown($event)\"\n            (itemFocus)=\"onFocus(index)\">\n        </ux-facet-typeahead-list-item>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\"\n            class=\"form-control\"\n            [placeholder]=\"typeaheadConfig?.placeholder\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            aria-autocomplete=\"list\"\n            aria-multiline=\"false\"\n            [attr.aria-controls]=\"typeaheadId\"\n            [ngModel]=\"query$ | async\"\n            (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n            (keydown)=\"typeaheadKeyService.handleKey($event, typeahead)\"\n            (blur)=\"typeaheadOpen = false\">\n\n        <ux-typeahead #typeahead\n            [id]=\"typeaheadId\"\n            [(open)]=\"typeaheadOpen\"\n            [loading]=\"loading\"\n            display=\"title\"\n            [options]=\"typeaheadOptions\"\n            [optionTemplate]=\"facetOptionTemplate\"\n            [selectOnEnter]=\"true\"\n            (optionSelected)=\"select($event)\"\n            (highlightedElementChange)=\"highlightedElement = $event\">\n        </ux-typeahead>\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-option=\"option\" let-api=\"api\">\n    <p class=\"facet-typeahead-list-option\" [attr.aria-label]=\"option.title\">\n        <span [innerHTML]=\"option.title | facetTypeaheadHighlight: (query$ | async)\"></span>\n        <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"option.count\">\n            ({{ option.count }})\n        </span>\n    </p>\n</ng-template>"
            }),
            __metadata("design:paramtypes", [TypeaheadKeyService, FacetService, a11y.LiveAnnouncer])
        ], FacetTypeaheadListComponent);
        return FacetTypeaheadListComponent;
    }());
    var FacetTypeaheadHighlight = /** @class */ (function () {
        function FacetTypeaheadHighlight() {
        }
        FacetTypeaheadHighlight.prototype.transform = function (value, searchQuery) {
            var regex = new RegExp(searchQuery, 'i');
            return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
        };
        FacetTypeaheadHighlight = __decorate([
            core.Pipe({
                name: 'facetTypeaheadHighlight'
            })
        ], FacetTypeaheadHighlight);
        return FacetTypeaheadHighlight;
    }());
    var ReorderableHandleDirective = /** @class */ (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective = __decorate([
            core.Directive({
                selector: '[uxReorderableHandle]'
            })
        ], ReorderableHandleDirective);
        return ReorderableHandleDirective;
    }());
    var ReorderableModelDirective = /** @class */ (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], ReorderableModelDirective.prototype, "uxReorderableModel", void 0);
        ReorderableModelDirective = __decorate([
            core.Directive({
                selector: '[uxReorderableModel]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ReorderableModelDirective);
        return ReorderableModelDirective;
    }());
    // @ts-ignore
    var dragula = (dragulaNamespace || {}).default || dragulaNamespace;
    var ReorderableService = /** @class */ (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        ReorderableService.prototype.getUniqueGroupName = function () {
            return '_uxReorderable_' + this._uniqueGroupId++;
        };
        /**
         * Adds the container to the named group.
         */
        ReorderableService.prototype.register = function (groupName, container) {
            if (!this._groups[groupName]) {
                this._groups[groupName] = new ReorderableGroup();
            }
            this._groups[groupName].register(container);
            return this._groups[groupName];
        };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        ReorderableService.prototype.unregister = function (groupName, container) {
            var group = this._groups[groupName];
            if (group) {
                group.unregister(container);
                if (group.isEmpty()) {
                    group.destroy();
                    delete this._groups[groupName];
                }
            }
        };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        ReorderableService.prototype.initialize = function (groupName) {
            var group = this._groups[groupName];
            if (group) {
                group.initialize();
            }
            return group;
        };
        /**
         * Returns the group object for the given name.
         */
        ReorderableService.prototype.getGroup = function (group) {
            return this._groups[group];
        };
        ReorderableService = __decorate([
            core.Injectable()
        ], ReorderableService);
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var ReorderableGroup = /** @class */ (function () {
        function ReorderableGroup() {
            this.drag = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.cancel = new core.EventEmitter();
            this.cloned = new core.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        ReorderableGroup.prototype.isEmpty = function () {
            return this._containers.length === 0;
        };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        ReorderableGroup.prototype.getModelForElement = function (element) {
            var e_1, _a;
            try {
                for (var _b = __values(this._containers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var container = _c.value;
                    var model = container.getModelFromElement(element);
                    if (model) {
                        return model;
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            return null;
        };
        /**
         * Adds the container to the group.
         */
        ReorderableGroup.prototype.register = function (container) {
            this._containers.push(container);
            if (this._instance) {
                this._instance.containers = this._containers.map(function (c) { return c.element; });
            }
            if (!this._config.mirrorContainer) {
                this._config.mirrorContainer = container.element;
            }
        };
        /**
         * Removes the container from the group.
         */
        ReorderableGroup.prototype.unregister = function (container) {
            var index = this._containers.indexOf(container);
            if (index >= 0) {
                this._containers.splice(index, 1);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
            }
        };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        ReorderableGroup.prototype.initialize = function () {
            var _this = this;
            if (this._instance) {
                return;
            }
            this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
            this._instance.on('drag', function (element, source) {
                _this.drag.emit({
                    model: _this.getModelForElement(element),
                    element: element,
                    source: source
                });
            });
            this._instance.on('dragend', function (element) {
                _this.dragEnd.emit({
                    model: _this.getModelForElement(element),
                    element: element
                });
            });
            this._instance.on('drop', function (element, target, source, sibling) {
                _this.drop.emit({
                    model: _this.getModelForElement(element),
                    element: element,
                    target: target,
                    source: source,
                    sibling: sibling
                });
            });
            this._instance.on('cancel', function (element) {
                _this.cancel.emit({
                    model: _this.getModelForElement(element),
                    element: element
                });
            });
            this._instance.on('cloned', function (clone, element, type) {
                _this.cloned.emit({
                    clone: clone,
                    element: element,
                    type: type
                });
            });
        };
        /**
         * Destroys the dragula instance.
         */
        ReorderableGroup.prototype.destroy = function () {
            if (this._instance) {
                this._instance.destroy();
                this._instance = null;
            }
        };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         */
        ReorderableGroup.prototype.canMove = function (element, containerElement, handle) {
            var e_2, _a;
            try {
                for (var _b = __values(this._containers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var container = _c.value;
                    if (container.element.isSameNode(containerElement)) {
                        return container.canMove(element, containerElement, handle);
                    }
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        };
        return ReorderableGroup;
    }());
    var ReorderableDirective = /** @class */ (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            /** Determines if reordering is disabled. */
            this.reorderingDisabled = false;
            /**
             * This event will be triggered when the order changes and will contain an updated dataset containing the items
             * in their current order. This should be used when the list of items is generated using ngFor to ensure the
             * data remains in the same order for both the `uxReorderable` and `ngFor` directives.
             */
            this.reorderableModelChange = new core.EventEmitter();
            /** This event is triggered when a user begins dragging an item. The event will contain the element being moved. */
            this.reorderStart = new core.EventEmitter();
            /** This event is triggered when the item being dragged is returned to the same location as it began. The event will contain the element that was being moved. */
            this.reorderCancel = new core.EventEmitter();
            /** This event is triggered when a user has relocated an item. The event will contain the element that was moved. */
            this.reorderEnd = new core.EventEmitter();
            this.dragging = false;
            this._subscriptions = new rxjs.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        ReorderableDirective.prototype.ngOnInit = function () {
            var _this = this;
            // If no group name then generate a unique one for this instance only
            if (!this.reorderableGroup) {
                this.reorderableGroup = this._service.getUniqueGroupName();
            }
            this._container = {
                element: this._elementRef.nativeElement,
                getModelFromElement: this.getModelFromElement.bind(this),
                canMove: this.canMove.bind(this)
            };
            // Register for drag events on this element
            var group = this._service.register(this.reorderableGroup, this._container);
            this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
            this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
            this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
            this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
            this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
        };
        ReorderableDirective.prototype.ngAfterViewInit = function () {
            this._service.initialize(this.reorderableGroup);
        };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        ReorderableDirective.prototype.ngOnDestroy = function () {
            this._service.unregister(this.reorderableGroup, this._container);
            this._subscriptions.unsubscribe();
        };
        ReorderableDirective.prototype.onDrag = function (event) {
            this.dragging = true;
            this.reorderStart.emit({ element: event.element, model: event.model });
        };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        ReorderableDirective.prototype.onDrop = function (event) {
            // if there is no provided module we can skip this
            if (!this.reorderableModel) {
                return;
            }
            var changed = false;
            if (event.source.isSameNode(this._elementRef.nativeElement)) {
                // remove this model from the list of models
                var index = this.reorderableModel.indexOf(event.model);
                if (index >= 0) {
                    this.reorderableModel.splice(index, 1);
                    changed = true;
                }
            }
            if (event.target.isSameNode(this._elementRef.nativeElement)) {
                // get the position of sibling element
                var index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                    this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                    this.reorderableModel.length;
                // insert the model at its new location
                this.reorderableModel.splice(index, 0, event.model);
                changed = true;
            }
            // Emit event if any changes were made
            if (changed) {
                this.reorderableModelChange.emit(this.reorderableModel);
            }
        };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        ReorderableDirective.prototype.getModelFromElement = function (element) {
            var model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
            if (!model) {
                return null;
            }
            return model.uxReorderableModel;
        };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        ReorderableDirective.prototype.onDragEnd = function (event) {
            this.dragging = false;
            if (this._elementRef.nativeElement.contains(event.element)) {
                this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                this.reorderEnd.emit({
                    element: event.element,
                    model: event.model
                });
            }
        };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        ReorderableDirective.prototype.onClone = function (event) {
            if (this._elementRef.nativeElement.contains(event.element)) {
                this.setTableCellWidths(event.element, event.clone);
                this.captureCanvases(event.element, event.clone);
                this._renderer.addClass(event.element, 'ux-reorderable-moving');
            }
        };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        ReorderableDirective.prototype.canMove = function (element, container, handle) {
            if (this.reorderingDisabled) {
                return false;
            }
            return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
        };
        ReorderableDirective.prototype.setTableCellWidths = function (source, target) {
            // if it is not a table row then skip this
            if (source.tagName !== 'TR') {
                return;
            }
            // find any immediate td children and fix their width
            var sourceCells = Array.from(source.children);
            var targetCells = Array.from(target.children);
            // fix the width of these cells
            sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
        };
        ReorderableDirective.prototype.captureCanvases = function (source, target) {
            // find all child canvas elements
            var sourceCanvases = Array.from(source.querySelectorAll('canvas'));
            var targetCanvases = Array.from(target.querySelectorAll('canvas'));
            // replicate the canvas content
            targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], ReorderableDirective.prototype, "reorderableModel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ReorderableDirective.prototype, "reorderableGroup", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ReorderableDirective.prototype, "reorderingDisabled", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ReorderableDirective.prototype, "reorderableModelChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ReorderableDirective.prototype, "reorderStart", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ReorderableDirective.prototype, "reorderCancel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ReorderableDirective.prototype, "reorderEnd", void 0);
        __decorate([
            core.ContentChildren(ReorderableHandleDirective, { read: core.ElementRef, descendants: true }),
            __metadata("design:type", core.QueryList)
        ], ReorderableDirective.prototype, "handles", void 0);
        __decorate([
            core.ContentChildren(ReorderableModelDirective),
            __metadata("design:type", core.QueryList)
        ], ReorderableDirective.prototype, "models", void 0);
        __decorate([
            core.HostBinding('class.ux-reorderable-container-moving'),
            __metadata("design:type", Object)
        ], ReorderableDirective.prototype, "dragging", void 0);
        ReorderableDirective = __decorate([
            core.Directive({
                selector: '[uxReorderable]'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                ReorderableService])
        ], ReorderableDirective);
        return ReorderableDirective;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function REORDERABLE_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new ReorderableService();
    }
    var REORDERABLE_SERVICE_PROVIDER = {
        provide: ReorderableService,
        deps: [[new core.Optional(), new core.SkipSelf(), ReorderableService]],
        useFactory: REORDERABLE_SERVICE_PROVIDER_FACTORY
    };
    var ReorderableModule = /** @class */ (function () {
        function ReorderableModule() {
        }
        ReorderableModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                declarations: [
                    ReorderableDirective,
                    ReorderableHandleDirective,
                    ReorderableModelDirective
                ],
                exports: [
                    ReorderableDirective,
                    ReorderableHandleDirective,
                    ReorderableModelDirective
                ],
                providers: [
                    REORDERABLE_SERVICE_PROVIDER
                ]
            })
        ], ReorderableModule);
        return ReorderableModule;
    }());
    var DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetCheckListComponent,
        FacetCheckListItemComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadListItemComponent,
        FacetTypeaheadHighlight,
        FacetClearButtonDirective
    ];
    var FacetsModule = /** @class */ (function () {
        function FacetsModule() {
        }
        FacetsModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    CheckboxModule,
                    common.CommonModule,
                    forms.FormsModule,
                    IconModule,
                    ReorderableModule,
                    TooltipModule,
                    TypeaheadModule,
                ],
                exports: DECLARATIONS$1,
                declarations: DECLARATIONS$1
            })
        ], FacetsModule);
        return FacetsModule;
    }());
    var FilterAddEvent = /** @class */ (function () {
        function FilterAddEvent(filter) {
            this.filter = filter;
        }
        return FilterAddEvent;
    }());
    var FilterRemoveAllEvent = /** @class */ (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());
    var FilterRemoveEvent = /** @class */ (function () {
        function FilterRemoveEvent(filter) {
            this.filter = filter;
        }
        return FilterRemoveEvent;
    }());
    var FilterService = /** @class */ (function () {
        function FilterService() {
            /** The list of active filters */
            this.filters$ = new rxjs.BehaviorSubject([]);
            /** Emit all the events when they occur */
            this.events$ = new rxjs.Subject();
        }
        FilterService.prototype.add = function (filter) {
            // if the filter is already selected or it is the intial filter then do nothing
            if (this.isSelected(filter) || filter.initial) {
                return;
            }
            // update the list of active filters
            this.filters$.next(__spread(this.filters$.value, [filter]));
            // emit the event
            this.events$.next(new FilterAddEvent(filter));
        };
        FilterService.prototype.remove = function (filter) {
            // if the filter is not selected then do nothing
            if (!this.isSelected(filter)) {
                return;
            }
            // update the list of active filters
            this.filters$.next(this.filters$.value.filter(function (_filter) { return _filter !== filter; }));
            // emit the event
            this.events$.next(new FilterRemoveEvent(filter));
        };
        FilterService.prototype.removeAll = function () {
            // empty the list of active filters
            this.filters$.next([]);
            // emit the event
            this.events$.next(new FilterRemoveAllEvent());
        };
        FilterService.prototype.isSelected = function (filter) {
            return this.filters$.value.indexOf(filter) > -1;
        };
        FilterService = __decorate([
            core.Injectable()
        ], FilterService);
        return FilterService;
    }());
    var FilterContainerComponent = /** @class */ (function () {
        function FilterContainerComponent(filterService) {
            var _this = this;
            this.filterService = filterService;
            /** Defines the aria-label for the clear all button */
            this.clearAriaLabel = 'Clear All Filters';
            /** Emit when the active filters chance */
            this.filtersChange = new core.EventEmitter();
            /** Emit when a specific event occurs */
            this.events = new core.EventEmitter();
            /** Unsubscribe from the subscriptions on destroy */
            this._onDestroy = new rxjs.Subject();
            // subscribe to changes to the active filters
            filterService.filters$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged())
                .subscribe(function (filters) { return _this.filtersChange.emit(filters); });
            // relay any events to the event emitter
            this.filterService.events$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this.events.emit(event); });
        }
        Object.defineProperty(FilterContainerComponent.prototype, "filters", {
            /** Allow filters to set from outside the component */
            set: function (filters) { this.filterService.filters$.next(filters); },
            enumerable: true,
            configurable: true
        });
        /** Destroy all subscriptions */
        FilterContainerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], FilterContainerComponent.prototype, "filters", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FilterContainerComponent.prototype, "clearTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FilterContainerComponent.prototype, "clearAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FilterContainerComponent.prototype, "filtersChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FilterContainerComponent.prototype, "events", void 0);
        __decorate([
            core.ContentChild('clearAllTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], FilterContainerComponent.prototype, "clearAllTemplate", void 0);
        FilterContainerComponent = __decorate([
            core.Component({
                selector: 'ux-filter-container',
                template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<button type=\"button\"\n    class=\"btn btn-link btn-secondary m-l-xs\"\n    [class.table-filter-clear]=\"clearAllTemplate\"\n    [class.btn-icon]=\"!clearAllTemplate\"\n    tabindex=\"0\"\n    [attr.aria-label]=\"clearAriaLabel\"\n    *ngIf=\"(filterService.filters$ | async).length > 0\"\n    [uxTooltip]=\"clearTooltip || 'Clear All'\"\n    (click)=\"filterService.removeAll()\">\n    <ng-container [ngTemplateOutlet]=\"clearAllTemplate || defaultClearAllTemplate\">\n    </ng-container>\n</button>\n\n<ng-template #defaultClearAllTemplate>\n    <svg class=\"filter-selected-clear-graphic\" width=\"100%\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n</ng-template>\n",
                providers: [FilterService]
            }),
            __metadata("design:paramtypes", [FilterService])
        ], FilterContainerComponent);
        return FilterContainerComponent;
    }());
    var FilterDropdownComponent = /** @class */ (function () {
        function FilterDropdownComponent(_filterService) {
            var _this = this;
            this._filterService = _filterService;
            /** The list of items to display in the dropdown */
            this.filters = [];
            this._onDestroy = new rxjs.Subject();
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        FilterDropdownComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.selected = this.initial;
            // check to see if any of the filters have been preselected or changes to selected filters
            this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                filters.forEach(function (filter) {
                    if (_this.filters.indexOf(filter) !== -1) {
                        _this.selected = filter;
                    }
                });
            });
        };
        FilterDropdownComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        FilterDropdownComponent.prototype.selectFilter = function (filter, event) {
            this.removeFilter();
            this.selected = filter;
            this._filterService.add(this.selected);
            event.stopPropagation();
            event.preventDefault();
        };
        FilterDropdownComponent.prototype.removeFilter = function () {
            this._filterService.remove(this.selected);
            this.selected = this.initial;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], FilterDropdownComponent.prototype, "filters", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FilterDropdownComponent.prototype, "initial", void 0);
        FilterDropdownComponent = __decorate([
            core.Component({
                selector: 'ux-filter-dropdown',
                template: "<div class=\"btn-group\">\n    <button\n        type=\"button\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [class.active]=\"selected !== initial\"\n        [uxMenuTriggerFor]=\"menu\">\n        {{ selected?.group }} \n            <span class=\"filter-header\" *ngIf=\"selected !== initial\">\n                ({{ selected?.name }})\n            </span> \n        <ux-icon name=\"down\"></ux-icon>\n    </button>\n\n    <ux-menu #menu menuClass=\"ux-filter-menu\">\n        <button\n            type=\"button\"\n            *ngFor=\"let filter of filters\"\n            uxMenuItem\n            [attr.aria-selected]=\"filter === selected\"\n            (click)=\"selectFilter(filter, $event)\"\n            (keydown.enter)=\"selectFilter(filter, $event)\">\n\n            <ux-icon\n                name=\"checkmark\"\n                [style.visibility]=\"filter === selected ? 'visible' : 'hidden'\">\n            </ux-icon>\n\n            <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n        </button>\n    </ux-menu>\n</div>"
            }),
            __metadata("design:paramtypes", [FilterService])
        ], FilterDropdownComponent);
        return FilterDropdownComponent;
    }());
    var uniqueId$5 = 1;
    var FilterDynamicComponent = /** @class */ (function () {
        function FilterDynamicComponent(typeaheadKeyService, _filterService) {
            var _this = this;
            this.typeaheadKeyService = typeaheadKeyService;
            this._filterService = _filterService;
            /** The list of possible filter options */
            this.filters = [];
            /** Generate a unique id for the typeahead */
            this.typeaheadId = "ux-filter-dynamic-typeahead-" + uniqueId$5++;
            /** Store the current search query */
            this.query$ = new rxjs.BehaviorSubject('');
            /** Indicate whether or not the typeahead should be shown */
            this.showTypeahead = true;
            /** Store the items that should be displayed in the typeahead */
            this.typeaheadItems = [];
            /** Store the open state of the typeahead */
            this.typeaheadOpen = false;
            /** The default options */
            this._defaultOptions = { placeholder: '', minCharacters: 3, maxResults: Infinity };
            /** Store the user specified typeahead options */
            this._options = __assign({}, this._defaultOptions);
            /** Unsubscribe from all subscriptions */
            this._onDestroy = new rxjs.Subject();
            // listen for remove all events in which case we should deselect event initial filters
            _filterService.events$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; }))
                .subscribe(function () { return _this.removeFilter(); });
            // ensure that the current selected filter is still selected when the active filters change
            _filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                if (_this.selected && filters.indexOf(_this.selected) === -1) {
                    _this.removeFilter();
                }
            });
        }
        Object.defineProperty(FilterDynamicComponent.prototype, "options", {
            /** Get the options with the defaults for any missing options */
            get: function () {
                return __assign(__assign({}, this._defaultOptions), this._options);
            },
            /** Specify the typeahead options */
            set: function (options) { this._options = options; },
            enumerable: true,
            configurable: true
        });
        /** Set up the initial conditions */
        FilterDynamicComponent.prototype.ngOnInit = function () {
            var _this = this;
            // The initially selected item should be set the the specified initial item
            this.selected = this.initial;
            // watch for changes to the selected filters
            this._filterService.filters$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (filters) {
                filters.forEach(function (filter) {
                    if (_this.filters.indexOf(filter) !== -1) {
                        _this.selected = filter;
                    }
                });
            });
            // get the items to be displayed in the typeahead
            this.typeaheadItems = this.getItems();
            // determine if we should show the typeahead control
            if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                this.showTypeahead = false;
            }
        };
        /** Cleanup all subscriptions */
        FilterDynamicComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Get the items to display in the typeahead based on the search query */
        FilterDynamicComponent.prototype.getItems = function () {
            var _this = this;
            var query = this.query$.value.toLowerCase();
            return this.filters.filter(function (item) { return item !== _this.initial && item.name.toLowerCase().indexOf(query) !== -1; })
                .map(function (item) { return item.name; })
                .slice(0, this._options.maxResults);
        };
        /** When the dropdown is closed clear the query */
        FilterDynamicComponent.prototype.onClose = function () {
            this.query$.next('');
        };
        /** If a filter needs removed, and is not the initial filter then remove it */
        FilterDynamicComponent.prototype.removeFilter = function () {
            // check if the filter we want to remove is the initial filter
            if (this.selected !== this.initial) {
                this._filterService.remove(this.selected);
                this.selected = this.initial;
            }
            // clear the search query
            this.query$.next('');
        };
        /** Select a specific filter */
        FilterDynamicComponent.prototype.selectFilter = function (filter) {
            // clear any current filters
            this.removeFilter();
            // store the newly selected filter
            this.selected = filter;
            // store the filter in the service
            this._filterService.add(this.selected);
        };
        /** Update typeahead items and visibility */
        FilterDynamicComponent.prototype.updateTypeahead = function (query) {
            this.typeaheadOpen = query.length >= this._options.minCharacters;
            this.typeaheadItems = this.getItems();
        };
        /** Select a filter from a typeahead item */
        FilterDynamicComponent.prototype.select = function (event) {
            // find the filter with the matching name
            var filter = this.filters.find(function (_filter) { return _filter.name === event.option; });
            if (filter) {
                this.selectFilter(filter);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], FilterDynamicComponent.prototype, "filters", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FilterDynamicComponent.prototype, "initial", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], FilterDynamicComponent.prototype, "options", null);
        FilterDynamicComponent = __decorate([
            core.Component({
                selector: 'ux-filter-dynamic',
                template: "<div class=\"btn-group ux-dynamic-filter\">\n\n    <button\n        type=\"button\"\n        [class.active]=\"selected !== initial\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [uxMenuTriggerFor]=\"menu\"\n        #trigger=\"ux-menu-trigger\">\n        {{ selected?.group }}\n            <span class=\"filter-header\" *ngIf=\"selected !== initial\">\n                ({{ selected?.name }})\n            </span>\n        <ux-icon name=\"down\"></ux-icon>\n    </button>\n\n    <ux-menu #menu menuClass=\"ux-dynamic-filter-menu\" (closed)=\"onClose()\">\n        <!-- Initial Option -->\n        <button\n            uxMenuItem\n            *ngIf=\"showTypeahead\"\n            (click)=\"removeFilter()\"\n            (keydown.enter)=\"removeFilter()\">\n            <ux-icon\n                name=\"checkmark\"\n                [style.visibility]=\"initial === selected ? 'visible' : 'hidden'\">\n            </ux-icon>\n            <span class=\"filter-dropdown-title\">\n                {{ initial.name }}\n            </span>\n        </button>\n\n        <!-- Selected Options -->\n        <button uxMenuItem *ngIf=\"selected !== initial && showTypeahead\">\n            <ux-icon name=\"checkmark\"></ux-icon>\n            <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n        </button>\n\n        <ux-menu-divider *ngIf=\"showTypeahead\"></ux-menu-divider>\n\n        <div *ngIf=\"showTypeahead\" class=\"typeahead-box\" role=\"none\">\n\n            <input type=\"text\"\n                class=\"form-control\"\n                [placeholder]=\"options?.placeholder\"\n                [attr.aria-activedescendant]=\"highlightedElement?.id\"\n                [attr.aria-controls]=\"typeaheadId\"\n                aria-autocomplete=\"list\"\n                aria-multiline=\"false\"\n                [ngModel]=\"query$ | async\"\n                (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n                (keydown)=\"typeaheadKeyService.handleKey($event, typeahead); $event.stopPropagation();\"\n                (keydown.enter)=\"$event.preventDefault()\"\n                (blur)=\"typeaheadOpen = false\"\n                (click)=\"$event.stopPropagation()\">\n\n            <ux-typeahead #typeahead\n                [id]=\"typeaheadId\"\n                [(open)]=\"typeaheadOpen\"\n                display=\"title\"\n                [selectOnEnter]=\"true\"\n                [options]=\"typeaheadItems\"\n                [optionTemplate]=\"filterOptionTemplate\"\n                (optionSelected)=\"select($event); trigger.closeMenu($event.origin)\"\n                (highlightedElementChange)=\"highlightedElement = $event\">\n            </ux-typeahead>\n        </div>\n\n        <ng-container *ngIf=\"!showTypeahead\">\n\n            <button\n                *ngFor=\"let filter of filters\"\n                type=\"button\"\n                uxMenuItem\n                (click)=\"selectFilter(filter); trigger.closeMenu('mouse')\"\n                (keydown.enter)=\"selectFilter(filter); trigger.closeMenu('keyboard')\">\n\n                <ux-icon\n                    name=\"checkmark\"\n                    [style.visibility]=\"filter === selected ? 'visible' : 'hidden'\">\n                </ux-icon>\n\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </button>\n\n        </ng-container>\n\n    </ux-menu>\n</div>\n\n<ng-template #filterOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span [attr.aria-label]=\"option\" [innerHTML]=\"option | filterTypeaheadHighlight: (query$ | async)\"></span>\n</ng-template>"
            }),
            __metadata("design:paramtypes", [TypeaheadKeyService, FilterService])
        ], FilterDynamicComponent);
        return FilterDynamicComponent;
    }());
    var FilterTypeaheadHighlight = /** @class */ (function () {
        function FilterTypeaheadHighlight() {
        }
        FilterTypeaheadHighlight.prototype.transform = function (value, searchQuery) {
            var regex = new RegExp(searchQuery, 'i');
            return value.replace(regex, "<b class=\"filter-typeahead-highlighted\">" + value.match(regex) + "</b>");
        };
        FilterTypeaheadHighlight = __decorate([
            core.Pipe({
                name: 'filterTypeaheadHighlight'
            })
        ], FilterTypeaheadHighlight);
        return FilterTypeaheadHighlight;
    }());
    var MenuDividerComponent = /** @class */ (function () {
        function MenuDividerComponent() {
        }
        MenuDividerComponent = __decorate([
            core.Component({
                selector: 'ux-menu-divider',
                template: "",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    role: 'separator'
                }
            })
        ], MenuDividerComponent);
        return MenuDividerComponent;
    }());
    /**
     * This is used to avoid having to do an `instanceof` check
     * which would cause a circular dependency between the
     * `MenuComponent` and `MenuItemComponent`
     */
    var MenuItemType;
    (function (MenuItemType) {
        MenuItemType[MenuItemType["Default"] = 0] = "Default";
        MenuItemType[MenuItemType["Custom"] = 1] = "Custom";
    })(MenuItemType || (MenuItemType = {}));
    var MENU_OPTIONS_TOKEN = new core.InjectionToken('MENU_OPTIONS_TOKEN');
    var MenuComponent = /** @class */ (function () {
        function MenuComponent(_changeDetector, _options) {
            this._changeDetector = _changeDetector;
            this._options = _options;
            /** Define the position of the menu */
            this.placement = 'bottom';
            /** Define the alignment of the menu */
            this.alignment = 'start';
            /** Define if we should animate the menu */
            this.animate = this._options && this._options.hasOwnProperty('animate') ? this._options.animate : true;
            /** Emit when the opening has begun (the opened EventEmitter waits until the animation has finished) */
            this.opening = new core.EventEmitter();
            /** Emit when the menu is opened */
            this.opened = new core.EventEmitter();
            /** Emit whenever closing has begun (the closed EventEmitter waits until animation has finished) */
            this.closing = new core.EventEmitter();
            /** Emit when the menu is closed */
            this.closed = new core.EventEmitter();
            /** Store the menu open state */
            this.isMenuOpen = false;
            /** Store the animation state */
            this._isAnimating = false;
            /** Determine if this is a submenu */
            this._isSubMenu = false;
            /** Emit when the focused item changes (we use this as the key manager is not instantiated until a late lifecycle hook) */
            this._activeItem$ = new rxjs.BehaviorSubject(null);
            /** Access allow a close event to propagate all the way up the submenus */
            this._closeAll$ = new rxjs.Subject();
            /** Emit keyboard events */
            this._onKeydown$ = new rxjs.Subject();
            /** Emit hover events */
            this._isHovering$ = new rxjs.BehaviorSubject(false);
            /** Emit focus events */
            this._isFocused$ = new rxjs.BehaviorSubject(false);
            /** Access all child menu items for accessibility purposes */
            this._items$ = new rxjs.BehaviorSubject([]);
            /** Automatically unsubscribe when the component is destroyed */
            this._onDestroy$ = new rxjs.Subject();
            /** Create an internal querylist to store the menu items */
            this._itemsList = new core.QueryList();
        }
        Object.defineProperty(MenuComponent.prototype, "_isExpanded", {
            get: function () {
                return this._menuItems.pipe(operators.switchMap(function (items) { return rxjs.merge.apply(void 0, __spread(items.map(function (item) { return item.isExpanded$; }))); }), operators.takeUntil(this._onDestroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuComponent.prototype, "_menuItemClick", {
            get: function () {
                return this._menuItems.pipe(operators.switchMap(function (items) { return rxjs.merge.apply(void 0, __spread(items.map(function (item) { return item.onClick$; }))); }), operators.takeUntil(this._onDestroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuComponent.prototype, "_menuItems", {
            /** Return only menu items an not custom tabbable items */
            get: function () {
                return this._items$.pipe(operators.map(function (items) { return items.filter(function (item) { return item.type === MenuItemType.Default; }); }));
            },
            enumerable: true,
            configurable: true
        });
        MenuComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // initialise the query list with the items
            this._items$.pipe(operators.takeUntil(this._onDestroy$)).subscribe(function (items) {
                // if no items has been marked as tabbable then this should be
                if (!_this._activeItem$.value && items.length > 0) {
                    _this._activeItem$.next(items[0]);
                }
                _this._itemsList.reset(items);
                _this._itemsList.notifyOnChanges();
            });
            // setup keyboard functionality
            this._keyManager = new a11y.FocusKeyManager(this._itemsList)
                .withVerticalOrientation()
                .withTypeAhead()
                .withWrap();
            // emit the tabbable item on change
            this._keyManager.change.pipe(operators.map(function () { return _this._keyManager.activeItem; }), operators.takeUntil(this._onDestroy$))
                .subscribe(function (item) { return _this._activeItem$.next(item); });
        };
        MenuComponent.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
            this._closeAll$.complete();
            this._isHovering$.complete();
            this._isFocused$.complete();
            this._activeItem$.complete();
            this._items$.complete();
        };
        /** Register a menu item - we do this do avoid `@ContentChildren` detecting submenu items */
        MenuComponent.prototype._addItem = function (item) {
            if (!this.hasItem(item)) {
                this._items$.next(__spread(this._items$.value, [item]));
            }
        };
        /** Remove an item */
        MenuComponent.prototype._removeItem = function (item) {
            if (this.hasItem(item)) {
                this._items$.next(this._items$.value.filter(function (_item) { return _item !== item; }));
            }
        };
        /** Determine if an item exists */
        MenuComponent.prototype.hasItem = function (item) {
            return !!this._items$.value.find(function (_item) { return _item === item; });
        };
        /** Internal function to set the open state and run change detection */
        MenuComponent.prototype._setMenuOpen = function (menuOpen) {
            // store the open state
            this.isMenuOpen = menuOpen;
            // if we are closing the menu reset some values
            if (!menuOpen) {
                this._isHovering$.next(false);
                this._isFocused$.next(false);
            }
            // the change detector is actually an instance of a ViewRef (which extends ChangeDetectorRef) when used within a component
            // and the ViewRef contains the destroyed state of the component which is more reliable
            // than setting a flag in ngOnDestroy as the component can be destroyed before
            // the lifecycle hook is called
            var viewRef = this._changeDetector;
            // check for changes - required to show the menu as we are using `*ngIf`
            if (!viewRef.destroyed) {
                this._changeDetector.detectChanges();
            }
            // emit the closing event
            menuOpen ? this.opening.emit() : this.closing.emit();
        };
        /** Track the animation state */
        MenuComponent.prototype._onAnimationStart = function () {
            this._isAnimating = true;
        };
        /** Track animation state and emit event when opening or closing */
        MenuComponent.prototype._onAnimationDone = function () {
            this._isAnimating = false;
            if (this.isMenuOpen) {
                this.opened.emit();
            }
            else {
                this.closed.emit();
            }
        };
        MenuComponent.prototype._closeMenu = function () {
            this._setMenuOpen(false);
        };
        /** Forward any keyboard events to the key manage for accessibility */
        MenuComponent.prototype._onKeydown = function (event) {
            this._keyManager.setFocusOrigin('keyboard').onKeydown(event);
            // emit the keydown event
            this._onKeydown$.next(event);
        };
        MenuComponent.prototype._onHoverStart = function () {
            this._isHovering$.next(true);
        };
        MenuComponent.prototype._onHoverEnd = function () {
            this._isHovering$.next(false);
        };
        MenuComponent.prototype._onFocus = function () {
            this._isFocused$.next(true);
        };
        MenuComponent.prototype._onBlur = function () {
            this._isFocused$.next(false);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuComponent.prototype, "placement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuComponent.prototype, "alignment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MenuComponent.prototype, "animate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuComponent.prototype, "menuClass", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuComponent.prototype, "opening", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuComponent.prototype, "opened", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuComponent.prototype, "closing", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuComponent.prototype, "closed", void 0);
        __decorate([
            core.ViewChild(core.TemplateRef, { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], MenuComponent.prototype, "templateRef", void 0);
        MenuComponent = __decorate([
            core.Component({
                selector: 'ux-menu',
                template: "<ng-template>\n    <div\n        *ngIf=\"isMenuOpen\"\n        class=\"ux-menu\"\n        [class.ux-sub-menu]=\"_isSubMenu\"\n        [class.ux-menu-placement-top]=\"placement === 'top'\"\n        [ngClass]=\"menuClass\"\n        @menuAnimation\n        [@.disabled]=\"!animate\"\n        (@menuAnimation.start)=\"_onAnimationStart()\"\n        (@menuAnimation.done)=\"_onAnimationDone()\"\n        (mouseenter)=\"_onHoverStart()\"\n        (mouseover)=\"_onHoverStart()\"\n        (mouseleave)=\"_onHoverEnd()\"\n        (focusin)=\"_onFocus()\"\n        (focusout)=\"_onBlur()\">\n        <ng-content></ng-content>\n    </div>\n</ng-template>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'menu'
                },
                animations: [
                    animations.trigger('menuAnimation', [
                        animations.transition(':enter', [
                            animations.style({ opacity: 0, transform: 'scaleY(0)' }),
                            animations.animate('200ms ease-out', animations.style({ opacity: 1, transform: 'none' })),
                        ]),
                        animations.transition(':leave', [
                            animations.animate('200ms ease-out', animations.style({ opacity: 0, transform: 'scaleY(0)' }))
                        ])
                    ]),
                ]
            }),
            __param(1, core.Optional()), __param(1, core.Inject(MENU_OPTIONS_TOKEN)),
            __metadata("design:paramtypes", [core.ChangeDetectorRef, Object])
        ], MenuComponent);
        return MenuComponent;
    }());
    var MenuItemComponent = /** @class */ (function () {
        function MenuItemComponent(_menu, _elementRef, _focusIndicatorService, _renderer) {
            this._menu = _menu;
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this._renderer = _renderer;
            /** Define if this item is disabled or not */
            this.disabled = false;
            /** Define the role of the element */
            this.role = 'menuitem';
            /** Indicate the type of the menu item */
            this.type = MenuItemType.Default;
            /** Store the current hover state */
            this.isHovered$ = new rxjs.BehaviorSubject(false);
            /** Store the current focus state */
            this.isFocused$ = new rxjs.BehaviorSubject(false);
            /** Store the current expanded state */
            this.isExpanded$ = new rxjs.BehaviorSubject(false);
            /** Emit when an item is clicked */
            this.onClick$ = new rxjs.Subject();
            /** Automatically unsubscribe from observables on destroy */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(MenuItemComponent.prototype, "isOpen", {
            /** Access the open state */
            get: function () {
                return this._menu.isMenuOpen;
            },
            enumerable: true,
            configurable: true
        });
        MenuItemComponent.prototype.ngOnInit = function () {
            var _this = this;
            // register this item in the MenuComponent
            this._menu._addItem(this);
            // we only want to show the focus indicator whenever the keyboard is used
            this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
            // subscribe to active item changes
            this._menu._activeItem$.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function (item) { return _this.setTabIndex(item === _this); });
        };
        MenuItemComponent.prototype.ngOnDestroy = function () {
            this._menu._removeItem(this);
            this.isHovered$.complete();
            this.isExpanded$.complete();
            this.isFocused$.complete();
            this.onClick$.complete();
            this._focusIndicator.destroy();
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        MenuItemComponent.prototype.focus = function (origin) {
            this._focusIndicator.focus(origin);
        };
        /** This function is built into the CDK manager to allow jumping to items based on text content */
        MenuItemComponent.prototype.getLabel = function () {
            return this._elementRef.nativeElement.textContent.trim();
        };
        MenuItemComponent.prototype._onMouseEnter = function () {
            this.isHovered$.next(true);
        };
        MenuItemComponent.prototype._onMouseLeave = function () {
            this.isHovered$.next(false);
        };
        MenuItemComponent.prototype._onFocus = function () {
            this.isFocused$.next(true);
        };
        MenuItemComponent.prototype._onBlur = function () {
            this.isFocused$.next(false);
        };
        MenuItemComponent.prototype._onClick = function (event) {
            if (!this.disabled) {
                this.onClick$.next(isKeyboardTrigger(event) ? 'keyboard' : 'mouse');
            }
        };
        /** Forward any keyboard events to the MenuComponent for accessibility */
        MenuItemComponent.prototype._onKeydown = function (event) {
            this._menu._onKeydown(event);
        };
        /** Update the tab index on this item */
        MenuItemComponent.prototype.setTabIndex = function (isTabbable) {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', isTabbable ? '0' : '-1');
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MenuItemComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuItemComponent.prototype, "role", void 0);
        __decorate([
            core.HostListener('mouseenter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onMouseEnter", null);
        __decorate([
            core.HostListener('mouseleave'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onMouseLeave", null);
        __decorate([
            core.HostListener('focus'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onFocus", null);
        __decorate([
            core.HostListener('blur'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onBlur", null);
        __decorate([
            core.HostListener('click', ['$event']),
            core.HostListener('keydown.enter', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onClick", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], MenuItemComponent.prototype, "_onKeydown", null);
        MenuItemComponent = __decorate([
            core.Component({
                selector: '[uxMenuItem]',
                template: "<ng-content></ng-content>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    '[attr.role]': 'role',
                    '[class.disabled]': 'disabled',
                    '[class.ux-menu-item]': 'true',
                    '[class.open]': 'isOpen'
                }
            }),
            __metadata("design:paramtypes", [MenuComponent,
                core.ElementRef,
                FocusIndicatorService,
                core.Renderer2])
        ], MenuItemComponent);
        return MenuItemComponent;
    }());
    var MenuTabbableItemDirective = /** @class */ (function () {
        function MenuTabbableItemDirective(_menu, _elementRef, _focusIndicatorService, _renderer) {
            this._menu = _menu;
            this._elementRef = _elementRef;
            this._focusIndicatorService = _focusIndicatorService;
            this._renderer = _renderer;
            /** Define if this item is disabled or not */
            this.disabled = false;
            /** Indicate the type of the menu item */
            this.type = MenuItemType.Default;
            /** Automatically unsubscribe when directive is destroyed */
            this._onDestroy$ = new rxjs.Subject();
        }
        MenuTabbableItemDirective.prototype.ngOnInit = function () {
            var _this = this;
            // register this item in the MenuComponent
            this._menu._addItem(this);
            // we only want to show the focus indicator whenever the keyboard is used
            this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
            // subscribe to active item changes
            this._menu._activeItem$.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function (item) { return _this.setTabIndex(item === _this); });
        };
        MenuTabbableItemDirective.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
            this._focusIndicator.destroy();
        };
        /** Focus this item with a given origin */
        MenuTabbableItemDirective.prototype.focus = function (origin) {
            this._focusIndicator.focus(origin);
        };
        /** This function is built into the CDK manager to allow jumping to items based on text content */
        MenuTabbableItemDirective.prototype.getLabel = function () {
            return this._elementRef.nativeElement.textContent.trim();
        };
        /** Forward any keyboard events to the MenuComponent for accessibility */
        MenuTabbableItemDirective.prototype._onKeydown = function (event) {
            this._menu._onKeydown(event);
        };
        /** Update the tab index on this item */
        MenuTabbableItemDirective.prototype.setTabIndex = function (isTabbable) {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'tabindex', isTabbable ? '0' : '-1');
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MenuTabbableItemDirective.prototype, "disabled", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], MenuTabbableItemDirective.prototype, "_onKeydown", null);
        MenuTabbableItemDirective = __decorate([
            core.Directive({
                selector: '[uxMenuTabbableItem]',
            }),
            __metadata("design:paramtypes", [MenuComponent,
                core.ElementRef,
                FocusIndicatorService,
                core.Renderer2])
        ], MenuTabbableItemDirective);
        return MenuTabbableItemDirective;
    }());
    var MenuTriggerDirective = /** @class */ (function () {
        function MenuTriggerDirective(_overlay, _elementRef, _viewContainerRef, _focusOrigin, _focusIndicatorService, _parentMenu, _menuItem) {
            this._overlay = _overlay;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._focusOrigin = _focusOrigin;
            this._focusIndicatorService = _focusIndicatorService;
            this._parentMenu = _parentMenu;
            this._menuItem = _menuItem;
            /** Determine if we should disable the trigger */
            this.disabled = false;
            /** Automatically unsubscribe on directive destroy */
            this._onDestroy$ = new rxjs.Subject();
        }
        MenuTriggerDirective_1 = MenuTriggerDirective;
        Object.defineProperty(MenuTriggerDirective.prototype, "_isSubmenuTrigger", {
            /** Determine if this triggers a submenu */
            get: function () {
                return !!this._parentMenu;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuTriggerDirective.prototype, "_isRootTrigger", {
            /** Determine if this is the root trigger */
            get: function () {
                return !this._isSubmenuTrigger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuTriggerDirective.prototype, "_menuShouldClose", {
            /** If this is a submenu we want to know when the mouse leaves the items or parent item */
            get: function () {
                if (!this._isSubmenuTrigger) {
                    return rxjs.of();
                }
                // This combined observable will essentially check for all of the combinations of events that can cause a menu
                // to remain open, for example:
                //
                // 1. Hovering over any item in the menu should keep the menu open
                // 2. Having any item in the menu focused should keep the menu open
                // 3. Having the parent menu item hovered should keep a submenu open
                // 4. Having the parent menu item focused should keep a submenu open
                // 5. Having a submenu open should keep the parent open (if the submenu meets one of the above conditions)
                //
                // We also debounce this because there is often a delay between a blur and a focus event or moving the mouse
                // from a menu item to a sub menu item, so we add this buffer time to prevent the menu from closing unexpectedly
                return rxjs.combineLatest(this.menu._isHovering$, this.menu._isFocused$, this._menuItem.isHovered$, this.menu._isExpanded, this._menuItem.isFocused$)
                    .pipe(operators.debounceTime(50), operators.filter(function (_a) {
                    var _b = __read(_a, 5), isHovered = _b[0], isFocused = _b[1], isItemHovered = _b[2], isExpanded = _b[3], isItemFocused = _b[4];
                    return !isHovered && !isFocused && !isItemHovered && !isExpanded && !isItemFocused;
                }));
            },
            enumerable: true,
            configurable: true
        });
        MenuTriggerDirective.prototype.ngOnInit = function () {
            var _this = this;
            // set up focus indicator handling
            this._focusIndicator = this._focusIndicatorService.monitor(this._elementRef.nativeElement);
            // if there is a parent menu then we should override the default initial
            // position to be to the right rather than beneath. Note this gets called
            // before ngOnInit in the MenuComponent so if the user specifies an explicit
            // position then it will still take precendence
            if (this._isSubmenuTrigger) {
                this.menu._isSubMenu = true;
                this.menu.placement = 'right';
            }
            // listen for the menu to open (after animation so we can focus the first item)
            this.menu.opened.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function () { return _this.menuDidOpen(); });
            // propagate the close event if it is triggered
            this.menu._closeAll$.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function (origin) { return _this.closeMenu(origin, true); });
            // handle keyboard events in the menu
            this.menu._onKeydown$.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function (event) { return _this.onMenuKeydown(event); });
        };
        MenuTriggerDirective.prototype.ngOnDestroy = function () {
            this.destroyMenu();
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        /** Open the menu */
        MenuTriggerDirective.prototype.openMenu = function () {
            var _this = this;
            // if the menu is already open then do nothing
            if (this.menu.isMenuOpen || this.disabled) {
                return;
            }
            // get or create an overlayRef
            var overlayRef = this.getOverlay();
            var portal = this.getPortal();
            // if the overlay is already attached do nothing
            if (overlayRef.hasAttached()) {
                return;
            }
            // attach the menu to the DOM
            overlayRef.attach(portal);
            // mark the menu as open
            this.menu._setMenuOpen(true);
            if (this._menuItem) {
                this._menuItem.isExpanded$.next(true);
            }
            // listen for a menu item to be selected
            this.menu._menuItemClick.pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                .subscribe(function (origin) { return _this.closeMenu(origin, true); });
            // subscribe to any close events
            this.didMenuClose().pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                .subscribe(function () { return _this.closeMenu(); });
            // listen for the menu to animate closed then destroy it
            this.menu.closed.pipe(operators.take(1), operators.takeUntil(this._onDestroy$))
                .subscribe(function () { return _this.destroyMenu(); });
        };
        /** Close a menu or submenu */
        MenuTriggerDirective.prototype.closeMenu = function (origin, closeParents) {
            if (closeParents === void 0) {
                closeParents = false;
            }
            // update the menu state
            this.menu._setMenuOpen(false);
            if (this._menuItem) {
                this._menuItem.isExpanded$.next(false);
            }
            // if we should close parents then propagate the event
            if (closeParents && this._parentMenu) {
                this._parentMenu._closeAll$.next(origin);
            }
            // we should focus the trigger element if this is the root trigger
            if (this._isRootTrigger) {
                this._focusIndicator.focus(origin);
            }
            return this.menu.closed;
        };
        /** Toggle the open state of a menu */
        MenuTriggerDirective.prototype.toggleMenu = function (event) {
            // if this occurs on a submenu trigger then we can skip
            if (this._isSubmenuTrigger) {
                return;
            }
            if (!this.menu._isAnimating) {
                // determine the focus origin based on whether or not a keyboard was used
                var origin_1 = event instanceof KeyboardEvent ? 'keyboard' : 'mouse';
                // set the correct focus origin - if triggered by an event then use the source otherwise it was programmatic
                this._focusOrigin.setOrigin(event ? origin_1 : 'program');
                // toggle the menu open state
                this.menu.isMenuOpen ? this.closeMenu(origin_1, true) : this.openMenu();
            }
            // the enter key will trigger the click event and therefore set the wrong focus origin
            // so we nee to ensure this doesn't happen
            if (event) {
                event.preventDefault();
            }
        };
        /** Submenus should be opened by hovering on the menu item */
        MenuTriggerDirective.prototype._onMouseEnter = function () {
            if (this._isSubmenuTrigger && !this._parentMenu._isAnimating) {
                this.openMenu();
            }
        };
        /** Pressing the escape key should close all menus */
        MenuTriggerDirective.prototype._onEscape = function () {
            if (this.menu.isMenuOpen) {
                this.closeMenu();
                // refocus the root trigger and show the focus ring
                if (this._isRootTrigger) {
                    this._focusIndicator.focus('keyboard');
                }
            }
        };
        /** Handle keyboard events for opening submenus */
        MenuTriggerDirective.prototype._onKeydown = function (event) {
            // arrow key in the correct direction should open the menu
            if (this.menu.placement === 'right' && event.keyCode === keycodes.RIGHT_ARROW ||
                this.menu.placement === 'left' && event.keyCode === keycodes.LEFT_ARROW ||
                this.menu.placement === 'top' && event.keyCode === keycodes.UP_ARROW ||
                this.menu.placement === 'bottom' && event.keyCode === keycodes.DOWN_ARROW) {
                this._focusOrigin.setOrigin('keyboard');
                // if the menu was opened by a click but we subsequently use the arrow keys focus the first item
                if (this.menu.isMenuOpen) {
                    this.menu._keyManager.setFocusOrigin('keyboard').setFirstItemActive();
                }
                else {
                    // otherwise open the menu
                    this.openMenu();
                }
                // prevent the browser from scrolling
                event.preventDefault();
            }
        };
        /** Remove the menu from the DOM */
        MenuTriggerDirective.prototype.destroyMenu = function () {
            // if the menu has been destroyed already then do nothing
            if (!this._overlayRef) {
                return;
            }
            // remove the overlay
            this._overlayRef.detach();
        };
        /** Create an overlay or return an existing instance */
        MenuTriggerDirective.prototype.getOverlay = function () {
            // if we have already created the overlay then reuse it
            if (this._overlayRef) {
                return this._overlayRef;
            }
            var _a = this.getOrigin(), originX = _a.originX, originY = _a.originY;
            var _b = this.getOverlayPosition(), overlayX = _b.overlayX, overlayY = _b.overlayY;
            // otherwise create a new one
            this._overlayRef = this._overlay.create({
                hasBackdrop: !this._isSubmenuTrigger,
                backdropClass: 'cdk-overlay-transparent-backdrop',
                scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                positionStrategy: this._overlay.position()
                    .flexibleConnectedTo(this._elementRef)
                    .withLockedPosition()
                    .withPositions([
                    { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY },
                    { originX: this.menu.alignment === 'start' ? 'end' : 'start', originY: originY, overlayX: overlayX, overlayY: overlayY },
                    { originX: originX, originY: this.menu.placement === 'bottom' ? 'top' : 'bottom', overlayX: overlayX, overlayY: overlayY },
                    { originX: this.menu.alignment === 'start' ? 'end' : 'start', originY: this.menu.placement === 'bottom' ? 'top' : 'bottom', overlayX: overlayX, overlayY: overlayY },
                ])
            });
            return this._overlayRef;
        };
        /** Create a Template portal if one does not already exist (or the template has changed) */
        MenuTriggerDirective.prototype.getPortal = function () {
            // if there is no portal or the templateRef has changed then create a new one
            if (!this._portal || this.menu.templateRef !== this._portal.templateRef) {
                this._portal = new portal.TemplatePortal(this.menu.templateRef, this._viewContainerRef);
            }
            return this._portal;
        };
        /** Get the origin position based on the specified tooltip placement */
        MenuTriggerDirective.prototype.getOrigin = function () {
            // ensure placement is defined
            this.menu.placement = this.menu.placement || 'bottom';
            if (this.menu.placement === 'top' || this.menu.placement === 'bottom') {
                return { originX: this.menu.alignment, originY: this.menu.placement };
            }
            if (this.menu.placement === 'left') {
                return { originX: 'start', originY: this.getVerticalAlignment() };
            }
            if (this.menu.placement === 'right') {
                return { originX: 'end', originY: this.getVerticalAlignment() };
            }
        };
        /** Calculate the overlay position based on the specified tooltip placement */
        MenuTriggerDirective.prototype.getOverlayPosition = function () {
            // ensure placement is defined
            this.menu.placement = this.menu.placement || 'top';
            if (this.menu.placement === 'top') {
                return { overlayX: this.menu.alignment, overlayY: 'bottom' };
            }
            if (this.menu.placement === 'bottom') {
                return { overlayX: this.menu.alignment, overlayY: 'top' };
            }
            if (this.menu.placement === 'left') {
                return { overlayX: 'end', overlayY: this.getVerticalAlignment() };
            }
            if (this.menu.placement === 'right') {
                return { overlayX: 'start', overlayY: this.getVerticalAlignment() };
            }
        };
        /** Convert the alignment property to a valid CDK alignment value */
        MenuTriggerDirective.prototype.getVerticalAlignment = function () {
            switch (this.menu.alignment) {
                case 'start':
                    return 'top';
                case 'end':
                    return 'bottom';
                default:
                    return this.menu.alignment;
            }
        };
        /** Get an observable that emits on any of the triggers that close a menu */
        MenuTriggerDirective.prototype.didMenuClose = function () {
            return rxjs.merge(this._overlayRef.backdropClick(), this._overlayRef.detachments(), this._parentMenu ? this._parentMenu.closing : rxjs.of(), this._menuShouldClose);
        };
        /** When the menu opens we want to focus the first item in the list */
        MenuTriggerDirective.prototype.menuDidOpen = function () {
            // if the keyboard is used we should always focus and show the indicator
            // regardless of it this is the root menu or not
            if (this._focusOrigin.getOrigin() === 'keyboard') {
                this.menu._keyManager.setFocusOrigin('keyboard').setFirstItemActive();
            }
        };
        /** Handle keypresses in submenus where we may want to close them */
        MenuTriggerDirective.prototype.onMenuKeydown = function (event) {
            // if we are a submenu and the user presses an arrow key in the opposite
            // direction than it is positioned from its parents then we should close the menu
            if (this._parentMenu) {
                if (this.menu.placement === 'right' && event.keyCode === keycodes.LEFT_ARROW ||
                    this.menu.placement === 'left' && event.keyCode === keycodes.RIGHT_ARROW ||
                    this.menu.placement === 'top' && event.keyCode === keycodes.DOWN_ARROW ||
                    this.menu.placement === 'bottom' && event.keyCode === keycodes.UP_ARROW) {
                    this.closeMenu();
                    // refocus the parent menu item
                    this._menuItem.focus('keyboard');
                }
            }
        };
        var MenuTriggerDirective_1;
        __decorate([
            core.Input('uxMenuTriggerFor'),
            __metadata("design:type", MenuComponent)
        ], MenuTriggerDirective.prototype, "menu", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MenuTriggerDirective.prototype, "disabled", void 0);
        __decorate([
            core.ContentChildren(MenuTriggerDirective_1),
            __metadata("design:type", core.QueryList)
        ], MenuTriggerDirective.prototype, "menuTriggers", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            core.HostListener('keydown.enter', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], MenuTriggerDirective.prototype, "toggleMenu", null);
        __decorate([
            core.HostListener('mouseenter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuTriggerDirective.prototype, "_onMouseEnter", null);
        __decorate([
            core.HostListener('document:keydown.escape'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuTriggerDirective.prototype, "_onEscape", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], MenuTriggerDirective.prototype, "_onKeydown", null);
        MenuTriggerDirective = MenuTriggerDirective_1 = __decorate([
            core.Directive({
                selector: '[uxMenuTriggerFor]',
                exportAs: 'ux-menu-trigger',
                host: {
                    '[attr.aria-haspopup]': '!!menu',
                    '[attr.aria-expanded]': 'menu?.isMenuOpen'
                }
            }),
            __param(5, core.Optional()),
            __param(6, core.Optional()), __param(6, core.Self()),
            __metadata("design:paramtypes", [overlay.Overlay,
                core.ElementRef,
                core.ViewContainerRef,
                FocusIndicatorOriginService,
                FocusIndicatorService,
                MenuComponent,
                MenuItemComponent])
        ], MenuTriggerDirective);
        return MenuTriggerDirective;
    }());
    var MenuModule = /** @class */ (function () {
        function MenuModule() {
        }
        MenuModule_1 = MenuModule;
        MenuModule.forRoot = function (options) {
            return {
                ngModule: MenuModule_1,
                providers: [
                    { provide: MENU_OPTIONS_TOKEN, useValue: options }
                ]
            };
        };
        /** Support options at a child module level (implementation is the same as `forRoot`) */
        MenuModule.forChild = function (options) {
            return MenuModule_1.forRoot(options);
        };
        var MenuModule_1;
        MenuModule = MenuModule_1 = __decorate([
            core.NgModule({
                declarations: [
                    MenuComponent,
                    MenuTriggerDirective,
                    MenuItemComponent,
                    MenuDividerComponent,
                    MenuTabbableItemDirective
                ],
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    overlay.OverlayModule
                ],
                exports: [
                    MenuComponent,
                    MenuTriggerDirective,
                    MenuItemComponent,
                    MenuDividerComponent,
                    MenuTabbableItemDirective
                ]
            })
        ], MenuModule);
        return MenuModule;
    }());
    var DECLARATIONS$2 = [
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent,
        FilterTypeaheadHighlight
    ];
    var FilterModule = /** @class */ (function () {
        function FilterModule() {
        }
        FilterModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    IconModule,
                    MenuModule,
                    TooltipModule,
                    TypeaheadModule,
                ],
                exports: DECLARATIONS$2,
                declarations: DECLARATIONS$2
            })
        ], FilterModule);
        return FilterModule;
    }());
    var FlippableCardComponent = /** @class */ (function () {
        function FlippableCardComponent(focusIndicatorService, elementRef) {
            /** Determines whether the card should flip horizontally or vertically. */
            this.direction = 'horizontal';
            /**
             * Determines when the card should flip. Possible options are `click`, `hover` and `manual`.
             * The manual option should be used if you want complete control over when the card should flip.
             */
            this.trigger = 'hover';
            /** Sets the width (in pixels) of the card. */
            this.width = 280;
            /** Sets the height (in pixels) of the card. */
            this.height = 200;
            /** Determines whether or not the card is flipped. */
            this.flipped = false;
            /** If two way binding is used this value will be updated when the state of the card changes. */
            this.flippedChange = new core.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        FlippableCardComponent.prototype.ngOnDestroy = function () {
            this._focusIndicator.destroy();
        };
        FlippableCardComponent.prototype.setFlipped = function (state) {
            this.flipped = state;
            this.flippedChange.emit(this.flipped);
        };
        FlippableCardComponent.prototype.toggleFlipped = function () {
            this.setFlipped(!this.flipped);
        };
        FlippableCardComponent.prototype.clickTrigger = function () {
            // add or remove the class depending on whether or not the card has been flipped
            if (this.trigger === 'click') {
                this.toggleFlipped();
            }
        };
        FlippableCardComponent.prototype.hoverEnter = function () {
            // if the trigger is hover then begin to flip
            if (this.trigger === 'hover') {
                this.setFlipped(true);
            }
        };
        FlippableCardComponent.prototype.hoverExit = function () {
            if (this.trigger === 'hover') {
                this.setFlipped(false);
            }
        };
        FlippableCardComponent.prototype.onKeyDown = function (event) {
            if (this.trigger !== 'manual') {
                this.toggleFlipped();
                event.preventDefault();
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FlippableCardComponent.prototype, "direction", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FlippableCardComponent.prototype, "trigger", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], FlippableCardComponent.prototype, "width", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], FlippableCardComponent.prototype, "height", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], FlippableCardComponent.prototype, "flipped", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FlippableCardComponent.prototype, "flippedChange", void 0);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], FlippableCardComponent.prototype, "clickTrigger", null);
        __decorate([
            core.HostListener('mouseenter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], FlippableCardComponent.prototype, "hoverEnter", null);
        __decorate([
            core.HostListener('mouseleave'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], FlippableCardComponent.prototype, "hoverExit", null);
        __decorate([
            core.HostListener('keydown.enter', ['$event']),
            core.HostListener('keydown.space', ['$event']),
            core.HostListener('keydown.spacebar', ['$event']) // IE uses different naming
            ,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], FlippableCardComponent.prototype, "onKeyDown", null);
        FlippableCardComponent = __decorate([
            core.Component({
                selector: 'ux-flippable-card',
                template: "<div class=\"ux-flipper\"\n     [class.ux-flip-card]=\"flipped\"\n     [style.width.px]=\"width\"\n     [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"flipped\">\n\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"!flipped\">\n\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                host: {
                    'tabindex': '0',
                    '[class.horizontal]': 'direction === "horizontal"',
                    '[class.vertical]': 'direction === "vertical"'
                },
                exportAs: 'ux-flippable-card',
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [FocusIndicatorService, core.ElementRef])
        ], FlippableCardComponent);
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = /** @class */ (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective = __decorate([
            core.Directive({
                selector: 'ux-flippable-card-front'
            })
        ], FlippableCardFrontDirective);
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = /** @class */ (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective = __decorate([
            core.Directive({
                selector: 'ux-flippable-card-back'
            })
        ], FlippableCardBackDirective);
        return FlippableCardBackDirective;
    }());
    var FlippableCardModule = /** @class */ (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule
                ],
                exports: [
                    FlippableCardComponent,
                    FlippableCardBackDirective,
                    FlippableCardFrontDirective
                ],
                declarations: [
                    FlippableCardComponent,
                    FlippableCardBackDirective,
                    FlippableCardFrontDirective
                ]
            })
        ], FlippableCardModule);
        return FlippableCardModule;
    }());
    var FloatingActionButtonsService = /** @class */ (function () {
        function FloatingActionButtonsService() {
            this.open$ = new rxjs.BehaviorSubject(false);
            this.direction$ = new rxjs.BehaviorSubject('top');
        }
        FloatingActionButtonsService.prototype.open = function () {
            this.open$.next(true);
        };
        FloatingActionButtonsService.prototype.toggle = function () {
            this.open$.next(!this.open$.getValue());
        };
        FloatingActionButtonsService.prototype.close = function () {
            this.open$.next(false);
            // make the first button tabbable again
            this.setPrimaryButtonFocusable();
        };
        FloatingActionButtonsService.prototype.isHorizontal = function () {
            return this.direction$.value === 'left' || this.direction$.value === 'right';
        };
        FloatingActionButtonsService.prototype.isVertical = function () {
            return this.direction$.value === 'top' || this.direction$.value === 'bottom';
        };
        FloatingActionButtonsService.prototype.setButtons = function (buttons) {
            var _this = this;
            this._buttons = buttons;
            // make the first button tabbable (after a delay to prevent expression changed error)
            requestAnimationFrame(function () { return _this.setPrimaryButtonFocusable(); });
        };
        /** Make only the first button tabbable */
        FloatingActionButtonsService.prototype.setPrimaryButtonFocusable = function () {
            this._buttons.forEach(function (btn) { return btn.tabindex$.next(btn.primary ? 0 : -1); });
        };
        FloatingActionButtonsService.prototype.focusPrimaryButton = function () {
            this.focus(this._buttons.find(function (btn) { return btn.primary; }));
        };
        FloatingActionButtonsService.prototype.focus = function (button) {
            // if the button is not defined then do nothing
            if (!button) {
                return;
            }
            // set the button tab index
            this._buttons.forEach(function (btn) { return btn.tabindex$.next(button === btn ? 0 : -1); });
            // apply the focus
            button.focus();
        };
        FloatingActionButtonsService.prototype.focusSibling = function (next) {
            // if the buttons are not visible then do nothing
            if (this.open$.value === false) {
                return;
            }
            // get the current focused item
            var button = this.getFocusedButton();
            if (next && button === this._buttons.last) {
                return this.focus(this._buttons.first);
            }
            else if (!next && button === this._buttons.first) {
                return this.focus(this._buttons.last);
            }
            // find the sibling button
            var sibling = this._buttons.toArray()[this.getButtonIndex(button) + (next ? 1 : -1)];
            // focus the next button
            this.focus(sibling);
        };
        FloatingActionButtonsService.prototype.getFocusedButton = function () {
            return this._buttons.find(function (btn) { return btn.tabindex$.value === 0; });
        };
        FloatingActionButtonsService.prototype.getButtonIndex = function (button) {
            return this._buttons.toArray().findIndex(function (btn) { return btn === button; });
        };
        FloatingActionButtonsService = __decorate([
            core.Injectable()
        ], FloatingActionButtonsService);
        return FloatingActionButtonsService;
    }());
    var FloatingActionButtonComponent = /** @class */ (function () {
        function FloatingActionButtonComponent(primary, fab, _tooltip) {
            this.fab = fab;
            this._tooltip = _tooltip;
            /** Determine if this is the primary button in the set */
            this.primary = false;
            /** Store the tabindex */
            this.tabindex$ = new rxjs.BehaviorSubject(-1);
            /** Unsubscribe from all observables on component destroy */
            this._onDestroy = new rxjs.Subject();
            this.primary = primary !== null;
        }
        FloatingActionButtonComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this._tooltip) {
                // ensure the tooltip gets hidden when the button is hidden
                this.fab.open$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (isOpen) { return !isOpen && !_this.primary; }))
                    .subscribe(function () { return _this._tooltip.hide(); });
            }
        };
        FloatingActionButtonComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        FloatingActionButtonComponent.prototype.focus = function () {
            this.button.nativeElement.focus();
        };
        FloatingActionButtonComponent.prototype.onFocus = function () {
            // ensure the tooltip gets shown
            if (this._tooltip) {
                this._tooltip.show();
            }
        };
        FloatingActionButtonComponent.prototype.onBlur = function () {
            // ensure the tooltip gets hidden
            if (this._tooltip) {
                this._tooltip.hide();
            }
        };
        FloatingActionButtonComponent.prototype.close = function () {
            this.fab.close();
        };
        FloatingActionButtonComponent.prototype.onKeydown = function (event) {
            switch (event.which) {
                case keycodes.UP_ARROW:
                    if (this.fab.isVertical()) {
                        this.fab.focusSibling(this.fab.direction$.value !== 'bottom');
                        event.preventDefault();
                    }
                    break;
                case keycodes.DOWN_ARROW:
                    if (this.fab.isVertical()) {
                        this.fab.focusSibling(this.fab.direction$.value === 'bottom');
                        event.preventDefault();
                    }
                    break;
                case keycodes.LEFT_ARROW:
                    if (this.fab.isHorizontal()) {
                        this.fab.focusSibling(this.fab.direction$.value !== 'right');
                        event.preventDefault();
                    }
                    break;
                case keycodes.RIGHT_ARROW:
                    if (this.fab.isHorizontal()) {
                        this.fab.focusSibling(this.fab.direction$.value === 'right');
                        event.preventDefault();
                    }
                    break;
                case keycodes.ENTER:
                    this.fab.focusPrimaryButton();
                    break;
                case keycodes.ESCAPE:
                    this.fab.focusPrimaryButton();
                    this.fab.close();
                    break;
            }
        };
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], FloatingActionButtonComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.ViewChild('button', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], FloatingActionButtonComponent.prototype, "button", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], FloatingActionButtonComponent.prototype, "onKeydown", null);
        FloatingActionButtonComponent = __decorate([
            core.Component({
                selector: 'ux-floating-action-button',
                template: "<button #button\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        type=\"button\"\n        class=\"btn floating-action-button\"\n        [class.button-primary]=\"primary\"\n        [class.button-secondary]=\"!primary\"\n        [attr.aria-label]=\"ariaLabel\"\n        [tabIndex]=\"tabindex$ | async\"\n        (focus)=\"onFocus()\"\n        (blur)=\"onBlur()\"\n        (click)=\"primary ? fab.toggle() : close()\">\n\n    <ng-content></ng-content>\n\n</button>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            }),
            __param(0, core.Attribute('fab-primary')), __param(2, core.Optional()),
            __metadata("design:paramtypes", [String, FloatingActionButtonsService, TooltipDirective])
        ], FloatingActionButtonComponent);
        return FloatingActionButtonComponent;
    }());
    var FloatingActionButtonsComponent = /** @class */ (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            var _this = this;
            this.fab = fab;
            this._elementRef = _elementRef;
            /** Emit whenever the open state changes */
            this.openChange = new core.EventEmitter();
            this._subscription = new rxjs.Subscription();
            this._subscription.add(this.fab.open$.subscribe(function (value) { return _this.openChange.emit(value); }));
        }
        Object.defineProperty(FloatingActionButtonsComponent.prototype, "direction", {
            /** Specify the direction that the FAB should display */
            set: function (direction) { this.fab.direction$.next(direction); },
            enumerable: true,
            configurable: true
        });
        FloatingActionButtonsComponent.prototype.ngAfterViewInit = function () {
            this.fab.setButtons(this.buttons);
        };
        FloatingActionButtonsComponent.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        /*
         * Detect any clicks to trigger close of the menu
         */
        FloatingActionButtonsComponent.prototype.close = function (target) {
            if (!this._elementRef.nativeElement.contains(target)) {
                this.fab.close();
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], FloatingActionButtonsComponent.prototype, "direction", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FloatingActionButtonsComponent.prototype, "openChange", void 0);
        __decorate([
            core.ContentChildren(FloatingActionButtonComponent),
            __metadata("design:type", core.QueryList)
        ], FloatingActionButtonsComponent.prototype, "buttons", void 0);
        __decorate([
            core.HostListener('document:click', ['$event.target']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [HTMLElement]),
            __metadata("design:returntype", void 0)
        ], FloatingActionButtonsComponent.prototype, "close", null);
        FloatingActionButtonsComponent = __decorate([
            core.Component({
                selector: 'ux-floating-action-buttons',
                template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"fab.direction$ | async\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                providers: [FloatingActionButtonsService],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                animations: [
                    animations.trigger('fabAnimation', [
                        animations.transition('void => true', [
                            animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                            animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                        ]),
                        animations.transition('true => void', [
                            animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                        ])
                    ])
                ]
            }),
            __metadata("design:paramtypes", [FloatingActionButtonsService, core.ElementRef])
        ], FloatingActionButtonsComponent);
        return FloatingActionButtonsComponent;
    }());
    var FloatingActionButtonsModule = /** @class */ (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule
                ],
                exports: [
                    FloatingActionButtonsComponent,
                    FloatingActionButtonComponent
                ],
                declarations: [
                    FloatingActionButtonsComponent,
                    FloatingActionButtonComponent
                ]
            })
        ], FloatingActionButtonsModule);
        return FloatingActionButtonsModule;
    }());
    var HierarchyBarNodeIconDirective = /** @class */ (function () {
        function HierarchyBarNodeIconDirective() {
        }
        HierarchyBarNodeIconDirective = __decorate([
            core.Directive({
                selector: '[uxHierarchyBarNodeIcon]',
            })
        ], HierarchyBarNodeIconDirective);
        return HierarchyBarNodeIconDirective;
    }());
    var HierarchyBarService = /** @class */ (function () {
        function HierarchyBarService() {
            /** Define the list of selected nodes */
            this.nodes$ = new rxjs.BehaviorSubject([]);
            /** Define the events that show the popover when interacting with the arrows */
            this.popoverShowTriggers = ['click'];
            /** Define the events that hide the popover when interacting with the arrows */
            this.popoverHideTriggers = ['click', 'clickoutside', 'escape'];
            /** Emit the selected node when it changes */
            this.selection$ = new rxjs.Subject();
            /** Define the aria label for the show siblings popover button */
            this.showSiblingsAriaLabel = 'Show Siblings';
            /** Store nodes as a flattened list */
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        HierarchyBarService.prototype.setRootNode = function (root) {
            // if the node is null or undefined then do nothing
            if (!root) {
                return;
            }
            // store the root node
            this._root = root;
            // create a flat structure of nodes
            this._nodes = this.getNodeList(root);
            // flatten the array - based on the selected node
            this.nodes$.next(this.getSelectedChildren(root));
        };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        HierarchyBarService.prototype.selectNode = function (node) {
            // deselect all nodes
            this.deselectAll();
            // if the node is undefined then do nothing
            if (!node) {
                return;
            }
            // ensure the current node is selected and its parents
            this.select(node);
            // emit a new node list to trigger change detection
            this.nodes$.next(this.getSelectedChildren(this._root));
            // emit the new selection
            this.selection$.next(node);
        };
        /**
         * Handles getting children with support for both arrays and observables
         */
        HierarchyBarService.prototype.getChildren = function (node) {
            var _this = this;
            if (Array.isArray(node.children)) {
                return rxjs.of({ loading: false, children: node.children });
            }
            var children$ = node.children;
            // if it is an observable then handle loading
            return rxjs.Observable.create(function (observer) {
                // emit initial value
                observer.next({ loading: true, children: [] });
                // now wait until the children observable completes
                children$.pipe(operators.first()).subscribe(function (children) {
                    // replace the observable with an array for future loading
                    node.children = children;
                    // rebuild the node tree
                    _this.setRootNode(_this._root);
                    // emit the latest value
                    observer.next({ loading: false, children: children });
                    // close the observable stream
                    observer.complete();
                });
            });
        };
        /**
         * Utility function to get the sibling nodes, taking into account that
         * a node may be a root node and may not have a parent.
         */
        HierarchyBarService.prototype.getSiblings = function (node) {
            return node.parent ? this.getChildren(node.parent) : rxjs.of({ loading: false, children: [] });
        };
        /**
         * Traverses all the parents to ensure they are selected
         */
        HierarchyBarService.prototype.select = function (node) {
            node.selected = true;
            if (node.parent) {
                this.select(node.parent);
            }
        };
        /**
         * Deselects all nodes
         */
        HierarchyBarService.prototype.deselectAll = function () {
            this._nodes.forEach(function (node) { return node.selected = false; });
        };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         */
        HierarchyBarService.prototype.getNodeList = function (node) {
            var _this = this;
            // if there are no children then return only itself
            if (!node.children || rxjs.isObservable(node.children) || node.children.length === 0) {
                return [node];
            }
            // store the parent property
            node.children.forEach(function (child) { return child.parent = node; });
            // get all descendants of this node
            var descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
            return __spread([node], descendants);
        };
        /**
         * Gets all selected nodes from the parent node.
         */
        HierarchyBarService.prototype.getSelectedChildren = function (node) {
            if (rxjs.isObservable(node.children)) {
                return [node];
            }
            // get the children - and account for when there is none
            var children = node.children || [];
            // check if any child is selected
            var child = children.find(function (_child) { return _child.selected; });
            // return the remaining chain of selected items
            return child ? __spread([node], this.getSelectedChildren(child)) : [node];
        };
        HierarchyBarService = __decorate([
            core.Injectable()
        ], HierarchyBarService);
        return HierarchyBarService;
    }());
    var HierarchyBarComponent = /** @class */ (function () {
        function HierarchyBarComponent(_hierarchyBar) {
            var _this = this;
            this._hierarchyBar = _hierarchyBar;
            /** Define which presentational mode we should display */
            this.mode = 'standard';
            /** hierarchy bar as being readonly - default false */
            this.readonly = false;
            /** Emit when the selected node changes */
            this.selectedChange = new core.EventEmitter();
            /** Unsubscribe from all subscriptions when component is destroyed */
            this._onDestroy = new rxjs.Subject();
            // emit the latest selection value
            _hierarchyBar.selection$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (selection) { return _this.selectedChange.next(selection); });
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            /** Define the root node of the hierarchy bar */
            set: function (node) {
                this._hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            /** Define the selected node in the hierarchy bar */
            set: function (node) {
                this._hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "loadingIndicator", {
            /** Provide a custom loading indicator */
            set: function (loadingIndicator) {
                this._hierarchyBar.loadingIndicator = loadingIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "overflowTemplate", {
            /** Provide a custom overflow template */
            set: function (overflowTemplate) {
                this._hierarchyBar.overflowTemplate = overflowTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "popoverShowTriggers", {
            /** Define the events that show the popover when interacting with the arrows */
            set: function (popoverShowTriggers) {
                this._hierarchyBar.popoverShowTriggers = popoverShowTriggers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "popoverHideTriggers", {
            /** Define the events that hide the popover when interacting with the arrows */
            set: function (popoverHideTriggers) {
                this._hierarchyBar.popoverHideTriggers = popoverHideTriggers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "showSiblingsAriaLabel", {
            /** Define the aria label for the show siblings popover button */
            set: function (label) {
                this._hierarchyBar.showSiblingsAriaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "icon", {
            /** Allow a custom icon to be specified */
            set: function (icon) {
                this._hierarchyBar.icon = icon;
            },
            enumerable: true,
            configurable: true
        });
        HierarchyBarComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], HierarchyBarComponent.prototype, "mode", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarComponent.prototype, "readonly", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], HierarchyBarComponent.prototype, "root", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], HierarchyBarComponent.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef),
            __metadata("design:paramtypes", [core.TemplateRef])
        ], HierarchyBarComponent.prototype, "loadingIndicator", null);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef),
            __metadata("design:paramtypes", [core.TemplateRef])
        ], HierarchyBarComponent.prototype, "overflowTemplate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], HierarchyBarComponent.prototype, "popoverShowTriggers", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], HierarchyBarComponent.prototype, "popoverHideTriggers", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], HierarchyBarComponent.prototype, "showSiblingsAriaLabel", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], HierarchyBarComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.ContentChild(HierarchyBarNodeIconDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef),
            __metadata("design:paramtypes", [core.TemplateRef])
        ], HierarchyBarComponent.prototype, "icon", null);
        HierarchyBarComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar',
                template: "<!-- Hierarchy Bar - Standard Layout -->\n<ux-hierarchy-bar-standard [readonly]=\"readonly\" [mode]=\"mode\" *ngIf=\"mode !== 'collapsed'\">\n\n    <!-- Forward the content to the correct layout -->\n    <ng-container ngProjectAs=\"left-addons\" [ngTemplateOutlet]=\"leftAddons\"></ng-container>\n    <ng-container ngProjectAs=\"trailing-addons\" [ngTemplateOutlet]=\"trailingAddons\"></ng-container>\n    <ng-container ngProjectAs=\"right-addons\" [ngTemplateOutlet]=\"rightAddons\"></ng-container>\n\n</ux-hierarchy-bar-standard>\n\n<!-- Hierarchy Bar - Collapsed Layout -->\n<ux-hierarchy-bar-collapsed [readonly]=\"readonly\" *ngIf=\"mode === 'collapsed'\">\n\n    <!-- Forward the content to the correct layout -->\n    <ng-container ngProjectAs=\"left-addons\" [ngTemplateOutlet]=\"leftAddons\"></ng-container>\n    <ng-container ngProjectAs=\"trailing-addons\" [ngTemplateOutlet]=\"trailingAddons\"></ng-container>\n    <ng-container ngProjectAs=\"right-addons\" [ngTemplateOutlet]=\"rightAddons\"></ng-container>\n\n</ux-hierarchy-bar-collapsed>\n\n<!-- We can only have one ng-content so this allows us to use it more than once -->\n<ng-template #leftAddons>\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</ng-template>\n\n<ng-template #trailingAddons>\n    <ng-content select=\"[uxHierarchyBarTrailingAddon]\"></ng-content>\n</ng-template>\n\n<ng-template #rightAddons>\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                viewProviders: [HierarchyBarService]
            }),
            __metadata("design:paramtypes", [HierarchyBarService])
        ], HierarchyBarComponent);
        return HierarchyBarComponent;
    }());
    var ClickOutsideDirective = /** @class */ (function () {
        function ClickOutsideDirective(_elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.uxClickOutside = new core.EventEmitter();
            /** Often a click event makes the element appear - if so we can end up closing it immediately */
            this._initialised = false;
            setTimeout(function () { return _this._initialised = true; });
        }
        ClickOutsideDirective.prototype.click = function (event) {
            if (this._initialised && this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                this.uxClickOutside.emit(event);
            }
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ClickOutsideDirective.prototype, "uxClickOutside", void 0);
        __decorate([
            core.HostListener('document:click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], ClickOutsideDirective.prototype, "click", null);
        ClickOutsideDirective = __decorate([
            core.Directive({
                selector: '[uxClickOutside]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ClickOutsideDirective);
        return ClickOutsideDirective;
    }());
    var ClickOutsideModule = /** @class */ (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule = __decorate([
            core.NgModule({
                exports: [ClickOutsideDirective],
                declarations: [ClickOutsideDirective]
            })
        ], ClickOutsideModule);
        return ClickOutsideModule;
    }());
    var uniquePopoverId = 0;
    var PopoverComponent = /** @class */ (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent(changeDetectorRef) {
            var _this = _super.call(this, changeDetectorRef) || this;
            /** Define a unique id for each popover */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /** This will emit an event any time the user clicks outside the popover */
            _this.clickOutside$ = new rxjs.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        PopoverComponent.prototype.setTitle = function (title) {
            this.title = title;
            this._changeDetectorRef.markForCheck();
        };
        PopoverComponent = __decorate([
            core.Component({
                selector: 'ux-popover',
                template: "<div class=\"popover show\" [ngClass]=\"[placement, 'popover-align-' + alignment, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef])
        ], PopoverComponent);
        return PopoverComponent;
    }(TooltipComponent));
    var PopoverDirective = /** @class */ (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective(elementRef, viewContainerRef, overlay, scrollDispatcher, changeDetectorRef, renderer, tooltipService) {
            var _this = _super.call(this, elementRef, viewContainerRef, overlay, scrollDispatcher, changeDetectorRef, renderer, tooltipService) || this;
            /** All the user to add a custom class to the popover */
            _this.customClass = '';
            /** All the user to add a role to the popover - default is tooltip */
            _this.role = 'tooltip';
            /** Provide the TemplateRef a context object */
            _this.context = {};
            /** Delay the showing of the popover by a number of miliseconds */
            _this.delay = 0;
            /** Specify which events should show the popover */
            _this.showTriggers = ['click'];
            /** Specify which events should hide the popover */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /** Keep track of the tooltip visibility and update aria-expanded attribute */
            _this.isVisible = false;
            /** Define the overlay class */
            _this._overlayClass = 'ux-overlay-pane';
            /** Internally store the type of this component - usual for distinctions when extending the tooltip class */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        PopoverDirective.prototype.ngOnInit = function () {
            // set up the event triggers
            rxjs.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
            // check if there is an aria-described by attribute
            this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
            // set up the default event triggers
            _super.prototype.ngOnInit.call(this);
        };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        PopoverDirective.prototype.ngOnChanges = function (changes) {
            _super.prototype.ngOnChanges.call(this, changes);
            if (this._instance && changes.title) {
                this._instance.setTitle(changes.title.currentValue);
            }
        };
        PopoverDirective.prototype.createInstance = function (overlayRef) {
            var instance = overlayRef.attach(this._portal).instance;
            // supply the tooltip with the correct properties
            instance.setTitle(this.title);
            instance.setContent(this.content);
            instance.setPlacement(this.placement);
            instance.setAlignment(this.alignment);
            instance.setClass(this.customClass);
            instance.setContext(this.context);
            instance.setRole(this.role);
            // Update the aria-describedby attribute
            this.setAriaDescribedBy(instance.id);
            // subscribe to the outside click event
            instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
            return instance;
        };
        PopoverDirective.prototype.createPortal = function () {
            return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
        };
        PopoverDirective.prototype.onKeyDown = function (event) {
            // if visible and the escape key is pressed and it is one of the hide triggers
            if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                this.hide();
            }
        };
        PopoverDirective.prototype.onClickOutside = function () {
            // if visible and it is one of the hide triggers
            if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                this.hide();
            }
        };
        /** Programmatically update the aria-describedby property */
        PopoverDirective.prototype.setAriaDescribedBy = function (id) {
            // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
            if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                _super.prototype.setAriaDescribedBy.call(this, id);
            }
        };
        __decorate([
            core.Input('uxPopover'),
            __metadata("design:type", Object)
        ], PopoverDirective.prototype, "content", void 0);
        __decorate([
            core.Input('popoverTitle'),
            __metadata("design:type", String)
        ], PopoverDirective.prototype, "title", void 0);
        __decorate([
            core.Input('popoverDisabled'),
            __metadata("design:type", Boolean)
        ], PopoverDirective.prototype, "disabled", void 0);
        __decorate([
            core.Input('popoverClass'),
            __metadata("design:type", String)
        ], PopoverDirective.prototype, "customClass", void 0);
        __decorate([
            core.Input('popoverRole'),
            __metadata("design:type", String)
        ], PopoverDirective.prototype, "role", void 0);
        __decorate([
            core.Input('popoverContext'),
            __metadata("design:type", Object)
        ], PopoverDirective.prototype, "context", void 0);
        __decorate([
            core.Input('popoverDelay'),
            __metadata("design:type", Number)
        ], PopoverDirective.prototype, "delay", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], PopoverDirective.prototype, "showTriggers", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], PopoverDirective.prototype, "hideTriggers", void 0);
        __decorate([
            core.HostBinding('attr.aria-expanded'),
            __metadata("design:type", Boolean)
        ], PopoverDirective.prototype, "isVisible", void 0);
        PopoverDirective = __decorate([
            core.Directive({
                selector: '[uxPopover]',
                exportAs: 'ux-popover'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.ViewContainerRef,
                overlay.Overlay,
                overlay.ScrollDispatcher,
                core.ChangeDetectorRef,
                core.Renderer2,
                TooltipService])
        ], PopoverDirective);
        return PopoverDirective;
    }(TooltipDirective));
    var PopoverModule = /** @class */ (function () {
        function PopoverModule() {
        }
        PopoverModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    overlay.OverlayModule,
                    observers.ObserversModule,
                    ClickOutsideModule,
                    TooltipModule
                ],
                exports: [PopoverDirective],
                declarations: [PopoverComponent, PopoverDirective],
                entryComponents: [PopoverComponent]
            })
        ], PopoverModule);
        return PopoverModule;
    }());
    var HierarchyBarCollapsedComponent = /** @class */ (function () {
        function HierarchyBarCollapsedComponent(hierarchyBar, 
        /** Access the renderer to mutate the DOM */
        _renderer, 
        /** Access the resize service to watch for changes to the host element */
        _resizeService, 
        /** Access the host elementRef */
        _elementRef) {
            this.hierarchyBar = hierarchyBar;
            this._renderer = _renderer;
            this._resizeService = _resizeService;
            this._elementRef = _elementRef;
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_first", {
            /** Get the first node to display */
            get: function () {
                return this._nodes[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_last", {
            /** Get the last node to display */
            get: function () {
                return this._nodes[this._nodes.length - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_siblings", {
            /** Get all the sibling nodes */
            get: function () {
                return this.hierarchyBar.getSiblings(this._last);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_parents", {
            /** Get all the nodes between the first and last nodes */
            get: function () {
                var _this = this;
                return this._nodes.filter(function (node) { return node !== _this._first && node !== _this._last; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarCollapsedComponent.prototype, "_nodes", {
            /** Get the nodes as an array */
            get: function () {
                return this.hierarchyBar.nodes$.value;
            },
            enumerable: true,
            configurable: true
        });
        HierarchyBarCollapsedComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // check for overflow when the selected nodes change
            this.hierarchyBar.nodes$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function () { return _this.updateOverflow(); });
            // watch for the host element size changing
            this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.updateOverflow(); });
        };
        HierarchyBarCollapsedComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            // remove the resize event listener
            this._resizeService.removeResizeListener(this._elementRef.nativeElement);
        };
        HierarchyBarCollapsedComponent.prototype.updateOverflow = function () {
            // remove the class if it is present
            this._renderer.removeClass(this.nodeContainer.nativeElement, 'hierarchy-bar-nodes-overflow');
            // check if there is overflow
            if (this.nodeContainer.nativeElement.scrollWidth > this.nodeContainer.nativeElement.offsetWidth) {
                this._renderer.addClass(this.nodeContainer.nativeElement, 'hierarchy-bar-nodes-overflow');
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarCollapsedComponent.prototype, "readonly", void 0);
        __decorate([
            core.ViewChild('nodes', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], HierarchyBarCollapsedComponent.prototype, "nodeContainer", void 0);
        HierarchyBarCollapsedComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar-collapsed',
                template: "<!-- Allow content to be placed on the left of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"left-addons\"></ng-content>\n</div>\n\n<div #nodes class=\"hierarchy-bar-nodes\">\n\n    <ux-hierarchy-bar-node\n        [readonly]=\"readonly\"\n        [popoverTemplate]=\"content\"\n        [node]=\"_first\"\n        (selected)=\"hierarchyBar.selectNode($event)\">\n    </ux-hierarchy-bar-node>\n\n    <div class=\"hierarchy-bar-overflow\" *ngIf=\"_parents.length > 0\">\n        <div class=\"hierarchy-bar-overflow-container\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.overflowTemplate || defaultOverflowTemplate\"\n                          [ngTemplateOutletContext]=\"{ $implicit: _parents }\">\n            </ng-container>\n        </div>\n\n        <button [attr.aria-label]=\"hierarchyBar.showSiblingsAriaLabel\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            class=\"hierarchy-bar-node-arrow\"\n            placement=\"bottom\"\n            [uxPopover]=\"siblingsTemplate\"\n            popoverClass=\"hierarchy-bar-popover\"\n            role=\"button\"\n            tabindex=\"0\"\n            [disabled]=\"readonly\"\n            #popover=\"ux-popover\"\n            [popoverContext]=\"{ popover: popover }\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            type=\"button\">\n\n            <ux-icon name=\"next\" class=\"hierarchy-bar-node-arrow-icon\"></ux-icon>\n        </button>\n    </div>\n\n\n    <ux-hierarchy-bar-node\n        *ngIf=\"_last !== _first\"\n        [readonly]=\"readonly\"\n        [popoverTemplate]=\"content\"\n        [node]=\"_last\"\n        (selected)=\"hierarchyBar.selectNode($event)\">\n    </ux-hierarchy-bar-node>\n\n    <!-- Allow content to be placed after the last node -->\n    <div class=\"hierarchy-bar-addons\">\n        <ng-content select=\"trailing-addons\"></ng-content>\n    </div>\n\n</div>\n\n<!-- Allow content to be placed on the right of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"right-addons\"></ng-content>\n</div>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [loading]=\"(hierarchyBar.getChildren(node) | async)?.loading\"\n        [nodes]=\"(hierarchyBar.getChildren(node) | async)?.children\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the siblings popover list -->\n<ng-template #siblingsTemplate let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [nodes]=\"(_siblings | async)?.children\"\n        [loading]=\"(_siblings | async)?.loading\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the parents popover list -->\n<ng-template #parentsTemplate let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [nodes]=\"_parents\"\n        [separator]=\"true\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Default Overflow Template -->\n<ng-template #defaultOverflowTemplate>\n    <button uxFocusIndicator\n            uxFocusIndicatorOrigin\n            [disabled]=\"readonly\"\n            class=\"overflow-button\"\n            aria-label=\"Show parents\"\n            [uxPopover]=\"parentsTemplate\"\n            popoverClass=\"hierarchy-bar-popover\"\n            role=\"button\"\n            tabindex=\"0\"\n            #popover=\"ux-popover\"\n            [popoverContext]=\"{ popover: popover }\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            placement=\"bottom\"\n            type=\"button\">\n            <ux-icon name=\"more\"></ux-icon>\n    </button>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [HierarchyBarService,
                core.Renderer2,
                ResizeService,
                core.ElementRef])
        ], HierarchyBarCollapsedComponent);
        return HierarchyBarCollapsedComponent;
    }());
    var HierarchyBarNodeComponent = /** @class */ (function () {
        function HierarchyBarNodeComponent(hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /** Emit when the node is selected */
            this.selected = new core.EventEmitter();
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], HierarchyBarNodeComponent.prototype, "node", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], HierarchyBarNodeComponent.prototype, "popoverTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], HierarchyBarNodeComponent.prototype, "mode", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarNodeComponent.prototype, "readonly", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], HierarchyBarNodeComponent.prototype, "selected", void 0);
        HierarchyBarNodeComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar-node',
                template: "<div class=\"hierarchy-bar-node\"\n     [class.hierarchy-bar-node-readonly]=\"readonly\"\n     [class.hierarchy-bar-node-child-indicator]=\"node.children\">\n\n    <ng-container\n        *ngIf=\"mode === 'dropdown'; then dropdownMode; else standardClickMode\">\n    </ng-container>\n\n</div>\n\n<ng-template #standardClickMode>\n    <button type=\"button\"\n            uxFocusIndicator\n            class=\"hierarchy-bar-node-content\"\n            [disabled]=\"readonly\"\n            [attr.aria-label]=\"node.title\"\n            (click)=\"selected.emit(node)\">\n\n        <!-- Show a custom icon if specified -->\n        <div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.icon\" [ngTemplateOutletContext]=\"{ node: node, $implicit: node }\"></ng-container>\n        </div>\n\n        <!-- Show an icon if specified -->\n        <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon && !hierarchyBar.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n        <!-- Show the name of the current node -->\n        <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n    </button>\n\n    <!-- Show a dropdown arrow if there are children -->\n    <button type=\"button\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            *ngIf=\"node.children\"\n            #popover=\"ux-popover\"\n            aria-label=\"Show children\"\n            role=\"button\"\n            class=\"hierarchy-bar-node-arrow\"\n            [disabled]=\"readonly\"\n            [uxPopover]=\"popoverTemplate\"\n            [popoverContext]=\"{ node: node, popover: popover }\"\n            placement=\"bottom\"\n            popoverClass=\"hierarchy-bar-popover\"\n            [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n            [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n            tabindex=\"0\">\n        <ux-icon name=\"next\"\n                 class=\"hierarchy-bar-node-arrow-icon\">\n        </ux-icon>\n    </button>\n</ng-template>\n\n<ng-template #dropdownMode>\n    <button type=\"button\"\n            uxFocusIndicator\n            uxFocusIndicatorOrigin\n            #popover=\"ux-popover\"\n            aria-label=\"Show children\"\n            class=\"hierarchy-bar-node-content\"\n            [disabled]=\"readonly\"\n            [uxPopover]=\"popoverTemplate\"\n            [popoverContext]=\"{ node: node, popover: popover }\"\n            placement=\"bottom\"\n            popoverClass=\"hierarchy-bar-popover\"\n            [showTriggers]=\"node.children ? hierarchyBar.popoverShowTriggers : []\"\n            [hideTriggers]=\"node.children ? hierarchyBar.popoverHideTriggers : []\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"node.title\">\n\n        <!-- Show a custom icon if specified -->\n        <div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n            <ng-container [ngTemplateOutlet]=\"hierarchyBar.icon\" [ngTemplateOutletContext]=\"{ node: node, $implicit: node }\"></ng-container>\n        </div>\n\n        <!-- Show an icon if specified -->\n        <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon && !hierarchyBar.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n        <!-- Show the name of the current node -->\n        <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <div [class.readonly-arrow]=\"readonly\" class=\"hierarchy-bar-node-arrow-icon-dropdown\">\n            <ux-icon *ngIf=\"node.children\" name=\"next\"\n                     class=\"hierarchy-bar-node-arrow-icon\">\n            </ux-icon>\n        </div>\n\n    </button>\n\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [HierarchyBarService])
        ], HierarchyBarNodeComponent);
        return HierarchyBarNodeComponent;
    }());
    var HierarchyBarPopoverItemComponent = /** @class */ (function () {
        function HierarchyBarPopoverItemComponent(focusOriginService, elementRef, renderer, hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /**
             * Emit when a click or enter key press occurs.
             * Note this is an `async` EventEmitter to ensure that
             * the event handlers in the `FocusIndicatorOrigin` set
             * the origin before we emit the select event, otherwise
             * the item may not get a focus ring when the keyboard is used.
             */
            this.selected = new core.EventEmitter(true);
            this._focusOrigin = new FocusIndicatorOrigin(focusOriginService, elementRef, renderer);
        }
        HierarchyBarPopoverItemComponent.prototype.ngOnDestroy = function () {
            this._focusOrigin.destroy();
        };
        HierarchyBarPopoverItemComponent.prototype.onSelect = function () {
            this.selected.emit(this.node);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], HierarchyBarPopoverItemComponent.prototype, "node", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], HierarchyBarPopoverItemComponent.prototype, "selected", void 0);
        __decorate([
            core.HostListener('click'),
            core.HostListener('keydown.enter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], HierarchyBarPopoverItemComponent.prototype, "onSelect", null);
        HierarchyBarPopoverItemComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar-popover-item',
                template: "<!-- Show an icon if specified -->\n<img class=\"hierarchy-bar-node-icon\" *ngIf=\"!hierarchyBar.icon && node?.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n<!-- Show a custom icon if specified -->\n<div class=\"hierarchy-bar-node-icon\" *ngIf=\"hierarchyBar.icon\">\n    <ng-container\n        [ngTemplateOutlet]=\"hierarchyBar.icon\"\n        [ngTemplateOutletContext]=\"{ node: node, $implicit: node }\">\n    </ng-container>\n</div>\n\n<!-- Show the name of the current node -->\n<span class=\"hierarchy-bar-node-title\">{{ node?.title }}</span>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [FocusIndicatorOriginService,
                core.ElementRef,
                core.Renderer2,
                HierarchyBarService])
        ], HierarchyBarPopoverItemComponent);
        return HierarchyBarPopoverItemComponent;
    }());
    var HierarchyBarPopoverComponent = /** @class */ (function () {
        function HierarchyBarPopoverComponent(hierarchyBar) {
            this.hierarchyBar = hierarchyBar;
            /** Define the nodes to display */
            this.nodes = [];
            /** Defines if dropdown items should have separators between them to distinguish if nodes are siblings or ancestors */
            this.separator = false;
            /** Emit a select event when an item ahs been clicked or enter key pressed */
            this.selected = new core.EventEmitter();
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], HierarchyBarPopoverComponent.prototype, "nodes", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarPopoverComponent.prototype, "loading", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarPopoverComponent.prototype, "separator", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], HierarchyBarPopoverComponent.prototype, "selected", void 0);
        HierarchyBarPopoverComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar-popover',
                template: "<!-- Loading Indicator -->\n<ul class=\"hierarchy-bar-node-list\" *ngIf=\"loading\">\n\n    <li class=\"hierarchy-bar-loading-indicator\">\n        <ng-container [ngTemplateOutlet]=\"hierarchyBar.loadingIndicator || defaultLoadingIndicator\"></ng-container>\n    </li>\n</ul>\n\n<!-- List of children -->\n<div class=\"hierarchy-bar-node-list\"\n    [class.hierarchy-bar-node-list-separator]=\"separator\"\n    *ngIf=\"!loading\"\n    uxTabbableList\n    [returnFocus]=\"true\">\n\n    <ux-hierarchy-bar-popover-item *ngFor=\"let node of nodes; let first = first\"\n        uxFocusIndicator\n        [node]=\"node\"\n        [focusIf]=\"first\"\n        uxTabbableListItem\n        (selected)=\"selected.emit($event)\">\n    </ux-hierarchy-bar-popover-item>\n\n</div>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-loading-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-loading-title\">Loading...</span>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [HierarchyBarService])
        ], HierarchyBarPopoverComponent);
        return HierarchyBarPopoverComponent;
    }());
    var HierarchyBarStandardComponent = /** @class */ (function () {
        function HierarchyBarStandardComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            /** Identify which nodes are overflowing */
            this.overflow$ = new rxjs.BehaviorSubject([]);
            /** Determine if there is any overflow */
            this.isOverflowing$ = new rxjs.BehaviorSubject(false);
            /** Unsubscribe from all subscriptions when component is destroyed */
            this._onDestroy = new rxjs.Subject();
            // subscribe to changes in the selected node - update the UI after the render
            hierarchyBar.nodes$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return requestAnimationFrame(_this.scrollIntoView.bind(_this)); });
        }
        HierarchyBarStandardComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        HierarchyBarStandardComponent.prototype.scrollIntoView = function () {
            var _this = this;
            if (!this.nodelist) {
                return;
            }
            // get the native element
            var nativeElement = this.nodelist.nativeElement;
            var isOverflowing = nativeElement.scrollWidth > nativeElement.offsetWidth;
            // emit whether we are overflowing or not
            this.isOverflowing$.next(isOverflowing);
            // if the hierarchy bar contents do not overflow then do nothing
            if (isOverflowing) {
                // determine the amount of overflow
                var amount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                // determine which nodes are not fully visible
                this.overflow$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < amount_1; })
                    .map(function (_node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                // move the scroll position to always show the last item
                this.nodelist.nativeElement.scrollLeft = amount_1;
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], HierarchyBarStandardComponent.prototype, "mode", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], HierarchyBarStandardComponent.prototype, "readonly", void 0);
        __decorate([
            core.ViewChild('nodelist', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], HierarchyBarStandardComponent.prototype, "nodelist", void 0);
        __decorate([
            core.ViewChildren(HierarchyBarNodeComponent, { read: core.ElementRef }),
            __metadata("design:type", core.QueryList)
        ], HierarchyBarStandardComponent.prototype, "nodes", void 0);
        HierarchyBarStandardComponent = __decorate([
            core.Component({
                selector: 'ux-hierarchy-bar-standard',
                template: "<!-- Allow content to be placed on the left of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"left-addons\"></ng-content>\n</div>\n\n<div #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"isOverflowing$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [showTriggers]=\"hierarchyBar.popoverShowTriggers\"\n         [hideTriggers]=\"hierarchyBar.popoverHideTriggers\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        <ng-container [ngTemplateOutlet]=\"hierarchyBar.overflowTemplate || defaultOverflowTemplate\"\n                      [ngTemplateOutletContext]=\"{ $implicit: overflow$ | async }\">\n        </ng-container>\n    </div>\n\n    <ux-hierarchy-bar-node\n        [mode]=\"mode\"\n        [readonly]=\"readonly\"\n        *ngFor=\"let node of hierarchyBar.nodes$ | async\"\n        [node]=\"node\"\n        [popoverTemplate]=\"content\"\n        (selected)=\"hierarchyBar.selectNode(node)\">\n    </ux-hierarchy-bar-node>\n\n    <!-- Allow content to be placed after the last node -->\n    <div class=\"hierarchy-bar-addons\">\n        <ng-content select=\"trailing-addons\"></ng-content>\n    </div>\n\n</div>\n\n<!-- Allow content to be placed on the right of the items -->\n<div class=\"hierarchy-bar-addons\">\n    <ng-content select=\"right-addons\"></ng-content>\n</div>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n    <ux-hierarchy-bar-popover\n        [loading]=\"(hierarchyBar.getChildren(node) | async)?.loading\"\n        [nodes]=\"(hierarchyBar.getChildren(node) | async)?.children\"\n        (selected)=\"hierarchyBar.selectNode($event); popover.hide()\">\n    </ux-hierarchy-bar-popover>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <div uxTabbableList [returnFocus]=\"true\">\n\n        <ux-hierarchy-bar-popover-item\n            *ngFor=\"let child of overflow$ | async; let first = first\"\n            uxFocusIndicator\n            [node]=\"child\"\n            [focusIf]=\"first\"\n            uxTabbableListItem\n            (selected)=\"hierarchyBar.selectNode(child); popover.hide()\">\n        </ux-hierarchy-bar-popover-item>\n    </div>\n</ng-template>\n\n<!-- Default Overflow Template -->\n<ng-template #defaultOverflowTemplate>\n    . . .\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [HierarchyBarService])
        ], HierarchyBarStandardComponent);
        return HierarchyBarStandardComponent;
    }());
    var HierarchyBarModule = /** @class */ (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    FocusIfModule,
                    IconModule,
                    PopoverModule,
                    ResizeModule,
                ],
                exports: [
                    HierarchyBarComponent,
                    HierarchyBarStandardComponent,
                    HierarchyBarCollapsedComponent,
                    HierarchyBarNodeIconDirective
                ],
                declarations: [
                    HierarchyBarComponent,
                    HierarchyBarStandardComponent,
                    HierarchyBarCollapsedComponent,
                    HierarchyBarNodeComponent,
                    HierarchyBarPopoverComponent,
                    HierarchyBarPopoverItemComponent,
                    HierarchyBarNodeIconDirective
                ],
            })
        ], HierarchyBarModule);
        return HierarchyBarModule;
    }());
    (function (SidePanelAnimationState) {
        SidePanelAnimationState["Closed"] = "closed";
        SidePanelAnimationState["Open"] = "open";
        SidePanelAnimationState["OpenImmediate"] = "openImmediate";
    })(exports["ɵba"] || (exports["ɵba"] = {}));
    var sidePanelStateAnimation = animations.trigger('panelState', [
        animations.state(exports["ɵba"].Closed, animations.style({ visibility: 'hidden' })),
        animations.state(exports["ɵba"].Open + ", " + exports["ɵba"].OpenImmediate, animations.style({ visibility: 'visible', transform: 'none' })),
        animations.transition("void <=> " + exports["ɵba"].Open, animations.animate('0.2s cubic-bezier(0.49, 1, 0.38, 0.98)')),
        animations.transition("void <=> " + exports["ɵba"].OpenImmediate, animations.animate('0s'))
    ]);
    var SidePanelService = /** @class */ (function () {
        function SidePanelService() {
            /** Emit the open state when it changes */
            this.open$ = new rxjs.BehaviorSubject(false);
        }
        SidePanelService.prototype.open = function () {
            this.open$.next(true);
        };
        SidePanelService.prototype.close = function () {
            this.open$.next(false);
        };
        SidePanelService = __decorate([
            core.Injectable()
        ], SidePanelService);
        return SidePanelService;
    }());
    var SidePanelComponent = /** @class */ (function () {
        function SidePanelComponent(service, _elementRef, _focusOrigin) {
            this.service = service;
            this._elementRef = _elementRef;
            this._focusOrigin = _focusOrigin;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.focusOnShow = false;
            this.openChange = new core.EventEmitter();
            this.closeOnEscape = true;
            this.animationPanelState = exports["ɵba"].Closed;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: function () {
                return this.service.open$.value;
            },
            set: function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        SidePanelComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.service.open$.pipe(operators.skip(1), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy))
                .subscribe(function (isOpen) { return _this.openChange.emit(isOpen); });
            this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isOpen) {
                _this.animationPanelState = isOpen
                    ? _this.animate
                        ? exports["ɵba"].Open
                        : exports["ɵba"].OpenImmediate
                    : exports["ɵba"].Closed;
            });
        };
        SidePanelComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        SidePanelComponent.prototype.openPanel = function () {
            this.service.open();
        };
        SidePanelComponent.prototype.closePanel = function () {
            this.service.close();
        };
        SidePanelComponent.prototype._onDocumentEscape = function () {
            if (this.open && this.closeOnEscape) {
                this._focusOrigin.setOrigin('keyboard');
                this.closePanel();
            }
        };
        SidePanelComponent.prototype._onDocumentClick = function (target) {
            if (!this.open || !this.closeOnExternalClick) {
                return;
            }
            if (!this._elementRef.nativeElement.contains(target) || (target && target.classList.contains('modal-backdrop'))) {
                this.closePanel();
            }
        };
        __decorate([
            core.Input(),
            core.HostBinding('class.open'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SidePanelComponent.prototype, "open", null);
        __decorate([
            core.Input(),
            core.HostBinding('class.inline'),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "inline", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SidePanelComponent.prototype, "attachTo", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "width", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "top", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-modal'),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "modal", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('class.animate'),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "animate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "closeOnExternalClick", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SidePanelComponent.prototype, "focusOnShow", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SidePanelComponent.prototype, "openChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SidePanelComponent.prototype, "closeOnEscape", void 0);
        __decorate([
            core.HostBinding('style.width'),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [])
        ], SidePanelComponent.prototype, "componentWidth", null);
        __decorate([
            core.HostListener('document:keyup.escape'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], SidePanelComponent.prototype, "_onDocumentEscape", null);
        __decorate([
            core.HostListener('document:click', ['$event.target']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [HTMLElement]),
            __metadata("design:returntype", void 0)
        ], SidePanelComponent.prototype, "_onDocumentClick", null);
        SidePanelComponent = __decorate([
            core.Component({
                selector: 'ux-side-panel',
                exportAs: 'ux-side-panel',
                template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [@panelState]=\"animationPanelState\"\n    [focusIf]=\"open && focusOnShow\"\n    [focusIfScroll]=\"false\"\n    [cdkTrapFocus]=\"open && modal\"\n    *ngIf=\"open\">\n    <ng-content></ng-content>\n</div>\n",
                providers: [SidePanelService],
                animations: [sidePanelStateAnimation],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'ux-side-panel'
                }
            }),
            __metadata("design:paramtypes", [SidePanelService,
                core.ElementRef,
                FocusIndicatorOriginService])
        ], SidePanelComponent);
        return SidePanelComponent;
    }());
    var ItemDisplayPanelContentDirective = /** @class */ (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective = __decorate([
            core.Directive({
                selector: '[uxItemDisplayPanelContent]'
            })
        ], ItemDisplayPanelContentDirective);
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = /** @class */ (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective = __decorate([
            core.Directive({
                selector: '[uxItemDisplayPanelFooter]'
            })
        ], ItemDisplayPanelFooterDirective);
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = /** @class */ (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef, focusOrigin) {
            var _this = _super.call(this, service, elementRef, focusOrigin) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            /** Defines the aria-label for the close button */
            _this.closeAriaLabel = 'Close';
            _this.shadow = false;
            _this.visibleChange = new core.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: function () {
                return !this.closeOnExternalClick;
            },
            set: function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: function () {
                return this.open;
            },
            set: function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        ItemDisplayPanelComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isVisible) { return _this.visibleChange.emit(isVisible); });
        };
        ItemDisplayPanelComponent.prototype.focus = function () {
            if (this.panel) {
                this.panel.nativeElement.focus();
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ItemDisplayPanelComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ItemDisplayPanelComponent.prototype, "boxShadow", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ItemDisplayPanelComponent.prototype, "closeVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], ItemDisplayPanelComponent.prototype, "preventClose", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ItemDisplayPanelComponent.prototype, "closeAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ItemDisplayPanelComponent.prototype, "shadow", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], ItemDisplayPanelComponent.prototype, "visibleChange", void 0);
        __decorate([
            core.ContentChild(ItemDisplayPanelFooterDirective, { static: false }),
            __metadata("design:type", ItemDisplayPanelFooterDirective)
        ], ItemDisplayPanelComponent.prototype, "footer", void 0);
        __decorate([
            core.ViewChild('panel', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], ItemDisplayPanelComponent.prototype, "panel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], ItemDisplayPanelComponent.prototype, "visible", null);
        ItemDisplayPanelComponent = __decorate([
            core.Component({
                selector: 'ux-item-display-panel',
                template: "<div class=\"ux-side-panel-host ux-item-display-panel\" #panel\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [@panelState]=\"animationPanelState\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\"\n    *ngIf=\"open\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n\n        <button *ngIf=\"closeVisible\"\n                uxFocusIndicator\n                [attr.aria-label]=\"closeAriaLabel\"\n                type=\"button\"\n                class=\"btn btn-lg btn-link btn-icon button-secondary\"\n                (click)=\"visible = false\">\n\n            <ux-icon name=\"close\"></ux-icon>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                providers: [SidePanelService],
                animations: [sidePanelStateAnimation],
                host: {
                    'class': 'ux-side-panel ux-item-display-panel'
                }
            }),
            __metadata("design:paramtypes", [SidePanelService, core.ElementRef, FocusIndicatorOriginService])
        ], ItemDisplayPanelComponent);
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));
    var DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = /** @class */ (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    FocusIfModule,
                    IconModule
                ],
                exports: DECLARATIONS$3,
                declarations: DECLARATIONS$3
            })
        ], ItemDisplayPanelModule);
        return ItemDisplayPanelModule;
    }());
    var MarqueeWizardStepIconDirective = /** @class */ (function () {
        function MarqueeWizardStepIconDirective() {
        }
        MarqueeWizardStepIconDirective = __decorate([
            core.Directive({
                selector: '[uxMarqueeWizardStepIcon]',
            })
        ], MarqueeWizardStepIconDirective);
        return MarqueeWizardStepIconDirective;
    }());
    var WizardStepComponent = /** @class */ (function () {
        function WizardStepComponent(_changeDetector, _elementRef, _renderer) {
            this._changeDetector = _changeDetector;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            /** Allows you to define whether or not a step is valid. The user will not be able to proceed to the next step if this property has a value of false. */
            this.valid = true;
            /** Emits when visited changes. */
            this.visitedChange = new core.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            /**
             * Defines whether or not this step has previously been visited.
             * A visited step can be clicked on and jumped to at any time.
             * By default, steps will become 'visited' when the user navigates to a step for the first time.
             */
            get: function () {
                return this._visited;
            },
            set: function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
                // mark for change detection
                this._changeDetector.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.prototype.setId = function (id) {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'id', id);
            this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-labelledby', id + "-label");
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardStepComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardStepComponent.prototype, "disableNextWhenInvalid", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardStepComponent.prototype, "valid", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], WizardStepComponent.prototype, "visitedChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], WizardStepComponent.prototype, "validator", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], WizardStepComponent.prototype, "visited", null);
        __decorate([
            core.HostBinding('attr.aria-expanded'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], WizardStepComponent.prototype, "active", null);
        WizardStepComponent = __decorate([
            core.Component({
                selector: 'ux-wizard-step',
                template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'tabpanel'
                }
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                core.ElementRef,
                core.Renderer2])
        ], WizardStepComponent);
        return WizardStepComponent;
    }());
    var uniqueId$6 = 0;
    var WizardComponent = /** @class */ (function () {
        function WizardComponent() {
            /** Defines whether or not the wizard should be displayed in a `horizontal` or `vertical` layout. */
            this.orientation = 'horizontal';
            /** Defines the text displayed in the 'Next' button. */
            this.nextText = 'Next';
            /** Defines the text displayed in the 'Previous' button. */
            this.previousText = 'Previous';
            /** Defines the text displayed in the 'Cancel' button. */
            this.cancelText = 'Cancel';
            /** Defines the text displayed in the 'Finish' button. */
            this.finishText = 'Finish';
            /** Defines the text displayed in the tooltip when the 'Next' button is hovered. */
            this.nextTooltip = 'Go to the next step';
            /** Defines the text displayed in the tooltip when the 'Previous' button is hovered. */
            this.previousTooltip = 'Go to the previous step';
            /** Defines the text displayed in the tooltip when the 'Cancel' button is hovered. */
            this.cancelTooltip = 'Cancel the wizard';
            /** Defines the text displayed in the tooltip when the 'Finish' button is hovered. */
            this.finishTooltip = 'Finish the wizard';
            /** Defines the text for the aria label on the 'Next' button. */
            this.nextAriaLabel = 'Go to the next step';
            /** Defines the text for the aria label on the 'Previous' button. */
            this.previousAriaLabel = 'Go to the previous step';
            /** Defines the text for the aria label on the 'Cancel' button. */
            this.cancelAriaLabel = 'Cancel the wizard';
            /** Defines the text for the aria label on the 'Finish' button. */
            this.finishAriaLabel = 'Finish the wizard';
            /** If set to `true` the 'Next' button will appear disabled and will not respond to clicks. */
            this.nextDisabled = false;
            /** If set to `true` the 'Previous' button will appear disabled and will not respond to clicks. */
            this.previousDisabled = false;
            /** If set to `true` the 'Cancel' button will appear disabled and will not respond to clicks. */
            this.cancelDisabled = false;
            /** If set to `true` the 'Finish' button will appear disabled and will not respond to clicks. */
            this.finishDisabled = false;
            /** If set to `false` the 'Next' button will be hidden. */
            this.nextVisible = true;
            /** If set to `false` the 'Previous' button will be hidden. */
            this.previousVisible = true;
            /** If set to `false` the 'Cancel' button will be hidden. */
            this.cancelVisible = true;
            /** If set to false the 'Finish' button will be hidden. */
            this.finishVisible = true;
            /** If set to `true` the 'Cancel' button will be visible even on the last step. By default it will be hidden on the final step. */
            this.cancelAlwaysVisible = false;
            /** If set to `true` the 'Finish' button will be visible on all steps of the wizard. By default this button will only be visible on the final step of the wizard. */
            this.finishAlwaysVisible = false;
            /** If set to `true` the 'Next' or 'Finish' button will become disabled when the current step is invalid. */
            this.disableNextWhenInvalid = false;
            /** Emits when the wizard has moved to the next step. It will receive the current step index as a parameter. */
            this.onNext = new core.EventEmitter();
            /** Emits when the wizard has moved to the previous step. It will receive the current step index as a parameter. */
            this.onPrevious = new core.EventEmitter();
            /** Emits when the 'Cancel' button has been pressed. */
            this.onCancel = new core.EventEmitter();
            /** Emits when the 'Finish' button is clicked, but before the finish event fires. This fires regardless of the validity of the final step. */
            this.onFinishing = new core.EventEmitter();
            /** Emits when the 'Finish' button has been pressed and the final step is valid. */
            this.onFinish = new core.EventEmitter();
            /** Emits before the current step changes. The event contains the current step index in the `from` property, and the requested step index in the `to` property. */
            this.stepChanging = new core.EventEmitter();
            /** Emits when the current step has changed. */
            this.stepChange = new core.EventEmitter();
            /** Emits when the user tries to continue but the current step is invalid. */
            this.stepError = new core.EventEmitter();
            this.steps = new core.QueryList();
            this.id = "ux-wizard-" + uniqueId$6++;
            this.invalidIndicator = false;
            this._step = 0;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            /**
             * The current active step. When the step changes an event will be emitted containing the index of the newly active step.
             * If this is not specifed the wizard will start on the first step.
             */
            get: function () {
                return this._step;
            },
            set: function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // initially set the correct visibility of the steps
            setTimeout(this.update.bind(this));
            // initially set the ids for each step
            this.setWizardStepIds();
            // if the steps change then update the ids
            this.steps.changes.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.setWizardStepIds();
                _this.update();
            });
        };
        WizardComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Set ids for each of the wizard steps */
        WizardComponent.prototype.setWizardStepIds = function () {
            var _this = this;
            this.steps.forEach(function (step, idx) { return step.setId(_this.id + "-step-" + idx); });
        };
        /**
         * Navigate to the next step
         */
        WizardComponent.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var step, validationResult, _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                            step = this.getCurrentStep();
                            // Disable the button while waiting on validation
                            this.nextDisabled = true;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, , 5, 6]);
                            validationResult = this.isStepValid();
                            _a = step;
                            if (!(validationResult instanceof Promise))
                                return [3 /*break*/, 3];
                            return [4 /*yield*/, validationResult];
                        case 2:
                            _b = _c.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _b = validationResult;
                            _c.label = 4;
                        case 4:
                            _a.valid = _b;
                            return [3 /*break*/, 6];
                        case 5:
                            // Re-enable button
                            this.nextDisabled = false;
                            return [7 /*endfinally*/];
                        case 6:
                            // check if current step is invalid
                            if (!step.valid) {
                                this.invalidIndicator = true;
                                this.stepError.next(this.step);
                                return [2 /*return*/];
                            }
                            // check if we are currently on the last step
                            if ((this.step + 1) < this.steps.length) {
                                this.step++;
                                // emit the current step
                                this.onNext.next(this.step);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Whether the Next or Finish button should be disabled.
         */
        WizardComponent.prototype.isNextDisabled = function () {
            var step = this.getCurrentStep();
            // ensure the step is not null before we try to access its properties. It may be null if an ngFor is being
            // used and the steps haven't rendered yet
            if (!step) {
                return false;
            }
            // Use the `disableNextWhenInvalid` setting to determine whether to disable the Next/Finish button
            // based on validation.
            // If not defined on the WizardStepComponent, use the value from WizardComponent.
            return (step.disableNextWhenInvalid === undefined ? this.disableNextWhenInvalid : step.disableNextWhenInvalid) && !step.valid;
        };
        /**
         * Navigate to the previous step
         */
        WizardComponent.prototype.previous = function () {
            this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
            // check if we are currently on the last step
            if (this.step > 0) {
                this.step--;
                // emit the current step
                this.onPrevious.next(this.step);
            }
        };
        /**
         * Perform actions when the finish button is clicked
         */
        WizardComponent.prototype.finish = function () {
            return __awaiter(this, void 0, void 0, function () {
                var validationResult, _a, _b;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            // fires when the finish button is clicked always
                            this.onFinishing.next();
                            // Disable the button while waiting on validation
                            this.finishDisabled = true;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, , 5, 6]);
                            validationResult = this.isStepValid();
                            _a = this.getCurrentStep();
                            if (!(validationResult instanceof Promise))
                                return [3 /*break*/, 3];
                            return [4 /*yield*/, validationResult];
                        case 2:
                            _b = _c.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _b = validationResult;
                            _c.label = 4;
                        case 4:
                            _a.valid = _b;
                            return [3 /*break*/, 6];
                        case 5:
                            // Re-enable button
                            this.finishDisabled = false;
                            return [7 /*endfinally*/];
                        case 6:
                            /**
                             * This is required because we need to ensure change detection has run
                             * to determine whether or not we have the latest value for the 'valid' input
                             * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                             * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                             */
                            return [2 /*return*/, new Promise(function (resolve) {
                                    setTimeout(function () {
                                        // only fires when the finish button is clicked and the step is valid
                                        if (_this.getCurrentStep().valid) {
                                            _this.onFinish.next();
                                        }
                                        else {
                                            _this.stepError.next(_this.step);
                                        }
                                        resolve();
                                    });
                                })];
                    }
                });
            });
        };
        /**
         * Perform actions when the cancel button is clicked
         */
        WizardComponent.prototype.cancel = function () {
            this.onCancel.next();
        };
        /**
         * Update the active state of each step
         */
        WizardComponent.prototype.update = function () {
            var _this = this;
            // update which steps should be active
            this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
        };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        WizardComponent.prototype.gotoStep = function (step) {
            if (step.visited) {
                var stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                this.step = stepIndex;
            }
        };
        /**
         * Determine if the current step is the last step
         */
        WizardComponent.prototype.isLastStep = function () {
            return this.step === (this.steps.length - 1);
        };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        WizardComponent.prototype.reset = function () {
            // mark all steps as not visited
            this.steps.forEach(function (step) { return step.visited = false; });
            // go to the first step
            this.step = 0;
        };
        /**
         * Get the step at the current index
         */
        WizardComponent.prototype.getCurrentStep = function () {
            return this.getStepAtIndex(this.step);
        };
        /**
         * Return a step at a specific index
         */
        WizardComponent.prototype.getStepAtIndex = function (index) {
            return this.steps.toArray()[index];
        };
        /**
         * Returns the valid status of the current step, including the `validation` function (if provided).
         */
        WizardComponent.prototype.isStepValid = function () {
            // get the current activer step
            var currentStep = this.getCurrentStep();
            // if there is no validator then return the valid state
            if (!currentStep.validator) {
                return currentStep.valid;
            }
            // get the validator result
            return currentStep.validator();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "orientation", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "nextText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "previousText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "cancelText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "finishText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "nextTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "previousTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "cancelTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "finishTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "nextAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "previousAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "cancelAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], WizardComponent.prototype, "finishAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "nextDisabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "previousDisabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "cancelDisabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "finishDisabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "nextVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "previousVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "cancelVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "finishVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "cancelAlwaysVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "finishAlwaysVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], WizardComponent.prototype, "disableNextWhenInvalid", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "onNext", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "onPrevious", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "onCancel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "onFinishing", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "onFinish", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "stepChanging", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "stepChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "stepError", void 0);
        __decorate([
            core.ContentChildren(WizardStepComponent),
            __metadata("design:type", Object)
        ], WizardComponent.prototype, "steps", void 0);
        __decorate([
            core.ContentChild('footerTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], WizardComponent.prototype, "footerTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], WizardComponent.prototype, "step", null);
        WizardComponent = __decorate([
            core.Component({
                selector: 'ux-wizard',
                template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\"\n        uxTabbableList\n        [direction]=\"orientation\"\n        role=\"tablist\"\n        [attr.aria-orientation]=\"orientation\">\n\n        <div *ngFor=\"let stp of steps; let index = index\"\n            role=\"tab\"\n            class=\"wizard-step\"\n            [class.active]=\"stp.active\"\n            [class.visited]=\"stp.visited\"\n            [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\"\n            [attr.aria-posinset]=\"index + 1\"\n            [attr.aria-setsize]=\"steps.length\"\n            [attr.aria-selected]=\"stp.active\"\n            [attr.aria-controls]=\"id + '-step-' + index\"\n            [id]=\"id + '-step-' + index + '-label'\"\n            uxFocusIndicator\n            uxTabbableListItem\n            [programmaticFocusIndicator]=\"true\"\n            [disabled]=\"index !== 0 && !stp.visited\"\n            (click)=\"gotoStep(stp)\"\n            (keydown.enter)=\"gotoStep(stp)\">\n            <span class=\"wizard-step-text\">{{ stp.header }}</span>\n            <ux-icon *ngIf=\"stp.visited && !stp.active\" class=\"wizard-step-icon\" name=\"checkmark\"></ux-icon>\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n\n    <ng-container *ngIf=\"footerTemplate\"\n                  [ngTemplateOutlet]=\"footerTemplate\"\n                  [ngTemplateOutletContext]=\"{ step: step }\">\n    </ng-container>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-secondary\"\n            *ngIf=\"previousVisible\"\n            [uxTooltip]=\"previousTooltip\"\n            [disabled]=\"previousDisabled || step === 0\"\n            [attr.aria-label]=\"previousAriaLabel\"\n            (click)=\"previous(); tip.hide()\">\n        {{ previousText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-primary\"\n            *ngIf=\"nextVisible && !isLastStep()\"\n            [uxTooltip]=\"nextTooltip\"\n            [disabled]=\"nextDisabled || isNextDisabled()\"\n            [attr.aria-label]=\"nextAriaLabel\"\n            (click)=\"next(); tip.hide()\">\n        {{ nextText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-primary\"\n            *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n            [uxTooltip]=\"finishTooltip\"\n            [disabled]=\"finishDisabled || isNextDisabled()\"\n            [attr.aria-label]=\"finishAriaLabel\"\n            (click)=\"finish(); tip.hide()\">\n        {{ finishText }}\n    </button>\n\n    <button #tip=\"ux-tooltip\"\n            type=\"button\"\n            class=\"btn button-secondary\"\n            *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n            [uxTooltip]=\"cancelTooltip\"\n            [disabled]=\"cancelDisabled\"\n            [attr.aria-label]=\"cancelAriaLabel\"\n            (click)=\"cancel(); tip.hide()\">\n        {{ cancelText }}\n    </button>\n\n</div>\n",
                host: {
                    '[class]': 'orientation'
                }
            })
        ], WizardComponent);
        return WizardComponent;
    }());
    var StepChangingEvent = /** @class */ (function () {
        function StepChangingEvent(from, to) {
            this.from = from;
            this.to = to;
        }
        return StepChangingEvent;
    }());
    var DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = /** @class */ (function () {
        function WizardModule() {
        }
        WizardModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule,
                    TooltipModule,
                ],
                exports: DECLARATIONS$4,
                declarations: DECLARATIONS$4
            })
        ], WizardModule);
        return WizardModule;
    }());
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = /** @class */ (function () {
        function MarqueeWizardService() {
            this.valid$ = new rxjs.Subject();
        }
        MarqueeWizardService = __decorate([
            core.Injectable()
        ], MarqueeWizardService);
        return MarqueeWizardService;
    }());
    var MarqueeWizardStepComponent = /** @class */ (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(changeDetector, elementRef, renderer, _marqueeWizardService) {
            var _this = _super.call(this, changeDetector, elementRef, renderer) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            /** Determine the completed state of this step */
            _this.completed = false;
            /** Emit when the completed step changes */
            _this.completedChange = new core.EventEmitter();
            /** Store the validity of the current step */
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: function () {
                return this._valid;
            },
            set: function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        MarqueeWizardStepComponent.prototype.setCompleted = function (completed) {
            this.completed = completed;
            this.completedChange.emit(completed);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MarqueeWizardStepComponent.prototype, "completed", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MarqueeWizardStepComponent.prototype, "completedChange", void 0);
        __decorate([
            core.ContentChild(MarqueeWizardStepIconDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], MarqueeWizardStepComponent.prototype, "_iconTemplate", void 0);
        MarqueeWizardStepComponent = __decorate([
            core.Component({
                selector: 'ux-marquee-wizard-step',
                template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                core.ElementRef,
                core.Renderer2,
                MarqueeWizardService])
        ], MarqueeWizardStepComponent);
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));
    var MarqueeWizardComponent = /** @class */ (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService, _resizeService, _elementRef) {
            var _this = _super.call(this) || this;
            _this._resizeService = _resizeService;
            _this._elementRef = _elementRef;
            /** Initial set to default width to match 240px on left but can be changed with a perecentage value */
            _this.sidePanelWidth = 25;
            /** Width of the splitter - default is 10 */
            _this.gutterSize = 10;
            /** If set to true the resizable splitter will be enabled and set to the default width **/
            _this.resizable = false;
            /** Emit the current width of the splitter*/
            _this.sidePanelWidthChange = new core.EventEmitter();
            /** Access each step content component */
            _this.steps = new core.QueryList();
            /**
             * If the wizard is in a modal it may initially have a size of 0 until the modal displays
             * in which case if we are using the splitter it will not render correctly. We use this
             * variable to only initialise the splitter when the content has a width.
             */
            _this._isInitialised = false;
            /** Unsubscribe from all subscriptions when component is destroyed */
            _this._onDestroyed = new rxjs.Subject();
            // watch for changes to the size
            _resizeService.addResizeListener(_elementRef.nativeElement)
                .pipe(operators.takeUntil(_this._onDestroyed))
                .subscribe(_this.onResize.bind(_this));
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; }))
                .subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: function () {
                return this.description && this.description instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        MarqueeWizardComponent.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
            this._onDestroyed.next();
            this._onDestroyed.complete();
            this._resizeService.removeResizeListener(this._elementRef.nativeElement);
        };
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        MarqueeWizardComponent.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var step;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            step = this.getCurrentStep();
                            return [4 /*yield*/, _super.prototype.next.call(this)];
                        case 1:
                            _a.sent();
                            if (step && step.valid) {
                                // mark this step as completed
                                step.setCompleted(true);
                            }
                            else {
                                this.stepError.next(this.step);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        MarqueeWizardComponent.prototype.finish = function () {
            return __awaiter(this, void 0, void 0, function () {
                var step;
                var _this = this;
                return __generator(this, function (_a) {
                    step = this.getCurrentStep();
                    // call the original finish function
                    return [2 /*return*/, _super.prototype.finish.call(this).then(function () {
                            // if the step is valid indicate that it is now complete
                            if (step.valid) {
                                step.setCompleted(true);
                            }
                            else {
                                _this.stepError.next(_this.step);
                            }
                        })];
                });
            });
        };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        MarqueeWizardComponent.prototype.validChange = function (state) {
            var steps = this.steps.toArray();
            var current = steps.findIndex(function (step) { return step === state.step; });
            var affected = steps.slice(current);
            affected.forEach(function (step) {
                // the step should no longer be completed
                step.completed = false;
                // if the step is not the current step then also mark it as unvisited
                if (step !== state.step) {
                    step.visited = false;
                }
            });
        };
        MarqueeWizardComponent.prototype.onResize = function (event) {
            if (event.width !== 0 && event.height !== 0) {
                this._isInitialised = true;
            }
        };
        /** Whenever the drag event ends, update the internal value and emit the new size */
        MarqueeWizardComponent.prototype.onDragEnd = function (_a) {
            var sizes = _a.sizes;
            // we need to only get the size of the first panel which will be the side panel
            this.sidePanelWidth = sizes[0];
            this.sidePanelWidthChange.emit(this.sidePanelWidth);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], MarqueeWizardComponent.prototype, "description", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], MarqueeWizardComponent.prototype, "stepTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], MarqueeWizardComponent.prototype, "sidePanelWidth", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], MarqueeWizardComponent.prototype, "gutterSize", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], MarqueeWizardComponent.prototype, "resizable", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MarqueeWizardComponent.prototype, "sidePanelWidthChange", void 0);
        __decorate([
            core.ContentChildren(MarqueeWizardStepComponent),
            __metadata("design:type", Object)
        ], MarqueeWizardComponent.prototype, "steps", void 0);
        MarqueeWizardComponent = __decorate([
            core.Component({
                selector: 'ux-marquee-wizard',
                template: "<ng-container *ngIf=\"resizable && _isInitialised\">\n    <as-split direction=\"horizontal\"\n           [gutterSize]=\"gutterSize\"\n           (dragEnd)=\"onDragEnd($event)\">\n        <as-split-area [size]=\"sidePanelWidth\">\n            <ng-container [ngTemplateOutlet]=\"sidePanel\"></ng-container>\n        </as-split-area>\n        <as-split-area [size]=\"100 - sidePanelWidth\">\n            <ng-container [ngTemplateOutlet]=\"mainContentPanel\"></ng-container>\n        </as-split-area>\n    </as-split>\n</ng-container>\n\n<ng-container *ngIf=\"!resizable\">\n    <ng-container [ngTemplateOutlet]=\"sidePanel\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"mainContentPanel\"></ng-container>\n</ng-container>\n\n<ng-template #sidePanel>\n    <div class=\"marquee-wizard-side-panel\" [class.marquee-wizard-side-panel-resize]=\"resizable\">\n\n        <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n            <!-- If a template was provided display it -->\n            <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n            <!-- Otherwise wimply display the string -->\n            <ng-container *ngIf=\"!isTemplate\">\n                <p>{{ description }}</p>\n            </ng-container>\n        </div>\n\n        <ul class=\"marquee-wizard-steps\"\n            uxTabbableList\n            direction=\"vertical\"\n            role=\"tablist\"\n            aria-orientation=\"vertical\">\n\n            <li *ngFor=\"let step of steps; let index = index\"\n                role=\"tab\"\n                uxTabbableListItem\n                [disabled]=\"!step.visited\"\n                class=\"marquee-wizard-step\"\n                [class.active]=\"step.active\"\n                [class.visited]=\"step.visited\"\n                [class.invalid]=\"!step.valid\"\n                [attr.aria-posinset]=\"index + 1\"\n                [attr.aria-setsize]=\"steps.length\"\n                [attr.aria-selected]=\"step.active\"\n                [attr.aria-controls]=\"step.id\"\n                [id]=\"step.id + '-label'\"\n                (click)=\"gotoStep(step)\"\n                (keydown.enter)=\"gotoStep(step)\">\n\n                <ng-container [ngTemplateOutlet]=\"stepTemplate || defaultStepTemplate\" [ngTemplateOutletContext]=\"{ $implicit: step }\"></ng-container>\n            </li>\n\n        </ul>\n    </div>\n</ng-template>\n\n\n<ng-template #mainContentPanel>\n    <div class=\"marquee-wizard-content-panel\" [class.marquee-wizard-content-panel-resize]=\"resizable\">\n        <div class=\"marquee-wizard-content\">\n            <ng-content></ng-content>\n        </div>\n\n        <div class=\"modal-footer\">\n\n            <ng-container *ngIf=\"footerTemplate\"\n                          [ngTemplateOutlet]=\"footerTemplate\"\n                          [ngTemplateOutletContext]=\"{ step: step }\">\n            </ng-container>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-secondary\"\n                    *ngIf=\"previousVisible\"\n                    [uxTooltip]=\"previousTooltip\"\n                    [attr.aria-label]=\"previousAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"previousDisabled || step === 0\"\n                    (click)=\"previous(); tip.hide()\">\n                {{ previousText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-primary\"\n                    *ngIf=\"nextVisible && !isLastStep()\"\n                    [uxTooltip]=\"nextTooltip\"\n                    [attr.aria-label]=\"nextAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"nextDisabled || isNextDisabled()\"\n                    (click)=\"next(); tip.hide()\">\n                {{ nextText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-primary\"\n                    *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\"\n                    [uxTooltip]=\"finishTooltip\"\n                    [attr.aria-label]=\"finishAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"finishDisabled || isNextDisabled()\"\n                    (click)=\"finish(); tip.hide()\">\n                {{ finishText }}\n            </button>\n\n            <button #tip=\"ux-tooltip\"\n                    type=\"button\"\n                    class=\"btn button-secondary\"\n                    *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\"\n                    [uxTooltip]=\"cancelTooltip\"\n                    [attr.aria-label]=\"cancelAriaLabel\"\n                    container=\"body\"\n                    [disabled]=\"cancelDisabled\"\n                    (click)=\"cancel(); tip.hide()\">\n                {{ cancelText }}\n            </button>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #defaultStepTemplate let-step>\n\n    <!-- Insert the icon -->\n    <div *ngIf=\"step._iconTemplate\" class=\"marquee-wizard-step-icon\">\n        <ng-container [ngTemplateOutlet]=\"step._iconTemplate\"></ng-container>\n    </div>\n\n    <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n    <ux-icon *ngIf=\"step.completed\" class=\"marquee-wizard-step-status\" name=\"checkmark\"></ux-icon>\n</ng-template>",
                providers: [MarqueeWizardService]
            }),
            __metadata("design:paramtypes", [MarqueeWizardService,
                ResizeService,
                core.ElementRef])
        ], MarqueeWizardComponent);
        return MarqueeWizardComponent;
    }(WizardComponent));
    var MarqueeWizardModule = /** @class */ (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule,
                    TooltipModule,
                    WizardModule,
                    angularSplit.AngularSplitModule,
                    ResizeModule
                ],
                exports: [
                    MarqueeWizardComponent,
                    MarqueeWizardStepComponent,
                    MarqueeWizardStepIconDirective
                ],
                declarations: [
                    MarqueeWizardComponent,
                    MarqueeWizardStepComponent,
                    MarqueeWizardStepIconDirective
                ]
            })
        ], MarqueeWizardModule);
        return MarqueeWizardModule;
    }());
    var FrameExtractionService = /** @class */ (function () {
        function FrameExtractionService() {
        }
        FrameExtractionService.prototype.createVideoPlayer = function (source) {
            var videoPlayer = document.createElement('video');
            videoPlayer.preload = 'auto';
            videoPlayer.src = source;
            return videoPlayer;
        };
        FrameExtractionService.prototype.createCanvas = function (width, height) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        };
        FrameExtractionService.prototype.goToFrame = function (videoPlayer, time) {
            videoPlayer.currentTime = time;
            return rxjs.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
        };
        FrameExtractionService.prototype.getThumbnail = function (videoPlayer, canvas, time, width, height) {
            var _this = this;
            if (width === void 0) {
                width = 160;
            }
            if (height === void 0) {
                height = 90;
            }
            return rxjs.Observable.create(function (observer) {
                // go to specified frame
                var subscription = _this.goToFrame(videoPlayer, time).subscribe(function () {
                    // create image from current frame
                    canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                    observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                    observer.complete();
                    subscription.unsubscribe();
                });
            });
        };
        FrameExtractionService.prototype.getFrameThumbnail = function (source, width, height, time) {
            // create required elements
            var videoPlayer = this.createVideoPlayer(source);
            var canvas = this.createCanvas(width, height);
            var frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
            // ensure we release memory after we are finished
            frameSubscription.subscribe(null, null, function () {
                videoPlayer = null;
                canvas = null;
            });
            return frameSubscription;
        };
        FrameExtractionService.prototype.getFrameThumbnails = function (source, width, height, start, end, skip) {
            var _this = this;
            if (skip === void 0) {
                skip = 5;
            }
            // create required elements
            var videoPlayer = this.createVideoPlayer(source);
            var canvas = this.createCanvas(width, height);
            return rxjs.Observable.create(function (observer) {
                rxjs.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                    // calculate the frames required
                    var frames = [];
                    for (var idx = start; idx < end; idx += skip) {
                        frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                    }
                    rxjs.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                        videoPlayer = null;
                        canvas = null;
                        observer.complete();
                    });
                });
            });
        };
        FrameExtractionService = __decorate([
            core.Injectable()
        ], FrameExtractionService);
        return FrameExtractionService;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function FRAME_EXTRACTION_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new FrameExtractionService();
    }
    var FRAME_EXTRACTION_SERVICE_PROVIDER = {
        provide: FrameExtractionService,
        deps: [[new core.Optional(), new core.SkipSelf(), FrameExtractionService]],
        useFactory: FRAME_EXTRACTION_SERVICE_PROVIDER_FACTORY
    };
    var FrameExtractionModule = /** @class */ (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule = __decorate([
            core.NgModule({
                providers: [FRAME_EXTRACTION_SERVICE_PROVIDER]
            })
        ], FrameExtractionModule);
        return FrameExtractionModule;
    }());
    var MediaPlayerService = /** @class */ (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /** Aria Labels */
            this.muteAriaLabel = this.getMuteAriaLabel;
            this.playAriaLabel = this.getPlayAriaLabel;
            this.fullscreenAriaLabel = this.getFullscreenAriaLabel;
            this.selectSubtitlesAriaLabel = this.getSubtitlesAriaLabel;
            this.goToStartAriaLabel = 'Go to start';
            this.goToEndAriaLabel = 'Go to end';
            this.subtitlesTitleAriaLabel = 'Subtitles';
            this.subtitlesOffAriaLabel = 'Subtitles Off';
            this.noSubtitlesAriaLabel = 'No subtitles';
            this.mediaPlayerAriaLabel = 'Media Player';
            this.seekAriaLabel = 'Seek Slider';
            /*
                Create observables for media player events
            */
            this.playing = new rxjs.BehaviorSubject(false);
            this.initEvent = new rxjs.ReplaySubject();
            this.abortEvent = new rxjs.Subject();
            this.canPlayEvent = new rxjs.BehaviorSubject(false);
            this.canPlayThroughEvent = new rxjs.BehaviorSubject(false);
            this.durationChangeEvent = new rxjs.Subject();
            this.endedEvent = new rxjs.Subject();
            this.errorEvent = new rxjs.Subject();
            this.loadedDataEvent = new rxjs.Subject();
            this.loadedMetadataEvent = new rxjs.Subject();
            this.loadStartEvent = new rxjs.Subject();
            this.pauseEvent = new rxjs.Subject();
            this.playEvent = new rxjs.Subject();
            this.playingEvent = new rxjs.Subject();
            this.rateChangeEvent = new rxjs.Subject();
            this.seekedEvent = new rxjs.Subject();
            this.seekingEvent = new rxjs.Subject();
            this.stalledEvent = new rxjs.Subject();
            this.suspendEvent = new rxjs.Subject();
            this.timeUpdateEvent = new rxjs.Subject();
            this.volumeChangeEvent = new rxjs.Subject();
            this.waitingEvent = new rxjs.Subject();
            this.mediaClickEvent = new rxjs.Subject();
            this.fullscreenEvent = new rxjs.BehaviorSubject(false);
            this.quietModeEvent = new rxjs.BehaviorSubject(false);
            this.progressEvent = rxjs.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                var interval = setInterval(function () {
                    var buffered = _this._mediaPlayer.buffered;
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: function () {
                return this._quietMode;
            },
            set: function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: function () {
                return this._mediaPlayer && !isNaN(this.mediaPlayer.duration) ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.textTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.videoTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: function (value) {
                if (this._mediaPlayer) {
                    this._mediaPlayer.volume = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        MediaPlayerService.prototype.setMediaPlayer = function (hostElement, mediaPlayer) {
            this._hostElement = hostElement;
            this._mediaPlayer = mediaPlayer;
            this.initEvent.next(true);
        };
        /**
         * Toggle playing state
         */
        MediaPlayerService.prototype.togglePlay = function () {
            // prevent any action is not loaded
            if (this.loaded === false) {
                return;
            }
            if (this.paused) {
                this.play();
            }
            else {
                this.pause();
            }
        };
        /**
         * Starts playing the audio/video
         */
        MediaPlayerService.prototype.play = function () {
            this._mediaPlayer.play();
        };
        /**
         * Pauses the currently playing audio/video
         */
        MediaPlayerService.prototype.pause = function () {
            this._mediaPlayer.pause();
        };
        /**
         * Re-loads the audio/video element
         */
        MediaPlayerService.prototype.load = function () {
            this._mediaPlayer.load();
        };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        MediaPlayerService.prototype.canPlayType = function (type) {
            return this._mediaPlayer.canPlayType(type);
        };
        /**
         * Adds a new text track to the audio/video
         */
        MediaPlayerService.prototype.addTextTrack = function (kind, label, language) {
            return this._mediaPlayer.addTextTrack(kind, label, language);
        };
        /**
         * Attempt to display media in fullscreen mode
         */
        MediaPlayerService.prototype.requestFullscreen = function () {
            // get the host element (we need to do some browser specific checks and typescript complains)
            var host = this._hostElement;
            var requestFullscreen = host.requestFullscreen || host.webkitRequestFullscreen || host.msRequestFullscreen || host.mozRequestFullScreen;
            // if we can perform the action then perform it and update the state
            if (requestFullscreen) {
                requestFullscreen.call(host);
                // update the internal state
                this.fullscreen = true;
            }
        };
        /**
         * Exit full screen mode
         */
        MediaPlayerService.prototype.exitFullscreen = function () {
            // get the document element (we need to do some browser specific checks and typescript complains)
            var host = document;
            var exitFullscreen = host.exitFullscreen || host.webkitExitFullscreen || host.msExitFullscreen || host.mozCancelFullScreen;
            // if we can perform the action then perform it and update the state
            if (exitFullscreen) {
                exitFullscreen.call(host);
                // update the internal state
                this.fullscreen = false;
            }
        };
        /**
         * Toggle Fullscreen State
         */
        MediaPlayerService.prototype.toggleFullscreen = function () {
            if (this.fullscreen) {
                this.exitFullscreen();
            }
            else {
                this.requestFullscreen();
            }
        };
        MediaPlayerService.prototype.fullscreenChange = function () {
            // get the document element (we need to do some browser specific checks and typescript complains)
            var host = document;
            // set the fullscreen state (this also emits the event)
            this.fullscreen = host.fullscreen || host.webkitIsFullScreen || host.mozFullScreen || host.msFullscreenElement !== null && host.msFullscreenElement !== undefined;
        };
        /**
         * Extract the frames from the video
         */
        MediaPlayerService.prototype.getFrames = function (width, height, skip) {
            if (this.type === 'video') {
                return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
            }
            return rxjs.from([]);
        };
        MediaPlayerService.prototype.hideSubtitleTracks = function () {
            for (var index = 0; index < this.textTracks.length; index++) {
                this.textTracks[index].mode = 'hidden';
            }
        };
        MediaPlayerService.prototype.getMuteAriaLabel = function (volume) {
            return volume === 0 ? 'Unmute' : 'Mute';
        };
        MediaPlayerService.prototype.getPlayAriaLabel = function (isPlaying) {
            return isPlaying ? 'Pause' : 'Play';
        };
        MediaPlayerService.prototype.getFullscreenAriaLabel = function (isFullscreen) {
            return isFullscreen ? 'Exit full screen' : 'Full screen';
        };
        MediaPlayerService.prototype.getSubtitlesAriaLabel = function (track) {
            return "Select subtitles, " + track + " currently selected.";
        };
        MediaPlayerService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [FrameExtractionService])
        ], MediaPlayerService);
        return MediaPlayerService;
    }());
    var MediaPlayerBaseExtensionDirective = /** @class */ (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective = __decorate([
            core.Directive({
                selector: '[mediaPlayerBaseExtension]'
            }),
            __metadata("design:paramtypes", [MediaPlayerService])
        ], MediaPlayerBaseExtensionDirective);
        return MediaPlayerBaseExtensionDirective;
    }());
    var SliderComponent = /** @class */ (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /** This should reference either a single number or a SliderValue object, depending on the slider type specified. */
            this.value = 0;
            /** Emits when the `value` changes. */
            this.valueChange = new core.EventEmitter();
            // expose enums to Angular view
            this.sliderType = exports.SliderType;
            this.sliderStyle = exports.SliderStyle;
            this.sliderSize = exports.SliderSize;
            this.sliderSnap = exports.SliderSnap;
            this.sliderThumb = exports.SliderThumb;
            this.sliderTickType = exports.SliderTickType;
            this.sliderThumbEvent = exports.SliderThumbEvent;
            this.sliderCalloutTrigger = exports.SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: null
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: null
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: exports.SliderType.Value,
                handles: {
                    style: exports.SliderStyle.Button,
                    callout: {
                        trigger: exports.SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: exports.SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: exports.SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {}
                }
            };
        }
        Object.defineProperty(SliderComponent.prototype, "options", {
            get: function () {
                return this._options;
            },
            /** A wide range of options can used to customize the appearance and behavior of the component. */
            set: function (options) {
                this._options = options;
                this.updateOptions();
            },
            enumerable: true,
            configurable: true
        });
        SliderComponent.prototype.ngOnInit = function () {
            this.updateValues();
            this.setThumbState(exports.SliderThumb.Lower, false, false);
            this.setThumbState(exports.SliderThumb.Upper, false, false);
            // emit the initial value
            this.valueChange.next(this.clone(this.value));
        };
        SliderComponent.prototype.ngDoCheck = function () {
            if (this.detectValueChange(this.value, this._value)) {
                this.updateValues();
                this._value = this.clone(this.value);
            }
        };
        SliderComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // persistent tooltips will need positioned correctly at this stage
            setTimeout(function () {
                _this.updateTooltipPosition(exports.SliderThumb.Lower);
                _this.updateTooltipPosition(exports.SliderThumb.Upper);
                // mark as dirty
                _this._changeDetectorRef.markForCheck();
            });
        };
        SliderComponent.prototype.snapToNearestTick = function (thumb, snapTarget, forwards) {
            // get the value for the thumb
            var value = this.getThumbState(thumb).value;
            // get the closest ticks - remove any tick if we are currently on it
            var closest = this.getTickDistances(value, thumb, snapTarget)
                .filter(function (tick) { return tick.value !== value; })
                .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
            // If we have no ticks then move by a predefined amount
            if (closest) {
                return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
            }
            var step = snapTarget === exports.SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
            this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
        };
        SliderComponent.prototype.snapToEnd = function (thumb, forwards) {
            this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
        };
        SliderComponent.prototype.getThumbValue = function (thumb) {
            return this.getThumbState(thumb).value;
        };
        SliderComponent.prototype.getFormattedValue = function (thumb) {
            return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
        };
        SliderComponent.prototype.getThumbState = function (thumb) {
            return thumb === exports.SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
        };
        SliderComponent.prototype.setThumbState = function (thumb, hover, drag) {
            if (thumb === exports.SliderThumb.Lower) {
                this.thumbs.lower.hover = hover;
                this.thumbs.lower.drag = drag;
            }
            else {
                this.thumbs.upper.hover = hover;
                this.thumbs.upper.drag = drag;
            }
            // update the visibility of the tooltips
            this.updateTooltips(thumb);
        };
        SliderComponent.prototype.thumbEvent = function (thumb, event) {
            // get the current thumb state
            var state = this.getThumbState(thumb);
            // update based upon event
            switch (event) {
                case exports.SliderThumbEvent.DragStart:
                    state.drag = true;
                    break;
                case exports.SliderThumbEvent.DragEnd:
                    state.drag = false;
                    break;
                case exports.SliderThumbEvent.MouseOver:
                    state.hover = true;
                    break;
                case exports.SliderThumbEvent.MouseLeave:
                    state.hover = false;
                    break;
                case exports.SliderThumbEvent.None:
                    state.drag = false;
                    state.hover = false;
                    break;
            }
            // update the thumb state
            this.setThumbState(thumb, state.hover, state.drag);
        };
        SliderComponent.prototype.getAriaValueText = function (thumb) {
            // get the current thumb value
            var value = this.getThumbValue(thumb);
            // get all the ticks
            var tick = this.ticks.find(function (_tick) { return _tick.value === value; });
            if (tick && tick.label) {
                return tick.label;
            }
            // otherwise simply display the formatted value
            return this.getFormattedValue(thumb);
        };
        SliderComponent.prototype.updateTooltips = function (thumb) {
            var visible = false;
            var state = this.getThumbState(thumb);
            switch (this.options.handles.callout.trigger) {
                case exports.SliderCalloutTrigger.Persistent:
                    visible = true;
                    break;
                case exports.SliderCalloutTrigger.Drag:
                    visible = state.drag;
                    break;
                case exports.SliderCalloutTrigger.Hover:
                    visible = state.hover || state.drag;
                    break;
                case exports.SliderCalloutTrigger.Dynamic:
                    visible = true;
                    break;
            }
            // update the state for the corresponding thumb
            this.getTooltip(thumb).visible = visible;
            // update the tooltip text
            this.updateTooltipText(thumb);
            // update the tooltip positions
            this.updateTooltipPosition(thumb);
        };
        SliderComponent.prototype.updateTooltipText = function (thumb) {
            // get the thumb value
            var state = this.getThumbState(thumb);
            var tooltip = this.getTooltip(thumb);
            // store the formatted label
            tooltip.label = this.getFormattedValue(thumb).toString();
        };
        SliderComponent.prototype.getTooltipElement = function (thumb) {
            return thumb === exports.SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
        };
        SliderComponent.prototype.getTooltip = function (thumb) {
            return thumb === exports.SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
        };
        SliderComponent.prototype.updateTooltipPosition = function (thumb) {
            var tooltip = this.getTooltip(thumb);
            // if tooltip is not visible then stop here
            if (tooltip.visible === false) {
                return;
            }
            var tooltipElement = this.getTooltipElement(thumb);
            // get the element widths
            var thumbWidth;
            if (this._options.handles.style === exports.SliderStyle.Button) {
                thumbWidth = this._options.track.height === exports.SliderSize.Narrow ? 16 : 24;
            }
            else {
                thumbWidth = 2;
            }
            var tooltipWidth = tooltipElement.nativeElement.offsetWidth;
            // calculate the tooltips new position
            var tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
            // update tooltip position
            tooltip.position = -tooltipPosition;
            if (this._options.type === exports.SliderType.Range && this._options.handles.callout.trigger === exports.SliderCalloutTrigger.Dynamic) {
                this.preventTooltipOverlap(tooltip);
            }
        };
        SliderComponent.prototype.preventTooltipOverlap = function (tooltip) {
            var trackWidth = this.track.nativeElement.offsetWidth;
            var lower = (trackWidth / 100) * this.thumbs.lower.position;
            var upper = (trackWidth / 100) * this.thumbs.upper.position;
            var lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
            var upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
            var diff = (lower + lowerWidth) - (upper - upperWidth);
            // if the tooltips are closer than 16px then adjust so the dont move any close
            if (diff > 0) {
                if (tooltip === this.tooltips.lower && this.thumbs.lower.drag === false) {
                    tooltip.position -= (diff / 2);
                }
                else if (tooltip === this.tooltips.upper && this.thumbs.upper.drag === false) {
                    tooltip.position += (diff / 2);
                }
            }
        };
        SliderComponent.prototype.clamp = function (value, min, max) {
            return Math.min(Math.max(value, min), max);
        };
        SliderComponent.prototype.updateThumbPosition = function (event, thumb) {
            // get event position - either mouse or touch
            var eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
            // if event position is null do nothing
            if (eventPosition === null) {
                return;
            }
            // get mouse position
            var mouseX = window.pageXOffset + eventPosition;
            // get track size and position
            var trackBounds = this.track.nativeElement.getBoundingClientRect();
            // restrict the value within the range size
            var position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
            // get fraction representation of location within the track
            var fraction = (position / trackBounds.width);
            // convert to value within the range
            var value = ((this._options.track.max - this._options.track.min) * fraction) + this._options.track.min;
            // ensure value is valid
            value = this.validateValue(thumb, value);
            // snap to a tick if required
            value = this.snapToTick(value, thumb);
            // update the value accordingly
            this.setThumbValue(thumb, value);
            this.updateOrder(thumb);
            this.updateValues();
            // update tooltip text & position
            this.updateTooltipText(thumb);
            // update the position of all visible tooltips
            this.updateTooltipPosition(exports.SliderThumb.Lower);
            this.updateTooltipPosition(exports.SliderThumb.Upper);
            // mark as dirty for change detection
            this._changeDetectorRef.markForCheck();
        };
        SliderComponent.prototype.updateOrder = function (thumb) {
            var lower = thumb === exports.SliderThumb.Lower ? 101 : 100;
            var upper = thumb === exports.SliderThumb.Lower ? 100 : 101;
            // The most recently used thumb should be above
            this.thumbs.lower.order = lower;
            this.thumbs.upper.order = upper;
        };
        SliderComponent.prototype.getTickDistances = function (value, thumb, snapTarget) {
            // if snap target is none then return original value
            if (snapTarget === exports.SliderSnap.None) {
                return [];
            }
            // get filtered ticks
            var ticks;
            switch (snapTarget) {
                case exports.SliderSnap.Minor:
                    ticks = this.ticks.filter(function (tick) { return tick.type === exports.SliderTickType.Minor; });
                    break;
                case exports.SliderSnap.Major:
                    ticks = this.ticks.filter(function (tick) { return tick.type === exports.SliderTickType.Major; });
                    break;
                default:
                    ticks = this.ticks.slice(0);
            }
            // get the track limit
            var lowerLimit = this._options.track.min;
            var upperLimit = this._options.track.max;
            if (this._options.type === exports.SliderType.Range && thumb === exports.SliderThumb.Lower) {
                upperLimit = this.thumbs.upper.value;
            }
            if (this._options.type === exports.SliderType.Range && thumb === exports.SliderThumb.Upper) {
                lowerLimit = this.thumbs.lower.value;
            }
            // Find the closest tick to the current position
            var range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
            // If there are no close ticks in the valid range then dont snap
            if (range.length === 0) {
                return [];
            }
            return range.sort(function (tickOne, tickTwo) {
                var tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                var tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                return tickOneDelta - tickTwoDelta;
            });
        };
        SliderComponent.prototype.snapToTick = function (value, thumb) {
            var tickDistances = this.getTickDistances(value, thumb, this._options.track.ticks.snap);
            // if there are no ticks return the current value
            if (tickDistances.length === 0) {
                return value;
            }
            // get the closest tick
            return tickDistances[0].value;
        };
        SliderComponent.prototype.validateValue = function (thumb, value) {
            // if slider is not a range value is always valid providing it is within the chart min and max values
            if (this._options.type === exports.SliderType.Value) {
                return Math.max(Math.min(value, this._options.track.max), this._options.track.min);
            }
            // check if value is with chart ranges
            if (value > this._options.track.max) {
                return thumb === exports.SliderThumb.Lower ? Math.min(this._options.track.max, this.thumbs.upper.value) : this._options.track.max;
            }
            if (value < this._options.track.min) {
                return thumb === exports.SliderThumb.Upper ? Math.max(this._options.track.min, this.thumbs.lower.value) : this._options.track.min;
            }
            // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
            if (thumb === exports.SliderThumb.Lower) {
                if (this.thumbs.upper.value === null) {
                    return value;
                }
                return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
            }
            if (thumb === exports.SliderThumb.Upper) {
                if (this.thumbs.lower.value === null) {
                    return value;
                }
                return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
            }
        };
        SliderComponent.prototype.updateOptions = function () {
            // add in the default options that user hasn't specified
            this._options = this.deepMerge(this._options || {}, this.defaultOptions);
            this.updateTrackColors();
            this.updateTicks();
            this.updateValues();
        };
        SliderComponent.prototype.updateValues = function () {
            if (this.value === undefined || this.value === null) {
                this.value = 0;
            }
            var lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
            var upperValue = typeof this.value === 'number' ? this.value : this.value.high;
            // validate values
            lowerValue = this.validateValue(exports.SliderThumb.Lower, Number(lowerValue.toFixed(4)));
            upperValue = this.validateValue(exports.SliderThumb.Upper, Number(upperValue.toFixed(4)));
            // calculate the positions as percentages
            var lowerPosition = (((lowerValue - this._options.track.min) / (this._options.track.max - this._options.track.min)) * 100);
            var upperPosition = (((upperValue - this._options.track.min) / (this._options.track.max - this._options.track.min)) * 100);
            // update thumb positions
            this.thumbs.lower.position = lowerPosition;
            this.thumbs.upper.position = upperPosition;
            // calculate the track sizes
            this.tracks.lower.size = lowerPosition;
            this.tracks.middle.size = upperPosition - lowerPosition;
            this.tracks.upper.size = this._options.type === exports.SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
            // update the value input
            this.setValue(lowerValue, upperValue);
        };
        SliderComponent.prototype.setValue = function (low, high) {
            this.thumbs.lower.value = low;
            this.thumbs.upper.value = high;
            var previousValue = this.clone(this._value);
            this.value = this._options.type === exports.SliderType.Value ? low : { low: low, high: high };
            // call the event emitter if changes occured
            if (this.detectValueChange(this.value, previousValue)) {
                this.valueChange.emit(this.clone(this.value));
                this.updateTooltipText(exports.SliderThumb.Lower);
                this.updateTooltipText(exports.SliderThumb.Upper);
            }
            else {
                this.valueChange.emit(this.clone(this.value));
            }
        };
        SliderComponent.prototype.setThumbValue = function (thumb, value) {
            // update the thumb value
            this.getThumbState(thumb).value = value;
            // forward these changes to the value
            this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
        };
        SliderComponent.prototype.updateTicks = function () {
            // get tick options
            var majorOptions = this._options.track.ticks.major;
            var minorOptions = this._options.track.ticks.minor;
            // check if we should show ticks
            if (majorOptions.show === false && minorOptions.show === false) {
                this.ticks = [];
            }
            // create ticks for both major and minor - only get the ones to be shown
            var majorTicks = this.getTicks(majorOptions, exports.SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
            var minorTicks = this.getTicks(minorOptions, exports.SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
            // remove any minor ticks that are on a major interval
            this.ticks = this.unionTicks(majorTicks, minorTicks);
        };
        SliderComponent.prototype.updateTrackColors = function () {
            // get colors for each part of the track
            var _a = this._options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
            // update the controller value
            this.tracks.lower.color = this.getTrackColorStyle(lower);
            this.tracks.middle.color = this.getTrackColorStyle(range);
            this.tracks.upper.color = this.getTrackColorStyle(higher);
        };
        /** Map the color value to the correct CSS color value */
        SliderComponent.prototype.getTrackColorStyle = function (color) {
            return Array.isArray(color) ? "linear-gradient(to right, " + color.join(', ') + ")" : color;
        };
        SliderComponent.prototype.getSteps = function (steps) {
            // if they are already an array just return it
            if (steps instanceof Array) {
                return steps;
            }
            var output = [];
            // otherwise calculate the steps
            for (var idx = this._options.track.min; idx <= this._options.track.max; idx += steps) {
                output.push(idx);
            }
            return output;
        };
        SliderComponent.prototype.getTicks = function (options, type) {
            // create an array to store the ticks and step points
            var steps = this.getSteps(options.steps);
            // get some chart options
            var min = this._options.track.min;
            var max = this._options.track.max;
            // convert each step to a slider tick and remove invalid ticks
            return steps.map(function (step) {
                return {
                    showTicks: options.show,
                    showLabels: options.labels,
                    type: type,
                    position: ((step - min) / (max - min)) * 100,
                    value: step,
                    label: options.formatter(step)
                };
            }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
        };
        SliderComponent.prototype.unionTicks = function (majorTicks, minorTicks) {
            // get all ticks combined removing any minor ticks with the same value as major ticks
            return majorTicks.concat(minorTicks)
                .filter(function (tick, index, array) { return tick.type === exports.SliderTickType.Major || !array.find(function (tk) { return tk.type === exports.SliderTickType.Major && tk.position === tick.position; }); })
                .sort(function (t1, t2) { return t1.value - t2.value; });
        };
        SliderComponent.prototype.deepMerge = function (destination, source) {
            // loop though all of the properties in the source object
            for (var prop in source) {
                // check if the destination object has the property
                if (!destination.hasOwnProperty(prop)) {
                    // copy the property across
                    destination[prop] = source[prop];
                    continue;
                }
                // if the property exists and is not an object then skip
                if (typeof destination[prop] !== 'object') {
                    continue;
                }
                // check if property is an array
                if (destination[prop] instanceof Array) {
                    continue;
                }
                // if it is an object then perform a recursive check
                destination[prop] = this.deepMerge(destination[prop], source[prop]);
            }
            return destination;
        };
        SliderComponent.prototype.detectValueChange = function (value1, value2) {
            // compare two slider values
            if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                // references to the objects in the correct types
                var obj1 = value1;
                var obj2 = value2;
                return obj1.low !== obj2.low || obj1.high !== obj2.high;
            }
            // if not a slider value - should be number of nullable type - compare normally
            return value1 !== value2;
        };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param value - The object to check - this must be type any
         */
        SliderComponent.prototype.isSliderValue = function (value) {
            // check if is an object
            if (typeof value !== 'object') {
                return false;
            }
            // next check if it contains the necessary properties
            return 'low' in value && 'high' in value;
        };
        SliderComponent.prototype.clone = function (value) {
            // if it is not an object simply return the value
            if (typeof value !== 'object') {
                return value;
            }
            // create a new object from the existing one
            var instance = __assign({}, value);
            // delete remove the value from the old object
            value = undefined;
            // return the new instance of the object
            return instance;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SliderComponent.prototype, "value", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SliderComponent.prototype, "options", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], SliderComponent.prototype, "valueChange", void 0);
        __decorate([
            core.ViewChild('lowerTooltip', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], SliderComponent.prototype, "lowerTooltip", void 0);
        __decorate([
            core.ViewChild('upperTooltip', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], SliderComponent.prototype, "upperTooltip", void 0);
        __decorate([
            core.ViewChild('track', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], SliderComponent.prototype, "track", void 0);
        SliderComponent = __decorate([
            core.Component({
                selector: 'ux-slider',
                template: "<div class=\"track\"\n     #track\n     [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n     [class.wide]=\"_options.track.height === sliderSize.Wide\"\n     [class.range]=\"_options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        uxFocusIndicator\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"_options.type === sliderType.Range ? _options.handles.aria.lowerThumb :\n        _options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"_options?.track?.min\"\n        [attr.aria-valuemax]=\"_options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) :\n        _options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"_options.handles.style === sliderStyle.Button\"\n        [class.line]=\"_options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"_options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"_options.handles.callout.trigger === sliderCalloutTrigger.Dynamic &&\n             thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"_options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"_options.handles.callout.background\"\n                [style.color]=\"_options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"_options.type === sliderType.Range\"\n         [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        uxFocusIndicator\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"_options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || _options?.track?.min\"\n        [attr.aria-valuemax]=\"_options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"_options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"_options.handles.style === sliderStyle.Button\"\n        [class.line]=\"_options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"_options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"_options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"_options.handles.callout.trigger === sliderCalloutTrigger.Dynamic &&\n             thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"_options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"_options.type === sliderType.Range\"\n                [style.background-color]=\"_options.handles.callout.background\"\n                [style.color]=\"_options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(_options.track.ticks.major.show || _options.track.ticks.minor.show) &&\n    _options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"_options.track.ticks.major.labels || _options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [ColorService, core.ChangeDetectorRef])
        ], SliderComponent);
        return SliderComponent;
    }());
    (function (SliderType) {
        SliderType[SliderType["Value"] = 0] = "Value";
        SliderType[SliderType["Range"] = 1] = "Range";
    })(exports.SliderType || (exports.SliderType = {}));
    (function (SliderStyle) {
        SliderStyle[SliderStyle["Button"] = 0] = "Button";
        SliderStyle[SliderStyle["Line"] = 1] = "Line";
    })(exports.SliderStyle || (exports.SliderStyle = {}));
    (function (SliderSize) {
        SliderSize[SliderSize["Narrow"] = 0] = "Narrow";
        SliderSize[SliderSize["Wide"] = 1] = "Wide";
    })(exports.SliderSize || (exports.SliderSize = {}));
    (function (SliderCalloutTrigger) {
        SliderCalloutTrigger[SliderCalloutTrigger["None"] = 0] = "None";
        SliderCalloutTrigger[SliderCalloutTrigger["Hover"] = 1] = "Hover";
        SliderCalloutTrigger[SliderCalloutTrigger["Drag"] = 2] = "Drag";
        SliderCalloutTrigger[SliderCalloutTrigger["Persistent"] = 3] = "Persistent";
        SliderCalloutTrigger[SliderCalloutTrigger["Dynamic"] = 4] = "Dynamic";
    })(exports.SliderCalloutTrigger || (exports.SliderCalloutTrigger = {}));
    (function (SliderSnap) {
        SliderSnap[SliderSnap["None"] = 0] = "None";
        SliderSnap[SliderSnap["Minor"] = 1] = "Minor";
        SliderSnap[SliderSnap["Major"] = 2] = "Major";
        SliderSnap[SliderSnap["All"] = 3] = "All";
    })(exports.SliderSnap || (exports.SliderSnap = {}));
    (function (SliderTickType) {
        SliderTickType[SliderTickType["Minor"] = 0] = "Minor";
        SliderTickType[SliderTickType["Major"] = 1] = "Major";
    })(exports.SliderTickType || (exports.SliderTickType = {}));
    (function (SliderThumbEvent) {
        SliderThumbEvent[SliderThumbEvent["None"] = 0] = "None";
        SliderThumbEvent[SliderThumbEvent["MouseOver"] = 1] = "MouseOver";
        SliderThumbEvent[SliderThumbEvent["MouseLeave"] = 2] = "MouseLeave";
        SliderThumbEvent[SliderThumbEvent["DragStart"] = 3] = "DragStart";
        SliderThumbEvent[SliderThumbEvent["DragEnd"] = 4] = "DragEnd";
    })(exports.SliderThumbEvent || (exports.SliderThumbEvent = {}));
    (function (SliderThumb) {
        SliderThumb[SliderThumb["Lower"] = 0] = "Lower";
        SliderThumb[SliderThumb["Upper"] = 1] = "Upper";
    })(exports.SliderThumb || (exports.SliderThumb = {}));
    var SliderModule = /** @class */ (function () {
        function SliderModule() {
        }
        SliderModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    ColorServiceModule,
                    DragModule
                ],
                exports: [
                    SliderComponent
                ],
                declarations: [
                    SliderComponent
                ]
            })
        ], SliderModule);
        return SliderModule;
    }());
    var uniqueId$7 = 1;
    var MediaPlayerControlsExtensionComponent = /** @class */ (function () {
        function MediaPlayerControlsExtensionComponent(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
            this.volumeActive = false;
            this.volumeFocus = false;
            this.returnFocus = true;
            this.subtitlesId = "ux-media-player-subtitle-popover-" + uniqueId$7++;
            this.subtitlesOpen = false;
            this.mouseEnterVolume = new rxjs.Subject();
            this.mouseLeaveVolume = new rxjs.Subject();
            this.options = {
                handles: {
                    aria: {
                        thumb: 'Volume'
                    }
                },
                track: {
                    colors: {
                        lower: '#666'
                    },
                    height: exports.SliderSize.Narrow,
                    ticks: {
                        major: {
                            show: false
                        },
                        minor: {
                            show: false
                        }
                    }
                }
            };
            this._volume = 100;
            this._previousVolume = 100;
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: function () {
                return this._volume;
            },
            set: function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
            this.mediaPlayerService.initEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
            this.mouseEnterVolume.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
            this.mouseLeaveVolume.pipe(operators.switchMap(function () { return rxjs.timer(1500).pipe(operators.takeUntil(_this.mouseEnterVolume)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
        };
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        MediaPlayerControlsExtensionComponent.prototype.toggleMute = function () {
            this.volume = this.volume === 0 ? this._previousVolume : 0;
        };
        MediaPlayerControlsExtensionComponent.prototype.goToStart = function () {
            this.mediaPlayerService.currentTime = 0;
        };
        MediaPlayerControlsExtensionComponent.prototype.goToEnd = function () {
            this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
        };
        MediaPlayerControlsExtensionComponent.prototype.isSubtitleActive = function () {
            for (var idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                    return true;
                }
            }
            return false;
        };
        MediaPlayerControlsExtensionComponent.prototype.setSubtitleTrack = function (track) {
            // hide all tracks
            this.mediaPlayerService.hideSubtitleTracks();
            // set the position of the subtitle track
            for (var idx = 0; idx < track.cues.length; idx++) {
                var cue = track.cues[idx];
                cue.line = -3;
            }
            // activate the selected one
            track.mode = 'showing';
        };
        MediaPlayerControlsExtensionComponent.prototype.getSubtitleTrack = function () {
            for (var idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                    return this.mediaPlayerService.textTracks[idx].label;
                }
            }
            return this.mediaPlayerService.noSubtitlesAriaLabel;
        };
        MediaPlayerControlsExtensionComponent = __decorate([
            core.Component({
                selector: 'ux-media-player-controls',
                template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\"\n        #volumeContainer\n        [class.active]=\"volumeActive || volumeFocus\"\n        (mouseenter)=\"mouseEnterVolume.next()\"\n        (mouseleave)=\"mouseLeaveVolume.next()\"\n        (uxFocusWithin)=\"volumeFocus = true\"\n        (uxBlurWithin)=\"volumeFocus = false\">\n\n        <button #volumeIcon\n                uxFocusIndicator\n                type=\"button\"\n                class=\"volume-slider-icon\"\n                [attr.aria-label]=\"mediaPlayerService.muteAriaLabel(volume)\"\n                [uxTooltip]=\"muteTooltip\"\n                [showTriggers]=\"['mouseenter']\"\n                [hideTriggers]=\"['mouseleave']\"\n                (click)=\"toggleMute()\"\n                (mouseup)=\"volumeIcon.blur()\">\n\n            <ux-icon *ngIf=\"volume === 0\" name=\"volume-mute\"></ux-icon>\n            <ux-icon *ngIf=\"volume > 0 && volume <= 70\" name=\"volume-low\"></ux-icon>\n            <ux-icon *ngIf=\"volume > 70\" name=\"volume\"></ux-icon>\n        </button>\n\n        <div class=\"volume-slider-node\">\n            <ux-slider [(value)]=\"volume\" [options]=\"options\"></ux-slider>\n        </div>\n    </div>\n</div>\n\n<button #startButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    (click)=\"goToStart()\"\n    (mouseup)=\"startButton.blur()\"\n    [attr.aria-label]=\"mediaPlayerService.goToStartAriaLabel\">\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n    </svg>\n</button>\n\n<button #playButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    [attr.aria-label]=\"mediaPlayerService.playAriaLabel(mediaPlayerService.playing | async)\"\n    (click)=\"mediaPlayerService.togglePlay()\"\n    (mouseup)=\"playButton.blur()\">\n\n    <svg *ngIf=\"!(mediaPlayerService.playing | async)\" viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" focusable=\"false\">\n        <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n    </svg>\n    <svg *ngIf=\"mediaPlayerService.playing | async\" viewBox=\"0 0 43 56.9\" width=\"20\" height=\"29\" focusable=\"false\">\n        <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n        <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    </svg>\n</button>\n\n<button #endButton\n    uxFocusIndicator\n    type=\"button\"\n    class=\"control-button\"\n    (click)=\"goToEnd()\"\n    (mouseup)=\"endButton.blur()\"\n    [attr.aria-label]=\"mediaPlayerService.goToEndAriaLabel\">\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"0,64 0,0 44.1,32\" />\n    </svg>\n</button>\n\n<div class=\"actions-list\">\n\n    <ng-content></ng-content>\n\n    <div class=\"action-button-container\" *ngIf=\"mediaPlayerService.textTracks.length > 0 && mediaPlayerService.type === 'video'\">\n        <button #subtitlesButton\n            uxFocusIndicator\n            type=\"button\"\n            class=\"action-button\"\n            (keydown)=\"returnFocus = true\"\n            (click)=\"subtitlesOpen = !subtitlesOpen\"\n            (mouseup)=\"subtitlesButton.blur(); returnFocus = false\"\n            [attr.aria-label]=\"mediaPlayerService.selectSubtitlesAriaLabel(getSubtitleTrack())\"\n            [attr.aria-expanded]=\"subtitlesOpen\"\n            [attr.aria-describedby]=\"subtitlesId\"\n            aria-haspopup=\"true\">\n\n            <ux-icon name=\"subtitles\"></ux-icon>\n        </button>\n\n        <div #subtitles\n            [style.top.px]=\"-subtitles.offsetHeight\"\n            class=\"popover top media-player-subtitles-popover show\"\n            [id]=\"subtitlesId\"\n            (keydown.escape)=\"subtitlesOpen = false\"\n            (uxClickOutside)=\"subtitlesOpen = false\"\n            *ngIf=\"subtitlesOpen\">\n            <div class=\"arrow\"></div>\n            <h3 class=\"popover-title\">{{ mediaPlayerService.subtitlesTitleAriaLabel }}</h3>\n            <div class=\"popover-content\">\n                <ul class=\"subtitles-list\" uxTabbableList [focusOnShow]=\"returnFocus\" [returnFocus]=\"returnFocus\">\n                    <li uxTabbableListItem\n                        tabindex=\"0\"\n                        class=\"subtitles-list-item\"\n                        [class.active]=\"!isSubtitleActive()\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false\"\n                        (keydown.enter)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false; returnFocus = true\">\n\n                        <ux-icon name=\"checkmark\" class=\"subtitles-list-item-checkmark\"></ux-icon>\n                        <span>{{ mediaPlayerService.subtitlesOffAriaLabel }}</span>\n                    </li>\n                    <li uxTabbableListItem\n                        class=\"subtitles-list-item\"\n                        *ngFor=\"let track of mediaPlayerService.textTracks\"\n                        [class.active]=\"track.mode === 'showing'\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"setSubtitleTrack(track); subtitlesOpen = false\"\n                        (keydown.enter)=\"setSubtitleTrack(track); subtitlesOpen = false; returnFocus = true\">\n\n                        <ux-icon name=\"checkmark\" class=\"subtitles-list-item-checkmark\"></ux-icon>\n                        <span>{{ track.label }}</span>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"action-button-container\">\n        <button #fullscreenButton\n            uxFocusIndicator\n            *ngIf=\"mediaPlayerService.type !== 'audio'\"\n            type=\"button\"\n            class=\"action-button\"\n            [attr.aria-label]=\"mediaPlayerService.fullscreenAriaLabel(mediaPlayerService.fullscreen)\"\n            (click)=\"mediaPlayerService.toggleFullscreen()\"\n            (mouseup)=\"fullscreenButton.blur()\">\n\n            <ux-icon [name]=\"mediaPlayerService.fullscreen ? 'contract' : 'expand'\"></ux-icon>\n        </button>\n    </div>\n</div>\n\n\n\n<ng-template #muteTooltip>\n    <span aria-hidden=\"true\">{{ volume === 0 ? 'Unmute' : 'Mute' }}</span>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                }
            }),
            __metadata("design:paramtypes", [MediaPlayerService])
        ], MediaPlayerControlsExtensionComponent);
        return MediaPlayerControlsExtensionComponent;
    }());
    var MediaPlayerCustomControlDirective = /** @class */ (function () {
        function MediaPlayerCustomControlDirective() {
        }
        MediaPlayerCustomControlDirective = __decorate([
            core.Directive({
                selector: '[uxMediaPlayerCustomControl]',
            })
        ], MediaPlayerCustomControlDirective);
        return MediaPlayerCustomControlDirective;
    }());
    var MediaPlayerTimelineExtensionComponent = /** @class */ (function () {
        function MediaPlayerTimelineExtensionComponent(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
            this.current = 0;
            this.position = 0;
            this.buffered = [];
            this.mouseDown = false;
            this.scrub = { visible: false, position: 0, time: 0 };
            this._onDestroy = new rxjs.Subject();
        }
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit = function () {
            var _this = this;
            // watch for changes to the current time
            this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                _this.scrub.position = 0;
            });
            this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                _this.current = current;
                _this.position = (_this.current / _this.mediaPlayerService.duration) * 100;
            });
            this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                _this.buffered = [];
                for (var idx = 0; idx < buffered.length; idx++) {
                    _this.buffered.push({
                        start: (buffered.start(idx) / _this.mediaPlayerService.duration) * 100,
                        end: (buffered.end(idx) / _this.mediaPlayerService.duration) * 100
                    });
                }
            });
        };
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            var mousedown$ = rxjs.fromEvent(this.thumb.nativeElement, 'mousedown');
            var mousemove$ = rxjs.fromEvent(document, 'mousemove');
            var mouseup$ = rxjs.fromEvent(document, 'mouseup');
            mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
        };
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub = function (event) {
            var target = event.target;
            if (target.classList.contains('media-progress-bar-thumb')) {
                return;
            }
            var timeline = this.timelineRef.nativeElement;
            var bounds = timeline.getBoundingClientRect();
            this.scrub.position = event.offsetX;
            this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
            if (this.mouseDown) {
                this.mediaPlayerService.pause();
                this.mediaPlayerService.currentTime = this.scrub.time;
            }
        };
        /** Skip a number of seconds in any direction */
        MediaPlayerTimelineExtensionComponent.prototype.skip = function (seconds) {
            var target = this.current + seconds;
            // ensure that the target position is within the bounds of the clip
            if (target < 0) {
                target = 0;
            }
            if (target > this.mediaPlayerService.duration) {
                target = this.mediaPlayerService.duration;
            }
            this.mediaPlayerService.currentTime = target;
        };
        __decorate([
            core.ViewChild('progressThumb', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], MediaPlayerTimelineExtensionComponent.prototype, "thumb", void 0);
        __decorate([
            core.ViewChild('timeline', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], MediaPlayerTimelineExtensionComponent.prototype, "timelineRef", void 0);
        MediaPlayerTimelineExtensionComponent = __decorate([
            core.Component({
                selector: 'ux-media-player-timeline',
                template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline\n     class=\"timeline-bar\"\n     tabindex=\"0\"\n     role=\"slider\"\n     [attr.aria-label]=\"mediaPlayerService.seekAriaLabel\"\n     aria-valuemin=\"0\"\n     [attr.aria-valuemax]=\"mediaPlayerService.duration | number: '0.0-0'\"\n     [attr.aria-valuenow]=\"mediaPlayerService.currentTime | number: '0.0-0'\"\n     attr.aria-valuetext=\"{{ mediaPlayerService.currentTime | duration }} of {{ mediaPlayerService.duration | duration }}\"\n     (keydown.ArrowLeft)=\"skip(-5)\"\n     (keydown.ArrowRight)=\"skip(5)\"\n     (mouseenter)=\"scrub.visible = true; tooltip.show()\"\n     (mouseleave)=\"scrub.visible = false; tooltip.hide()\"\n     (mousemove)=\"updateScrub($event); tooltip.reposition()\"\n     (mouseup)=\"updateScrub($event)\"\n     (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\"\n         *ngFor=\"let buffer of buffered\"\n         [style.left.%]=\"buffer.start\"\n         [style.width.%]=\"buffer.end - buffer.start\">\n    </div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb\n             class=\"media-progress-bar-thumb\"\n             (mouseenter)=\"scrub.visible = false; tooltip.hide(); $event.stopPropagation()\"\n             (mouseleave)=\"scrub.visible = true; tooltip.show(); $event.stopPropagation()\">\n        </div>\n    </div>\n\n    <div #tooltip=\"ux-tooltip\"\n         class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         tooltipClass=\"ux-media-player-timeline-tooltip\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"mediaPlayerService.duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ mediaPlayerService.duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                host: {
                    '(document:mouseup)': 'mouseDown = false',
                    '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                }
            }),
            __metadata("design:paramtypes", [MediaPlayerService])
        ], MediaPlayerTimelineExtensionComponent);
        return MediaPlayerTimelineExtensionComponent;
    }());
    var AudioService = /** @class */ (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        AudioService.prototype.getAudioFileMetadata = function (mediaElement) {
            var _this = this;
            return rxjs.Observable.create(function (observer) {
                _this._http.get(mediaElement.src, { responseType: 'blob' }).subscribe(function (response) {
                    var description;
                    var extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                    var filename = mediaElement.src.indexOf('base64') !== -1 ? '' : mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                    switch (extension) {
                        case 'mp3':
                            description = 'MPEG audio layer 3 file';
                            break;
                        case 'wma':
                            description = 'Windows media audio file';
                            break;
                        case 'wav':
                            description = 'WAVE audio file';
                            break;
                        case 'ogg':
                            description = 'Ogg Vorbis file';
                            break;
                        case 'aac':
                            description = 'Advanced audio coding file';
                            break;
                        case 'midi':
                            description = 'Musical instrument digital interface file';
                            break;
                        default:
                            description = 'Audio file';
                            break;
                    }
                    observer.next({
                        filename: filename,
                        extension: extension,
                        description: description,
                        size: response.size
                    });
                });
            });
        };
        AudioService.prototype.getWaveformFromUrl = function (url) {
            var _this = this;
            // if audio context is not support return a stream of empty data
            if (!window.AudioContext) {
                return rxjs.of([new Float32Array(0)]);
            }
            this._audioContext = new AudioContext();
            this.createVolumeNode();
            this.createAnalyserNode();
            return rxjs.Observable.create(function (observer) {
                // load the media from the URL provided
                _this._http.get(url, { responseType: 'arraybuffer' }).subscribe(function (response) {
                    _this.getAudioBuffer(response).subscribe(function (audioBuffer) {
                        // create the buffer source
                        _this.createBufferSource(audioBuffer);
                        var dataPoints = [];
                        var channels = _this._audioBuffer.numberOfChannels;
                        // extract the data from each channel
                        for (var channelIdx = 0; channelIdx < channels; channelIdx++) {
                            dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                        }
                        observer.next(dataPoints);
                        observer.complete();
                        // cleanup after ourselves
                        dataPoints = null;
                    }, function (error) { return observer.error(error); });
                }, function (error) { return observer.error(error); });
            });
        };
        AudioService.prototype.getWaveformPoints = function (channels, skip) {
            if (channels === void 0) {
                channels = [];
            }
            if (skip === void 0) {
                skip = 1000;
            }
            var waveform = [];
            var duration = channels.length > 0 ? channels[0].length : 0;
            var _loop_1 = function (idx) {
                // get all the channel data for a specific point
                var points = channels.map(function (channel) { return channel[idx]; });
                // find the minimum point and maximum points at each position across all channels
                waveform.push({
                    min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                    max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                });
            };
            // convert each channel data to a series of waveform points
            for (var idx = 0; idx < duration; idx += skip) {
                _loop_1(idx);
            }
            return waveform;
        };
        AudioService.prototype.getAudioBuffer = function (arrayBuffer) {
            var _this = this;
            return rxjs.Observable.create(function (observer) {
                _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                    observer.next(audioBuffer);
                    observer.complete();
                }, function (error) { return observer.error(error); });
            });
        };
        AudioService.prototype.getOfflineAudioContext = function () {
            return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
        };
        AudioService.prototype.createBufferSource = function (audioBuffer) {
            this.disconnectSource();
            this._audioBuffer = audioBuffer;
            this._audioBufferSource = this._audioContext.createBufferSource();
            this._audioBufferSource.buffer = this._audioBuffer;
            this._audioBufferSource.connect(this._analyserNode);
        };
        AudioService.prototype.createVolumeNode = function () {
            this._gainNode = this._audioContext.createGain();
            this._gainNode.connect(this._audioContext.destination);
        };
        AudioService.prototype.createAnalyserNode = function () {
            this._analyserNode = this._audioContext.createAnalyser();
            this._analyserNode.connect(this._gainNode);
        };
        AudioService.prototype.disconnectSource = function () {
            if (this._audioBufferSource) {
                this._audioBufferSource.disconnect();
            }
        };
        AudioService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [http.HttpClient])
        ], AudioService);
        return AudioService;
    }());
    var AudioServiceModule = /** @class */ (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule = __decorate([
            core.NgModule({
                imports: [http.HttpClientModule],
                providers: [AudioService]
            })
        ], AudioServiceModule);
        return AudioServiceModule;
    }());
    var MediaPlayerComponent = /** @class */ (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this.focused = false;
            /** The `anonymous` keyword means that there will be no exchange of user credentials when the media source is fetched. */
            this.crossorigin = 'use-credentials';
            this._onDestroy = new rxjs.Subject();
            // show controls when hovering and in quiet mode
            rxjs.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.tap(function () { return _this.hovering = true; }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: function () {
                return this.mediaPlayerService.source;
            },
            /** The url to the media file to be loaded by the media player. */
            set: function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: function () {
                return this.mediaPlayerService.type;
            },
            /**
             * Defines the appearance of the media player. The two possible values are `video` and `audio`.
             * The media player will adapt it's appearance to best suit the type specified.
             */
            set: function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: function () {
                return this.mediaPlayerService.quietMode;
            },
            /**
             * If enabled, the controls in the media player will be hidden unless the mouse is over the player and will appear in a darker style.
             * Dark mode is automatically enabled in full screen mode. Quiet mode is only available for videos.
             */
            set: function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "muteAriaLabel", {
            /**
             * If specified the function will be called passing the current volume as an argument.
             * It should return an appropriate aria-label for the mute/unmute button.
             */
            set: function (fn) {
                this.mediaPlayerService.muteAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "playAriaLabel", {
            /**
             * If specified the function will be called passing the current playing state as an argument.
             * It should return an appropriate aria-label for the play/pause button.
             */
            set: function (fn) {
                this.mediaPlayerService.playAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "fullscreenAriaLabel", {
            /**
             * If specified the function will be called passing the current fullscreen state as an argument.
             * It should return an appropriate aria-label for the fullscreen toggle button.
             */
            set: function (fn) {
                this.mediaPlayerService.fullscreenAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "selectSubtitlesAriaLabel", {
            /**
             * If specified the function will be called passing the current track as an argument.
             * It should return an appropriate aria-label for the subtitle selection button.
             */
            set: function (fn) {
                this.mediaPlayerService.selectSubtitlesAriaLabel = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "goToStartAriaLabel", {
            /** Defines an aria-label for the go to start button. */
            set: function (ariaLabel) {
                this.mediaPlayerService.goToStartAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "goToEndAriaLabel", {
            /** Defines an aria-label for the go to end button. */
            set: function (ariaLabel) {
                this.mediaPlayerService.goToEndAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "subtitlesTitleAriaLabel", {
            /** Defines an aria-label for the title displayed in the subtitle selection popover. */
            set: function (ariaLabel) {
                this.mediaPlayerService.subtitlesTitleAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "subtitlesOffAriaLabel", {
            /** Defines an aria-label to indicate subtitle are not currently enabled. */
            set: function (ariaLabel) {
                this.mediaPlayerService.subtitlesOffAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "noSubtitlesAriaLabel", {
            /** Define an aria-label to indicate there are no subtitles available. */
            set: function (ariaLabel) {
                this.mediaPlayerService.noSubtitlesAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "mediaPlayerAriaLabel", {
            /** Define an aria-label for the media player. */
            set: function (ariaLabel) {
                this.mediaPlayerService.mediaPlayerAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "seekAriaLabel", {
            /** Define an aria-label for the the seek element. */
            set: function (ariaLabel) {
                this.mediaPlayerService.seekAriaLabel = ariaLabel;
            },
            enumerable: true,
            configurable: true
        });
        MediaPlayerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
            this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
            this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
            this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
            this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
            this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
            // initially hide all text tracks
            this.mediaPlayerService.hideSubtitleTracks();
        };
        MediaPlayerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.ViewChild('player', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], MediaPlayerComponent.prototype, "_playerRef", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MediaPlayerComponent.prototype, "crossorigin", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MediaPlayerComponent.prototype, "filename", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "source", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "type", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], MediaPlayerComponent.prototype, "quietMode", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], MediaPlayerComponent.prototype, "muteAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], MediaPlayerComponent.prototype, "playAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], MediaPlayerComponent.prototype, "fullscreenAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], MediaPlayerComponent.prototype, "selectSubtitlesAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "goToStartAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "goToEndAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "subtitlesTitleAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "subtitlesOffAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "noSubtitlesAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "mediaPlayerAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], MediaPlayerComponent.prototype, "seekAriaLabel", null);
        MediaPlayerComponent = __decorate([
            core.Component({
                selector: 'ux-media-player',
                template: "<div class=\"player-container\"\n     uxFocusIndicator\n     tabindex=\"0\"\n     [attr.aria-label]=\"mediaPlayerService.mediaPlayerAriaLabel\"\n     [cdkTrapFocus]=\"mediaPlayerService.fullscreen\">\n\n    <div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n        <video class=\"video-player\"\n            #player\n            tabindex=\"-1\"\n            [src]=\"source\"\n            [crossOrigin]=\"crossorigin\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n\n            <ng-content select=\"track\"></ng-content>\n        </video>\n\n        <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n            <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n                <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n                <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n            </svg>\n        </div>\n\n    </div>\n\n    <div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n        <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n            <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n                <g transform=\"translate(-98.000000, -458.000000)\">\n                    <g transform=\"translate(98.000000, 458.000000)\">\n                        <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                        <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                            stroke=\"#60798D\"></path>\n                        <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                        <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    </g>\n                </g>\n            </g>\n        </svg>\n\n        <p class=\"audio-file-name\">{{ this.filename ? this.filename :  (audioMetadata | async)?.filename }}</p>\n        <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n        <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n        <audio #player\n            [src]=\"source\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n        </audio>\n    </div>\n\n    <div class=\"control-bar\"\n        (uxFocusWithin)=\"focused = true\"\n        (uxBlurWithin)=\"focused = false\">\n\n        <ux-media-player-timeline></ux-media-player-timeline>\n        <ux-media-player-controls>\n            <ng-content select=\"[uxMediaPlayerCustomControl]\"></ng-content>\n        </ux-media-player-controls>\n    </div>\n</div>",
                providers: [MediaPlayerService],
                host: {
                    '(keydown.Space)': 'mediaPlayerService.togglePlay(); $event.preventDefault()',
                    '[class.standard]': '!mediaPlayerService.fullscreen',
                    '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                    '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                    '[class.hover]': 'hovering || focused',
                    '[class.video]': 'type === "video"',
                    '[class.audio]': 'type === "audio"',
                    '(mouseenter)': 'hovering = true',
                    '(mouseleave)': 'hovering = false',
                    '(document:fullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                    '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                    '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                    '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange()'
                }
            }),
            __metadata("design:paramtypes", [MediaPlayerService, AudioService, core.ElementRef])
        ], MediaPlayerComponent);
        return MediaPlayerComponent;
    }());
    var DurationPipe = /** @class */ (function () {
        function DurationPipe() {
        }
        DurationPipe.prototype.transform = function (seconds) {
            var minutes = Math.floor(seconds / 60);
            var hours = Math.floor(minutes / 60);
            var days = Math.floor(hours / 24);
            hours = hours - (days * 24);
            minutes = minutes - (days * 24 * 60) - (hours * 60);
            seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
            if (hours > 0) {
                return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
            }
            else {
                return this.pad(minutes) + ":" + this.pad(seconds);
            }
        };
        DurationPipe.prototype.pad = function (value) {
            if (value < 10) {
                return "0" + value;
            }
            return value.toString();
        };
        DurationPipe = __decorate([
            core.Pipe({
                name: 'duration'
            })
        ], DurationPipe);
        return DurationPipe;
    }());
    var DurationPipeModule = /** @class */ (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule = __decorate([
            core.NgModule({
                exports: [DurationPipe],
                declarations: [DurationPipe]
            })
        ], DurationPipeModule);
        return DurationPipeModule;
    }());
    var FileSizePipe = /** @class */ (function () {
        function FileSizePipe() {
        }
        FileSizePipe.prototype.transform = function (value) {
            // allow for async values
            if (!value) {
                return value;
            }
            var units = ['B', 'KB', 'MB', 'GB', 'TB'];
            // calculate the which unit bracket the values should be a part of
            var idx = Math.floor(Math.log(value) / Math.log(1024));
            var formattedValue = value / Math.pow(1024, idx);
            return formattedValue.toFixed(2) + " " + units[idx];
        };
        FileSizePipe = __decorate([
            core.Pipe({
                name: 'fileSize'
            })
        ], FileSizePipe);
        return FileSizePipe;
    }());
    var FileSizePipeModule = /** @class */ (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule = __decorate([
            core.NgModule({
                exports: [FileSizePipe],
                declarations: [FileSizePipe]
            })
        ], FileSizePipeModule);
        return FileSizePipeModule;
    }());
    var DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent,
        MediaPlayerCustomControlDirective
    ];
    var MediaPlayerModule = /** @class */ (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    AudioServiceModule,
                    ClickOutsideModule,
                    common.CommonModule,
                    DurationPipeModule,
                    FileSizePipeModule,
                    FrameExtractionModule,
                    IconModule,
                    SliderModule,
                    TooltipModule,
                ],
                exports: DECLARATIONS$5,
                declarations: DECLARATIONS$5
            })
        ], MediaPlayerModule);
        return MediaPlayerModule;
    }());
    var NavigationItemComponent = /** @class */ (function () {
        function NavigationItemComponent(_elementRef, _renderer, _router, _parent) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._router = _router;
            this._parent = _parent;
            /** Whether the navigation item is expanded, displaying the items from the `children` array. */
            this.expanded = false;
            /** Indicate whether the indentation should include the arrow */
            this._indentWithoutArrow = true;
            /** Automatically unsubscribe when the component is destroyed */
            this._onDestroy = new rxjs.Subject();
            this._level = this._parent ? this._parent._level + 1 : 1;
            // Expand this component if it or a descendant is active.
            _router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.expanded = _this.hasActiveLink(_this.link);
            });
        }
        NavigationItemComponent_1 = NavigationItemComponent;
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            /** Get the active state of this item from the router */
            get: function () {
                return this.link ? this._router.isActive(this.link, true) : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        NavigationItemComponent.prototype.ngAfterViewInit = function () {
            // Add classes to parent for styling
            var parentListElement = this._elementRef.nativeElement.parentElement;
            if (parentListElement) {
                var levelClass = this.getLevelClass();
                if (levelClass.length > 0) {
                    this._renderer.addClass(parentListElement, 'nav');
                    this._renderer.addClass(parentListElement, levelClass);
                }
            }
        };
        NavigationItemComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // Set 'indentWithoutArrow'
            this.setIndentWithoutArrow();
            // Update 'indentWithoutArrow' in response to changes to children
            this._children.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.setIndentWithoutArrow(); });
        };
        NavigationItemComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Check if this item or any children are active */
        NavigationItemComponent.prototype.hasActiveLink = function (link) {
            // If this component has a link, check if it is active.
            if (link && this._router.isActive(link, true)) {
                return true;
            }
            // If this component has children, check if any of them, or their descendants, are active.
            return this.children.some(function (item) { return item.hasActiveLink(item.link); });
        };
        NavigationItemComponent.prototype.getLevelClass = function () {
            switch (this._level) {
                case 2:
                    return 'nav-second-level';
                case 3:
                    return 'nav-third-level';
                case 4:
                    return 'nav-fourth-level';
                case 5:
                    return 'nav-fifth-level';
            }
            return '';
        };
        NavigationItemComponent.prototype.setIndentWithoutArrow = function () {
            if (this.children.length > 0) {
                // If this element has children it will be indented and will have an arrow
                this._indentWithoutArrow = false;
            }
            else if (this._parent) {
                // If this element has a parent, indent it if any of its siblings have children
                this._indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
            }
            else {
                // Top-level elements should be indented
                this._indentWithoutArrow = true;
            }
        };
        var NavigationItemComponent_1;
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NavigationItemComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NavigationItemComponent.prototype, "icon", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NavigationItemComponent.prototype, "expanded", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NavigationItemComponent.prototype, "link", void 0);
        __decorate([
            core.ContentChildren(NavigationItemComponent_1, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], NavigationItemComponent.prototype, "_children", void 0);
        NavigationItemComponent = NavigationItemComponent_1 = __decorate([
            core.Component({
                selector: '[ux-navigation-item]',
                template: "<a *ngIf=\"link\"\n   [class.has-arrow]=\"children.length > 0\"\n   [class.no-arrow]=\"_indentWithoutArrow\"\n   [routerLink]=\"link\">\n    <span>{{ header }}</span>\n</a>\n\n<a *ngIf=\"!link\"\n   (click)=\"expanded = !expanded\"\n   [class.has-arrow]=\"children.length > 0\"\n   [class.no-arrow]=\"_indentWithoutArrow\">\n    <span>{{ header }}</span>\n</a>\n\n<ng-content></ng-content>\n",
                host: {
                    '[class.active]': 'active',
                    '[class.selected]': 'expanded',
                }
            }),
            __param(3, core.Optional()), __param(3, core.SkipSelf()),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                router.Router,
                NavigationItemComponent])
        ], NavigationItemComponent);
        return NavigationItemComponent;
    }());
    var NAVIGATION_MODULE_OPTIONS = new core.InjectionToken('NAVIGATION_MODULE_OPTIONS');
    var NavigationService = /** @class */ (function () {
        function NavigationService() {
            /** Whether to collapse other menu items when expanding a menu item. */
            this.autoCollapse = true;
            /** Emit when the expanded state has changed */
            this.expanded$ = new rxjs.Subject();
        }
        NavigationService.prototype.ngOnDestroy = function () {
            this.expanded$.complete();
        };
        /** Set the expanded state of an item */
        NavigationService.prototype.setExpanded = function (source, expanded) {
            if (expanded && this.autoCollapse) {
                this.collapseSiblings(source);
                this.expanded$.next();
            }
        };
        /** Collapse all siblings nodes */
        NavigationService.prototype.collapseSiblings = function (source) {
            var e_1, _a;
            var _this = this;
            var siblings = this.items;
            try {
                for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    var parent_1 = this.getParent(source, item);
                    if (parent_1) {
                        siblings = parent_1.children;
                        break;
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            // collapse every sibling
            siblings.filter(function (item) { return item !== source; }).forEach(function (item) { return _this.collapseAll(item); });
        };
        /** Collapse an item and all its children */
        NavigationService.prototype.collapseAll = function (item) {
            var _this = this;
            item.expanded = false;
            if (item.children) {
                item.children.forEach(function (child) { return _this.collapseAll(child); });
            }
        };
        /** Get a nodes parent if it has one */
        NavigationService.prototype.getParent = function (target, item) {
            return (item.children || []).find(function (child) { return child === target; }) ? item : null;
        };
        NavigationService = __decorate([
            core.Injectable()
        ], NavigationService);
        return NavigationService;
    }());
    var NavigationLinkDirective = /** @class */ (function () {
        function NavigationLinkDirective(_router, _locationStrategy, _navigationService, _changeDetector, _route, _options) {
            this._router = _router;
            this._locationStrategy = _locationStrategy;
            this._navigationService = _navigationService;
            this._changeDetector = _changeDetector;
            this._route = _route;
            this._options = _options;
            /** Emit with the current expaned state */
            this._expanded$ = new rxjs.Subject();
            /** Unsubscribe from all observables when this directive is destroyed */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NavigationLinkDirective.prototype, "expanded", {
            /** The expaned state of this item */
            set: function (value) { this._expanded$.next(value); },
            enumerable: true,
            configurable: true
        });
        NavigationLinkDirective.prototype.ngOnInit = function () {
            var _this = this;
            // any time expanded state anywhere change we should run change detection in case we should collapse
            this._navigationService.expanded$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._changeDetector.markForCheck(); });
            this._expanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                if (_this.navigationItem.children && _this.navigationItem.children.length > 0) {
                    _this.ariaExpanded = expanded;
                    _this._navigationService.setExpanded(_this.navigationItem, expanded);
                }
            });
            this._router.events
                .pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy))
                .subscribe(this.updateNavigationState.bind(this));
            this.updateNavigationState();
            this.updateAttributes();
        };
        NavigationLinkDirective.prototype.ngOnChanges = function () {
            this.updateAttributes();
        };
        NavigationLinkDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        NavigationLinkDirective.prototype.activated = function (event) {
            if (this.navigationItem.routerLink) {
                var commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                this._router.navigate(commands, this.navigationItem.routerExtras);
            }
            // Toggle expanded state (relevant only if it has children)
            this.navigationItem.expanded = !this.navigationItem.expanded;
            // Invoke the custom click handler if specified
            if (this.navigationItem.click) {
                this.navigationItem.click(event, this.navigationItem);
            }
            return false;
        };
        NavigationLinkDirective.prototype.updateNavigationState = function () {
            var _this = this;
            this.isActive = this.isActiveItem(this.navigationItem);
            if (this.navigationItem.children) {
                var activeChild = this.navigationItem.children.find(function (child) { return _this.isActiveItem(child); });
                if (activeChild) {
                    this.navigationItem.expanded = true;
                }
            }
            this._changeDetector.markForCheck();
        };
        NavigationLinkDirective.prototype.updateAttributes = function () {
            this.href = this.getHref();
            this.role = (this.navigationItem.children && this.navigationItem.children.length > 0) ? 'button' : 'treeitem';
            this.indentChildren = this.navigationItem.children && this.navigationItem.children.some(function (item) { return item.children && item.children.length > 0; });
        };
        NavigationLinkDirective.prototype.getHref = function () {
            if (this.navigationItem.routerLink) {
                var commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                var urlTree = this._router.createUrlTree(commands, this.navigationItem.routerExtras);
                return this._locationStrategy.prepareExternalUrl(this._router.serializeUrl(urlTree));
            }
            return null;
        };
        NavigationLinkDirective.prototype.isActiveItem = function (item) {
            var _a = this.getRouterOptions(item), exact = _a.exact, ignoreQueryParams = _a.ignoreQueryParams;
            if (item.routerLink) {
                var routerExtras = item.routerExtras;
                // if we are to ignore the query params we must remove them
                if (ignoreQueryParams) {
                    // get the current actual query params
                    var queryParams = this._route.snapshot.queryParams;
                    // override the provided query params with the actual query params so they will alway match
                    routerExtras = __assign(__assign({}, routerExtras), { queryParams: queryParams });
                }
                var commands = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                var urlTree = this._router.createUrlTree(commands, routerExtras);
                return this._router.isActive(urlTree, exact);
            }
            return false;
        };
        /** Get the router options with defaults for missing properties */
        NavigationLinkDirective.prototype.getRouterOptions = function (item) {
            // get the default options based on the ones provided in `forRoot`
            var defaultOptions = __assign({ exact: true, ignoreQueryParams: false }, (this._options ? this._options.routerOptions : {}));
            // if there are item specific router options they should take precendence
            return __assign(__assign({}, defaultOptions), item.routerOptions);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NavigationLinkDirective.prototype, "navigationItem", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NavigationLinkDirective.prototype, "expanded", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NavigationLinkDirective.prototype, "canExpand", void 0);
        __decorate([
            core.Input(), core.HostBinding('class.indent'),
            __metadata("design:type", Boolean)
        ], NavigationLinkDirective.prototype, "indent", void 0);
        __decorate([
            core.HostBinding('attr.href'),
            __metadata("design:type", String)
        ], NavigationLinkDirective.prototype, "href", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            __metadata("design:type", String)
        ], NavigationLinkDirective.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.aria-expanded'),
            __metadata("design:type", Boolean)
        ], NavigationLinkDirective.prototype, "ariaExpanded", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            core.HostListener('keydown.enter', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Event]),
            __metadata("design:returntype", Boolean)
        ], NavigationLinkDirective.prototype, "activated", null);
        NavigationLinkDirective = __decorate([
            core.Directive({
                selector: '[uxNavigationLink]',
                exportAs: 'uxNavigationLink'
            }),
            __param(5, core.Optional()), __param(5, core.Inject(NAVIGATION_MODULE_OPTIONS)),
            __metadata("design:paramtypes", [router.Router,
                common.LocationStrategy,
                NavigationService,
                core.ChangeDetectorRef,
                router.ActivatedRoute, Object])
        ], NavigationLinkDirective);
        return NavigationLinkDirective;
    }());
    var NavigationComponent = /** @class */ (function () {
        function NavigationComponent(_navigationService) {
            this._navigationService = _navigationService;
            /** Whether to present the menu as a hierarchical tree. */
            this.tree = true;
            /** The classes to be added to each different level */
            this._hierarchyClasses = [
                '',
                'nav-second-level',
                'nav-third-level',
                'nav-fourth-level',
                'nav-fifth-level',
            ];
        }
        Object.defineProperty(NavigationComponent.prototype, "items", {
            get: function () {
                return this._navigationService.items;
            },
            /** The navigation items to populate the menu with. */
            set: function (items) {
                this._navigationService.items = items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "autoCollapse", {
            /** Whether to collapse other menu items when expanding a menu item. */
            set: function (autoCollapse) {
                this._navigationService.autoCollapse = autoCollapse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "_depthLimit", {
            get: function () {
                return this.tree ? this._hierarchyClasses.length : 2;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         */
        NavigationComponent.prototype._needsIndent = function (items) {
            return items && items.some(function (item) { return item.children && item.children.length > 0; });
        };
        /** Determine the type of icon to display. We support `hpe-icon`, `ux-icon` or `component` */
        NavigationComponent.prototype._getIconType = function (item) {
            return getIconType(item.icon);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], NavigationComponent.prototype, "items", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NavigationComponent.prototype, "tree", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NavigationComponent.prototype, "autoCollapse", null);
        __decorate([
            core.ContentChild('uxNavigationItem', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], NavigationComponent.prototype, "navigationItemTemplate", void 0);
        NavigationComponent = __decorate([
            core.Component({
                selector: 'ux-navigation',
                template: "<nav class=\"ux-side-nav\" [class.tree]=\"tree\" role=\"navigation\">\n\n    <ol *ngIf=\"items\" role=\"tree\" class=\"nav\" uxTabbableList [hierarchy]=\"true\">\n\n        <ng-container *ngFor=\"let item of items; let rank = index\"\n            [ngTemplateOutlet]=\"navigationNode\"\n            [ngTemplateOutletContext]=\"{ item: item, level: 1, rank: rank, indent: _needsIndent(items) }\">\n        </ng-container>\n\n        <ng-template #navigationNode let-item=\"item\" let-parent=\"parent\" let-level=\"level\" let-rank=\"rank\" let-indent=\"indent\">\n\n            <li [attr.role]=\"(item.children && item.children.length > 0) ? 'treeitem' : 'none'\"\n                [attr.aria-expanded]=\"item.expanded\"\n                [class.selected]=\"item.expanded\"\n                [class.active]=\"navigationLink.isActive\">\n\n                <a uxNavigationLink\n                    #navigationLink=\"uxNavigationLink\"\n                    #tli=\"ux-tabbable-list-item\"\n                    [navigationItem]=\"item\"\n                    [expanded]=\"item.expanded\"\n                    [canExpand]=\"level < _depthLimit\"\n                    [indent]=\"indent\"\n                    uxTabbableListItem\n                    [parent]=\"parent\"\n                    [rank]=\"rank\"\n                    [(expanded)]=\"item.expanded\">\n\n                    <span *ngIf=\"!navigationItemTemplate && item.children && item.children.length > 0 && level < _depthLimit\"\n                          aria-hidden=\"true\"\n                          class=\"nav-expander\"\n                          (click)=\"item.expanded = !item.expanded; $event.stopPropagation(); $event.preventDefault()\">\n                    </span>\n\n                    <!-- Support HPE Icons, UX Icons and Icon Component -->\n                    <ng-container *ngIf=\"!navigationItemTemplate && item.icon && !tree\">\n\n                        <span *ngIf=\"_getIconType(item) !== 'component'\"\n                              class=\"nav-icon\"\n                              [ngClass]=\"[_getIconType(item), item.icon]\">\n                        </span>\n\n                        <ux-icon *ngIf=\"_getIconType(item) === 'component'\"\n                                 class=\"nav-icon\"\n                                 [name]=\"item.icon\">\n                        </ux-icon>\n\n                    </ng-container>\n\n                    <img *ngIf=\"!navigationItemTemplate && item.iconUrl && !tree\" class=\"nav-icon\" [src]=\"item.iconUrl\" alt=\"item.iconLabel\">\n                    <span *ngIf=\"!navigationItemTemplate\" class=\"nav-title\">{{ item.title }}</span>\n\n                    <ng-container\n                        [ngTemplateOutlet]=\"navigationItemTemplate\"\n                        [ngTemplateOutletContext]=\"{ item: item, level: level }\">\n                    </ng-container>\n\n                </a>\n\n                <ol *ngIf=\"item.children && item.expanded && level < _depthLimit\"\n                    role=\"group\"\n                    class=\"nav\"\n                    [ngClass]=\"_hierarchyClasses[level]\">\n\n                    <ng-container *ngFor=\"let child of item.children; let rank = index\"\n                        [ngTemplateOutlet]=\"navigationNode\"\n                        [ngTemplateOutletContext]=\"{ item: child, parent: tli, level: level + 1, rank: rank, indent: navigationLink.indentChildren }\">\n                    </ng-container>\n\n                </ol>\n\n            </li>\n\n        </ng-template>\n\n    </ol>\n\n    <!-- Backward compatibility with the original ux-navigation -->\n    <ol *ngIf=\"!items\" role=\"tree\" class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n\n</nav>\n",
                providers: [NavigationService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [NavigationService])
        ], NavigationComponent);
        return NavigationComponent;
    }());
    var NavigationModule = /** @class */ (function () {
        function NavigationModule() {
        }
        NavigationModule_1 = NavigationModule;
        // allow options to be specified globally
        NavigationModule.forRoot = function (options) {
            return {
                ngModule: NavigationModule_1,
                providers: [
                    { provide: NAVIGATION_MODULE_OPTIONS, useValue: options }
                ]
            };
        };
        var NavigationModule_1;
        NavigationModule = NavigationModule_1 = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule,
                    router.RouterModule
                ],
                exports: [
                    NavigationComponent,
                    NavigationItemComponent
                ],
                declarations: [
                    NavigationComponent,
                    NavigationItemComponent,
                    NavigationLinkDirective
                ]
            })
        ], NavigationModule);
        return NavigationModule;
    }());
    var NestedDonutChartComponent = /** @class */ (function () {
        function NestedDonutChartComponent(_colorService, _changeDetector, _elementRef, _resizeService) {
            this._colorService = _colorService;
            this._changeDetector = _changeDetector;
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            /** Define the maximum range of the arcs */
            this.max = 100;
            /** Define the thickness of each arc */
            this.thickness = 8;
            /** Define the spacing of each arc */
            this.spacing = 8;
            /** Determine if we should show the hover effect */
            this.disableHover = false;
            /** Determine if we should show a tooltip on arc hover */
            this.disableTooltip = false;
            /** Determine the position of the tooltip */
            this.tooltipPlacement = 'top';
            /** Set the duration of the animation */
            this.animationDuration = 750;
            /** Emit whenever an arc is clicked */
            this.itemClick = new core.EventEmitter();
            /** Indicate if the tooltip should be visible */
            this._tooltipVisible = false;
            /** Store the previously processed data */
            this._arcData = [];
            /** Determine if the intial render has taken place */
            this._isInitialized = false;
            /** Unsubscribe from all observables automatically */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NestedDonutChartComponent.prototype, "_radius", {
            /** Determine the radius of the chart based on the specified size */
            get: function () {
                return this._size / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NestedDonutChartComponent.prototype, "_size", {
            /**
             * Get the size of the chart. The chart will always be square to
             * the size will be the smaller of the width/height properties
             */
            get: function () {
                return Math.min(this._elementRef.nativeElement.offsetWidth, this._elementRef.nativeElement.offsetHeight);
            },
            enumerable: true,
            configurable: true
        });
        /** Perform the initial render */
        NestedDonutChartComponent.prototype.ngOnInit = function () {
            var _this = this;
            // create the selection where we will draw the tracks
            this._trackLayer = d3.select(this._chartElement.nativeElement)
                .append('g');
            // create the selection where we will draw the arcs
            this._arcLayer = d3.select(this._chartElement.nativeElement)
                .append('g');
            // create the arcs representing the data
            this.render();
            // mark the component as initialized
            this._isInitialized = true;
            // listen for any resizing - skip the first emission as it always emits on first subscribe
            this._resizeService.addResizeListener(this._elementRef.nativeElement)
                .pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.render();
                _this._changeDetector.markForCheck();
            });
        };
        /** Any time an input changes we must re-render the chart */
        NestedDonutChartComponent.prototype.ngOnChanges = function () {
            if (this._isInitialized) {
                this.render();
            }
        };
        NestedDonutChartComponent.prototype.ngOnDestroy = function () {
            this._resizeService.removeResizeListener(this._elementRef.nativeElement);
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Inset the content so it never overlaps the arcs */
        NestedDonutChartComponent.prototype._getContentInset = function () {
            return this.dataset.length * (this.spacing + this.thickness);
        };
        /** Get the dimensions of the content area */
        NestedDonutChartComponent.prototype._getContentSize = function () {
            return this._size - (this._getContentInset() * 2);
        };
        /** Get the dataset formated in an accessible manner */
        NestedDonutChartComponent.prototype._getAriaLabel = function () {
            return this.dataset.map(function (data) { return data.value + " " + data.name; }).join('. ');
        };
        /**
         * Display the tracks and arcs defined by the dataset.
         * We also provide the transition configuration so anytime the dataset
         * changes we will animate the update.
         */
        NestedDonutChartComponent.prototype.render = function () {
            var _this = this;
            // update the transform of the layers
            this._trackLayer.attr('transform', "translate(" + this._radius + ", " + this._radius + ")");
            this._arcLayer.attr('transform', "translate(" + this._radius + ", " + this._radius + ")");
            // create the arcs based on the dataset
            this._arcs = this._arcLayer.selectAll('path')
                .data(this.getChartData());
            // create the default transition based on the specified duration
            var arcTransition = d3.transition().ease(d3.easeCubic).duration(this.animationDuration);
            // create the tracks based on the dataset
            this._tracks = this._trackLayer.selectAll('path')
                .data(this.getChartData())
                .enter()
                .append('path')
                .attr('class', 'ux-nested-donut-chart-track');
            // set the track color on each render in case the input has changed
            this._trackLayer.selectAll('path')
                .attr('d', this.getTrackArc())
                .style('fill', function () { return _this.getTrackColor(); });
            // if an arc is removed then also remove the track
            this._tracks.exit().remove();
            // When a new arc is added we should create the element
            // size it and provide the background color and begin the
            // animation until it reaches its final angle
            this._arcs.enter()
                .append('path')
                .attr('class', 'ux-nested-donut-chart-arc')
                .style('fill', function (data) { return _this.getColor(data.color); })
                .attr('opacity', 1)
                .on('click', function (data) { return _this.itemClick.emit(data); })
                .on('mouseenter', function (data, index, nodes) { return _this.onArcMouseEnter(nodes[index], data); })
                .on('mousemove', function () { return _this.onArcMouseMove(d3.mouse(_this._chartElement.nativeElement)); })
                .on('mouseleave', function (_data, index, nodes) { return _this.onArcMouseLeave(nodes[index]); })
                .transition(arcTransition)
                .attrTween('d', this.getArcTween.bind(this));
            // any time an existing dataset value changes
            // we should update the angle with an animation
            // we also animate any color changes also.
            this._arcs.transition(arcTransition)
                .style('fill', function (data) { return _this.getColor(data.color); })
                .attrTween('d', this.getArcTween.bind(this));
            // when a dataset it removed animate the arc out
            // and then remove the associated DOM element
            this._arcs.exit().transition(arcTransition)
                .attrTween('d', this.getArcTween.bind(this))
                .remove();
        };
        /** Get the interpolation function based on the new and previous angle */
        NestedDonutChartComponent.prototype.getArcTween = function (data) {
            var _this = this;
            // create a new interpolation function with a new endAngle
            var interpolation = d3.interpolate(__assign(__assign({}, data), { endAngle: data.previousEndAngle }), data);
            // return the function that will produce the interpolation
            return function (delta) { return _this.getArc()(interpolation(delta)); };
        };
        /** Get the arc layout for a specific item in the dataset */
        NestedDonutChartComponent.prototype.getArc = function () {
            var _this = this;
            return d3.arc()
                .innerRadius(function (data) { return _this.getArcRadius(data.index); })
                .outerRadius(function (data) { return _this.getArcRadius(data.index) + _this.thickness; })
                .startAngle(function (data) { return data.startAngle; })
                .endAngle(function (data) { return data.endAngle; });
        };
        /**
         * Get the track arc layout for a specific item in the dataset.
         * This will match the arc of that represents the actual data
         * however the endAngle will always be a complete circle
         */
        NestedDonutChartComponent.prototype.getTrackArc = function () {
            return this.getArc().endAngle(function () { return Math.PI * 2; });
        };
        /**
         * Get the radius of an arc. This is calculated
         * based on the chart radius that has been defined,
         * minus the thickness defined, then taking into account
         * the depth of the arc and the spacing between each arc.
         */
        NestedDonutChartComponent.prototype.getArcRadius = function (index) {
            return (this._radius - this.thickness) - (index * (this.thickness + this.spacing));
        };
        /**
         * Map the dataset to the NestedDonutChartArc interface
         */
        NestedDonutChartComponent.prototype.getChartData = function () {
            var _this = this;
            var dataset = this.dataset.map(function (data, index) {
                var previousEndAngle = 0;
                // check if there was a previous dataset at this index
                if (_this._arcData && _this._arcData[index]) {
                    previousEndAngle = _this._arcData[index].endAngle;
                }
                return __assign(__assign({}, data), { index: index, startAngle: 0, endAngle: _this.getAngle(data), previousEndAngle: previousEndAngle });
            });
            // store the latest processed arc data
            this._arcData = dataset;
            return dataset;
        };
        /** Convert the data value to radians */
        NestedDonutChartComponent.prototype.getAngle = function (data) {
            var fraction = data.value / this.max;
            var degrees = fraction * 360.0;
            return degrees * (Math.PI / 180);
        };
        /**
         * Get the color of the arc, this may be a CSS color value, the name of a color
         * from the color set or a ThemeColor object. We return this as a rgba color to
         * support the alpha channel
         */
        NestedDonutChartComponent.prototype.getColor = function (color) {
            return ThemeColor.isInstanceOf(color) ? color.toRgba() : this._colorService.resolve(color);
        };
        /** If no track color is specified then default to a specific color based on the active colorset */
        NestedDonutChartComponent.prototype.getTrackColor = function () {
            if (this.trackColor) {
                return this.getColor(this.trackColor);
            }
            // otherwise default to a color based on the colorset (note we can't use the Color enum from MF package)
            if (this._colorService.colorExists(exports.Color.Grey6)) {
                return this.getColor(exports.Color.Grey6);
            }
            if (this._colorService.colorExists('bright-gray')) {
                return this.getColor('bright-gray');
            }
        };
        /** Define the on hover event */
        NestedDonutChartComponent.prototype.onArcMouseEnter = function (target, data) {
            // update the hover effect if it is enabled
            if (this.disableHover === false) {
                d3.select(target).transition().duration(250).attr('opacity', 0.5);
            }
            // update the tooltip context
            this._tooltipContext = __assign(__assign({}, data), { color: this.getColor(data.color) });
            // update the tooltip visibility
            this._tooltipVisible = true;
            // run change detection to ensure the visibility is updated
            this._changeDetector.detectChanges();
        };
        /** Update the tooltip position on mouse move */
        NestedDonutChartComponent.prototype.onArcMouseMove = function (_a) {
            var _b = __read(_a, 2), x = _b[0], y = _b[1];
            this._tooltipX = x;
            this._tooltipY = y - 2; // subtract 2 so that it appears slightly above the cursor
            // run change detection to update the element position
            this._changeDetector.detectChanges();
        };
        /** Define the on hover out event */
        NestedDonutChartComponent.prototype.onArcMouseLeave = function (target) {
            // update the hover effect if it is enabled
            if (this.disableHover === false) {
                d3.select(target).transition().duration(250).attr('opacity', 1);
            }
            // clear the tooltip context
            this._tooltipContext = null;
            // update the tooltip visibility
            this._tooltipVisible = false;
            // run change detection to ensure the visibility is updated
            this._changeDetector.detectChanges();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], NestedDonutChartComponent.prototype, "dataset", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NestedDonutChartComponent.prototype, "max", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NestedDonutChartComponent.prototype, "thickness", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NestedDonutChartComponent.prototype, "spacing", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NestedDonutChartComponent.prototype, "trackColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NestedDonutChartComponent.prototype, "disableHover", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], NestedDonutChartComponent.prototype, "disableTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NestedDonutChartComponent.prototype, "tooltipPlacement", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NestedDonutChartComponent.prototype, "animationDuration", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], NestedDonutChartComponent.prototype, "itemClick", void 0);
        __decorate([
            core.ViewChild('chart', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], NestedDonutChartComponent.prototype, "_chartElement", void 0);
        __decorate([
            core.ContentChild('tooltip', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], NestedDonutChartComponent.prototype, "_customTooltip", void 0);
        NestedDonutChartComponent = __decorate([
            core.Component({
                selector: 'ux-nested-donut-chart',
                template: "<svg #chart\n    class=\"ux-nested-donut-chart\"\n    [attr.focusable]=\"false\"\n    [attr.width]=\"_size\"\n    [attr.height]=\"_size\"\n    [attr.aria-label]=\"_getAriaLabel()\">\n</svg>\n\n<!-- Custom content in center of the chart -->\n<div class=\"ux-nested-donut-chart-content\"\n    [style.top.px]=\"_getContentInset()\"\n    [style.right.px]=\"_getContentInset()\"\n    [style.bottom.px]=\"_getContentInset()\"\n    [style.left.px]=\"_getContentInset()\"\n    [style.width.px]=\"_getContentSize()\"\n    [style.height.px]=\"_getContentSize()\">\n  <ng-content></ng-content>\n</div>\n\n<!-- Tooltip to appear on arc hover -->\n<div class=\"ux-nested-donut-chart-tooltip\" *ngIf=\"_tooltipVisible && !disableTooltip\">\n  <ux-tooltip\n    [placement]=\"tooltipPlacement\"\n    [content]=\"_customTooltip || tooltip\"\n    [context]=\"_tooltipContext\"\n    [style.top.px]=\"_tooltipY\"\n    [style.left.px]=\"_tooltipX\">\n  </ux-tooltip>\n</div>\n\n<!-- Default tooltip template -->\n<ng-template #tooltip let-name=\"name\" let-value=\"value\">\n  <span class=\"ux-nested-donut-chart-tooltip-content\">\n    {{ name }}: {{ value }}\n  </span>\n</ng-template>\n\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [ColorService,
                core.ChangeDetectorRef,
                core.ElementRef,
                ResizeService])
        ], NestedDonutChartComponent);
        return NestedDonutChartComponent;
    }());
    var NestedDonutChartModule = /** @class */ (function () {
        function NestedDonutChartModule() {
        }
        NestedDonutChartModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    ColorServiceModule,
                    TooltipModule,
                    ResizeModule
                ],
                declarations: [
                    NestedDonutChartComponent
                ],
                exports: [
                    NestedDonutChartComponent
                ]
            })
        ], NestedDonutChartModule);
        return NestedDonutChartModule;
    }());
    var NotificationService = /** @class */ (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            /**
             *  Sets the order in which notifications are displayed:
                `above` - newer notifications will appear above older ones.
                `below` - newer notifications will appear below older ones.
             */
            this.direction = 'above';
            /**
             * The list of notifications including notifications that have been dismissed
             */
            this.notifications$ = new rxjs.BehaviorSubject([]);
            /**
             * Define the default set of notification options
             */
            this.options = {
                duration: 4,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
        }
        Object.defineProperty(NotificationService.prototype, "notifications", {
            /**
             * Access the list of notifications as an array
             */
            get: function () {
                return this.notifications$.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This function should be called to show a notification.
         * It should be given a TemplateRef containing the content to be displayed.
         * @param templateRef - A TemplateRef containing the content to be displayed
         * @param options - The properties to configure the notification.
         * @param context - The context passed to the notification TemplateRef. This can be accessed by adding a let-data="data" to the ng-template element.
         */
        NotificationService.prototype.show = function (templateRef, options, context) {
            var _this = this;
            if (options === void 0) {
                options = this.options;
            }
            if (context === void 0) {
                context = {};
            }
            // populate the specified options with the default values for any missing properties
            options = __assign(__assign({}, this.options), options);
            // create the notificationRef based on the options and context specified
            var notificationRef = {
                templateRef: templateRef,
                duration: options.duration,
                date: new Date(),
                visible: true,
                height: options.height,
                spacing: options.spacing,
                backgroundColor: options.backgroundColor,
                iconColor: options.iconColor,
                data: context
            };
            // add the new notification to the list (either above or below based on direction)
            this.direction === 'above' ? this.notifications.unshift(notificationRef) : this.notifications.push(notificationRef);
            // update the notifications list
            this.notifications$.next(this.notifications);
            // remove notification after delay
            if (options.duration !== 0) {
                setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
            }
            return notificationRef;
        };
        /**
         * This function will return a list of all the notifications that have been shown.
         */
        NotificationService.prototype.getHistory = function () {
            return this.notifications;
        };
        /**
         * This function can be called to dismiss a notification. It should be passed the object to dismiss.
         * @param notificationRef - The notification that should be dismissed
         */
        NotificationService.prototype.dismiss = function (notificationRef) {
            notificationRef.visible = false;
            this.notifications$.next(this.notifications);
        };
        /**
         * This function will dismiss any currently visible notifications.
         */
        NotificationService.prototype.dismissAll = function () {
            this.notifications.forEach(function (notificationRef) { return notificationRef.visible = false; });
            this.notifications$.next(this.notifications);
        };
        /** Remove the notification from the screen and from the notification history */
        NotificationService.prototype.remove = function (notificationRef) {
            this.notifications$.next(this.notifications.filter(function (_notificationRef) { return _notificationRef !== notificationRef; }));
        };
        /** Remove all notifications from the screen and from the notification history */
        NotificationService.prototype.removeAll = function () {
            this.notifications$.next([]);
        };
        NotificationService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [ColorService])
        ], NotificationService);
        return NotificationService;
    }());
    var NotificationListComponent = /** @class */ (function () {
        function NotificationListComponent(_notificationService, _changeDetectorRef, _renderer) {
            var _this = this;
            this._notificationService = _notificationService;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            /** Sets the position of the list of notifications within the browser window. */
            this.position = 'bottom-right';
            /** The list of notifications that have not been dismissed */
            this.notifications$ = this._notificationService.notifications$.pipe(operators.map(function () { return _this._notifications; }));
            /** Unsubscribe from all subscriptions on component destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            /**
             *  Sets the order in which notifications are displayed:
                `above` - newer notifications will appear above older ones.
                `below` - newer notifications will appear below older ones.
             */
            set: function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotificationListComponent.prototype, "_notifications", {
            /** Filter out any hidden notifications */
            get: function () {
                return this._notificationService.notifications.filter(function (notification) { return notification.visible; });
            },
            enumerable: true,
            configurable: true
        });
        NotificationListComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // whenever the notifications change we want to recalculate the positions and height
            this._elements.changes.pipe(operators.takeUntil(this._onDestroy), tick(), operators.map(function (changes) { return changes.toArray(); }), operators.withLatestFrom(this.notifications$)).subscribe(function (_a) {
                var _b = __read(_a, 2), elements = _b[0], notifications = _b[1];
                // Set the `top` style property of each element
                _this.applyElementPositions(elements, notifications);
                if (_this.position === 'bottom-left' || _this.position === 'bottom-right') {
                    // calculate the total height of all notifications including spacing
                    _this._bottom = notifications.reduce(function (total, notification, index) {
                        return total + elements[index].nativeElement.scrollHeight + notification.spacing;
                    }, 0);
                    // we are running in OnPush mode, so we will need to manually trigger CD here
                    _this._changeDetectorRef.markForCheck();
                }
            });
        };
        NotificationListComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        NotificationListComponent.prototype.applyElementPositions = function (elements, notifications) {
            var top = 0;
            for (var i = 0; i < elements.length; i += 1) {
                var element = elements[i].nativeElement;
                var notification = notifications[i];
                this._renderer.setStyle(element, 'top', top + "px");
                top = top + element.scrollHeight + notification.spacing;
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], NotificationListComponent.prototype, "direction", null);
        __decorate([
            core.Input(),
            core.HostBinding('class'),
            __metadata("design:type", String)
        ], NotificationListComponent.prototype, "position", void 0);
        __decorate([
            core.HostBinding('style.bottom.px'),
            __metadata("design:type", Number)
        ], NotificationListComponent.prototype, "_bottom", void 0);
        __decorate([
            core.ViewChildren('notification'),
            __metadata("design:type", core.QueryList)
        ], NotificationListComponent.prototype, "_elements", void 0);
        NotificationListComponent = __decorate([
            core.Component({
                selector: 'ux-notification-list',
                template: "<div #notification\n    class=\"notification\"\n    *ngFor=\"let notificationRef of notifications$ | async; let index = index\"\n    [style.height.px]=\"notificationRef.height\"\n    [style.background-color]=\"notificationRef.backgroundColor\"\n    [@notificationState]>\n\n    <!-- Notification Content -->\n    <ng-container\n        [ngTemplateOutlet]=\"notificationRef.templateRef\"\n        [ngTemplateOutletContext]=\"{ $implicit: notificationRef, data: notificationRef.data }\">\n    </ng-container>\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('notificationState', [
                        animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                        animations.transition(':enter', [
                            animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                            animations.animate(500)
                        ]),
                        animations.transition(':leave', [
                            animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                        ])
                    ])
                ]
            }),
            __metadata("design:paramtypes", [NotificationService,
                core.ChangeDetectorRef,
                core.Renderer2])
        ], NotificationListComponent);
        return NotificationListComponent;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function NOTIFICATION_SERVICE_PROVIDER_FACTORY(parentService, colorService) {
        return parentService || new NotificationService(colorService);
    }
    var NOTIFICATION_SERVICE_PROVIDER = {
        provide: NotificationService,
        deps: [[new core.Optional(), new core.SkipSelf(), NotificationService], ColorService],
        useFactory: NOTIFICATION_SERVICE_PROVIDER_FACTORY
    };
    var NotificationModule = /** @class */ (function () {
        function NotificationModule() {
        }
        NotificationModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    ColorServiceModule
                ],
                exports: [
                    NotificationListComponent
                ],
                declarations: [
                    NotificationListComponent
                ],
                providers: [
                    NOTIFICATION_SERVICE_PROVIDER
                ]
            })
        ], NotificationModule);
        return NotificationModule;
    }());
    var OrganizationChartComponent = /** @class */ (function () {
        function OrganizationChartComponent(_elementRef, _resizeService, _componentFactoryResolver, _injector, _appRef, _viewContainerRef, _renderer, _focusIndicator, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._injector = _injector;
            this._appRef = _appRef;
            this._viewContainerRef = _viewContainerRef;
            this._renderer = _renderer;
            this._focusIndicator = _focusIndicator;
            this._ngZone = _ngZone;
            /** Define the presentation of the connectors */
            this.connector = 'elbow';
            /** Define the duration of the transition animations */
            this.duration = 750;
            /** Define whether or not we can reveal additional parents */
            this.showReveal = false;
            /** Define the aria label for the reveal button */
            this.revealAriaLabel = 'Reveal More';
            /** Emit whenever a node is selected */
            this.selectedChange = new core.EventEmitter(true);
            /** Emit whenever the reveal button is pressed */
            this.reveal = new core.EventEmitter();
            /** Emit when the transition ends */
            this.transitionEnd = new core.EventEmitter();
            /** Store a flattened array of nodes */
            this._nodeLayout = [];
            /** Store a flattened array of links */
            this._linkLayout = [];
            /** Store the portal/outlets associated with some data */
            this._portals = new Map();
            /** Store the focus indicators associated with nodes */
            this._indicators = new Map();
            /** Store whether or not a transition is in progress */
            this._isTransitioning = false;
            /** Store whether or not a camera pan is in progress */
            this._isPanning = false;
            /** Determine if the component is initialised */
            this._isInitialised = false;
            /** Determine if the connector type has changed since the last render */
            this._hasConnectorChanged = false;
            /** Automatically unsubscribe from all subscriptions on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(OrganizationChartComponent.prototype, "selected", {
            /** Programmatically select an item */
            set: function (selected) {
                if (this.selected === selected || !selected) {
                    return;
                }
                if (this._isInitialised) {
                    this.select(selected);
                    this.centerNode(selected);
                }
                else {
                    this._pendingSelection = selected;
                }
            },
            enumerable: true,
            configurable: true
        });
        OrganizationChartComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // before we do anything ensure they have provided a template
            if (!this.nodeTemplate) {
                throw new Error('Organization Chart - You must provide a node template!');
            }
            if (!this.nodeWidth || !this.nodeHeight) {
                throw new Error('Organization Chart - You must specify a nodeWidth and nodeHeight');
            }
            // create the zoom drag listener
            this._zoom = d3.zoom()
                .scaleExtent([1, 1])
                .interpolate(d3.interpolate)
                .on('zoom', this.applyCameraPosition.bind(this))
                .on('end', function () {
                if (!_this._isPanning) {
                    _this.ensureNodesAreVisible();
                }
            });
            // set up the selections
            this._linksContainer = d3.select(this.linksContainer.nativeElement);
            this._nodesContainer = d3.select(this.nodesContainer.nativeElement);
            // setup the zoom on the node layer
            this._ngZone.runOutsideAngular(function () { return _this._nodesContainer.call(_this._zoom); });
            // perform the initial render
            this.render();
            // ensure we set the initial chart size
            this._width = this._elementRef.nativeElement.offsetWidth;
            this._height = this._elementRef.nativeElement.offsetHeight;
            // watch for any resizing of the chart
            var resize$ = this._resizeService.addResizeListener(this._elementRef.nativeElement);
            // on size change immediate update the width and height measurements
            resize$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(this.onResize.bind(this));
            // after a debounce ensure nodes are visible
            resize$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(this.duration))
                .subscribe(this.ensureNodesAreVisible.bind(this));
            // initially horizontally center the root node
            this.centerNode(this.dataset, exports.OrganizationChartAxis.Horizontal, false);
            // initally move the camera down slightly so the root node does not appear at the very top of the chart
            this.moveCamera(0, 150, false);
            // mark this component as initialised
            this._isInitialised = true;
        };
        OrganizationChartComponent.prototype.ngOnChanges = function (changes) {
            if (changes.connector && !changes.connector.firstChange) {
                this._hasConnectorChanged = true;
            }
            // if only the selected property has changed then don't re-render as this is handled by the setter
            if (Object.keys(changes).length === 1 && changes.selected) {
                return;
            }
            if (this._isInitialised) {
                this.render();
            }
        };
        OrganizationChartComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            // correctly dispose all portals and outlets
            this._portals.forEach(function (node) {
                node.portal.detach();
                node.outlet.dispose();
            });
        };
        /** Perform the actual rendering of the chart */
        OrganizationChartComponent.prototype.render = function () {
            var _this = this;
            // perform the layout algorithm on the current dataset
            this.updateLayout();
            // select all the existing links and nodes
            this.updateSelections();
            // create a d3 transition based in the specified transition time
            var defaultTransition = d3.transition()
                .duration(this.duration)
                .on('start', function () { return _this._isTransitioning = true; })
                .on('end', function () {
                _this._isTransitioning = false;
                _this.transitionEnd.emit();
            });
            // render the links when they are first added to the DOM
            this._links.enter()
                .insert('path')
                .attr('class', 'ux-organization-chart-link')
                .attr('d', function (link) { return _this.getLinkPath(link); })
                .attr('opacity', -2)
                .transition(defaultTransition)
                .attr('d', function (link) { return _this.getLinkPath(link); })
                .attr('opacity', 1);
            // define the standard transition while the link is 'alive'
            this._links.transition()
                .duration(this._hasConnectorChanged ? 0 : this.duration)
                .attr('d', function (link) { return _this.getLinkPath(link); });
            // apply transitions when removing nodes
            this._links.exit()
                .transition(defaultTransition)
                .attr('d', function (link) { return _this.getCollapsedLinkPath(link); })
                .attr('opacity', 0)
                .remove();
            // when a node is first added to the DOM position it
            this._nodes.enter()
                .append('div')
                .attr('class', 'ux-organization-chart-node')
                .style('width', this.nodeWidth + 'px')
                .style('height', this.nodeHeight + 'px')
                .style('left', function (node) { return (node.parent ? node.parent.x : node.x) + 'px'; })
                .style('top', function (node) { return (node.parent ? node.parent.y : node.y) + 'px'; })
                .style('opacity', 0)
                .on('keydown', this.onKeydown.bind(this))
                .on('focus', this.onFocus.bind(this))
                .on('mousedown', function () { return d3.event.stopPropagation(); })
                .on('click', this.toggle.bind(this))
                .each(this.renderNodeTemplate.bind(this))
                .each(function (node, index, group) { return _this.monitorFocus(group[index], node); })
                .transition(defaultTransition)
                .style('left', function (node) { return node.x + 'px'; })
                .style('top', function (node) { return node.y + 'px'; })
                .style('opacity', 1);
            // apply any movements while nodes are 'alive'
            this._nodes.transition(defaultTransition)
                .style('left', function (node) { return node.x + 'px'; })
                .style('top', function (node) { return node.y + 'px'; });
            // apply transitions when removing nodes
            this._nodes.exit()
                .transition(defaultTransition)
                .style('left', function (node) { return (node.parent ? node.parent.x : node.x) + 'px'; })
                .style('opacity', 0)
                .remove()
                .on('end', function (node) { return _this.destroyNode(node); });
            // update the position of the reveal button
            d3.select(this.revealElement.nativeElement)
                .style('left', ((this.nodeWidth / 2) - (this.revealElement.nativeElement.offsetWidth / 2)) + 'px')
                .style('top', -((this.nodeHeight / 2) + (this.revealElement.nativeElement.offsetHeight / 2)) + 'px');
            // after any new links and nodes have been created or removed we should update the selections
            this.updateSelections();
            // update the selected classes - ensure there is always a selected node
            if (!this._selected) {
                this.select(this._pendingSelection || this.dataset);
                this._pendingSelection = null;
            }
            // set the tab indexes and aria labels for any newly added items
            this.setNodeAttributes();
            // apply the current camera position to any new nodes/links
            this.applyCameraPosition();
            // reset the connector changed status
            this._hasConnectorChanged = false;
        };
        /** Select a specified node */
        OrganizationChartComponent.prototype.select = function (node) {
            // get the node in the desired format
            node = this.coerceDataNode(node);
            // check if the node is already selected
            if (this._selected === node) {
                return;
            }
            // ensure all parents are expanded
            this.expandParents(node);
            // deselect any current node
            this.deselect(false);
            // if the selected item has changed then store the latest selection
            this._selected = node;
            // emit the latest selection
            this.selectedChange.next(this._selected);
            // show reveal any nodes that may previously have been hidden but are now visible due to selection
            if (this._isInitialised) {
                this.render();
            }
            // add the styling to the selected node
            this._renderer.addClass(this.getNodeElement(this._selected), 'ux-organization-chart-node-selected');
            // update the styling and tabindexes
            this.setNodeAttributes();
        };
        /** Deselect the currently selected node */
        OrganizationChartComponent.prototype.deselect = function (emit) {
            var _this = this;
            if (emit === void 0) {
                emit = true;
            }
            if (this._nodes) {
                this._nodes.nodes().forEach(function (element) { return _this._renderer.removeClass(element, 'ux-organization-chart-node-selected'); });
            }
            if (emit && !!this._selected) {
                this._selected = null;
                this.selectedChange.next(null);
                // update the tab indexes and aria labels
                this.setNodeAttributes();
            }
        };
        /** Toggle the collapsed state of a node */
        OrganizationChartComponent.prototype.toggle = function (node) {
            // do nothing if a transition is currently in progress
            if (this._isTransitioning) {
                return;
            }
            // get the node in the desired format
            node = this.coercePointNode(node);
            // ensure the clicked node is selected
            this.select(node);
            // apply the appropriate action
            this.isExpanded(node) ? this.collapse(node) : this.expand(node);
        };
        /** Expand a node */
        OrganizationChartComponent.prototype.expand = function (node) {
            // do nothing if a transition is currently in progress
            if (this._isTransitioning) {
                return;
            }
            // get the node in the desired format
            node = this.coercePointNode(node);
            // ensure this node and all parent nodes are expanded
            node.ancestors().forEach(function (_node) { return _node.data.expanded = true; });
            // re-render the nodes
            this.render();
            // if the node has children then we want to move the camera to a child node
            if (Array.isArray(node.data.children) && node.data.children.length > 0) {
                // center on the middle child
                this.centerNode(node.data.children[Math.floor(node.data.children.length / 2)]);
            }
            else {
                this.centerNode(node);
            }
        };
        /** Collapse a node */
        OrganizationChartComponent.prototype.collapse = function (node) {
            // do nothing if a transition is currently in progress
            if (this._isTransitioning) {
                return;
            }
            // get the node in the desired format
            node = this.coercePointNode(node);
            // ensure this node and all child nodes are collapse
            node.descendants().forEach(function (_node) { return _node.data.expanded = false; });
            // re-render the nodes
            this.render();
            // center the node that has just been collapsed
            this.centerNode(node);
        };
        /** Move a specific node to the center of the screen */
        OrganizationChartComponent.prototype.centerNode = function (node, axis, animate) {
            if (axis === void 0) {
                axis = exports.OrganizationChartAxis.Both;
            }
            if (animate === void 0) {
                animate = true;
            }
            // get the node in the desired format
            node = this.coercePointNode(node);
            // get the current camera position
            var camera = this.getCameraPosition();
            var x = axis === exports.OrganizationChartAxis.Vertical ? camera.x : (this._width / 2) - (node.x + (this.nodeWidth / 2));
            var y = axis === exports.OrganizationChartAxis.Horizontal ? camera.y : (this._height / 2) - (node.y + (this.nodeHeight / 2));
            // update the camera position
            this.setCameraPosition(x, y, animate);
        };
        /** Explicity set the position of the camera */
        OrganizationChartComponent.prototype.setCameraPosition = function (x, y, animate) {
            var _this = this;
            if (animate === void 0) {
                animate = true;
            }
            // get the current transform
            var camera = d3.zoomTransform(this._nodesContainer.node());
            // do nothing if the co-orindates have not changed
            if (camera.x === x && camera.y === y) {
                return;
            }
            // update the camera position
            camera = camera.translate(x - camera.x, y - camera.y);
            // indicate that the camera is panning programmatically
            this._isPanning = true;
            if (animate) {
                this._nodesContainer.transition()
                    .duration(this.duration)
                    .call(this._zoom.transform, camera)
                    .on('end interrupt cancel', function () { return _this._isPanning = false; });
            }
            else {
                this._nodesContainer.call(this._zoom.transform, camera);
                this._isPanning = false;
            }
        };
        /** Move the camera an amount from its current position */
        OrganizationChartComponent.prototype.moveCamera = function (x, y, animate) {
            if (animate === void 0) {
                animate = true;
            }
            // get the current camera position
            var camera = this.getCameraPosition();
            this.setCameraPosition(camera.x + x, camera.y + y, animate);
        };
        /** Focus a given node */
        OrganizationChartComponent.prototype.focus = function (node) {
            this.focusNode(this.coercePointNode(node));
        };
        /** Focus the root node */
        OrganizationChartComponent.prototype._focusRootNode = function () {
            this.focusNode(this.coercePointNode(this.dataset));
        };
        /** Destroy the outlet and portal associated with a node */
        OrganizationChartComponent.prototype.destroyNode = function (node) {
            // get the node in a consistent format
            node = this.coercePointNode(node);
            // remove focus monitoring
            if (this._indicators.has(node.data)) {
                // remove the focus monitoring
                this._indicators.get(node.data).destroy();
                // remove the indicator from the list of indicators
                this._indicators.delete(node.data);
            }
            // if there is not portal/outlets associated with this node then do nothing
            if (!this._portals.has(node.data)) {
                return;
            }
            // get the portal and outlet from the map
            var portalRef = this._portals.get(node.data);
            // perform the cleanup
            portalRef.portal.detach();
            portalRef.outlet.dispose();
            // remove this entry from the map
            this._portals.delete(node.data);
        };
        // update the data structure for the node and link layouts
        OrganizationChartComponent.prototype.updateLayout = function () {
            this._layout = this.getLayout();
            this._nodeLayout = this._layout.descendants();
            this._linkLayout = this._layout.links();
        };
        /** Ensure the selections stay in sync with the view */
        OrganizationChartComponent.prototype.updateSelections = function () {
            // select all the newly added dom nodes and associate the dataset
            this._nodes = this._nodesContainer.selectAll('.ux-organization-chart-node')
                .data(this._nodeLayout, function (node) { return node.data.id.toString(); });
            // select all the newly added path nodes
            this._links = this._linksContainer.selectAll('.ux-organization-chart-link')
                .data(this._linkLayout, function (link) {
                return link.source.data.id + "-" + link.target.data.id;
            });
        };
        /** Render the content of the node based on the template provided */
        OrganizationChartComponent.prototype.renderNodeTemplate = function (node, index, group) {
            var _this = this;
            // create the context for the node
            var context = {
                data: node.data.data,
                node: node.data,
                focused: false
            };
            // the focused state should be a getter
            Object.defineProperty(context, 'focused', {
                get: function () { return _this._focused === node.data; }
            });
            // create the outlet to insert the Template and the portal from the TemplateRef
            var outlet = this.createPortalOutlet(group[index]);
            var portal$1 = new portal.TemplatePortal(this.nodeTemplate, this._viewContainerRef, context);
            // insert the TemplateRef into the specified region
            portal$1.attach(outlet);
            // store the portal and outlet so we can correctly dispose of the nodes
            this._portals.set(node.data, { portal: portal$1, outlet: outlet });
        };
        /** Handle any zoom events (we use zoom for panning behaviour) */
        OrganizationChartComponent.prototype.applyCameraPosition = function () {
            // get the new x and y position
            var _a = d3.zoomTransform(this._nodesContainer.node()), x = _a.x, y = _a.y;
            // round the precision to integers to prevent any anti-aliasing
            x = Math.round(x);
            y = Math.round(y);
            // transform the position of the reveal button
            this._renderer.setStyle(this.revealElement.nativeElement, 'transform', "translate(" + x + "px, " + y + "px)");
            // transform the position of the nodes
            this._nodesContainer.selectAll('.ux-organization-chart-node').style('transform', "translate(" + x + "px, " + y + "px)");
            // transform the position of the links
            this._linksContainer.selectAll('.ux-organization-chart-link').attr('transform', "translate(" + x + " " + y + ")");
        };
        /** Get the data in with the required layout information */
        OrganizationChartComponent.prototype.getLayout = function () {
            var _this = this;
            // create a hierarchical representation of the data - don't include collapsed nodes
            var treeHierarchy = d3.hierarchy(this.dataset, function (node) { return Array.isArray(node.children) && node.expanded ? node.children : []; });
            // create our layout
            var layout = d3.tree()
                .nodeSize([this.nodeWidth, this.nodeHeight])
                .separation(this.getNodeSpacing.bind(this));
            // process the data with the layout
            var treeLayout = layout(treeHierarchy);
            // calculate the vertical spacing
            var verticalSpacing = this.verticalSpacing === undefined ? this.nodeHeight : this.verticalSpacing;
            // set the vertical spacing
            treeLayout.each(function (data) { return data.y = data.depth * (_this.nodeHeight + verticalSpacing); });
            return treeLayout;
        };
        /** Determine how much horizontal spacing should be between nodes */
        OrganizationChartComponent.prototype.getNodeSpacing = function (nodeOne, nodeTwo) {
            // if the nodes are not siblings then space further apart
            if (nodeOne.parent !== nodeTwo.parent) {
                return 2;
            }
            // if they are siblings they should be closer together
            return 1.5;
        };
        /** Ensure we consistently use the HierarchyPoint data structure */
        OrganizationChartComponent.prototype.coercePointNode = function (node) {
            // determine if this is a raw data node or a hierarchy point
            if (node.hasOwnProperty('depth') && node.hasOwnProperty('x') && node.hasOwnProperty('y')) {
                return node;
            }
            // otherwise find the matching node
            var match = this._nodeLayout.find(function (_node) { return _node.data === node; });
            // if the data does not exist in the hierarchy throw an exception
            if (!match) {
                throw new Error("The node does not exist in the hierarchy");
            }
            return match;
        };
        OrganizationChartComponent.prototype.coerceDataNode = function (node) {
            if (node.hasOwnProperty('depth') && node.hasOwnProperty('x') && node.hasOwnProperty('y')) {
                return node.data;
            }
            return node;
        };
        /** Handle chart resize events */
        OrganizationChartComponent.prototype.onResize = function (_a) {
            var width = _a.width, height = _a.height;
            this._width = width;
            this._height = height;
        };
        /** Deteremine if a node is expanded or collapsed */
        OrganizationChartComponent.prototype.isExpanded = function (node) {
            return !!node.data.expanded;
        };
        /** Get the current position of the camera */
        OrganizationChartComponent.prototype.getCameraPosition = function () {
            return d3.zoomTransform(this._nodesContainer.node());
        };
        /** Get the SVG line definition for each link */
        OrganizationChartComponent.prototype.getLinkPath = function (pointLink) {
            if (this.connector === 'elbow') {
                var source = { x: pointLink.source.x + (this.nodeWidth / 2), y: pointLink.source.y + this.nodeHeight };
                var target = { x: pointLink.target.x + (this.nodeWidth / 2), y: pointLink.target.y };
                return 'M' + source.x + ',' + (source.y) +
                    'v' + ((target.y - source.y) / 2) +
                    'h' + (target.x - source.x) +
                    'v' + ((target.y - source.y) / 2);
            }
            else {
                var source = { x: pointLink.source.x + (this.nodeWidth / 2), y: pointLink.source.y + (this.nodeHeight / 2) };
                var target = { x: pointLink.target.x + (this.nodeWidth / 2), y: pointLink.target.y + (this.nodeHeight / 2) };
                return d3.linkVertical()({ source: [source.x, source.y], target: [target.x, target.y] });
            }
        };
        /** Get the link path line defintion when the link is collapsing */
        OrganizationChartComponent.prototype.getCollapsedLinkPath = function (pointLink) {
            return this.getLinkPath({ source: pointLink.source, target: pointLink.source });
        };
        /** Create a dynamic region that Angular can insert into */
        OrganizationChartComponent.prototype.createPortalOutlet = function (element) {
            return new portal.DomPortalOutlet(element, this._componentFactoryResolver, this._appRef, this._injector);
        };
        /** Make the appropriate node tabbable and update aria attributes */
        OrganizationChartComponent.prototype.setNodeAttributes = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._nodes.nodes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var element = _c.value;
                    // intially the tab index of all items to -1
                    this._renderer.setAttribute(element, 'tabindex', '-1');
                    // set the expanded aria attribute
                    this._renderer.setAttribute(element, 'aria-expanded', !!this.getNodeData(element).data.expanded ? 'true' : 'false');
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            // if there is a selected item then it should be tabbable otherwise make the root tabbable
            if (this._selected) {
                this._renderer.setAttribute(this.getNodeElement(this._selected), 'tabindex', '0');
            }
        };
        /** Get the element that represents a given node */
        OrganizationChartComponent.prototype.getNodeElement = function (node) {
            node = this.coercePointNode(node);
            // find the element that matches the node data
            var index = this._nodes.data().indexOf(node);
            return this._nodes.nodes()[index];
        };
        /** Get the element that represents a given node */
        OrganizationChartComponent.prototype.getNodeData = function (node) {
            // find the element that matches the node element
            var index = this._nodes.nodes().indexOf(node);
            return this._nodes.data()[index];
        };
        /** Handle keyboard events */
        OrganizationChartComponent.prototype.onKeydown = function (node) {
            switch (d3.event.keyCode) {
                case keycodes.DOWN_ARROW:
                    d3.event.preventDefault();
                    // if the node is collapsed and has children expand
                    if (!node.data.expanded && Array.isArray(node.data.children) && node.data.children.length > 0) {
                        return this.expand(node);
                    }
                    return this.focusChild(node);
                case keycodes.RIGHT_ARROW:
                    d3.event.preventDefault();
                    return this.focusNextSibling(node);
                case keycodes.UP_ARROW:
                    d3.event.preventDefault();
                    return this.focusParent(node);
                case keycodes.LEFT_ARROW:
                    d3.event.preventDefault();
                    return this.focusPreviousSibling(node);
                case keycodes.ENTER:
                    return this.toggle(node);
            }
        };
        /** When a node receives focus */
        OrganizationChartComponent.prototype.onFocus = function (node) {
            if (!this.isNodeInViewport(node, this._width * 0.1, this._height * 0.1)) {
                this.centerNode(node);
            }
        };
        /** Move focus to the parent node */
        OrganizationChartComponent.prototype.focusParent = function (node) {
            if (node.parent) {
                this.focusNode(node.parent);
            }
            else if (this.revealElement) {
                this.revealElement.nativeElement.focus();
                // center the root node to ensure the reveal button is in view
                this.centerNode(this.dataset);
            }
        };
        /** Move focus to the child node */
        OrganizationChartComponent.prototype.focusChild = function (node) {
            if (Array.isArray(node.children) && node.children.length > 0) {
                this.focusNode(node.children[Math.floor(node.children.length / 2)]);
            }
        };
        /** Move focus to the sibling on the left */
        OrganizationChartComponent.prototype.focusPreviousSibling = function (node) {
            if (node.parent) {
                this.focusNode(node.parent.children[node.parent.children.indexOf(node) - 1]);
            }
        };
        /** Move focus to the sibling on the right */
        OrganizationChartComponent.prototype.focusNextSibling = function (node) {
            if (node.parent) {
                this.focusNode(node.parent.children[node.parent.children.indexOf(node) + 1]);
            }
        };
        /** Focus a given node */
        OrganizationChartComponent.prototype.focusNode = function (node) {
            if (node) {
                this.getNodeElement(node).focus({ preventScroll: true });
                // ensure we don't perform scrolling if the node is not in view (we rely on preventScroll as IE doesn't support it)
                this.nodesContainer.nativeElement.scrollTop = 0;
                this.nodesContainer.nativeElement.scrollLeft = 0;
            }
        };
        /** Determine if a node is fully visible within the viewport */
        OrganizationChartComponent.prototype.isNodeInViewport = function (node, insetX, insetY) {
            if (insetX === void 0) {
                insetX = 0;
            }
            if (insetY === void 0) {
                insetY = 0;
            }
            var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
            var left = node.x + x;
            var top = node.y + y;
            var right = node.x + x + this.nodeWidth;
            var bottom = node.y + y + this.nodeHeight;
            return left >= insetX && top >= insetY && right <= (this._width - insetX) && bottom <= (this._height - insetY);
        };
        /** Determine if a node is fully outside of the viewport */
        OrganizationChartComponent.prototype.isNodeOutsideViewport = function (node, insetX, insetY) {
            if (insetX === void 0) {
                insetX = 0;
            }
            if (insetY === void 0) {
                insetY = 0;
            }
            var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
            var left = node.x + x + this.nodeWidth;
            var top = node.y + y + this.nodeHeight;
            var right = node.x + x;
            var bottom = node.y + y;
            return left < insetX || top < insetY || right > (this._width - insetX) || bottom > (this._height - insetY);
        };
        /** Determine how far a node is from being within the viewport */
        OrganizationChartComponent.prototype.getDistanceFromViewport = function (node, insetX, insetY) {
            if (insetX === void 0) {
                insetX = 0;
            }
            if (insetY === void 0) {
                insetY = 0;
            }
            // if the node is in the viewport then it will always be 0, 0
            if (!this.isNodeOutsideViewport(node, insetX, insetY)) {
                return [0, 0];
            }
            var _a = this.getCameraPosition(), x = _a.x, y = _a.y;
            var left = insetX - (node.x + x + this.nodeWidth);
            var top = insetY - (node.y + y + this.nodeHeight);
            var right = (node.x + x) - (this._width - insetX);
            var bottom = (node.y + y) - (this._height - insetY);
            var horizontal = 0;
            var vertical = 0;
            if (left > 0 && left > right) {
                horizontal = left;
            }
            if (right > 0 && left < right) {
                horizontal = -right;
            }
            if (top > 0 && top > bottom) {
                vertical = top;
            }
            if (bottom > 0 && top < bottom) {
                vertical = -bottom;
            }
            // calculate the distances on both axis
            return [horizontal, vertical];
        };
        /** Begin monitoring the element focus so we only show styling when navigated by keyboard */
        OrganizationChartComponent.prototype.monitorFocus = function (element, node) {
            var _this = this;
            // create the focus indicator
            var indicator = this._focusIndicator.monitor(element, { checkChildren: false, programmaticFocusIndicator: true });
            // store the currently selected node as an instance variable
            indicator.isFocused$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isFocused) {
                // by default the CDK runs this outside of NgZone however we need it to run inside NgZone to update the node template
                _this._ngZone.run(function () {
                    if (isFocused) {
                        _this._focused = node.data;
                    }
                    else if (node.data === _this._focused) {
                        _this._focused = null;
                    }
                });
            });
            // store the focus indicator reference
            this._indicators.set(node.data, indicator);
        };
        // ensure that there are at least some nodes visible
        OrganizationChartComponent.prototype.ensureNodesAreVisible = function () {
            var _this = this;
            // determine how many nodes are currently visible
            var visibleCount = this._nodes.filter(function (node) { return !_this.isNodeOutsideViewport(node); }).size();
            if (visibleCount > 0) {
                return;
            }
            // get the distance each node is from being within the viewport
            var distances = this._nodes.data().map(function (node) { return _this.getDistanceFromViewport(node, _this.nodeWidth * 1.25, _this.nodeHeight * 1.5); });
            // find the closest node
            var _a = __read(distances.reduce(function (previous, current) {
                var _a = __read(previous, 2), previousX = _a[0], previousY = _a[1];
                var _b = __read(current, 2), currentX = _b[0], currentY = _b[1];
                return (Math.abs(previousX) + Math.abs(previousY)) < (Math.abs(currentX) + Math.abs(currentY)) ? previous : current;
            }), 2), x = _a[0], y = _a[1];
            // move the camera by the required amount
            this.moveCamera(x, y);
        };
        /** Expand all parent nodes */
        OrganizationChartComponent.prototype.expandParents = function (node) {
            // get the parent node
            var parent = this.getParent(node);
            while (parent) {
                parent.expanded = true;
                parent = this.getParent(parent);
            }
        };
        /** Get the parent of a given node */
        OrganizationChartComponent.prototype.getParent = function (node) {
            return __spread([this.coerceDataNode(this.dataset)], this.getAllChildren(this.dataset)).find(function (_node) {
                if (!Array.isArray(_node.children)) {
                    return false;
                }
                return _node.children.find(function (child) { return child.id === node.id; });
            });
        };
        /** Get a flat array of all the nodes childrent */
        OrganizationChartComponent.prototype.getAllChildren = function (node) {
            var _this = this;
            var children = node.children || [];
            // check for any children on the children
            return __spread(children, children.reduce(function (accumulation, child) { return __spread(accumulation, _this.getAllChildren(child)); }, [])).map(function (child) { return _this.coerceDataNode(child); });
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], OrganizationChartComponent.prototype, "dataset", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], OrganizationChartComponent.prototype, "connector", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], OrganizationChartComponent.prototype, "nodeWidth", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], OrganizationChartComponent.prototype, "nodeHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], OrganizationChartComponent.prototype, "duration", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], OrganizationChartComponent.prototype, "verticalSpacing", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], OrganizationChartComponent.prototype, "showReveal", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], OrganizationChartComponent.prototype, "revealAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], OrganizationChartComponent.prototype, "selected", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OrganizationChartComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OrganizationChartComponent.prototype, "reveal", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OrganizationChartComponent.prototype, "transitionEnd", void 0);
        __decorate([
            core.ContentChild('revealTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], OrganizationChartComponent.prototype, "revealTemplate", void 0);
        __decorate([
            core.ContentChild('nodeTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], OrganizationChartComponent.prototype, "nodeTemplate", void 0);
        __decorate([
            core.ViewChild('revealElement', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], OrganizationChartComponent.prototype, "revealElement", void 0);
        __decorate([
            core.ViewChild('links', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], OrganizationChartComponent.prototype, "linksContainer", void 0);
        __decorate([
            core.ViewChild('nodes', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], OrganizationChartComponent.prototype, "nodesContainer", void 0);
        OrganizationChartComponent = __decorate([
            core.Component({
                selector: 'ux-organization-chart',
                template: "<!-- Add a button above the root node to load additional parent items -->\n<button #revealElement\n    uxFocusIndicatorOrigin\n    class=\"ux-organization-chart-reveal\"\n    tabindex=\"-1\"\n    [attr.aria-label]=\"revealAriaLabel\"\n    [hidden]=\"!showReveal\"\n    (click)=\"reveal.emit(); _focusRootNode()\"\n    (keydown.ArrowDown)=\"_focusRootNode(); $event.preventDefault()\">\n\n    <!-- Display Reveal Template -->\n    <ng-container [ngTemplateOutlet]=\"revealTemplate || defaultRevealTemplate\"></ng-container>\n</button>\n\n<!-- Show the links connecting each node -->\n<svg #links class=\"ux-organization-chart-links\"></svg>\n\n<!-- Show the nodes containing information about each item -->\n<div #nodes class=\"ux-organization-chart-nodes\"></div>\n\n<!-- Provide a default reveal template -->\n<ng-template #defaultRevealTemplate>\n    <ux-icon name=\"tab-up\"></ux-icon>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                ResizeService,
                core.ComponentFactoryResolver,
                core.Injector,
                core.ApplicationRef,
                core.ViewContainerRef,
                core.Renderer2,
                FocusIndicatorService,
                core.NgZone])
        ], OrganizationChartComponent);
        return OrganizationChartComponent;
    }());
    (function (OrganizationChartAxis) {
        OrganizationChartAxis[OrganizationChartAxis["Horizontal"] = 0] = "Horizontal";
        OrganizationChartAxis[OrganizationChartAxis["Vertical"] = 1] = "Vertical";
        OrganizationChartAxis[OrganizationChartAxis["Both"] = 2] = "Both";
    })(exports.OrganizationChartAxis || (exports.OrganizationChartAxis = {}));
    var OrganizationChartModule = /** @class */ (function () {
        function OrganizationChartModule() {
        }
        OrganizationChartModule = __decorate([
            core.NgModule({
                declarations: [
                    OrganizationChartComponent
                ],
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    IconModule,
                    ResizeModule,
                ],
                exports: [
                    OrganizationChartComponent
                ]
            })
        ], OrganizationChartModule);
        return OrganizationChartModule;
    }());
    var TabHeadingDirective = /** @class */ (function () {
        function TabHeadingDirective() {
        }
        TabHeadingDirective = __decorate([
            core.Directive({
                selector: '[uxTabHeading]'
            })
        ], TabHeadingDirective);
        return TabHeadingDirective;
    }());
    var TabsetService = /** @class */ (function () {
        function TabsetService() {
            /** Store the list of tabs */
            this.tabs = [];
            /** Store the manual state */
            this.manual = false;
        }
        /** Update the array of tabs - required to preserve order */
        TabsetService.prototype.update = function (tabs) {
            this.tabs = __spread(tabs);
        };
        /** Programmatically select a tab */
        TabsetService.prototype.select = function (tab) {
            if (!tab.disabled) {
                // update the active state of each tab accordingly
                this.tabs.forEach(function (_tab) { return _tab === tab ? _tab.selectTab() : _tab.deselectTab(); });
            }
        };
        /** Determine if there is a selected tab */
        TabsetService.prototype.isTabActive = function () {
            return !!this.tabs.find(function (tab) { return tab.active; });
        };
        /** Select the first non-disabled tab */
        TabsetService.prototype.selectFirstTab = function () {
            // find the index of the first non-disabled tab
            var tab = this.tabs.find(function (_tab) { return !_tab.disabled; });
            if (tab) {
                this.select(tab);
            }
        };
        TabsetService = __decorate([
            core.Injectable()
        ], TabsetService);
        return TabsetService;
    }());
    var uniqueTabId = 0;
    var TabComponent = /** @class */ (function () {
        function TabComponent(_tabset, _changeDetector) {
            this._tabset = _tabset;
            this._changeDetector = _changeDetector;
            /** Define the tab unique id */
            this.id = "ux-tab-" + ++uniqueTabId;
            /** Define the active state of this tab */
            this.active = false;
            /** Define if this tab is disabled */
            this.disabled = false;
            /** Emit when this tab is selected */
            this.activated = new core.EventEmitter();
            /** Emit when this tab is deselected */
            this.deactivated = new core.EventEmitter();
            /** Unsubscribe from all subscriptions when component is destroyed */
            this._onDestroy = new rxjs.Subject();
        }
        TabComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        TabComponent.prototype.selectTab = function () {
            // if this tab is currently active do nothing
            if (this.active && !this._tabset.manual) {
                return;
            }
            if (!this._tabset.manual) {
                this.active = true;
            }
            this.activated.emit();
            this._changeDetector.detectChanges();
        };
        TabComponent.prototype.deselectTab = function () {
            // if this tab is not currently active do nothing
            if (!this.active && !this._tabset.manual) {
                return;
            }
            if (!this._tabset.manual) {
                this.active = false;
            }
            this.deactivated.emit();
            this._changeDetector.detectChanges();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TabComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabComponent.prototype, "active", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TabComponent.prototype, "heading", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TabComponent.prototype, "customClass", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TabComponent.prototype, "activated", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TabComponent.prototype, "deactivated", void 0);
        __decorate([
            core.ContentChild(TabHeadingDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], TabComponent.prototype, "headingRef", void 0);
        TabComponent = __decorate([
            core.Component({
                selector: 'ux-tab',
                template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [style.display]=\"active ? 'block' : 'none'\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!active\">\n  <ng-content></ng-content>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [TabsetService,
                core.ChangeDetectorRef])
        ], TabComponent);
        return TabComponent;
    }());
    var TabsetComponent = /** @class */ (function () {
        function TabsetComponent(_tabset, _changeDetector) {
            this._tabset = _tabset;
            this._changeDetector = _changeDetector;
            /** Determine if the appearance of the tabset */
            this.minimal = true;
            /** Determine if the tabset should appear stacked */
            this.stacked = 'none';
            /** Remove subscriptions on destroy */
            this._onDestroy$ = new rxjs.Subject();
        }
        Object.defineProperty(TabsetComponent.prototype, "manual", {
            /** Determine if we want to manually update the active state */
            set: function (manual) {
                this._tabset.manual = manual;
            },
            enumerable: true,
            configurable: true
        });
        TabsetComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // provide the service with the initial array of items
            this._tabset.update(this._tabs.toArray());
            // Make sure a tab is selected
            if (!this._tabset.isTabActive()) {
                this._tabset.selectFirstTab();
            }
            // run change detection once we have setup the tabs
            this._changeDetector.detectChanges();
            // watch for any future changes
            this._tabs.changes.pipe(operators.takeUntil(this._onDestroy$)).subscribe(function (tabs) {
                // update the internal list of tabs
                _this._tabset.update(tabs);
                // run change detection
                _this._changeDetector.detectChanges();
            });
        };
        TabsetComponent.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        TabsetComponent.prototype.selectTab = function (tab) {
            // pass tab to select method
            this._tabset.select(tab instanceof TabComponent ? tab : this._tabs.toArray()[tab]);
            // run change detection
            this._changeDetector.detectChanges();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TabsetComponent.prototype, "minimal", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TabsetComponent.prototype, "stacked", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TabsetComponent.prototype, "manual", null);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], TabsetComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.ContentChildren(TabComponent),
            __metadata("design:type", core.QueryList)
        ], TabsetComponent.prototype, "_tabs", void 0);
        TabsetComponent = __decorate([
            core.Component({
                selector: 'ux-tabset',
                template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    uxTabbableList\n    [direction]=\"stacked === 'none' ? 'horizontal' : 'vertical'\"\n    [allowBoundaryKeys]=\"true\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\"\n        class=\"nav-item\"\n        *ngFor=\"let tab of _tabset.tabs; let index = index\"\n        [class.active]=\"tab.active\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            uxTabbableListItem\n            uxFocusIndicator\n            (mousedown)=\"_tabset.select(tab)\"\n            (activated)=\"_tabset.select(tab)\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [TabsetService],
                host: {
                    '[class.tabs-left]': 'stacked === "left"',
                    '[class.tabs-right]': 'stacked === "right"',
                }
            }),
            __metadata("design:paramtypes", [TabsetService,
                core.ChangeDetectorRef])
        ], TabsetComponent);
        return TabsetComponent;
    }());
    var TabsetModule = /** @class */ (function () {
        function TabsetModule() {
        }
        TabsetModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule
                ],
                exports: [
                    TabsetComponent,
                    TabComponent,
                    TabHeadingDirective
                ],
                declarations: [
                    TabsetComponent,
                    TabComponent,
                    TabHeadingDirective
                ],
            })
        ], TabsetModule);
        return TabsetModule;
    }());
    var PageHeaderCustomMenuDirective = /** @class */ (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective = __decorate([
            core.Directive({
                selector: '[uxPageHeaderCustomMenu]'
            })
        ], PageHeaderCustomMenuDirective);
        return PageHeaderCustomMenuDirective;
    }());
    var PageHeaderIconMenuComponent = /** @class */ (function () {
        function PageHeaderIconMenuComponent() {
        }
        PageHeaderIconMenuComponent.prototype.select = function (item) {
            if (item.select) {
                item.select.call(item, item);
            }
        };
        PageHeaderIconMenuComponent.prototype.keydownHandler = function (item, event) {
            switch (event.keyCode) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this.select(item);
                    event.preventDefault();
                    event.stopPropagation();
                    break;
            }
        };
        PageHeaderIconMenuComponent.prototype._getIconType = function (identifier) {
            return identifier ? getIconType(identifier) : '';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], PageHeaderIconMenuComponent.prototype, "menu", void 0);
        PageHeaderIconMenuComponent = __decorate([
            core.Component({
                selector: 'ux-page-header-icon-menu',
                template: "<div class=\"page-header-icon-menu\">\n    <button\n        type=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        [uxMenuTriggerFor]=\"iconMenu\"\n        (click)=\"select(menu)\">\n\n        <!-- Support all icon types -->\n        <i *ngIf=\"_getIconType(menu.icon) !== 'component'\"\n           [ngClass]=\"[_getIconType(menu.icon), menu.icon]\">\n        </i>\n\n        <ux-icon *ngIf=\"_getIconType(menu.icon) === 'component'\"\n                 [name]=\"menu.icon\">\n        </ux-icon>\n\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n    </button>\n\n    <ux-menu #iconMenu alignment=\"end\" menuClass=\"ux-page-header-icon-menu\">\n        <ng-container *ngFor=\"let dropdown of menu?.dropdown\">\n\n            <div class=\"dropdown-header\" *ngIf=\"dropdown.header\">\n                <span class=\"font-bold\">{{ dropdown.title }}</span>\n            </div>\n\n            <button\n                type=\"button\"\n                *ngIf=\"!dropdown.header\"\n                uxMenuItem\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\">\n\n\n                <span class=\"dropdown-item-title\">\n                    <!-- Support all icon types -->\n                    <i *ngIf=\"_getIconType(dropdown.icon) !== 'component'\"\n                       class=\"hpe-fw\"\n                       [ngClass]=\"[_getIconType(dropdown.icon) || 'ux-icon', dropdown.icon || '']\">\n                    </i>\n\n                    <ux-icon *ngIf=\"_getIconType(dropdown.icon) === 'component'\"\n                             class=\"m-r-xs\"\n                             [name]=\"dropdown.icon\">\n                    </ux-icon>\n\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </button>\n\n            <ux-menu-divider *ngIf=\"dropdown.divider\"></ux-menu-divider>\n\n        </ng-container>\n    </ux-menu>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], PageHeaderIconMenuComponent);
        return PageHeaderIconMenuComponent;
    }());
    var PageHeaderService = /** @class */ (function () {
        function PageHeaderService(_router) {
            var _this = this;
            this._router = _router;
            this.items$ = new rxjs.BehaviorSubject([]);
            this.selected$ = new rxjs.BehaviorSubject(null);
            this.selectedRoot$ = new rxjs.BehaviorSubject(null);
            this.secondary$ = new rxjs.BehaviorSubject(false);
            this.secondaryNavigationAutoselect = false;
            this._onDestroy = new rxjs.Subject();
            this.selected$
                .pipe(operators.takeUntil(this._onDestroy), operators.map(function (selected) { return _this.getRoot(selected); }))
                .subscribe(function (root) { return _this.selectedRoot$.next(root); });
            this._router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd || event instanceof router.NavigationCancel || event instanceof router.NavigationError; }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.updateItemsWithActiveRoute(); });
        }
        PageHeaderService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        PageHeaderService.prototype.select = function (item) {
            if (!item) {
                return;
            }
            if (item.routerLink) {
                // Trigger router navigation
                var routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                this._router.navigate(routerLink, item.routerExtras);
            }
            else if (this.secondaryNavigationAutoselect && item.children && item.children.length > 0) {
                // Select the first child that isn't disabled in secondaryNavigationAutoselect mode
                var firstChild = item.children.find(function (_item) { return !_item.disabled; });
                if (firstChild) {
                    this.select(firstChild);
                }
            }
            else {
                // if we are in secondary navigation mode and we click a parent - dont deselect the child
                if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                    return;
                }
                // Otherwise select the given item
                this.selected$.next(item);
            }
        };
        PageHeaderService.prototype.deselect = function (item) {
            var _this = this;
            // deselect the current item
            item.selected = false;
            // iterate any children and deselect them
            if (item.children) {
                item.children.forEach(function (_item) { return _this.deselect(_item); });
            }
        };
        PageHeaderService.prototype.deselectAll = function () {
            var _this = this;
            this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
        };
        PageHeaderService.prototype.updateItem = function (item, selected) {
            // Item is selected if it is the selected item, or one of the selected item's ancestors.
            item.selected = item === selected || this.isParentOf(selected, item);
            if (item === selected) {
                // call the select function if present
                if (item.select) {
                    item.select.call(item, item);
                }
            }
        };
        PageHeaderService.prototype.setItems = function (items) {
            var _this = this;
            if (items === void 0) {
                items = [];
            }
            // identify all parent elements
            items.forEach(function (item) { return _this.setParent(item); });
            this.items$.next(items);
            // Set up the initally selected item
            // If nothing is set as selected, using the initial route
            var initialSelectedItem = items.find(function (item) { return item.selected === true; });
            if (initialSelectedItem) {
                this.select(initialSelectedItem);
            }
            else {
                this.updateItemsWithActiveRoute();
            }
        };
        PageHeaderService.prototype.setSecondaryNavigation = function (enabled) {
            this.secondary$.next(enabled);
        };
        PageHeaderService.prototype.getRoot = function (item) {
            return item && item.parent ? this.getRoot(item.parent) : item;
        };
        PageHeaderService.prototype.setParent = function (item, parent) {
            var _this = this;
            // set the parent field
            item.parent = parent;
            // call this function recursively on all children
            if (item.children) {
                item.children.forEach(function (child) { return _this.setParent(child, item); });
            }
        };
        PageHeaderService.prototype.isParentOf = function (node, parent) {
            // if there are no parents return false
            if (!node || !node.parent) {
                return false;
            }
            // if the parent is the match we are looking for return true
            if (node.parent === parent) {
                return true;
            }
            // if there are potentially grandparents then check them too
            return this.isParentOf(node.parent, parent);
        };
        PageHeaderService.prototype.updateItemsWithActiveRoute = function () {
            var e_1, _a;
            var activeItem = new PageHeaderActiveNavigationItem();
            try {
                for (var _b = __values(this.items$.getValue()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    this.findActiveItem(item, activeItem);
                    if (activeItem.exact) {
                        break;
                    }
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            if (activeItem.item) {
                this.selected$.next(activeItem.item);
            }
        };
        PageHeaderService.prototype.findActiveItem = function (item, activeItem) {
            var e_2, _a;
            if (item.routerLink) {
                var routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                var urlTree = this._router.createUrlTree(routerLink, item.routerExtras);
                if (this._router.isActive(urlTree, true) && !activeItem.exact) {
                    // When the item route is an exact match, no need to look any further
                    activeItem.item = item;
                    activeItem.exact = true;
                    return;
                }
                if (this._router.isActive(urlTree, false)) {
                    // Store an inexact match and continue looking
                    activeItem.item = item;
                    activeItem.exact = false;
                }
            }
            if (item.children) {
                try {
                    for (var _b = __values(item.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var childItem = _c.value;
                        this.findActiveItem(childItem, activeItem);
                        if (activeItem.exact) {
                            return;
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            }
        };
        PageHeaderService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [router.Router])
        ], PageHeaderService);
        return PageHeaderService;
    }());
    var PageHeaderActiveNavigationItem = /** @class */ (function () {
        function PageHeaderActiveNavigationItem() {
        }
        return PageHeaderActiveNavigationItem;
    }());
    var PageHeaderNavigationDropdownItemComponent = /** @class */ (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
        }
        PageHeaderNavigationDropdownItemComponent.prototype.select = function (item) {
            // clicking on an item that is disabled or with children then return
            if (item.disabled || item.children) {
                return;
            }
            // emit the selected item in an event
            this._pageHeaderService.select(item);
        };
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler = function (event, item) {
            switch (event.which) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this.select(item);
                    event.preventDefault();
                    event.stopPropagation();
                    break;
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], PageHeaderNavigationDropdownItemComponent.prototype, "item", void 0);
        PageHeaderNavigationDropdownItemComponent = __decorate([
            core.Component({
                selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                template: "<div *ngIf=\"item.children && item.children.length > 0\">\n\n    <button\n        type=\"button\"\n        uxMenuItem\n        [disabled]=\"item.disabled\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        [uxMenuTriggerFor]=\"menu\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <ux-icon class=\"dropdown-item-icon\" name=\"next\"></ux-icon>\n    </button>\n\n    <ux-menu #menu placement=\"right\" menuClass=\"horizontal-navigation-dropdown-submenu\">\n        <button\n            type=\"button\"\n            *ngFor=\"let subItem of item.children\"\n            uxMenuItem\n            [disabled]=\"subItem.disabled\"\n            [class.selected]=\"subItem.selected\"\n            [attr.aria-selected]=\"subItem.selected\"\n            (click)=\"select(subItem)\"\n            (keydown)=\"keydownHandler($event, subItem)\">\n\n            <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n        </button>\n    </ux-menu>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\">\n\n    <button\n        type=\"button\"\n        uxMenuItem\n        [disabled]=\"item.disabled\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n    </button>\n\n</div>"
            }),
            __metadata("design:paramtypes", [PageHeaderService])
        ], PageHeaderNavigationDropdownItemComponent);
        return PageHeaderNavigationDropdownItemComponent;
    }());
    var PageHeaderNavigationService = /** @class */ (function () {
        function PageHeaderNavigationService() {
            /**
             * Emit when focus changes. We can't directly use the FocusKeyManager
             * `change` observable as it cannot be instantiate until after the view
             * has been instantiated.
             */
            this._onChange = new rxjs.Subject();
            /** Unsubscribe on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        PageHeaderNavigationService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Make menu items navigable using arrow keys */
        PageHeaderNavigationService.prototype.initialize = function (items) {
            var _this = this;
            // store the query list for future lookups
            this._items = items;
            // create new focus key manager with horizontal orientation
            this._focusManager = new a11y.FocusKeyManager(items)
                .withHorizontalOrientation('ltr');
            // listen for changes to the focused item
            this._focusManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._onChange.next(); });
            // make the first item tabbable initially
            this._focusManager.updateActiveItem(0);
            // on changes ensure there is always an active item
            this._items.changes.subscribe(function () {
                if (_this._items.length > 0 && _this._items.toArray().indexOf(_this._focusManager.activeItem) === -1) {
                    _this._focusManager.updateActiveItem(0);
                }
            });
            // emit the initial change
            this._onChange.next();
        };
        /** Listen for keyboard events */
        PageHeaderNavigationService.prototype.onKeydown = function (event) {
            this._focusManager.onKeydown(event);
        };
        /** Get the tab index for this item as an observable */
        PageHeaderNavigationService.prototype.getTabIndex = function (item) {
            var _this = this;
            return this._onChange.pipe(operators.map(function () { return _this.getItemTabIndex(item); }), tick(), operators.takeUntil(this._onDestroy));
        };
        /** Determine the tab index of a given item */
        PageHeaderNavigationService.prototype.getItemTabIndex = function (item) {
            // until the focus key manager is set up make everything tabbable
            if (!this._items) {
                return 0;
            }
            // get the index within the query list
            var index = this._items.toArray().indexOf(item);
            // if it is the current active element then it is tabbable
            return index === this._focusManager.activeItemIndex ? 0 : -1;
        };
        PageHeaderNavigationService = __decorate([
            core.Injectable()
        ], PageHeaderNavigationService);
        return PageHeaderNavigationService;
    }());
    var PageHeaderNavigationItemComponent = /** @class */ (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService, _navigationService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this._navigationService = _navigationService;
            /** Store the secondary state */
            this.secondary$ = this._pageHeaderService.secondary$;
            /** Update the tabindex based on keyboard input */
            this._tabindex = this._navigationService.getTabIndex(this);
            /** Unsubscribe when the component is destroyed */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(PageHeaderNavigationItemComponent.prototype, "item", {
            get: function () {
                return this._item;
            },
            /** Access the data for this dropdown item */
            set: function (item) {
                this._item = item;
                this._iconType = getIconType(item.icon);
            },
            enumerable: true,
            configurable: true
        });
        PageHeaderNavigationItemComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._pageHeaderService.selected$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (selectedItem) {
                // Update selected state for this item
                _this._pageHeaderService.updateItem(_this.item, selectedItem);
                if (selectedItem && _this.isOpen) {
                    _this.isOpen = false;
                }
            });
        };
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        PageHeaderNavigationItemComponent.prototype.focus = function () {
            this.navigationBtn.nativeElement.focus();
        };
        PageHeaderNavigationItemComponent.prototype.select = function () {
            // if the item is disabled or has children then do nothing at this stage
            if (this.item.disabled || (this.item.children && this._pageHeaderService.secondary$.getValue() === false)) {
                return;
            }
            // otherwise select the current item
            this._pageHeaderService.select(this.item);
        };
        PageHeaderNavigationItemComponent.prototype.onKeydown = function (event) {
            if (event.keyCode === keycodes.LEFT_ARROW || event.keyCode === keycodes.RIGHT_ARROW) {
                this._navigationService.onKeydown(event);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], PageHeaderNavigationItemComponent.prototype, "item", null);
        __decorate([
            core.ViewChild('navigationBtn', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], PageHeaderNavigationItemComponent.prototype, "navigationBtn", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], PageHeaderNavigationItemComponent.prototype, "onKeydown", null);
        PageHeaderNavigationItemComponent = __decorate([
            core.Component({
                selector: 'ux-page-header-horizontal-navigation-item',
                template: "<div *ngIf=\"_item.children && _item.children.length > 0 && !(secondary$ | async)\">\n\n    <button #navigationBtn\n        type=\"button\"\n        [tabindex]=\"_tabindex | async\"\n        [uxMenuTriggerFor]=\"menu\"\n        [disabled]=\"_item.disabled\"\n        role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.disabled]=\"_item.disabled\"\n        [class.selected]=\"_item.selected\"\n        [class.open]=\"isOpen\"\n        [attr.aria-selected]=\"_item.selected\">\n\n        <!-- Support all icon types -->\n        <ng-container *ngIf=\"_item.icon\">\n            <i *ngIf=\"_iconType !== 'component'\"\n                class=\"navigation-item-icon\"\n                [ngClass]=\"[_iconType, _item.icon]\">\n            </i>\n\n            <ux-icon *ngIf=\"_iconType === 'component'\"\n                     class=\"navigation-item-icon\"\n                     [name]=\"_item.icon\">\n            </ux-icon>\n\n        </ng-container>\n\n        <span class=\"navigation-item-label\">{{ _item?.title }}</span>\n        <ux-icon class=\"navigation-item-dropdown-icon\" name=\"down\"></ux-icon>\n\n    </button>\n\n    <ux-menu\n        #menu\n        menuClass=\"horizontal-navigation-dropdown-menu\"\n        (opened)=\"isOpen = true\"\n        (closed)=\"isOpen = false\">\n\n        <ux-page-header-horizontal-navigation-dropdown-item\n            *ngFor=\"let item of _item?.children\"\n            [item]=\"item\">\n        </ux-page-header-horizontal-navigation-dropdown-item>\n    </ux-menu>\n\n</div>\n\n<button *ngIf=\"!_item.children || _item.children.length === 0 || (secondary$ | async)\"\n    uxFocusIndicator\n    #navigationBtn\n    type=\"button\"\n    [tabindex]=\"_tabindex | async\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.disabled]=\"_item.disabled\"\n    [class.selected]=\"_item.selected\"\n    [attr.aria-selected]=\"_item.selected\"\n    (click)=\"select()\"\n    [disabled]=\"_item.disabled\">\n\n    <!-- Support all icon types -->\n    <ng-container *ngIf=\"_item.icon\">\n        <i *ngIf=\"_iconType !== 'component'\"\n            class=\"navigation-item-icon\"\n            [ngClass]=\"[_iconType, _item.icon]\">\n        </i>\n\n        <ux-icon *ngIf=\"_iconType === 'component'\"\n                 class=\"navigation-item-icon\"\n                 [name]=\"_item.icon\">\n        </ux-icon>\n\n    </ng-container>\n\n    <span class=\"navigation-item-label\">{{ _item?.title }}</span>\n\n</button>"
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                PageHeaderService,
                PageHeaderNavigationService])
        ], PageHeaderNavigationItemComponent);
        return PageHeaderNavigationItemComponent;
    }());
    var PageHeaderNavigationSecondaryItemDirective = /** @class */ (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new rxjs.Subject();
        }
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                // Update selected state for this item
                _this._pageHeaderService.updateItem(_this.item, next);
            });
        };
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input('uxPageHeaderNavigationSecondaryItem'),
            __metadata("design:type", Object)
        ], PageHeaderNavigationSecondaryItemDirective.prototype, "item", void 0);
        PageHeaderNavigationSecondaryItemDirective = __decorate([
            core.Directive({
                selector: '[uxPageHeaderNavigationSecondaryItem]'
            }),
            __metadata("design:paramtypes", [PageHeaderService])
        ], PageHeaderNavigationSecondaryItemDirective);
        return PageHeaderNavigationSecondaryItemDirective;
    }());
    var PageHeaderNavigationComponent = /** @class */ (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _navigationService, _pageHeaderService) {
            this._navigationService = _navigationService;
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._onDestroy = new rxjs.Subject();
            resizeService.addResizeListener(elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(this.updateSelectedIndicator.bind(this));
            _pageHeaderService.selected$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this));
            _pageHeaderService.secondary$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this));
        }
        PageHeaderNavigationComponent.prototype.ngAfterViewInit = function () {
            this.updateSelectedIndicator();
            // setup the page focus key manager
            this._navigationService.initialize(this.menuItems);
        };
        PageHeaderNavigationComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator = function () {
            var _this = this;
            setTimeout(function () {
                // find the selected item
                var selected = _this.menuItems.find(function (item) { return item.item.selected; });
                // determine whether or not to show the indicator
                _this.indicatorVisible = !!selected;
                // set the width of the indicator to match the width of the navigation item
                if (selected) {
                    var styles = getComputedStyle(selected.elementRef.nativeElement);
                    _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                    _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                }
            });
        };
        __decorate([
            core.ViewChildren(PageHeaderNavigationItemComponent),
            __metadata("design:type", core.QueryList)
        ], PageHeaderNavigationComponent.prototype, "menuItems", void 0);
        PageHeaderNavigationComponent = __decorate([
            core.Component({
                selector: 'ux-page-header-horizontal-navigation',
                template: "<ux-page-header-horizontal-navigation-item\n    *ngFor=\"let item of items$ | async\"\n    [item]=\"item\">\n</ux-page-header-horizontal-navigation-item>\n\n<div class=\"selected-indicator\"\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\n    [style.margin-left.px]=\"indicatorX\"\n    [style.width.px]=\"indicatorWidth\">\n</div>",
                providers: [PageHeaderNavigationService],
                host: {
                    'role': 'menubar'
                }
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                ResizeService,
                PageHeaderNavigationService,
                PageHeaderService])
        ], PageHeaderNavigationComponent);
        return PageHeaderNavigationComponent;
    }());
    var PageHeaderComponent = /** @class */ (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            /** The alignment of the primary navigation tabs. */
            this.alignment = 'center';
            /** Determines whether or not to display the page header in the regular or condensed form. */
            this.condensed = false;
            /** Determines whether or not a back button should be visible in the page header. */
            this.backVisible = true;
            /** The alignment of the secondary navigation tabs. */
            this.secondaryNavigationAlignment = 'center';
            /**
             * The style of the breadcrumbs.
             *   - standard: The breadcrumbs use the same styling as the navigation tabs.
             *   - small: The breadcrumbs use a smaller font, and case is not adjusted.
             */
            this.crumbsStyle = 'standard';
            /** Emit whenever the back button is clicked */
            this.backClick = new core.EventEmitter();
            /** Emit whenever the product logo in the left corner is clicked. */
            this.logoClick = new core.EventEmitter();
            /** The currently selected page header item */
            this.selected$ = this._pageHeaderService.selected$;
            /** The currently selected root menu item - this may be different from selected$ if a child menu item is selected */
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            /** If set, the first child item will get selected when the parent item is selected. */
            set: function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            /** The primary navigation tabs. Use the children property in combination with [secondaryNavigation]="true" to include secondary navigation tabs. */
            set: function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            /** Whether to show a second level of navigation for any items with children. */
            set: function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            /** The optional set of breadcrumbs to display on the left side of the masthead. */
            set: function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoBackground", {
            get: function () {
                return this._logoBackground;
            },
            /** The logo background color. This can either be the name of a color from the color palette, or a CSS color value. */
            set: function (color) {
                this._logoBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoForeground", {
            get: function () {
                return this._logoForeground;
            },
            /** The logo text color, when a product acronym is specified via header. This can either be the name of a color from the color palette, or a CSS color value. */
            set: function (color) {
                this._logoForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "_hasLogoClick", {
            get: function () {
                return this.logoClick.observers.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        PageHeaderComponent.prototype.select = function (item) {
            this._pageHeaderService.select(item);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "logo", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "subheader", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "alignment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], PageHeaderComponent.prototype, "condensed", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], PageHeaderComponent.prototype, "iconMenus", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], PageHeaderComponent.prototype, "backVisible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "secondaryNavigationAlignment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], PageHeaderComponent.prototype, "secondaryNavigationAutoselect", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], PageHeaderComponent.prototype, "items", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], PageHeaderComponent.prototype, "secondaryNavigation", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], PageHeaderComponent.prototype, "crumbs", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PageHeaderComponent.prototype, "crumbsStyle", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], PageHeaderComponent.prototype, "logoBackground", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], PageHeaderComponent.prototype, "logoForeground", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PageHeaderComponent.prototype, "backClick", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PageHeaderComponent.prototype, "logoClick", void 0);
        __decorate([
            core.ContentChild('subheader', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], PageHeaderComponent.prototype, "subheaderTemplate", void 0);
        __decorate([
            core.ContentChild('logoTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], PageHeaderComponent.prototype, "logoTemplate", void 0);
        __decorate([
            core.ContentChildren(PageHeaderCustomMenuDirective, { read: core.TemplateRef }),
            __metadata("design:type", core.QueryList)
        ], PageHeaderComponent.prototype, "customMenus", void 0);
        PageHeaderComponent = __decorate([
            core.Component({
                selector: 'ux-page-header',
                exportAs: 'ux-page-header',
                template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <div *ngIf=\"!condensed\" class=\"page-header-content\">\n\n        <!-- Logo/product acronym -->\n        <div uxFocusIndicator (keydown.enter)=\"logoClick.emit($event)\" [attr.tabindex]=\"_hasLogoClick ? 0: -1\"\n             [class.page-header-logo-template]=\"logoTemplate\" [class.clickable]=\"_hasLogoClick\"\n             class=\"page-header-logo-container\"\n             role=\"presentation\" [style.backgroundColor]=\"logoBackground\" [style.color]=\"logoForeground\" (click)=\"logoClick.emit($event)\">\n            <img *ngIf=\"logo && !logoTemplate\" [attr.src]=\"logo\" [alt]=\"header\" class=\"page-header-logo\">\n            <h1 *ngIf=\"header && !logo && !logoTemplate\" class=\"page-header-acronym\">{{header}}</h1>\n            <ng-container *ngIf=\"logoTemplate\" [ngTemplateOutlet]=\"logoTemplate\"></ng-container>\n        </div>\n\n        <!-- Sub-title -->\n        <div *ngIf=\"subheader || subheaderTemplate\" class=\"page-header-subtitle-container\">\n            <span *ngIf=\"subheader\" class=\"page-header-subtitle\">{{subheader}}</span>\n            <ng-container [ngTemplateOutlet]=\"subheaderTemplate\"></ng-container>\n        </div>\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <!-- Back button -->\n            <button *ngIf=\"backVisible === true\" uxFocusIndicator type=\"button\" class=\"page-header-back-button\" (click)=\"backClick.emit($event)\" aria-label=\"Go Back\">\n                <ux-icon name=\"previous\" class=\"text-primary\"></ux-icon>\n            </button>\n\n            <!-- Breadcrumbs and header -->\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs *ngIf=\"crumbs && crumbs.length > 0\"\n                    [class.ux-breadcrumbs-small]=\"crumbsStyle === 'small'\"\n                    [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\">{{header}}</h1>\n\n            </div>\n\n        </div>\n\n        <!-- Primary navigation -->\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <!-- Icon menus -->\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div *ngIf=\"secondaryNavigation && ((selectedRoot$ | async) !== (selected$ | async))\"\n    class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\">\n\n    <ux-tabset *ngIf=\"(selectedRoot$ | async)?.children; let children\" [manual]=\"true\">\n        <ux-tab *ngFor=\"let child of children\"\n            [heading]=\"child.title\"\n            [active]=\"child === (selected$ | async)\"\n            (activated)=\"select(child)\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\"\n            [disabled]=\"child.disabled\">\n        </ux-tab>\n    </ux-tabset>\n\n</div>\n",
                providers: [PageHeaderService]
            }),
            __metadata("design:paramtypes", [ColorService, PageHeaderService])
        ], PageHeaderComponent);
        return PageHeaderComponent;
    }());
    var PageHeaderModule = /** @class */ (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    BreadcrumbsModule,
                    ColorServiceModule,
                    common.CommonModule,
                    IconModule,
                    MenuModule,
                    ResizeModule,
                    router.RouterModule,
                    TabsetModule,
                ],
                exports: [
                    PageHeaderComponent,
                    PageHeaderCustomMenuDirective
                ],
                declarations: [
                    PageHeaderComponent,
                    PageHeaderIconMenuComponent,
                    PageHeaderCustomMenuDirective,
                    PageHeaderNavigationComponent,
                    PageHeaderNavigationItemComponent,
                    PageHeaderNavigationDropdownItemComponent,
                    PageHeaderNavigationSecondaryItemDirective
                ]
            })
        ], PageHeaderModule);
        return PageHeaderModule;
    }());
    var PAGINATION_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return PaginationComponent; }),
        multi: true
    };
    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent() {
            /** Specify if we should show the next and previous buttons */
            this.directionButtons = true;
            /** Limit the number of pages shown at any given time */
            this.maxSize = 5;
            /** Specify if the component should be disabled */
            this.disabled = false;
            /** Aria Label for the component navigation */
            this.ariaLabel = 'Pagination Navigation';
            /** Aria label for the previous button */
            this.previousAriaLabel = 'Navigate to the previous page';
            /** Aria label for the next button */
            this.nextAriaLabel = 'Navigate to the next page';
            /** Emit the current page number */
            this.pageChange = new core.EventEmitter();
            /** Emit the total number of pages */
            this.numPages = new core.EventEmitter();
            /** Store a list of pages to display in the UI */
            this.pages = [];
            /** ControlValueAccessor functions */
            this.onTouched = function () { };
            this.onChange = function () { };
            this.isKeyboardEvent = false;
            this._page = 1;
            this._total = 100;
            this._pagesize = 10;
        }
        Object.defineProperty(PaginationComponent.prototype, "page", {
            get: function () {
                return this._page;
            },
            /** Specify the index of the active page */
            set: function (page) {
                // do nothing if the page has not changed
                if (page === this._page) {
                    return;
                }
                this._page = page;
                this.pages = this.getPages();
                // mark this component as changed
                this.onChange(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "itemsPerPage", {
            /** Specify the page size */
            set: function (pagesize) {
                this._pagesize = pagesize;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "totalItems", {
            /** Specify how many items there are in total */
            set: function (total) {
                this._total = total;
                this.pages = this.getPages();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "pageCount", {
            get: function () {
                return Math.ceil(this._total / this._pagesize);
            },
            enumerable: true,
            configurable: true
        });
        PaginationComponent.prototype.ngOnInit = function () {
            this.pages = this.getPages();
        };
        PaginationComponent.prototype.select = function (index) {
            // find the page we want to go to
            var target = this.pages.find(function (page) { return page.index === index; });
            // if the page is out of bounds then do nothing
            if (!target) {
                return;
            }
            // mark this component as touched
            this.onTouched();
            // set this as the current page
            this.page = target.index;
            // update the visible pages
            this.pages = this.getPages();
            // emit the current page
            this.pageChange.emit(this.page);
        };
        PaginationComponent.prototype.trackByFn = function (_index, item) {
            return item.index;
        };
        PaginationComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        PaginationComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        PaginationComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        PaginationComponent.prototype.writeValue = function (page) {
            this.page = page;
        };
        PaginationComponent.prototype.getPages = function () {
            // create a new array to store the pages
            var pages = [];
            // create all possible pages
            for (var index = 1; index <= this.pageCount; index++) {
                pages.push({ index: index, visible: this.isPageVisible(index) });
            }
            // emit the number of pages
            this.numPages.emit(this.pageCount);
            return pages;
        };
        PaginationComponent.prototype.isPageVisible = function (index) {
            // if we do not have a max size specified or the number of pages is less than the max size then it is always visible
            if (!this.maxSize || this.pageCount <= this.maxSize) {
                return true;
            }
            // find the starting position
            var start = Math.max(1, Math.ceil(this.page - (this.maxSize / 2)));
            var end = Math.min(start + this.maxSize, this.pageCount + 1);
            // if the range is less than the max size we need to adjust the starting point
            var range = end - start;
            if (range < this.maxSize) {
                start = start - (this.maxSize - range);
            }
            // if the item equals the start position or is less than the end position then show it
            return index >= start && index < end;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], PaginationComponent.prototype, "directionButtons", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], PaginationComponent.prototype, "maxSize", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], PaginationComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input('class'),
            __metadata("design:type", String)
        ], PaginationComponent.prototype, "classes", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PaginationComponent.prototype, "pageBtnClass", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], PaginationComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PaginationComponent.prototype, "previousAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], PaginationComponent.prototype, "nextAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], PaginationComponent.prototype, "page", null);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], PaginationComponent.prototype, "previousBtnTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], PaginationComponent.prototype, "nextBtnTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], PaginationComponent.prototype, "itemsPerPage", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], PaginationComponent.prototype, "totalItems", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PaginationComponent.prototype, "pageChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PaginationComponent.prototype, "numPages", void 0);
        PaginationComponent = __decorate([
            core.Component({
                selector: 'ux-pagination',
                template: "<nav role=\"navigation\" [attr.aria-label]=\"ariaLabel\">\n  <ul #container class=\"pagination\"\n    [ngClass]=\"classes\"\n    direction=\"horizontal\"\n    (blur)=\"isKeyboardEvent = false\"\n    (keydown.ArrowLeft)=\"select(page - 1); isKeyboardEvent = true\"\n    (keydown.ArrowRight)=\"select(page + 1); isKeyboardEvent = true\"\n    (keydown.Home)=\"select(1); isKeyboardEvent = true; $event.preventDefault()\"\n    (keydown.End)=\"select(pageCount); isKeyboardEvent = true; $event.preventDefault()\">\n\n    <li class=\"pagination-prev page-item\"\n        *ngIf=\"directionButtons\"\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        [checkChildren]=\"true\"\n        [class.disabled]=\"page === 1 || disabled\">\n\n      <a class=\"page-link\"\n         [tabindex]=\"page === 1 || disabled ? -1 : 0\"\n         [attr.aria-label]=\"previousAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page - 1)\"\n         (keydown.enter)=\"select(page - 1)\">\n        <ng-container [ngTemplateOutlet]=\"previousBtnTemplate || defaultPreviousBtnTemplate\"></ng-container>\n      </a>\n    </li>\n\n    <ng-container *ngFor=\"let pg of pages; trackBy: trackByFn\">\n      <li *ngIf=\"pg.visible\"\n          uxFocusIndicator\n          [programmaticFocusIndicator]=\"true\"\n          [checkChildren]=\"true\"\n          [class.disabled]=\"disabled\"\n          [class.active]=\"page === pg.index\"\n          class=\"pagination-page page-item\">\n\n        <a class=\"page-link\"\n           tabindex=\"0\"\n           [ngClass]=\"pageBtnClass\"\n           [focusIf]=\"isKeyboardEvent && page === pg.index\"\n           [attr.aria-current]=\"page === pg.index\"\n           [attr.aria-setsize]=\"pageCount\"\n           [attr.aria-posinset]=\"pg.index\"\n           (click)=\"select(pg.index)\"\n           (keydown.enter)=\"select(pg.index)\">\n            {{ pg.index }}\n        </a>\n      </li>\n    </ng-container>\n\n    <li class=\"pagination-next page-item\"\n        *ngIf=\"directionButtons\"\n        uxFocusIndicator\n        [programmaticFocusIndicator]=\"true\"\n        [checkChildren]=\"true\"\n        [class.disabled]=\"page === pageCount || disabled\">\n\n      <a class=\"page-link\"\n         [tabindex]=\"page === pageCount || disabled ? -1 : 0\"\n         [attr.aria-label]=\"nextAriaLabel\"\n         [ngClass]=\"pageBtnClass\"\n         (click)=\"select(page + 1)\"\n         (keydown.enter)=\"select(page + 1)\">\n\n        <ng-container [ngTemplateOutlet]=\"nextBtnTemplate || defaultNextBtnTemplate\"></ng-container>\n      </a>\n    </li>\n  </ul>\n</nav>\n\n<ng-template #defaultPreviousBtnTemplate>\n    <ux-icon class=\"pagination-prev-icon-default\" name=\"previous\"></ux-icon>\n</ng-template>\n\n<ng-template #defaultNextBtnTemplate>\n    <ux-icon class=\"pagination-next-icon-default\" name=\"next\"></ux-icon>\n</ng-template>\n",
                providers: [PAGINATION_CONTROL_VALUE_ACCESSOR]
            })
        ], PaginationComponent);
        return PaginationComponent;
    }());
    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        PaginationModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    FocusIfModule,
                    IconModule,
                ],
                declarations: [
                    PaginationComponent
                ],
                exports: [
                    PaginationComponent
                ]
            })
        ], PaginationModule);
        return PaginationModule;
    }());
    var PartitionMapSegmentEventsDirective = /** @class */ (function () {
        function PartitionMapSegmentEventsDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Emit when the segment receives focus */
            this.segmentFocus = new core.EventEmitter();
            /** Emit when the segment is blurred */
            this.segmentBlur = new core.EventEmitter();
            /** Unsubscribe from observables */
            this._onDestroy = new rxjs.Subject();
        }
        PartitionMapSegmentEventsDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            // Get the parent segment element
            // Note we cannot use DI to get the element as this is a template
            // and the context has no knowledge of the partition map template
            var segment = this.getSegmentElement();
            if (segment) {
                rxjs.fromEvent(segment, 'focus')
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (event) { return _this.segmentFocus.emit(event); });
                rxjs.fromEvent(segment, 'blur')
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (event) { return _this.segmentBlur.emit(event); });
            }
        };
        PartitionMapSegmentEventsDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Find the parent element that is a partition map segment
         */
        PartitionMapSegmentEventsDirective.prototype.getSegmentElement = function () {
            var ancestor = this._elementRef.nativeElement.parentElement;
            while (ancestor !== null) {
                if (ancestor.classList.contains('partition-map-segment')) {
                    return ancestor;
                }
                ancestor = ancestor.parentElement;
            }
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PartitionMapSegmentEventsDirective.prototype, "segmentFocus", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PartitionMapSegmentEventsDirective.prototype, "segmentBlur", void 0);
        PartitionMapSegmentEventsDirective = __decorate([
            core.Directive({
                selector: '[segmentFocus],[segmentBlur]',
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], PartitionMapSegmentEventsDirective);
        return PartitionMapSegmentEventsDirective;
    }());
    var PartitionMapComponent = /** @class */ (function () {
        function PartitionMapComponent(_colorService, _elementRef, _changeDetector, _ngZone, _focusOrigin, _contrastRatio, _liveAnnouncer, _resizeService) {
            this._colorService = _colorService;
            this._elementRef = _elementRef;
            this._changeDetector = _changeDetector;
            this._ngZone = _ngZone;
            this._focusOrigin = _focusOrigin;
            this._contrastRatio = _contrastRatio;
            this._liveAnnouncer = _liveAnnouncer;
            this._resizeService = _resizeService;
            /** Determine the pixel height of collapsed segments. */
            this.collapsedHeight = 40;
            /** Define a minimum desired pixel width for a segment. */
            this.minSegmentWidth = 5;
            /** Define the function that will return the aria announcement for a given segment. */
            this.segmentAnnouncement = this.defaultSegmentAnnouncement;
            /** Emits whenever a segment is selected. */
            this.selectedChange = new core.EventEmitter();
            /** Store the processed segments */
            this._segments = [];
            /** Store the specified color sequences */
            this._colors = [[]];
            /** Store the assigned colors for each segment */
            this._segmentColors = new Map();
            /** Store the visible x scale */
            this._x = d3.scaleLinear().range([0, 100]);
            /** Store the visible y scale */
            this._y = d3.scaleLinear().range([0, 100]);
            /** Store the width of the chart on resize to avoid any reflow */
            this._width = this._elementRef.nativeElement.offsetWidth;
            /** Store the height of the chart on resize to avoid any reflow */
            this._height = this._elementRef.nativeElement.offsetHeight;
            /** Flag to determine when the inputs have all been bound */
            this._initialized = false;
            /** Unsubscribe from any observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(PartitionMapComponent.prototype, "colors", {
            /** Define the colors to be used for each row and the order they should appear. */
            set: function (colors) {
                this._colors = colors;
                // clear the save color mappings
                this._segmentColors.clear();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PartitionMapComponent.prototype, "dataset", {
            get: function () {
                return this._dataset;
            },
            /** Define the dataset to display in the chart. */
            set: function (dataset) {
                // store the current dataset
                this._dataset = dataset;
                // clear any existing color assignments
                this._segmentColors.clear();
                // update the segment layout
                this.setDataset(dataset);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PartitionMapComponent.prototype, "selected", {
            /** Define the currently selected item. */
            set: function (selected) {
                // if this is set before the dataset is process then store it to be selected later
                if (this._segments.length === 0) {
                    this._awaitingSelection = selected;
                    return;
                }
                // perform the selection
                this.select(this.getHierarchyNodeFromSegment(selected));
            },
            enumerable: true,
            configurable: true
        });
        PartitionMapComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (dimensions) {
                _this._width = dimensions.width;
                _this._height = dimensions.height;
                _this._changeDetector.detectChanges();
                // set our new ranges
                if (_this._selected) {
                    _this._x.domain([_this.getSegmentX(_this._selected), _this.getSegmentX(_this._selected) + _this.getSegmentWidth(_this._selected)]);
                    _this._y.domain([_this._selected.y0, 1]).range([_this.getTotalCollapsedHeight(), 100]);
                }
                // render the chart to ensure positions and sizes are correct
                _this.updateSegments();
            });
            this._initialized = true;
            // Run again so that the colors get applied
            this._changeDetector.detectChanges();
        };
        PartitionMapComponent.prototype.ngOnDestroy = function () {
            this._resizeService.removeResizeListener(this._elementRef.nativeElement);
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Handle segment clicks */
        PartitionMapComponent.prototype._onSegmentSelect = function (segment) {
            // if the clicked node is already selected, navigate to the parent node
            this.select(this._isSelected(segment) && segment.parent ? segment.parent : segment);
        };
        /** Get the background color for a given segment */
        PartitionMapComponent.prototype._getBackgroundColor = function (segment) {
            // This can be called before `colors` is initialized, in which case return the default color
            if (!this._initialized) {
                return '#fff';
            }
            // each segment has a determinable color key based on the name and depth
            var key = segment.data.name + " - " + segment.depth;
            // check if a segment with the same name (and depth) has previously
            if (this._segmentColors.has(key)) {
                return this._segmentColors.get(key);
            }
            // get the corresponding row of colors
            var sequence = this.getColorSequence(segment.depth);
            // if the sequence has not been specified return a default of white
            if (!sequence || sequence.length === 0) {
                return '#fff';
            }
            // get siblings
            var siblings = this.getAllSiblings(segment);
            // get the previous sibling if there is one
            var sibling = siblings[siblings.indexOf(segment) - 1];
            // if there is a previous sibling then get its color and use the next one in the sequence
            if (sibling) {
                var index = sequence.indexOf(this._getBackgroundColor(sibling));
                var color = sequence[(index + 1) % sequence.length];
                // store the color by key
                this._segmentColors.set(key, color);
                return color;
            }
            // store the color by key
            this._segmentColors.set(key, sequence[0]);
            // if there is no previous sibling then simply return the first color in the sequence
            return sequence[0];
        };
        /** Get the tab index of a segment */
        PartitionMapComponent.prototype._getTabIndex = function (segment) {
            return segment === this._focusableSegment ? 0 : -1;
        };
        /** Shift focus to the parent segment */
        PartitionMapComponent.prototype._focusParent = function (segment) {
            // if there is no parent (ie, we are the root segment) then retain focus
            if (!segment.parent) {
                return;
            }
            // otherwise focus the parent
            this.focusSegment(segment.parent);
        };
        /** Shift focus to the child segment */
        PartitionMapComponent.prototype._focusChild = function (segment) {
            var _this = this;
            // if there are no children (ie, we are a leaf segment) then retain focus
            if (!segment.children) {
                return;
            }
            // find the first visible child
            var child = segment.children.find(function (_segment) { return _this.isVisible(_segment); });
            // otherwise focus the first visible child
            if (child) {
                this.focusSegment(child);
            }
        };
        /** Shift focus to the sibling segment */
        PartitionMapComponent.prototype._focusSibling = function (segment, delta) {
            // if we are the root node then do nothing
            if (!segment.parent) {
                return;
            }
            // get a list of all the siblings (at the same row regardless of the same parent)
            var siblings = this.getAllSiblings(segment);
            // get the index of the segment in the list of siblings
            var index = siblings.indexOf(segment);
            // get the target sibling
            var sibling = siblings[index + delta];
            // ensure the sibling is visible otherwise we can't select it
            if (!sibling || !this.isVisible(sibling)) {
                return;
            }
            // otherwise focus the sibling
            this.focusSegment(sibling);
        };
        PartitionMapComponent.prototype._focusFirstSibling = function (segment) {
            var _this = this;
            // if we are the root node then do nothing
            if (!segment.parent) {
                return;
            }
            // get a list of all the siblings (at the same row regardless of the same parent)
            var siblings = this.getAllSiblings(segment);
            // find the first visible sibling
            var sibling = siblings.find(function (_sibling) { return _this.isVisible(_sibling); });
            // ensure there is a sibling
            if (!sibling) {
                return;
            }
            // otherwise focus the sibling
            this.focusSegment(sibling);
        };
        PartitionMapComponent.prototype._focusLastSibling = function (segment) {
            var _this = this;
            // if we are the root node then do nothing
            if (!segment.parent) {
                return;
            }
            // get a list of all the siblings (at the same row regardless of the same parent)
            var siblings = this.getAllSiblings(segment);
            // find the last visible sibling
            var sibling = siblings.reverse().find(function (_sibling) { return _this.isVisible(_sibling); });
            // ensure there is a sibling
            if (!sibling) {
                return;
            }
            // otherwise focus the sibling
            this.focusSegment(sibling);
        };
        /** Determine if a given segment is currently collapsed */
        PartitionMapComponent.prototype._isCollapsed = function (segment) {
            return this._selected && segment.depth < this._selected.depth;
        };
        /** Determine if a given segment is currently selected */
        PartitionMapComponent.prototype._isSelected = function (segment) {
            return this._selected === segment;
        };
        /** Get the contast color class for the segment */
        PartitionMapComponent.prototype._getContrastColor = function (segment) {
            var backgroundColor = this._getBackgroundColor(segment);
            var lightColor = ThemeColor.parse('#fff');
            var darkColor = ThemeColor.parse('#000');
            var color = this._contrastRatio.getContrastColor(ThemeColor.parse(backgroundColor), lightColor, darkColor);
            return color === lightColor ? 'partition-map-segment-light' : 'partition-map-segment-dark';
        };
        /** Provide an aria announcement when the node is focused */
        PartitionMapComponent.prototype._onFocus = function (segment) {
            // get all ancestors
            var ancestors = segment.ancestors().map(function (ancestor) { return ancestor.data; });
            // get the current node and the parent nodes
            var _a = __read(ancestors), item = _a[0], parents = _a.slice(1);
            // get the hierarchy node data from the item
            var hierarchichalItem = this.getHierarchyNodeFromSegment(item);
            // get the function that creates the announcement
            var announcement = this.segmentAnnouncement({
                item: item,
                parents: parents,
                value: this._getSegmentValue(segment.data),
                collapsed: this._isCollapsed(hierarchichalItem),
                selected: this._isSelected(hierarchichalItem)
            });
            // make aria announcement
            this._liveAnnouncer.announce(announcement);
        };
        /** Determine if the content is smaller than the width of an ellipsis */
        PartitionMapComponent.prototype._getSegmentContentHidden = function (segment) {
            // get the width of the segment as a pixel value
            var width = (this._width / 100) * this.getNormalizedSegmentWidth(segment);
            // if the width is less than 50 px hide the content
            return width < 50;
        };
        /** Get the value of a segment based on the accumulation of all child values */
        PartitionMapComponent.prototype._getSegmentValue = function (segment) {
            var _this = this;
            // it it has a value then return the value
            if (segment.hasOwnProperty('value')) {
                return segment.value;
            }
            return segment.children.reduce(function (value, child) { return value + _this._getSegmentValue(child); }, 0);
        };
        PartitionMapComponent.prototype._getContext = function (segment) {
            var context = {
                segment: segment.data,
                value: this._getSegmentValue(segment.data),
                color: this._getBackgroundColor(segment),
                expanded: !this._isCollapsed(segment),
                children: []
            };
            // map the children to their contexts
            if (segment.children) {
                context.children = segment.children.map(this._getContext.bind(this));
            }
            return context;
        };
        /** Convert the public facing data structure into the layout format we require */
        PartitionMapComponent.prototype.setDataset = function (dataset) {
            // convert the segments to a hierarchichal structure
            var segmentHierarchy = d3.hierarchy(dataset)
                .sum(this.getSegmentValue); // calculate segment values based on their children
            // store the processed segments
            var root = d3.partition()(segmentHierarchy);
            // store the flattened form of the segments
            this._segments = root.descendants();
            // mark the root node as focusable
            this._focusableSegment = root;
            // we need to run change detection here so the `*ngFor` will update and add all the segments to the DOM
            this._changeDetector.detectChanges();
            // select all the segments within the chart
            this._segmentsSelection = d3.select(this._elementRef.nativeElement)
                .selectAll('.partition-map-segment')
                .data(this._segments);
            // set the correct sizing and position of the segments
            this.updateSegments();
            // if there is an item waiting to be selected then select it
            if (this._awaitingSelection) {
                // select the desired segment
                this.select(this.getHierarchyNodeFromSegment(this._awaitingSelection));
                // clear the pending selection in case the dataset changes we don't want to attempt another selection
                this._awaitingSelection = null;
            }
        };
        /** Update the size and position of the segments */
        PartitionMapComponent.prototype.updateSegments = function () {
            var _this = this;
            // if the chart has not yet been initialised do nothing
            if (!this._segmentsSelection) {
                return;
            }
            // perform the chart positioning and sizing
            this._segmentsSelection
                .style('left', function (data) { return _this.getNormalizedSegmentX(data) + '%'; })
                .style('top', function (data) { return _this.getNormalizedSegmentY(data) + '%'; })
                .style('width', function (data) { return (_this.getNormalizedSegmentWidth(data) + 0.01) + '%'; })
                .style('height', function (data) { return _this.getNormalizedSegmentHeight(data) + '%'; })
                .style('padding-right', function (data) { return _this.getSegmentPaddingRight(data) + '%'; })
                .style('padding-left', function (data) { return _this.getSegmentPaddingLeft(data) + '%'; });
        };
        /**
         * Get the X position of a given segment. The X position can be determined
         * by calculating the width of every sibling segment to the left of it
         */
        PartitionMapComponent.prototype.getSegmentX = function (segment) {
            var e_1, _a;
            // if root node then return the position
            if (!segment.parent) {
                return segment.x0;
            }
            // set initial start position equal to that of the parent
            var accumulation = this.getSegmentX(segment.parent);
            try {
                // iterate each previous sibling to accumulate the widths
                for (var _b = __values(segment.parent.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sibling = _c.value;
                    // if we have reached the current node then return all previous widths
                    if (sibling === segment) {
                        return accumulation;
                    }
                    // keep a tally of all the widths of previous siblings
                    accumulation += this.getSegmentWidth(sibling);
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        };
        /** Calculate width based of each segment */
        PartitionMapComponent.prototype.getSegmentWidth = function (segment) {
            // if root node then return 1 always
            if (!segment.parent) {
                return 1;
            }
            // get width of parent
            var parentOffset = this.getSegmentWidth(segment.parent) / (segment.parent.x1 - segment.parent.x0);
            // get the original width of the segment
            var width = (segment.x1 - segment.x0);
            // if the item is a descendant of the selected item then apply the modifier
            if (this.isDescendantOfSelected(segment)) {
                // we want to try an ensure that children are at least the specified minimum width
                // however it may not always be possible, but we should be able to at least distribute the widths better
                // even if we cannot meet the minimum desired width.
                var modifier = this.getDistributionModifier(segment);
                // return the width of the current node relative to the parent
                return (width * modifier) * parentOffset;
            }
            return width * parentOffset;
        };
        /** Return the X position of the segment in a normalized form based on the specifiec domain */
        PartitionMapComponent.prototype.getNormalizedSegmentX = function (segment) {
            return this._x(this.getSegmentX(segment));
        };
        /** Return the Y position of the segment in a normalized form based on the specifiec domain */
        PartitionMapComponent.prototype.getNormalizedSegmentY = function (segment) {
            // if there is a selected node we should take into account any collapsed nodes
            if (this._isCollapsed(segment)) {
                return segment.depth * this.getCollapsedHeight();
            }
            // otherwise simply return the normalized value
            return this._y(segment.y0);
        };
        /** Return the width of the segment in a normalized form based on the specifiec domain */
        PartitionMapComponent.prototype.getNormalizedSegmentWidth = function (segment) {
            return this._x(this.getSegmentX(segment) + this.getSegmentWidth(segment)) - this._x(this.getSegmentX(segment));
        };
        /** Return the height of the segment in a normalized form based on the specifiec domain */
        PartitionMapComponent.prototype.getNormalizedSegmentHeight = function (segment) {
            // if there is a selected node we should take into account any collapsed nodes
            if (this._isCollapsed(segment)) {
                return this.getCollapsedHeight();
            }
            // otherwise simply return the normalized value
            return this._y(segment.y0 + (segment.y1 - segment.y0)) - this._y(segment.y0);
        };
        /**
         * As parent segments collapse they increase in size, as the content is centered this can
         * cause the content to appear either mis-aligned or off screen. We can calculate the padding
         * required to always ensure the content appears visibly centered within the node.
         */
        PartitionMapComponent.prototype.getSegmentPaddingRight = function (segment) {
            // non-collapsed node do not require any padding
            if (!this._isCollapsed(segment)) {
                return 0;
            }
            return (this.getNormalizedSegmentWidth(segment) - this.getSegmentPaddingLeft(segment)) - this.getNormalizedSegmentWidth(this._selected);
        };
        PartitionMapComponent.prototype.getSegmentPaddingLeft = function (segment) {
            // non-collapsed node do not require any padding
            if (!this._isCollapsed(segment)) {
                return 0;
            }
            return Math.abs(this.getNormalizedSegmentX(segment));
        };
        /**
         * This function returns the value for each segment. Leaf segments will have a value property which we can simply return, however
         * non-leaf segments should get their values based on the leaf segments that are children, in which case we can return 0
         */
        PartitionMapComponent.prototype.getSegmentValue = function (segment) {
            if (segment.hasOwnProperty('value')) {
                var value = segment.value;
                // we must ensure that a leaf node never has no width otherwise things can get weird
                return Math.max(value, 1);
            }
            // if it has children then return 0 to base the value of the width of the children
            return 0;
        };
        /** Get the total height of all the collapse rows */
        PartitionMapComponent.prototype.getTotalCollapsedHeight = function () {
            return this._selected ? this._selected.depth * this.getCollapsedHeight() : 0;
        };
        /** Get the collapsed height in percentage format */
        PartitionMapComponent.prototype.getCollapsedHeight = function () {
            return parseFloat(((this.collapsedHeight / this._height) * 100).toPrecision(3));
        };
        /** Determine if a given segment is currently visible based on the selected segment */
        PartitionMapComponent.prototype.isVisible = function (segment) {
            // if no segment is selected then all segments are visible
            if (!this._selected) {
                return true;
            }
            // if there is a selected node then it should be a direct ancestor or descendant to be visible
            return !!__spread(this._selected.ancestors(), this._selected.descendants()).find(function (_segment) { return _segment === segment; });
        };
        /** Update the focusable item and perform a focus */
        PartitionMapComponent.prototype.focusSegment = function (segment) {
            // get the segment element from the data
            var element = this._segmentsSelection.nodes().find(function (node) { return d3.select(node).data()[0] === segment; });
            // if for some reason an element isn't found then stop here
            if (!element) {
                return;
            }
            // update the focusable segment
            this._focusableSegment = segment;
            // set the focus origin as a keyboard event
            this._focusOrigin.setOrigin('keyboard');
            // focus the element
            element.focus();
            // ensure we do not change scroll position when focusing
            this._elementRef.nativeElement.scrollLeft = 0;
            this._elementRef.nativeElement.scrollTop = 0;
        };
        /** Get all the segments at a given depth */
        PartitionMapComponent.prototype.getAllSiblings = function (segment) {
            return this._segments.filter(function (_segment) { return _segment.depth === segment.depth; });
        };
        PartitionMapComponent.prototype.getHierarchyNodeFromSegment = function (segment) {
            return this._segments.find(function (_segment) { return _segment.data === segment; });
        };
        /** Select a specified segment */
        PartitionMapComponent.prototype.select = function (segment) {
            var _this = this;
            // if no segment is specified or it is already selected then do nothing
            if (!segment || this._isSelected(segment)) {
                return;
            }
            // emit the selection
            this.selectedChange.emit(segment.data);
            // store the selected segment
            this._selected = segment;
            // update the focusable segment
            this._focusableSegment = segment;
            // set our new ranges
            this._x.domain([this.getSegmentX(segment), this.getSegmentX(segment) + this.getSegmentWidth(segment)]);
            this._y.domain([segment.y0, 1]).range([this.getTotalCollapsedHeight(), 100]);
            // create the transition
            var segmentTransition = d3.transition().duration(500);
            // update the segment sizes - outside angular zone as there is lots of `requestAnimationFrames` triggering lots of change detection
            this._ngZone.runOutsideAngular(function () {
                _this._segmentsSelection.transition(segmentTransition)
                    .style('left', function (data) { return _this.getNormalizedSegmentX(data) + '%'; })
                    .style('top', function (data) { return _this.getNormalizedSegmentY(data) + '%'; })
                    .style('width', function (data) { return (_this.getNormalizedSegmentWidth(data) + 0.01) + '%'; })
                    .style('height', function (data) { return _this.getNormalizedSegmentHeight(data) + '%'; })
                    .style('padding-right', function (data) { return _this.getSegmentPaddingRight(data) + '%'; })
                    .style('padding-left', function (data) { return _this.getSegmentPaddingLeft(data) + '%'; });
            });
        };
        /** Normalize the available colors to a string[][] from portentially a ThemeColor[][] */
        PartitionMapComponent.prototype.getColorSequence = function (depth) {
            var _this = this;
            // get the target row
            var colorSet = this._colors[depth];
            // if no color set available throw an error
            if (!colorSet) {
                throw new Error('Partition Map: Please provide a color sequence for items with a depth of ' + depth);
            }
            // convert this row to an array of strings
            return colorSet.map(function (color) { return ThemeColor.isInstanceOf(color) ? color.toRgba() : _this._colorService.resolve(color); });
        };
        /** Determine if a segment is a descendant of the currently selected item */
        PartitionMapComponent.prototype.isDescendantOfSelected = function (segment) {
            // if there are no segments selected then return true
            if (!this._selected) {
                return true;
            }
            // if the segment is the selected segment then it is not a descendant
            if (this._selected === segment) {
                return false;
            }
            return !!this._selected.descendants().find(function (_segment) { return _segment === segment; });
        };
        /**
         * We have an option to allow a minimum desired width for items. This will
         * allow us to attempt to determine the size a segment would be accounting for very
         * small segments that have their widths artifically increased to make them more visible
         */
        PartitionMapComponent.prototype.getDistributionModifier = function (segment) {
            var e_2, _a, e_3, _b;
            var _this = this;
            // calculate the desired number of pixels as a percentage
            var minSegmentWidth = (this.minSegmentWidth / this._width) * 100;
            // map to a segment width pair
            var siblings = segment.parent.children.map(function (_segment) {
                return { segment: _segment, width: _this._x(_segment.x1 - _segment.x0) };
            });
            // a simple closure to check if we now have acceptable sizes
            var isAcceptable = function (segments) {
                return !segments.find(function (_segment) { return _segment.width < minSegmentWidth; }) ||
                    segments.filter(function (_segment) { return _segment.width < minSegmentWidth; }).length === siblings.length;
            };
            // if all segments are above or below the desired width then we can stop here
            if (isAcceptable(siblings)) {
                return 1;
            }
            // find the total amount we need to reclaim for other segments
            var amountToReclaim = siblings.reduce(function (accumulation, _segment) { return accumulation + (_segment.width < minSegmentWidth ? minSegmentWidth - _segment.width : 0); }, 0);
            // loop through adjusting the segments until we either make all acceptable sizes or cannot resize any further
            while (!isAcceptable(siblings) && amountToReclaim !== 0) {
                // determine which segments can shrink
                var shrinkableSiblings = siblings.filter(function (sibling) { return sibling.width > minSegmentWidth; });
                // determine which segments need to grow
                var growableSiblings = siblings.filter(function (sibling) { return sibling.width < minSegmentWidth; });
                // if there are no items that can be shrunk/grown then do nothing
                if (shrinkableSiblings.length === 0 || growableSiblings.length === 0) {
                    break;
                }
                // determine the target amount to remove from each segment
                var shrinkTarget = amountToReclaim / shrinkableSiblings.length;
                // store the amount we have reclaimed in this pass
                var reclaimed = 0;
                try {
                    // iterate each segment and subtract accordingly
                    for (var shrinkableSiblings_1 = (e_2 = void 0, __values(shrinkableSiblings)), shrinkableSiblings_1_1 = shrinkableSiblings_1.next(); !shrinkableSiblings_1_1.done; shrinkableSiblings_1_1 = shrinkableSiblings_1.next()) {
                        var sibling = shrinkableSiblings_1_1.value;
                        // determine how much we can actually subtract - as subtracting the target may bring the width down below the
                        // minimum which we don't want, so instead determine if we can subtract the target amount, otherwise figure out
                        // how much we can subtract without bringing the width below the desired minimum
                        var subtractAmount = sibling.width - shrinkTarget > minSegmentWidth ? shrinkTarget : sibling.width - minSegmentWidth;
                        // update the amount to reclaim with the new value
                        reclaimed += subtractAmount;
                        // update the sibling width
                        sibling.width -= subtractAmount;
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (shrinkableSiblings_1_1 && !shrinkableSiblings_1_1.done && (_a = shrinkableSiblings_1.return))
                            _a.call(shrinkableSiblings_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                // update the amount left to reclaim
                amountToReclaim -= reclaimed;
                // determine the target amount to add to each segment
                var growTarget = reclaimed / growableSiblings.length;
                try {
                    // add the available reclaimed amount to the segment that need to grow
                    for (var growableSiblings_1 = (e_3 = void 0, __values(growableSiblings)), growableSiblings_1_1 = growableSiblings_1.next(); !growableSiblings_1_1.done; growableSiblings_1_1 = growableSiblings_1.next()) {
                        var sibling = growableSiblings_1_1.value;
                        // determine the amount we need to add. The target amount may be larger than the amount we need
                        // to add so ensure we only add the amount we need and no more.
                        var addAmount = sibling.width + growTarget < minSegmentWidth ? growTarget : minSegmentWidth - sibling.width;
                        // update the sibling width
                        sibling.width += addAmount;
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (growableSiblings_1_1 && !growableSiblings_1_1.done && (_b = growableSiblings_1.return))
                            _b.call(growableSiblings_1);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
            }
            // identify the current widget from all the siblings
            var matchingSegment = siblings.find(function (sibling) { return sibling.segment === segment; });
            // check if we are the last sibling
            var isLast = siblings.findIndex(function (sibling) { return sibling.segment === segment; }) === siblings.length - 1;
            // if we are the last and somehow we are smaller than the parent node, we want to bump up the size of the last node
            if (isLast) {
                // get the total parent width
                var parentWidth = this._x(segment.parent.x1 - segment.parent.x0);
                // get the total width of all the children
                var width = siblings.reduce(function (total, sibling) { return total + sibling.width; }, 0);
                // check if need to expand the last node
                if (parentWidth !== width) {
                    return (matchingSegment.width + (parentWidth - width)) / this._x(matchingSegment.segment.x1 - matchingSegment.segment.x0);
                }
            }
            // determine the amount the size has changed
            return matchingSegment.width / this._x(matchingSegment.segment.x1 - matchingSegment.segment.x0);
        };
        /** Get the default announcement when a segment is focused */
        PartitionMapComponent.prototype.defaultSegmentAnnouncement = function (info) {
            // create the announcement
            if (info.parents.length === 0) {
                return "This is the root segment. It has a value of " + info.value + ".";
            }
            // otherwise inform the user of the parent hierarchy
            return info.item.name + " has a value of " + info.value + " and is a " + info.parents.map(function (parent) { return "descendant of " + parent.name; }).join(' and a ');
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], PartitionMapComponent.prototype, "colors", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], PartitionMapComponent.prototype, "collapsedHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], PartitionMapComponent.prototype, "minSegmentWidth", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], PartitionMapComponent.prototype, "dataset", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], PartitionMapComponent.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], PartitionMapComponent.prototype, "segmentAnnouncement", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], PartitionMapComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.ContentChild('partitionMapSegment', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], PartitionMapComponent.prototype, "segmentTemplate", void 0);
        PartitionMapComponent = __decorate([
            core.Component({
                selector: 'ux-partition-map',
                template: "<div class=\"partition-map-segment\"\n     *ngFor=\"let segment of _segments\"\n     uxFocusIndicator\n     [ngClass]=\"_getContrastColor(segment)\"\n     [style.background-color]=\"_getBackgroundColor(segment)\"\n     [tabIndex]=\"_getTabIndex(segment)\"\n     [attr.aria-expanded]=\"!_isCollapsed(segment)\"\n     [attr.aria-selected]=\"_isSelected(segment)\"\n     [attr.aria-level]=\"segment.depth\"\n     (click)=\"_onSegmentSelect(segment)\"\n     (focus)=\"_onFocus(segment)\"\n     (keydown.Enter)=\"_onSegmentSelect(segment)\"\n     (keydown.ArrowUp)=\"_focusParent(segment); $event.preventDefault()\"\n     (keydown.ArrowDown)=\"_focusChild(segment); $event.preventDefault()\"\n     (keydown.ArrowLeft)=\"_focusSibling(segment, -1); $event.preventDefault()\"\n     (keydown.ArrowRight)=\"_focusSibling(segment, 1); $event.preventDefault()\"\n     (keydown.Home)=\"_focusFirstSibling(segment); $event.preventDefault()\"\n     (keydown.End)=\"_focusLastSibling(segment); $event.preventDefault()\">\n\n     <div class=\"partition-map-segment-content\" [class.partition-map-segment-content-hidden]=\"_getSegmentContentHidden(segment)\">\n\n      <!-- Show default template if provided -->\n      <span class=\"partition-map-segment-label\" *ngIf=\"!segmentTemplate\">\n        {{ segment.data.name }}\n      </span>\n\n       <!-- Show custom template if provided -->\n      <ng-container *ngIf=\"segmentTemplate\"\n        [ngTemplateOutlet]=\"segmentTemplate\"\n        [ngTemplateOutletContext]=\"_getContext(segment)\">\n      </ng-container>\n    </div>\n\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [ColorService,
                core.ElementRef,
                core.ChangeDetectorRef,
                core.NgZone,
                FocusIndicatorOriginService,
                ContrastService,
                a11y.LiveAnnouncer,
                ResizeService])
        ], PartitionMapComponent);
        return PartitionMapComponent;
    }());
    var PartitionMapModule = /** @class */ (function () {
        function PartitionMapModule() {
        }
        PartitionMapModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    ColorServiceModule,
                    ResizeModule
                ],
                declarations: [
                    PartitionMapComponent,
                    PartitionMapSegmentEventsDirective
                ],
                exports: [
                    PartitionMapComponent,
                    PartitionMapSegmentEventsDirective
                ]
            })
        ], PartitionMapModule);
        return PartitionMapModule;
    }());
    var ProgressBarComponent = /** @class */ (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.min = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        Object.defineProperty(ProgressBarComponent.prototype, "valueNow", {
            /** When indeteminate we should omit the valuenow label */
            get: function () {
                return this.indeterminate ? null : this.value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ProgressBarComponent.prototype, "value", void 0);
        __decorate([
            core.Input(), core.HostBinding('attr.aria-valuemin'),
            __metadata("design:type", Number)
        ], ProgressBarComponent.prototype, "min", void 0);
        __decorate([
            core.Input(), core.HostBinding('attr.aria-valuemax'),
            __metadata("design:type", Number)
        ], ProgressBarComponent.prototype, "max", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ProgressBarComponent.prototype, "indeterminate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ProgressBarComponent.prototype, "trackColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ProgressBarComponent.prototype, "barColor", void 0);
        __decorate([
            core.HostBinding('attr.aria-valuenow'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], ProgressBarComponent.prototype, "valueNow", null);
        ProgressBarComponent = __decorate([
            core.Component({
                selector: 'ux-progress-bar',
                template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"((value - min) / (max - min)) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n\n<!-- Workaround for Multiple ng-content tags issue: https://github.com/angular/angular/issues/22972 -->\n<ng-template #content><ng-content></ng-content></ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    role: 'progressbar'
                }
            })
        ], ProgressBarComponent);
        return ProgressBarComponent;
    }());
    var ProgressBarModule = /** @class */ (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                exports: [ProgressBarComponent],
                declarations: [ProgressBarComponent]
            })
        ], ProgressBarModule);
        return ProgressBarModule;
    }());
    var RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonGroupDirective; }),
        multi: true
    };
    var RadioButtonGroupDirective = /** @class */ (function () {
        function RadioButtonGroupDirective() {
            /** Emit when the currently selected value changes */
            this.valueChange = new core.EventEmitter();
            /** Used to inform Angular forms that the component has been touched */
            this.onTouched = function () { };
            /** Used to inform Angular forms that the component value has changed */
            this.onChange = function () { };
            /** Unsubscribe from all subscriptions on destroy */
            this._onDestroy$ = new rxjs.Subject();
            /** Internally store the current value */
            this._value = null;
        }
        Object.defineProperty(RadioButtonGroupDirective.prototype, "value", {
            /** Return the currently selected value */
            get: function () {
                return this._value;
            },
            /** Define the current selected value within the group */
            set: function (value) {
                this._value = value;
                this.updateSelectedRadioButton();
            },
            enumerable: true,
            configurable: true
        });
        RadioButtonGroupDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.updateSelectedRadioButton();
            // update the selected items any time new ones are added
            this._radioButtons.changes.pipe(operators.takeUntil(this._onDestroy$))
                .subscribe(function () { return _this.updateSelectedRadioButton(); });
        };
        RadioButtonGroupDirective.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        /** Allow Angular forms for provide us with a callback for when the input value changes */
        RadioButtonGroupDirective.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        /** Allow Angular forms for provide us with a callback for when the touched state changes */
        RadioButtonGroupDirective.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /** Allow Angular forms to give us the current value */
        RadioButtonGroupDirective.prototype.writeValue = function (value) {
            this.value = value;
        };
        /** Allow Angular forms to disable the component */
        RadioButtonGroupDirective.prototype.setDisabledState = function (isDisabled) {
            if (this._radioButtons) {
                this._radioButtons.forEach(function (radio) { return radio.setDisabledState(isDisabled); });
            }
        };
        /** Emit the currently selected value */
        RadioButtonGroupDirective.prototype.emitChange = function (value) {
            this.valueChange.next(value);
            this.onChange(value);
            this.onTouched();
        };
        /** Inform all child radio buttons of the latest value */
        RadioButtonGroupDirective.prototype.updateSelectedRadioButton = function () {
            var _this = this;
            // update the selected value in all radio buttons
            if (this._radioButtons) {
                this._radioButtons.forEach(function (radio) { return radio.writeValue(_this._value); });
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RadioButtonGroupDirective.prototype, "value", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RadioButtonGroupDirective.prototype, "valueChange", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return RadioButtonComponent; }), { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], RadioButtonGroupDirective.prototype, "_radioButtons", void 0);
        RadioButtonGroupDirective = __decorate([
            core.Directive({
                selector: 'ux-radio-button-group, [uxRadioButtonGroup]',
                providers: [
                    RADIO_GROUP_CONTROL_VALUE_ACCESSOR
                ],
                host: {
                    'role': 'radiogroup'
                }
            })
        ], RadioButtonGroupDirective);
        return RadioButtonGroupDirective;
    }());
    var RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var uniqueRadioId = 0;
    var RadioButtonComponent = /** @class */ (function () {
        function RadioButtonComponent(_changeDetector, _group) {
            this._changeDetector = _changeDetector;
            this._group = _group;
            /** Provide a default unique id value for the radiobutton */
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            /** Specify a unique Id for this component */
            this.id = this._radioButtonId;
            /** Specify the tabindex */
            this.tabindex = 0;
            /** If set to `true` the radio button will not change state when clicked. */
            this.clickable = true;
            /** If this value is set to `true` then the radio button will be disabled */
            this.disabled = false;
            /** If set to `true` the checkbox will be displayed without a border and background. */
            this.simplified = false;
            /** Specify an aria label for the input element */
            this.ariaLabel = '';
            /** Specify an aria labelledby property for the input element */
            this.ariaLabelledby = null;
            /** Specify an aria describedby property for the input element */
            this.ariaDescribedby = null;
            /** Emits when the value has been changed. */
            this.valueChange = new core.EventEmitter();
            /** Determine if the underlying input component has been focused with the keyboard */
            this._focused = false;
            /** Used to inform Angular forms that the component has been touched */
            this.onTouchedCallback = function () { };
            /** Used to inform Angular forms that the component value has changed */
            this.onChangeCallback = function () { };
        }
        /** Select the current option */
        RadioButtonComponent.prototype.select = function () {
            if (this.disabled || !this.clickable) {
                return;
            }
            // toggle the checked state
            this.value = this.option;
            // if there is a group set the selected value
            if (this._group) {
                this._group.value = this.option;
                this._group.emitChange(this.option);
            }
            // emit the value
            this.valueChange.emit(this.value);
            // update the value if used within a form control
            this.onChangeCallback(this.value);
            // mark the component as touched
            this.onTouchedCallback();
        };
        // Functions required to update ng-model
        RadioButtonComponent.prototype.writeValue = function (value) {
            if (value !== this.value) {
                this.value = value;
                this._changeDetector.detectChanges();
            }
        };
        /** Allow Angular forms for provide us with a callback for when the input value changes */
        RadioButtonComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /** Allow Angular forms for provide us with a callback for when the touched state changes */
        RadioButtonComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /** Allow Angular forms to disable the component */
        RadioButtonComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RadioButtonComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RadioButtonComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RadioButtonComponent.prototype, "value", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RadioButtonComponent.prototype, "required", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], RadioButtonComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RadioButtonComponent.prototype, "clickable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RadioButtonComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RadioButtonComponent.prototype, "simplified", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RadioButtonComponent.prototype, "option", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], RadioButtonComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input('aria-labelledby'),
            __metadata("design:type", String)
        ], RadioButtonComponent.prototype, "ariaLabelledby", void 0);
        __decorate([
            core.Input('aria-describedby'),
            __metadata("design:type", String)
        ], RadioButtonComponent.prototype, "ariaDescribedby", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], RadioButtonComponent.prototype, "valueChange", void 0);
        RadioButtonComponent = __decorate([
            core.Component({
                selector: 'ux-radio-button',
                template: "<label [attr.for]=\"(id || _radioButtonId) + '-input'\"\n       class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"_focused\">\n\n    <div class=\"ux-radio-button-container\">\n\n        <input class=\"ux-radio-button-input\"\n            uxFocusIndicator\n            type=\"radio\"\n            [id]=\"(id || _radioButtonId) + '-input'\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (indicator)=\"_focused = $event\"\n            (change)=\"select()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                providers: [RADIOBUTTON_VALUE_ACCESSOR],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Optional()),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                RadioButtonGroupDirective])
        ], RadioButtonComponent);
        return RadioButtonComponent;
    }());
    var RadioButtonModule = /** @class */ (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    forms.FormsModule
                ],
                exports: [
                    RadioButtonComponent,
                    RadioButtonGroupDirective
                ],
                declarations: [
                    RadioButtonComponent,
                    RadioButtonGroupDirective
                ]
            })
        ], RadioButtonModule);
        return RadioButtonModule;
    }());
    var SankeyChart = /** @class */ (function () {
        function SankeyChart() {
            /** Define the nodes in the chart */
            this._nodes = [];
            /** Define the links in the chart */
            this._links = [];
            /** Store the node-links */
            this._nodeLinks = [];
            /** Define the minimum width of the nodes */
            this._minWidth = 0;
            /** Define the maximum width of the nodes */
            this._maxWidth = Infinity;
            /** Define the minimum distance from the edge of the chart */
            this._padding = 24;
        }
        /** Define the spacing of the chart */
        SankeyChart.prototype.spacing = function (spacing) {
            this._spacing = spacing;
            return this;
        };
        /** Define the width of the chart */
        SankeyChart.prototype.width = function (width) {
            this._width = width;
            return this;
        };
        /** Define the height of the chart */
        SankeyChart.prototype.height = function (height) {
            this._height = height;
            return this;
        };
        /** Define the nodes */
        SankeyChart.prototype.nodes = function (nodes) {
            this._nodes = nodes;
            return this;
        };
        /** Define the links */
        SankeyChart.prototype.links = function (links) {
            this._links = links;
            return this;
        };
        /** Define the minimum and maximum size of the nodes */
        SankeyChart.prototype.size = function (minWidth, maxWidth, minHeight) {
            this._minWidth = minWidth;
            this._maxWidth = maxWidth;
            this._minHeight = minHeight;
            return this;
        };
        /** Get the sizes of each column */
        SankeyChart.prototype.columns = function () {
            // get the number of columns - we use this a lot so avoid multiple function calls
            var columnCount = this.getColumnCount();
            // get the amount of padding there should be on each side of a node
            var padding = this.getColumnPadding();
            var columnWidths = [];
            for (var idx = 0; idx < columnCount; idx++) {
                columnWidths[idx] = this.getNodeWidth() + (padding * 2);
                // do no have the default padding on the left of the start node
                // or right of the last node, instead have a default padding
                if (idx === 0 || idx === columnCount - 1) {
                    columnWidths[idx] -= (padding - this._padding);
                }
            }
            return columnWidths;
        };
        /**
         * Perform the various stages of the layout
         * in the correct order as some steps are dependant
         * on the previous layout stages.
         */
        SankeyChart.prototype.layout = function () {
            this.getNodeLinks();
            this.getNodeValues();
            this.getNodeColumns();
            this.getNodeWidths();
            this.getNodeHeights();
            this.getNodePositions();
            this.getLinkPlots();
            return this._nodeLinks;
        };
        /** The curve equation for links */
        SankeyChart.prototype.link = function (link) {
            // const dist = chart.blockSpacing / 2;
            var topLeft = link.topLeft, topRight = link.topRight, bottomLeft = link.bottomLeft, bottomRight = link.bottomRight;
            var dist = (topRight[0] - topLeft[0]) / 2;
            var topLeftCurve = [topLeft[0] + dist, topLeft[1]];
            var topRightCurve = [topRight[0] - dist, topRight[1]];
            var bottomLeftCurve = [bottomLeft[0] + dist, bottomLeft[1]];
            var bottomRightCurve = [bottomRight[0] - dist, bottomRight[1]];
            return 'M' + topLeft[0] + ',' + topLeft[1] +
                'C' + topLeftCurve[0] + ',' + topLeftCurve[1] +
                ' ' + topRightCurve[0] + ',' + topRightCurve[1] +
                ' ' + topRight[0] + ',' + topRight[1] +
                'L' + bottomRight[0] + ',' + bottomRight[1] +
                'C' + bottomRightCurve[0] + ',' + bottomRightCurve[1] +
                ' ' + bottomLeftCurve[0] + ',' + bottomLeftCurve[1] +
                ' ' + bottomLeft[0] + ',' + bottomLeft[1] +
                'L' + topLeft[0] + ',' + topLeft[1];
        };
        SankeyChart.prototype.getFalloffPath = function (nodeLink) {
            var x = (nodeLink.x + nodeLink.width);
            var y = nodeLink.outputs.reduce(function (bottom, output) { return Math.max(bottom, output.bottomLeft[1]); }, 0);
            var width = 20;
            var radius = 6;
            var height = (nodeLink.y + nodeLink.height - y) + (this._spacing / 2);
            return 'M' + x + ',' + y +
                'h ' + (width - radius) +
                'a' + radius + ',' + radius + ' 0 0,1' +
                (radius) + ',' + (radius) + ' ' +
                'v' + Math.max(radius, height) + 'h-' + width + 'Z';
        };
        /**
         * Get a `SankeyNodeLink` object from the id of a node
         */
        SankeyChart.prototype.getNodeLink = function (id) {
            return this._nodeLinks.find(function (nodeLink) { return nodeLink.node.id === id; });
        };
        /** Replace the node ids with actual references */
        SankeyChart.prototype.getNodeLinks = function () {
            var _this = this;
            this._nodeLinks = this._nodes.map(function (node) {
                // get all the links that input into and output from this node
                var inputs = _this._links.filter(function (link) { return link.target === node.id; });
                var outputs = _this._links.filter(function (link) { return link.source === node.id; });
                return { node: node, inputs: inputs, outputs: outputs, value: 0, column: 0, x: 0, y: 0, width: 0, height: 0, naturalHeight: 0, falloff: 0, active: false, focus: false };
            });
        };
        /** Get the value for the node based on all its inputs and outputs */
        SankeyChart.prototype.getNodeValues = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._nodeLinks), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    // the node value can be determined by the total values from all inputs
                    // however the first column of nodes have no inputs so must be based of their outputs.
                    // We should take the maximum value based on the inputs and outputs as nodes that are
                    // not in the first column may not output all of the amount the receive from inputs,
                    // for example in the case of falloff etc..
                    node.value = Math.max(d3.sum(node.inputs, function (input) { return input.value; }), d3.sum(node.outputs, function (output) { return output.value; }));
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        };
        /**
         * We need to determine which column the node should
         * be placed in. This is determined by taking the input
         * and adding one.
         */
        SankeyChart.prototype.getNodeColumns = function (nodeLinks, column) {
            var e_2, _a;
            var _this = this;
            if (nodeLinks === void 0) {
                nodeLinks = this._nodeLinks.filter(function (node) { return node.inputs.length === 0; });
            }
            if (column === void 0) {
                column = 0;
            }
            try {
                for (var nodeLinks_1 = __values(nodeLinks), nodeLinks_1_1 = nodeLinks_1.next(); !nodeLinks_1_1.done; nodeLinks_1_1 = nodeLinks_1.next()) {
                    var nodeLink = nodeLinks_1_1.value;
                    nodeLink.column = column;
                    // call this function to all output links
                    this.getNodeColumns(nodeLink.outputs.map(function (output) { return _this.getNodeLink(output.target); }), column + 1);
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (nodeLinks_1_1 && !nodeLinks_1_1.done && (_a = nodeLinks_1.return))
                        _a.call(nodeLinks_1);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        };
        /** Get the width of each node */
        SankeyChart.prototype.getNodeWidths = function () {
            var _this = this;
            this._nodeLinks.forEach(function (node) { return node.width = _this.getNodeWidth(); });
        };
        /**
         * Scale the nodes height based on the value the represent
         */
        SankeyChart.prototype.getNodeHeights = function () {
            var e_3, _a, e_4, _b;
            // get columns by group
            var groups = this.getColumnGroups();
            var groupList = Object.keys(groups).map(function (group) { return groups[group]; });
            // get the column with the largest total value
            var total = groupList.reduce(function (count, nodes) { return Math.max(count, nodes.reduce(function (accumulation, node) { return accumulation + node.value; }, 0)); }, 0);
            try {
                // Calculate node heights
                for (var groupList_1 = __values(groupList), groupList_1_1 = groupList_1.next(); !groupList_1_1.done; groupList_1_1 = groupList_1.next()) {
                    var nodeLinks = groupList_1_1.value;
                    try {
                        // get the proportional size of each node based on the available space
                        for (var nodeLinks_2 = (e_4 = void 0, __values(nodeLinks)), nodeLinks_2_1 = nodeLinks_2.next(); !nodeLinks_2_1.done; nodeLinks_2_1 = nodeLinks_2.next()) {
                            var nodeLink = nodeLinks_2_1.value;
                            nodeLink.naturalHeight = ((nodeLink.value / total) * this._height) - this._spacing;
                            nodeLink.height = Math.max(nodeLink.naturalHeight, this._minHeight);
                        }
                    }
                    catch (e_4_1) {
                        e_4 = { error: e_4_1 };
                    }
                    finally {
                        try {
                            if (nodeLinks_2_1 && !nodeLinks_2_1.done && (_b = nodeLinks_2.return))
                                _b.call(nodeLinks_2);
                        }
                        finally {
                            if (e_4)
                                throw e_4.error;
                        }
                    }
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (groupList_1_1 && !groupList_1_1.done && (_a = groupList_1.return))
                        _a.call(groupList_1);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            // If minHeight is defined, it might cause some columns to exceed the height of the chart following the
            // initial height calculation.
            if (this._minHeight > 0) {
                try {
                    // Recalculate node heights until they fit (if possible)
                    this.adjustNodeHeightsToFit(groupList);
                }
                catch (error) {
                    // If the above recalculation fails, give up and use the naturalHeight (ignore minHeight)
                    this.setNodesToNaturalHeight(groupList);
                }
            }
        };
        /**
         * Recalculate node heights within height limits until they fit (if possible).
         * @throws If it is not possible to fit all nodes in the chart due to `minHeight`.
         */
        SankeyChart.prototype.adjustNodeHeightsToFit = function (groupList) {
            var e_5, _a, e_6, _b;
            var _this = this;
            var largestColumn = this.getLargestColumn(groupList);
            while (largestColumn.height > this._height) {
                // Get the list of nodes whose height cannot be reduced
                var fixedNodes = largestColumn.nodes.filter(function (nodeLink) { return nodeLink.height <= _this._minHeight; });
                // Get the total height in the column which cannot shrink (including spacing)
                var fixedHeight = fixedNodes.length * this._minHeight + largestColumn.nodes.length * this._spacing;
                // If the unshrinkable height is greater than the available height, we can't continue
                if (fixedHeight > this._height) {
                    throw new Error("Cannot fit data into chart with minHeight = " + this._minHeight + "px (need " + fixedHeight + "px; " + this._height + "px available)");
                }
                // Find the amount of height which can potentially be reduced
                var flexibleHeight = largestColumn.height - fixedHeight;
                // Find the amount of height that the above needs to fit into
                var availableHeight = this._height - fixedHeight;
                // Get the multiplier to reduce the nodes in order to fit the available height
                var ratio = availableHeight / flexibleHeight;
                try {
                    // Adjust the nodes and reapply the minHeight
                    for (var groupList_2 = (e_5 = void 0, __values(groupList)), groupList_2_1 = groupList_2.next(); !groupList_2_1.done; groupList_2_1 = groupList_2.next()) {
                        var group = groupList_2_1.value;
                        try {
                            for (var group_1 = (e_6 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                                var nodeLink = group_1_1.value;
                                if (nodeLink.height > this._minHeight) {
                                    nodeLink.height *= ratio;
                                }
                                if (nodeLink.height < this._minHeight) {
                                    nodeLink.height = this._minHeight;
                                }
                            }
                        }
                        catch (e_6_1) {
                            e_6 = { error: e_6_1 };
                        }
                        finally {
                            try {
                                if (group_1_1 && !group_1_1.done && (_b = group_1.return))
                                    _b.call(group_1);
                            }
                            finally {
                                if (e_6)
                                    throw e_6.error;
                            }
                        }
                    }
                }
                catch (e_5_1) {
                    e_5 = { error: e_5_1 };
                }
                finally {
                    try {
                        if (groupList_2_1 && !groupList_2_1.done && (_a = groupList_2.return))
                            _a.call(groupList_2);
                    }
                    finally {
                        if (e_5)
                            throw e_5.error;
                    }
                }
                largestColumn = this.getLargestColumn(groupList);
            }
        };
        /** Set all nodes height to be the same as the naturalHeight. */
        SankeyChart.prototype.setNodesToNaturalHeight = function (groupList) {
            var e_7, _a, e_8, _b;
            try {
                for (var groupList_3 = __values(groupList), groupList_3_1 = groupList_3.next(); !groupList_3_1.done; groupList_3_1 = groupList_3.next()) {
                    var group = groupList_3_1.value;
                    try {
                        for (var group_2 = (e_8 = void 0, __values(group)), group_2_1 = group_2.next(); !group_2_1.done; group_2_1 = group_2.next()) {
                            var nodeLink = group_2_1.value;
                            nodeLink.height = nodeLink.naturalHeight;
                        }
                    }
                    catch (e_8_1) {
                        e_8 = { error: e_8_1 };
                    }
                    finally {
                        try {
                            if (group_2_1 && !group_2_1.done && (_b = group_2.return))
                                _b.call(group_2);
                        }
                        finally {
                            if (e_8)
                                throw e_8.error;
                        }
                    }
                }
            }
            catch (e_7_1) {
                e_7 = { error: e_7_1 };
            }
            finally {
                try {
                    if (groupList_3_1 && !groupList_3_1.done && (_a = groupList_3.return))
                        _a.call(groupList_3);
                }
                finally {
                    if (e_7)
                        throw e_7.error;
                }
            }
        };
        /**
         * Get all nodes grouped in their corresponding columns
         */
        SankeyChart.prototype.getColumnGroups = function () {
            // group nodes by columns
            return this._nodeLinks.reduce(function (collection, nodeLink) {
                collection[nodeLink.column] = collection[nodeLink.column] || [];
                collection[nodeLink.column].push(nodeLink);
                return collection;
            }, {});
        };
        /**
         * Get the number of columns
         */
        SankeyChart.prototype.getColumnCount = function () {
            return this._nodeLinks.reduce(function (column, nodeLink) { return Math.max(nodeLink.column + 1, column); }, 0);
        };
        /**
         * Position the nodes in their corresponding x and y positions
         */
        SankeyChart.prototype.getNodePositions = function () {
            var e_9, _a;
            // get all nodes by group
            var groups = this.getColumnGroups();
            // get the amount of padding required between each item
            var padding = this.getColumnPadding();
            try {
                for (var _b = __values(this._nodeLinks), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var nodeLink = _c.value;
                    // get the x position based on the column
                    nodeLink.x = this.getColumnPosition(nodeLink.column) + padding;
                    if (nodeLink.column === 0) {
                        nodeLink.x = this._padding;
                    }
                    // get the y position based on the accumulative height of the nodes above it
                    nodeLink.y = groups[nodeLink.column]
                        .slice(0, groups[nodeLink.column].indexOf(nodeLink))
                        .reduce(function (top, _node) { return top + _node.height; }, 0) + (this._spacing * groups[nodeLink.column].indexOf(nodeLink));
                }
            }
            catch (e_9_1) {
                e_9 = { error: e_9_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_9)
                        throw e_9.error;
                }
            }
        };
        SankeyChart.prototype.getColumnPadding = function () {
            // get the number of columns - we use this a lot so avoid multiple function calls
            var columnCount = this.getColumnCount();
            // get the chart width minus the width of the nodes
            var width = (this._width - (columnCount * this.getNodeWidth())) - (this._padding * 2);
            // get the total amount of places requiring padding (the first and last columns only have padding on one side)
            var paddingCount = Math.max(((columnCount * 2) - 2), 0);
            // get the actual size of the padding
            return width / paddingCount;
        };
        SankeyChart.prototype.getLinkPlots = function () {
            var e_10, _a, e_11, _b, e_12, _c;
            try {
                for (var _d = __values(this._nodeLinks), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var nodeLink = _e.value;
                    var inputY = nodeLink.y;
                    try {
                        // process each input link
                        for (var _f = (e_11 = void 0, __values(nodeLink.inputs)), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var link = _g.value;
                            link.topRight = [nodeLink.x, inputY];
                            inputY += ((link.value / nodeLink.value) * nodeLink.height);
                            link.bottomRight = [nodeLink.x, inputY];
                        }
                    }
                    catch (e_11_1) {
                        e_11 = { error: e_11_1 };
                    }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return))
                                _b.call(_f);
                        }
                        finally {
                            if (e_11)
                                throw e_11.error;
                        }
                    }
                    var outputValue = 0;
                    var outputY = nodeLink.y;
                    try {
                        // process each output link
                        for (var _h = (e_12 = void 0, __values(nodeLink.outputs)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var link = _j.value;
                            link.topLeft = [nodeLink.x + nodeLink.width, outputY];
                            outputY += ((link.value / nodeLink.value) * nodeLink.height);
                            link.bottomLeft = [nodeLink.x + nodeLink.width, outputY];
                            outputValue += link.value;
                        }
                    }
                    catch (e_12_1) {
                        e_12 = { error: e_12_1 };
                    }
                    finally {
                        try {
                            if (_j && !_j.done && (_c = _h.return))
                                _c.call(_h);
                        }
                        finally {
                            if (e_12)
                                throw e_12.error;
                        }
                    }
                    // determine how much falloff there is
                    nodeLink.falloff = nodeLink.value - outputValue;
                }
            }
            catch (e_10_1) {
                e_10 = { error: e_10_1 };
            }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return))
                        _a.call(_d);
                }
                finally {
                    if (e_10)
                        throw e_10.error;
                }
            }
        };
        /** Determine the position at which a column starts */
        SankeyChart.prototype.getColumnPosition = function (column) {
            // the position is the acculation of the widths of all previous columns
            return this.columns().splice(0, column).reduce(function (total, width) { return total + width; }, 0);
        };
        /** Get the pixel width of a node */
        SankeyChart.prototype.getNodeWidth = function () {
            var width = (this._width - (this._padding * 2)) / ((this.getColumnCount() * 2) - 1);
            return Math.min(this._maxWidth, Math.max(this._minWidth, width));
        };
        /** Get the column with the greatest height (along with its height) */
        SankeyChart.prototype.getLargestColumn = function (groupList) {
            var e_13, _a;
            var largestColumn = null;
            var largestColumnHeight = 0;
            try {
                for (var groupList_4 = __values(groupList), groupList_4_1 = groupList_4.next(); !groupList_4_1.done; groupList_4_1 = groupList_4.next()) {
                    var group = groupList_4_1.value;
                    var totalHeight = group.reduce(function (acc, node) { return acc += node.height; }, 0) + group.length * this._spacing;
                    if (totalHeight > largestColumnHeight) {
                        largestColumnHeight = totalHeight;
                        largestColumn = group;
                    }
                }
            }
            catch (e_13_1) {
                e_13 = { error: e_13_1 };
            }
            finally {
                try {
                    if (groupList_4_1 && !groupList_4_1.done && (_a = groupList_4.return))
                        _a.call(groupList_4);
                }
                finally {
                    if (e_13)
                        throw e_13.error;
                }
            }
            return {
                nodes: largestColumn,
                height: largestColumnHeight
            };
        };
        return SankeyChart;
    }());
    var SankeyFocusManager = /** @class */ (function () {
        function SankeyFocusManager() {
            /** Store the node that can currently be tabbed to */
            this.active$ = new rxjs.BehaviorSubject(null);
            /** Emit whenever an item should receive focus */
            this.focused$ = new rxjs.Subject();
            /** Store the nodes  */
            this._nodes = [];
        }
        Object.defineProperty(SankeyFocusManager.prototype, "_active", {
            /** Get the current active item */
            get: function () {
                return this.active$.value;
            },
            enumerable: true,
            configurable: true
        });
        SankeyFocusManager.prototype.ngOnDestroy = function () {
            this.active$.complete();
            this.focused$.complete();
        };
        /** Update the list of possible nodes */
        SankeyFocusManager.prototype.setNodes = function (nodes) {
            this._nodes = nodes;
            // check if there is currently a tabbable node, if not we should make the first node tabbable
            if (!this.hasActiveNode()) {
                this.setActiveItem(this._nodes[0]);
            }
        };
        /** Set the current active item */
        SankeyFocusManager.prototype.setActiveItem = function (node) {
            this.active$.next(node);
        };
        /** Handle keyboard input from nodes */
        SankeyFocusManager.prototype.onKeydown = function (event) {
            switch (event.which) {
                case keycodes.UP_ARROW:
                    this.shiftFocusVertically(-1);
                    event.preventDefault();
                    break;
                case keycodes.DOWN_ARROW:
                    this.shiftFocusVertically(1);
                    event.preventDefault();
                    break;
                case keycodes.LEFT_ARROW:
                    this.shiftFocusHorizontally(-1);
                    event.preventDefault();
                    break;
                case keycodes.RIGHT_ARROW:
                    this.shiftFocusHorizontally(1);
                    event.preventDefault();
                    break;
            }
        };
        SankeyFocusManager.prototype.setFocusedItem = function (item) {
            this.setActiveItem(item);
            this.focused$.next(item);
        };
        SankeyFocusManager.prototype.shiftFocusVertically = function (delta) {
            var _this = this;
            var nodes = this.getNodesInColumn(this._active.column);
            // get the node below or above the active node
            var target = nodes[nodes.findIndex(function (node) { return node.node.id === _this._active.node.id; }) + delta];
            if (target) {
                this.setFocusedItem(target);
            }
        };
        /** Shift the focus to a node in a sibling column */
        SankeyFocusManager.prototype.shiftFocusHorizontally = function (delta) {
            var _this = this;
            // get nodes in the sibling column in the desired direction
            var nodes = this.getNodesInColumn(this._active.column + delta);
            // if there are no nodes then do nothing as we cannot reduce an empty array
            if (nodes.length === 0) {
                return;
            }
            // get the node with the most similar y position
            var target = nodes.reduce(function (closest, node) {
                var closestDiff = Math.max(closest.y, _this._active.y) - Math.min(closest.y, _this._active.y);
                var currentDiff = Math.max(node.y, _this._active.y) - Math.min(node.y, _this._active.y);
                return closestDiff < currentDiff ? closest : node;
            });
            if (target) {
                this.setFocusedItem(target);
            }
        };
        /** Get a list of nodes that are in a given column */
        SankeyFocusManager.prototype.getNodesInColumn = function (column) {
            return this.getNodesInOrder(this._nodes.filter(function (node) { return node.column === column; }));
        };
        /** Sort the nodes based on the Y position */
        SankeyFocusManager.prototype.getNodesInOrder = function (nodes) {
            return __spread(nodes).sort(function (nodeOne, nodeTwo) { return nodeOne.y - nodeTwo.y; });
        };
        /** Determine whether or not there is a not that is tabbable */
        SankeyFocusManager.prototype.hasActiveNode = function () {
            var _this = this;
            return !!this.active$.value && !!this._nodes.find(function (node) { return node.node.id === _this.active$.value.node.id; });
        };
        SankeyFocusManager = __decorate([
            core.Injectable()
        ], SankeyFocusManager);
        return SankeyFocusManager;
    }());
    var SankeyNodeDirective = /** @class */ (function () {
        function SankeyNodeDirective(_focusManager, _elementRef) {
            this._focusManager = _focusManager;
            this._elementRef = _elementRef;
            /** Specify the tab index of the current item */
            this.tabIndex = -1;
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        SankeyNodeDirective.prototype.ngOnInit = function () {
            var _this = this;
            // Update the tabindex based on the current active item
            this._focusManager.active$.pipe(operators.map(function (item) { return item && item.node.id === _this.node.node.id; }), operators.takeUntil(this._onDestroy))
                .subscribe(function (isActive) { return _this.tabIndex = isActive ? 0 : -1; });
            // If this element should be focused perform the focus
            this._focusManager.focused$.pipe(operators.filter(function (node) { return node.node.id === _this.node.node.id; }), operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this._elementRef.nativeElement.focus(); });
        };
        SankeyNodeDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        SankeyNodeDirective.prototype.onClick = function () {
            this._focusManager.setActiveItem(this.node);
        };
        SankeyNodeDirective.prototype.onKeydown = function (event) {
            this._focusManager.onKeydown(event);
        };
        __decorate([
            core.Input('uxSankeyNode'),
            __metadata("design:type", Object)
        ], SankeyNodeDirective.prototype, "node", void 0);
        __decorate([
            core.HostBinding(),
            __metadata("design:type", Number)
        ], SankeyNodeDirective.prototype, "tabIndex", void 0);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], SankeyNodeDirective.prototype, "onClick", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SankeyNodeDirective.prototype, "onKeydown", null);
        SankeyNodeDirective = __decorate([
            core.Directive({
                selector: '[uxSankeyNode]',
            }),
            __metadata("design:paramtypes", [SankeyFocusManager,
                core.ElementRef])
        ], SankeyNodeDirective);
        return SankeyNodeDirective;
    }());
    var SankeyChartComponent = /** @class */ (function () {
        function SankeyChartComponent(_focusManager, _changeDetector, _colorService) {
            this._focusManager = _focusManager;
            this._changeDetector = _changeDetector;
            this._colorService = _colorService;
            /** Define the nodes to display */
            this.nodes = [];
            /** Define the links to display */
            this.links = [];
            /** Define the headers of each column */
            this.columns = [];
            /** Define the minimum width of a node */
            this.minWidth = 0;
            /** Define the maximum width of a node */
            this.maxWidth = Infinity;
            /** The minimum height of a node. */
            this.minHeight = 0;
            /** Define the function to get the contents of a link tooltip */
            this.linkTooltip = this.getLinkTooltip;
            /** Define the function to get the contents of a falloff tooltip */
            this.falloffTooltip = this.getFalloffTooltip;
            /** Define the nodes that should be rendered */
            this._nodes = [];
            /** Define the columns to display */
            this._columns = [];
            /** Determine if the tooltip should be visible or not */
            this._isTooltipOpen = false;
            /** Define the position of the tooltip */
            this._tooltipPosition = { x: 0, y: 0 };
            /** Determine if the component is initialised */
            this._isInitialised = false;
            /** Store the instance of the sankey layout */
            this._sankey = new SankeyChart();
        }
        SankeyChartComponent.prototype.ngAfterViewInit = function () {
            // verify we have a node template defined before proceeding
            if (!this.nodeTemplate) {
                throw new Error('Sankey Chart - Node Template has not been defined.');
            }
            // set the initial chart size
            this._width = this.nodeContainer.nativeElement.offsetWidth;
            this._height = this.nodeContainer.nativeElement.offsetHeight;
            // perform the initial render
            this._render();
            // mark the component as initialised
            this._isInitialised = true;
        };
        /**
         * Detect any changes from Inputs. We can skip
         * the first function call as this happens before
         * the initial render so it has no effect.
         */
        SankeyChartComponent.prototype.ngOnChanges = function () {
            if (this._isInitialised) {
                this._render();
            }
        };
        /** Re-render the chart */
        SankeyChartComponent.prototype._render = function () {
            this._nodes = this._sankey
                .nodes(this.nodes)
                .links(this.links)
                .spacing(14)
                .size(this.minWidth, this.maxWidth, this.minHeight)
                .width(this._width || this.nodeContainer.nativeElement.offsetWidth)
                .height(this._height || this.nodeContainer.nativeElement.offsetHeight)
                .layout();
            // ensure the focus manager has the latest node data
            this._focusManager.setNodes(this._nodes);
            this._columns = this.getColumns();
            this._changeDetector.detectChanges();
        };
        /** Update the layout whenever the dimensions change changes */
        SankeyChartComponent.prototype._onResize = function (dimensions) {
            this._width = dimensions.width;
            this._height = dimensions.height;
            this._render();
        };
        /**
         * Column count should be based on the data, not the titles
         * as they may not specify titles but the nodes will still be
         * rendered.
         */
        SankeyChartComponent.prototype._getColumnCount = function () {
            return this._nodes.reduce(function (column, node) { return Math.max(column, node.column); }, 0);
        };
        /**
         * Get the SVG path that defines the shape of the link
         */
        SankeyChartComponent.prototype._getPath = function (link) {
            return this._sankey.link(link);
        };
        /**
         * Set the active state of a node and the inputs and outputs
         * associated with this node.
         */
        SankeyChartComponent.prototype._setNodeActive = function (nodeLink, active) {
            var _this = this;
            // set the node active state
            nodeLink.active = active;
            // set the active state of each link
            nodeLink.inputs.forEach(function (link) { return link.active = active; });
            nodeLink.outputs.forEach(function (link) { return link.active = active; });
            // set the active state of all input and output nodes
            nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.active = active; });
            nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.active = active; });
            nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.active = active; });
            nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.active = active; });
            // ensure we update the view to show highlights
            this._changeDetector.detectChanges();
        };
        /**
         * Set the focused state of a node and the inputs and outputs
         * associated with this node.
         */
        SankeyChartComponent.prototype._setNodeFocus = function (nodeLink, focused, element) {
            var _this = this;
            // set the node focus state
            nodeLink.focus = focused;
            // set the active state of each link
            nodeLink.inputs.forEach(function (link) { return link.focus = focused; });
            nodeLink.outputs.forEach(function (link) { return link.focus = focused; });
            // set the active state of all input and output nodes
            nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.focus = focused; });
            nodeLink.inputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.focus = focused; });
            nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.source); }).forEach(function (_node) { return _node.focus = focused; });
            nodeLink.outputs.map(function (link) { return _this._sankey.getNodeLink(link.target); }).forEach(function (_node) { return _node.focus = focused; });
            // we need to add the focus indicator here programmatically. The default quantum-ux-aspects focus indicator
            // styling uses `!important` so our inline style needs to also be `!important` to override this, and unfortunately
            // there is a known issue with `NgStyle` and `[style.xyz]` bindings preventing them from adding the `!important`
            // modifier so we must do it manually (not using `Renderer2`).
            if (this.color) {
                element.style.setProperty('box-shadow', this._getFocusIndicator(nodeLink), 'important');
            }
            // ensure we update the view to show highlights
            this._changeDetector.detectChanges();
        };
        /**
         * Set the active state of a link and the source and target
         * nodes associated with the link
         */
        SankeyChartComponent.prototype._setLinkActive = function (link, active) {
            link.active = active;
            if (link.source !== undefined) {
                this._sankey.getNodeLink(link.source).active = active;
            }
            if (link.target !== undefined) {
                this._sankey.getNodeLink(link.target).active = active;
            }
            // update the tooltip visibility
            this._isTooltipOpen = active;
            // update the tooltip content
            this._tooltipContent = active ? this.linkTooltip(link) : '';
            // ensure we update the view to show highlights
            this._changeDetector.detectChanges();
        };
        /**
         * This is required because we want to toggle a class based on the `active`
         * property on a link, however toggling classes using `NgClass` or the class
         * binding syntax `[class.xyz]` does not work in IE when applied to an SVG
         * element. (https://github.com/angular/angular/issues/6327)
         *
         * The alternatice is to bind directly to the `class` attribute and return a
         * string that will toggle the class based on the `active` property.
         */
        SankeyChartComponent.prototype._getLinkClass = function (link) {
            return "ux-sankey-chart-link " + ((link.active || link.focus) ? 'ux-sankey-chart-link-active' : '');
        };
        /**
         * Get the SVG path that defines the shape of the falloff indicator
         */
        SankeyChartComponent.prototype._getFalloffPath = function (node) {
            return this._sankey.getFalloffPath(node);
        };
        /**
         * Falloff represents the amount of data that does not get passed on,
         * for example, if a node gets 1,000,000 items from inputs and only outputs
         * 500,000 then there is falloff of 500,000. However, items in the last column
         * never pass on any information, so tecnhically 100% of their input is falloff
         * so we shouldn't show it in the last column.
         */
        SankeyChartComponent.prototype._showFalloff = function (nodeLink) {
            return nodeLink.column < this._columns.length - 1;
        };
        /** Update the visibility and content of the tooltip on falloff hover */
        SankeyChartComponent.prototype._setFalloffTooltip = function (nodeLink, isVisible) {
            this._isTooltipOpen = isVisible;
            this._tooltipContent = isVisible ? this.falloffTooltip(nodeLink.falloff) : '';
            this._changeDetector.detectChanges();
        };
        /**
         * Update the position of the tooltip
         */
        SankeyChartComponent.prototype._setTooltipPosition = function (event) {
            var _a = this.nodeContainer.nativeElement.getBoundingClientRect(), left = _a.left, top = _a.top;
            var x = (event.pageX - left) - (window.scrollX || document.documentElement.scrollLeft);
            var y = (event.pageY - top) - (window.scrollY || document.documentElement.scrollTop);
            this._tooltipPosition = { x: x, y: y };
            this._changeDetector.detectChanges();
        };
        /**
         * Correctly track the node changes in `*ngFor` based on
         * the unique node ids to prevent unnecessary re-rendering
         */
        SankeyChartComponent.prototype._trackNodeBy = function (_index, nodeLink) {
            return nodeLink.node.id;
        };
        /**
         * Correctly track the link changes in `*ngFor` based on
         * the source and target to prevent unnecessary re-rendering
         */
        SankeyChartComponent.prototype._trackLinkBy = function (_index, link) {
            return link.source + "-" + link.target;
        };
        /**
         * Get the color of node based on whether or not
         * the `color` input has been provided.
         */
        SankeyChartComponent.prototype._getColor = function (item) {
            // if we are not node hovering or focusing or no custom color is defined then return nothing
            if (!item.active && !item.focus || !this.color) {
                return;
            }
            // return an rgba value if it is a `ThemeColor` to support transparency
            return this.color instanceof ThemeColor ? this.color.toRgba() : this._colorService.resolve(this.color);
        };
        /**
         * We want the focus indicator color to match the active color,
         * which if programmatically defined need to be overriden
         */
        SankeyChartComponent.prototype._getFocusIndicator = function (nodeLink) {
            // if the node is not focused or there is no custom color
            // then return null in which case CSS indicator will show
            if (!nodeLink.focus || !this.color) {
                return '';
            }
            // otherwise return the shadow based on the color provided.
            var color = this.color instanceof ThemeColor ? this.color : ThemeColor.parse(this._colorService.resolve(this.color));
            // generate a box shadow based on the specified color
            return "0 0 0 1px #fff, 0 0 0 3px " + color.setAlpha(0.5).toRgba();
        };
        /**
         * Get columns mapped with their title if they have any
         */
        SankeyChartComponent.prototype.getColumns = function () {
            var _this = this;
            return this._sankey.columns().map(function (width, index) { return ({ width: width, title: _this.columns[index] || '', position: _this.getColumnPosition(index) }); });
        };
        /**
         * Get the start position of a column which can be determined
         * by finding a node that is in that column and using its
         * x position as all nodes start at the same position within a column.
         */
        SankeyChartComponent.prototype.getColumnPosition = function (column) {
            // find a node in this column and take its x position
            var node = this._nodes.find(function (_node) { return _node.column === column; });
            return node ? node.x : 0;
        };
        /**
         * Get the default content of a link tooltip
         */
        SankeyChartComponent.prototype.getLinkTooltip = function (link) {
            return link.value.toLocaleString('en') + ' items';
        };
        /**
         * Get the default content of a falloff tooltip
         */
        SankeyChartComponent.prototype.getFalloffTooltip = function (falloff) {
            return falloff.toLocaleString('en') + ' items';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], SankeyChartComponent.prototype, "nodes", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], SankeyChartComponent.prototype, "links", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], SankeyChartComponent.prototype, "columns", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SankeyChartComponent.prototype, "minWidth", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SankeyChartComponent.prototype, "maxWidth", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SankeyChartComponent.prototype, "minHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], SankeyChartComponent.prototype, "linkTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], SankeyChartComponent.prototype, "falloffTooltip", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SankeyChartComponent.prototype, "color", void 0);
        __decorate([
            core.ContentChild('sankeyNodeTemplate', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], SankeyChartComponent.prototype, "nodeTemplate", void 0);
        __decorate([
            core.ViewChild('linkContainer', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], SankeyChartComponent.prototype, "linkContainer", void 0);
        __decorate([
            core.ViewChild('nodeContainer', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], SankeyChartComponent.prototype, "nodeContainer", void 0);
        SankeyChartComponent = __decorate([
            core.Component({
                selector: 'ux-sankey-chart',
                template: "<div class=\"ux-sankey-chart-columns\" *ngIf=\"columns && columns.length > 0\">\n    <div *ngFor=\"let column of _columns\"\n         class=\"ux-sankey-chart-column\"\n         [style.width.px]=\"column.width\">\n\n        <p class=\"ux-sankey-chart-column-title\"\n            [style.left.px]=\"column.position\">\n            {{ column.title }}\n        </p>\n    </div>\n</div>\n\n<svg #linkContainer\n     [attr.width]=\"_width\"\n     [attr.height]=\"_height\"\n     class=\"ux-sankey-chart-links\"\n     [style.top.px]=\"!columns || columns.length === 0 ? 8 : null\">\n\n    <defs>\n        <linearGradient id=\"falloff-gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n            <stop class=\"ux-sankey-chart-falloff-gradient-start\" offset=\"25%\"></stop>\n            <stop class=\"ux-sankey-chart-falloff-gradient-end\" offset=\"100%\"></stop>\n        </linearGradient>\n    </defs>\n    <g>\n        <ng-container *ngFor=\"let node of _nodes; trackBy: _trackNodeBy\">\n            <path *ngFor=\"let link of node.outputs; trackBy: _trackLinkBy\"\n                    [attr.class]=\"_getLinkClass(link)\"\n                    [attr.d]=\"_getPath(link)\"\n                    [style.fill]=\"_getColor(link)\"\n                    (mouseenter)=\"_setLinkActive(link, true)\"\n                    (mouseleave)=\"_setLinkActive(link, false)\"\n                    (mousemove)=\"_setTooltipPosition($event)\">\n            </path>\n            <path *ngIf=\"node.falloff && _showFalloff(node)\"\n                    class=\"ux-sankey-chart-falloff-indicator\"\n                    [attr.d]=\"_getFalloffPath(node)\"\n                    (mouseenter)=\"_setFalloffTooltip(node, true)\"\n                    (mouseleave)=\"_setFalloffTooltip(node, false)\"\n                    (mousemove)=\"_setTooltipPosition($event)\">\n            </path>\n        </ng-container>\n    </g>\n</svg>\n\n<div #nodeContainer\n     class=\"ux-sankey-chart-nodes\"\n     (uxResize)=\"_onResize($event)\"\n     [style.top.px]=\"!columns || columns.length === 0 ? 8 : null\">\n\n    <div *ngFor=\"let node of _nodes; trackBy: _trackNodeBy\"\n        #nodeElement\n        [uxSankeyNode]=\"node\"\n        uxFocusIndicator\n        class=\"ux-sankey-chart-node\"\n        [class.ux-sankey-chart-node-active]=\"node.active || node.focus\"\n        [style.left.px]=\"node.x\"\n        [style.top.px]=\"node.y\"\n        [style.width.px]=\"node.width\"\n        [style.height.px]=\"node.height\"\n        [style.background-color]=\"_getColor(node)\"\n        (mouseenter)=\"_setNodeActive(node, true)\"\n        (mouseleave)=\"_setNodeActive(node, false)\"\n        (indicator)=\"_setNodeFocus(node, $event, nodeElement)\">\n\n        <ng-container\n            [ngTemplateOutlet]=\"nodeTemplate\"\n            [ngTemplateOutletContext]=\"{ node: node.node, active: node.active, focus: node.focus }\">\n        </ng-container>\n    </div>\n\n    <ux-tooltip *ngIf=\"_isTooltipOpen\"\n                class=\"ux-sankey-tooltip\"\n                placement=\"top\"\n                [content]=\"_tooltipContent\"\n                alignment=\"center\"\n                [style.left.px]=\"_tooltipPosition.x\"\n                [style.top.px]=\"_tooltipPosition.y\"\n                [@tooltipAnimation]>\n    </ux-tooltip>\n\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                viewProviders: [SankeyFocusManager],
                animations: [
                    animations.trigger('tooltipAnimation', [
                        animations.transition(':enter', [
                            animations.style({ opacity: 0 }),
                            animations.animate(160, animations.style({ opacity: 1 }))
                        ]),
                        animations.transition(':leave', [
                            animations.animate(160, animations.style({ opacity: 0 }))
                        ])
                    ])
                ]
            }),
            __metadata("design:paramtypes", [SankeyFocusManager,
                core.ChangeDetectorRef,
                ColorService])
        ], SankeyChartComponent);
        return SankeyChartComponent;
    }());
    var SankeyChartModule = /** @class */ (function () {
        function SankeyChartModule() {
        }
        SankeyChartModule = __decorate([
            core.NgModule({
                declarations: [
                    SankeyChartComponent,
                    SankeyNodeDirective
                ],
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    ResizeModule,
                    TooltipModule,
                    ColorServiceModule
                ],
                exports: [
                    SankeyChartComponent
                ]
            })
        ], SankeyChartModule);
        return SankeyChartModule;
    }());
    var UNSET_FOCUS = { groupId: null, index: -1 };
    var SearchBuilderFocusService = /** @class */ (function () {
        function SearchBuilderFocusService() {
            this.focus$ = new rxjs.BehaviorSubject(UNSET_FOCUS);
        }
        /**
         * Set focus on a search builder component.
         * @param groupId The `id` of the group containing the component.
         * @param index The (zero-based) index of the component.
         */
        SearchBuilderFocusService.prototype.setFocus = function (groupId, index) {
            this.focus$.next({ groupId: groupId, index: index });
        };
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         */
        SearchBuilderFocusService.prototype.clearFocus = function () {
            this.focus$.next(UNSET_FOCUS);
        };
        SearchBuilderFocusService = __decorate([
            core.Injectable()
        ], SearchBuilderFocusService);
        return SearchBuilderFocusService;
    }());
    var SearchBuilderService = /** @class */ (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new rxjs.Subject();
            this.validationChange = new rxjs.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        SearchBuilderService.prototype.registerComponent = function (component) {
            // ensure there are no components with a matching name
            if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
            }
            // if unique then add the component to the list
            this._components.push(component);
        };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        SearchBuilderService.prototype.registerComponents = function (components) {
            var _this = this;
            components.forEach(function (component) { return _this.registerComponent(component); });
        };
        /**
         * Get a registered component class
         */
        SearchBuilderService.prototype.getComponent = function (name) {
            // find the component
            var component = this._components.find(function (cmp) { return cmp.name === name; });
            // if there is no match throw an exception
            if (!component) {
                throw new Error("No search build component with the name " + name + " exists");
            }
            // ensure config is defined - at least to an empty object
            component.config = component.config || {};
            return component;
        };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        SearchBuilderService.prototype.setQuery = function (query) {
            this.query = Object.assign({}, query);
        };
        /**
         * Return the current query state
         */
        SearchBuilderService.prototype.getQuery = function () {
            return this.query;
        };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        SearchBuilderService.prototype.queryHasChanged = function () {
            this.queryChange.next(this.query);
        };
        /**
         * Store the validation state of the query
         */
        SearchBuilderService.prototype.setValid = function (id, valid) {
            var _this = this;
            // store the state for this specific component
            this._validation[id] = valid;
            // evaluate the entire validation state
            this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
        };
        /**
         * Generate a unique id for each component
         */
        SearchBuilderService.prototype.generateComponentId = function () {
            return this._componentId++;
        };
        SearchBuilderService = __decorate([
            core.Injectable()
        ], SearchBuilderService);
        return SearchBuilderService;
    }());
    var SearchBuilderGroupService = /** @class */ (function () {
        function SearchBuilderGroupService(_searchBuilderService, _searchBuilderFocusService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
        }
        /**
         * Initialise the group by defining an id
         */
        SearchBuilderGroupService.prototype.init = function (id) {
            var _this = this;
            // store the name of the group
            this._id = id;
            // create the entry in the query object if it doesn't exist
            if (!this._searchBuilderService.query[this._id]) {
                // create the section
                this._searchBuilderService.query[this._id] = [];
                // emit the changes after the initial setup
                setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
            }
        };
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         */
        SearchBuilderGroupService.prototype.removeAtIndex = function (index) {
            // get the query for this group
            var query = this.getQuery();
            // remove the field from the array
            query.splice(index, 1);
            // Focus the previous item if available
            this._searchBuilderFocusService.setFocus(this._id, index <= 0 ? 0 : index - 1);
        };
        /**
         * Get the query for this specific search group
         */
        SearchBuilderGroupService.prototype.getQuery = function () {
            return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
        };
        SearchBuilderGroupService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [SearchBuilderService,
                SearchBuilderFocusService])
        ], SearchBuilderGroupService);
        return SearchBuilderGroupService;
    }());
    var SearchBuilderGroupComponent = /** @class */ (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderFocusService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new core.EventEmitter();
            this.remove = new core.EventEmitter();
            this.focusIndex = -1;
            this._onDestroy = new rxjs.Subject();
        }
        SearchBuilderGroupComponent.prototype.ngOnInit = function () {
            var _this = this;
            // ensure we have a name otherwise throw an error
            if (!this.id) {
                throw new Error('Search builder group must have an id attribute.');
            }
            // otherwise register the group
            this.searchBuilderGroupService.init(this.id);
            // Track focus for child components
            this._searchBuilderFocusService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focus) {
                _this.focusIndex = (focus.groupId === _this.id) ? focus.index : -1;
            });
        };
        SearchBuilderGroupComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        SearchBuilderGroupComponent.prototype.addField = function (event) {
            this.add.emit(event);
        };
        SearchBuilderGroupComponent.prototype.removeFieldAtIndex = function (index, field) {
            this.searchBuilderGroupService.removeAtIndex(index);
            this.remove.emit(field);
        };
        SearchBuilderGroupComponent.prototype.setFocus = function (index) {
            this._searchBuilderFocusService.setFocus(this.id, index);
        };
        SearchBuilderGroupComponent.prototype.clearFocus = function () {
            this._searchBuilderFocusService.clearFocus();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SearchBuilderGroupComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SearchBuilderGroupComponent.prototype, "header", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SearchBuilderGroupComponent.prototype, "operator", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SearchBuilderGroupComponent.prototype, "addText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], SearchBuilderGroupComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SearchBuilderGroupComponent.prototype, "showPlaceholder", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], SearchBuilderGroupComponent.prototype, "add", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], SearchBuilderGroupComponent.prototype, "remove", void 0);
        SearchBuilderGroupComponent = __decorate([
            core.Component({
                selector: 'ux-search-builder-group',
                template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<div class=\"search-group-content\">\n\n  <div class=\"search-group-operator search-group-operator-{{ operator }}\"\n    [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</div>\n\n  <div class=\"search-group-items\">\n\n    <div *ngFor=\"let field of searchBuilderGroupService.getQuery(); let i = index\"\n      class=\"search-group-item-container\"\n      [class.search-group-item-focus]=\"focusIndex === i\"\n      (uxFocusWithin)=\"setFocus(i)\"\n      (uxBlurWithin)=\"clearFocus()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field; groupId: id; index: i\"></ng-container>\n      </div>\n\n      <button type=\"button\"\n        uxFocusIndicator\n        aria-label=\"Remove field\"\n        class=\"search-group-item-remove\"\n        (click)=\"removeFieldAtIndex(i, field)\">\n\n        <ux-icon name=\"close\"></ux-icon>\n\n      </button>\n\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n\n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n\n      </div>\n\n      <!-- Allow a custom placeholder -->\n      <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </div>\n\n  <button type=\"button\" uxFocusIndicator class=\"search-builder-group-add-field\" (click)=\"addField($event)\">\n        <ux-icon class=\"search-builder-group-add-field-icon\" name=\"add\"></ux-icon>\n        <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n  </button>\n\n</div>\n\n<hr class=\"search-builder-group-divider\">\n",
                providers: [SearchBuilderGroupService]
            }),
            __metadata("design:paramtypes", [SearchBuilderGroupService,
                SearchBuilderFocusService])
        ], SearchBuilderGroupComponent);
        return SearchBuilderGroupComponent;
    }());
    var SearchBuilderOutletDirective = /** @class */ (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService, _searchBuilderFocusService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this._onDestroy = new rxjs.Subject();
        }
        SearchBuilderOutletDirective.prototype.ngOnInit = function () {
            var _this = this;
            // get the class from the type
            var componentDefinition = this._searchBuilderService.getComponent(this.outlet);
            // create the component factory
            var componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
            // create the component instance
            this._componentRef = this._viewContainerRef.createComponent(componentFactory);
            // combine the predefined config with any dynmaic config
            var config = Object.assign({}, componentDefinition.config, this.context.config || {});
            // set the context and config property on the component instance
            this._componentRef.instance.context = this.context;
            this._componentRef.instance.config = config;
            this._searchBuilderFocusService.focus$
                .pipe(operators.distinctUntilChanged(), operators.delay(0), operators.takeUntil(this._onDestroy))
                .subscribe(function (focus) {
                _this._componentRef.instance.focus = (focus.groupId === _this.groupId && focus.index === _this.index);
            });
        };
        SearchBuilderOutletDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input('uxSearchBuilderOutlet'),
            __metadata("design:type", String)
        ], SearchBuilderOutletDirective.prototype, "outlet", void 0);
        __decorate([
            core.Input('uxSearchBuilderOutletContext'),
            __metadata("design:type", Object)
        ], SearchBuilderOutletDirective.prototype, "context", void 0);
        __decorate([
            core.Input('uxSearchBuilderOutletGroupId'),
            __metadata("design:type", String)
        ], SearchBuilderOutletDirective.prototype, "groupId", void 0);
        __decorate([
            core.Input('uxSearchBuilderOutletIndex'),
            __metadata("design:type", Number)
        ], SearchBuilderOutletDirective.prototype, "index", void 0);
        SearchBuilderOutletDirective = __decorate([
            core.Directive({
                selector: '[uxSearchBuilderOutlet]'
            }),
            __metadata("design:paramtypes", [core.ViewContainerRef,
                core.ComponentFactoryResolver,
                SearchBuilderService,
                SearchBuilderFocusService])
        ], SearchBuilderOutletDirective);
        return SearchBuilderOutletDirective;
    }());
    var SearchBuilderComponent = /** @class */ (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new core.EventEmitter();
            this.valid = new core.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: function () {
                return this._searchBuilderService.getQuery();
            },
            set: function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        SearchBuilderComponent.prototype.ngOnDestroy = function () {
            this._querySubscription.unsubscribe();
            this._validSubscription.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], SearchBuilderComponent.prototype, "components", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SearchBuilderComponent.prototype, "query", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], SearchBuilderComponent.prototype, "queryChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], SearchBuilderComponent.prototype, "valid", void 0);
        SearchBuilderComponent = __decorate([
            core.Component({
                selector: 'ux-search-builder',
                template: "<ng-content></ng-content>",
                providers: [SearchBuilderService]
            }),
            __metadata("design:paramtypes", [SearchBuilderService])
        ], SearchBuilderComponent);
        return SearchBuilderComponent;
    }());
    var TagInputEvent = /** @class */ (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        TagInputEvent.prototype.preventDefault = function () {
            this._defaultPrevented = true;
        };
        TagInputEvent.prototype.defaultPrevented = function () {
            return this._defaultPrevented;
        };
        return TagInputEvent;
    }());
    var uniqueId$8 = 0;
    var TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TagInputComponent = /** @class */ (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            /** Specify a unique Id for the component */
            this.id = "ux-tag-input-" + ++uniqueId$8;
            /** The editable text appearing in the tag input. */
            this.input = '';
            /** Controls whether pasting text into the text input area automatically converts that text into one or more tags. */
            this.addOnPaste = true;
            /** Controls the disabled state of the tag input. */
            this.disabled = false;
            /**
             * If set to `true`, the tag input will prevent addition and removal of tags to enforce the minTags and maxTags settings.
             * Otherwise, a validation error will be raised.
             */
            this.enforceTagLimits = false;
            /**
             * If `true`, input entered into the text input area can be converted into a tag by pressing enter.
             * Otherwise, tags can only be added from the typeahead list or other external means.
             * (Note that the `maxTags` and `tagPattern` will prevent invalid inputs regardless of this setting.)
             */
            this.freeInput = true;
            /** If `true` the input field will be readonly and selection can only occur by using the dropdown. */
            this.readonlyInput = false;
            /**
             * The maximum number of tags permitted in the tag input. If the number of tags is equal to `maxTags` and
             * `enforceTagLimits` is `true`, addition of tags will be prevented until a tag is removed
             */
            this.maxTags = Number.MAX_VALUE;
            /**
             * The minimum number of tags permitted in the tag input. If the number of tags is equal to `minTags` and `enforceTagLimits` is
             * `true`, removal of tags will be prevented until a new tag is added.
             */
            this.minTags = 0;
            /** The placeholder text which appears in the text input area when it is empty. */
            this.placeholder = '';
            /** Controls whether the typeahead appears when the text input area is clicked. This has no effect if the ux-typeahead component is not configured. */
            this.showTypeaheadOnClick = false;
            /**
             * A string containing the characters which delimit tags.
             * Typing one of the characters in `tagDelimiters` will cause the preceding text to be added as a tag,
             * and the text input area will be cleared. Pasting a string containing one or more of characters in
             * `tagDelimiters` will cause the string to be split into multiple tags.
             * Note that the delimiter character will not be part of the tag text.
             */
            this.tagDelimiters = '';
            /**
             * A function which returns either a string, string[], or Set<string>, compatible with the NgClass directive. The function receives the following parameters:
             * - `tag: any` - the string or custom object representing the tag.
             * - `index: number` - the zero-based index of the tag as it appears in the tag input.
             * - `selected: boolean` - true if the tag is currently selected.
             */
            this.tagClass = function () { return undefined; };
            /**
             * An object which contains details of validation errors. The following properties will be present if there is a related validation error:
             * - `tagRangeError` - present if the number of tags is outside the range specified by minTags and maxTags.
             * - `inputPattern` - present if an input has been submitted which does not match the tagPattern.
             */
            this.validationErrors = {};
            /** Defines the autocomplete property on the input field which can be used to prevent the browser from displaying autocomplete suggestions. */
            this.autocomplete = 'off';
            /** Determine if we should show the clear all button */
            this.clearButton = false;
            /** Determine an aria label for the clear button */
            this.clearButtonAriaLabel = 'Reset selection';
            /** Emits when tags is changed. */
            this.tagsChange = new core.EventEmitter();
            /** Emits when input is changed. */
            this.inputChange = new core.EventEmitter();
            /** Raised when a tag is about to be added. The `tag` property of the event contains the tag to be added. Call `preventDefault()` on the event to prevent addition. */
            this.tagAdding = new core.EventEmitter();
            /** Raised when a tag has been added. The tag property of the event contains the tag. */
            this.tagAdded = new core.EventEmitter();
            /** Raised when a tag has failed validation according to the `tagPattern`. The tag property of the event contains the string which failed validation. */
            this.tagInvalidated = new core.EventEmitter();
            /** Raised when a tag is about to be removed. The `tag` property of the event contains the tag to be removed. Call `preventDefault()` on the event to prevent removal. */
            this.tagRemoving = new core.EventEmitter();
            /** Raised when a tag has been removed. The tag property of the event contains the tag. */
            this.tagRemoved = new core.EventEmitter();
            /** Raised when a tag has been clicked. The `tag` property of the event contains the clicked tag. Call `preventDefault()` on the event to prevent the default behaviour of selecting the tag. */
            this.tagClick = new core.EventEmitter();
            // When clicking on the input during mutliple mode it will send a on touched event to the parent component
            this.inputFocus = new core.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            /**
             * The list of tags appearing in the tag input. This can be an array of strings or custom objects.
             * See the `displayProperty` property for details of using a custom object.
             */
            get: function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: function (value) {
                this._tags = Array.isArray(value) ? value : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "_showClearButton", {
            get: function () {
                return this.clearButton && this.tags && this.tags.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        TagInputComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // Watch for optional child typeahead control
            this.connectTypeahead(this.typeaheadQuery.first);
            this.typeaheadQuery.changes.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (query) { return _this.connectTypeahead(query.first); });
        };
        TagInputComponent.prototype.ngOnChanges = function (changes) {
            if (changes.disabled) {
                if (changes.disabled.currentValue) {
                    // Clear selection and close dropdown
                    this.selectedIndex = -1;
                    if (this.typeahead) {
                        this.typeahead.open = false;
                    }
                }
            }
            // Update validation status
            this.validate();
        };
        TagInputComponent.prototype.ngOnDestroy = function () {
            if (this._subscription) {
                this._subscription.unsubscribe();
            }
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        TagInputComponent.prototype.writeValue = function (value) {
            if (value) {
                this.tags = value;
            }
        };
        TagInputComponent.prototype.registerOnChange = function (fn) {
            this._onChangeHandler = fn;
        };
        TagInputComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedHandler = fn;
        };
        TagInputComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * Set focus on the input field.
         */
        TagInputComponent.prototype.focus = function () {
            if (this.tagInput) {
                this.tagInput.nativeElement.focus();
            }
        };
        /**
         * Validate the value of the control (tags property).
         */
        TagInputComponent.prototype.validate = function () {
            this.valid = true;
            var tagRangeError = null;
            if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                tagRangeError = {
                    given: this.tags.length,
                    min: this.minTags,
                    max: this.maxTags
                };
                this.valid = false;
            }
            this.validationErrors['tagRangeError'] = tagRangeError;
            // forward any error to the form control
            return tagRangeError;
        };
        TagInputComponent.prototype.keyHandler = function (event) {
            if (this.disabled) {
                return;
            }
            // Get the input field cursor location
            var inputCursorPos = this.tagInput.nativeElement.selectionStart;
            // Determine if the input field has any text selected
            var hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
            // Determine if a tag has focus
            var tagSelected = this.isValidTagIndex(this.selectedIndex);
            var inputLength = this.input ? this.input.length : 0;
            // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
            var canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
            var canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
            // Forward key events to the typeahead component.
            this._typeaheadKeyService.handleKey(event, this.typeahead);
            switch (event.which) {
                case keycodes.ENTER:
                    // Check if a typeahead option is highlighted
                    if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                        // Add the typeahead option as a tag, clear the input, and close the dropdown
                        this.commitTypeahead(this.typeahead.highlighted);
                        this.typeahead.open = false;
                    }
                    else if (this.typeahead && !this.typeahead.open && !this.freeInput) {
                        this.typeahead.open = true;
                    }
                    else {
                        // Validate and add the input text as a tag, if possible
                        this.commitInput();
                    }
                    event.preventDefault();
                    break;
                case keycodes.BACKSPACE:
                    if (canNavigateLeft) {
                        this.backspace();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    break;
                case keycodes.DELETE:
                    if (tagSelected) {
                        this.removeTagAt(this.selectedIndex);
                    }
                    break;
                case keycodes.LEFT_ARROW:
                    if (canNavigateLeft) {
                        this.moveSelection(-1);
                        event.preventDefault();
                    }
                    break;
                case keycodes.RIGHT_ARROW:
                    if (canNavigateRight) {
                        this.moveSelection(1);
                        event.preventDefault();
                    }
                    break;
            }
            // Check for keys in the tagDelimiters
            if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                // Commit previous text
                this.commitInput();
                event.stopPropagation();
                event.preventDefault();
            }
        };
        TagInputComponent.prototype.focusOutHandler = function () {
            var _this = this;
            // If a click on the typeahead is in progress, don't do anything.
            // This works around an issue in IE where clicking a scrollbar drops focus.
            if (this.typeahead && this.typeahead.clicking) {
                return;
            }
            // Close the dropdown on blur
            setTimeout(function () {
                if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                    _this.selectedIndex = -1;
                    if (_this.typeahead) {
                        _this.typeahead.open = false;
                    }
                }
            }, 200);
        };
        TagInputComponent.prototype.onClick = function () {
            // Prevent error if you click input when at max tag limit
            if (this.tagInput === undefined) {
                return;
            }
            // focus the input element
            this.tagInput.nativeElement.focus();
            // show the typeahead if we need to
            this.inputClickHandler();
        };
        TagInputComponent.prototype.tagClickHandler = function (event, tag, index) {
            if (this.disabled) {
                return;
            }
            // Send tagClick event
            var tagClickEvent = new TagInputEvent(tag);
            this.tagClick.emit(tagClickEvent);
            // Prevent focus if preventDefault() was called
            if (tagClickEvent.defaultPrevented()) {
                event.preventDefault();
                return;
            }
            // Select the tag (for IE that doesn't propagate focus)
            this.selectTagAt(index);
        };
        TagInputComponent.prototype.inputClickHandler = function () {
            if (this.disabled) {
                return;
            }
            if (this.typeahead && this.showTypeaheadOnClick) {
                this.typeahead.open = true;
            }
        };
        TagInputComponent.prototype.inputFocusHandler = function () {
            if (this.disabled) {
                return;
            }
            this.selectInput();
            // mark form control as touched
            this._onTouchedHandler();
        };
        TagInputComponent.prototype.inputPasteHandler = function (event) {
            if (this.disabled) {
                return;
            }
            if (this.addOnPaste) {
                // Get text from the clipboard
                var input = null;
                if (event.clipboardData) {
                    input = event.clipboardData.getData('text/plain');
                }
                else if (window.clipboardData) {
                    // Internet Explorer only
                    input = window.clipboardData.getData('Text');
                }
                // Commit the clipboard text directly
                if (this.commit(input)) {
                    this.selectInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            }
        };
        TagInputComponent.prototype.typeaheadOptionSelectedHandler = function (event) {
            if (this.disabled) {
                return;
            }
            // When the typeahead sends the optionSelected event, commit the object directly
            this.commitTypeahead(event.option);
        };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        TagInputComponent.prototype.commitInput = function () {
            if (this.commit(this.input)) {
                this.selectInput();
                this.setInputValue('');
            }
        };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        TagInputComponent.prototype.commitTypeahead = function (tag) {
            if (this.addTag(tag)) {
                this.selectInput();
                this.setInputValue('');
            }
        };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        TagInputComponent.prototype.commit = function (input) {
            var e_1, _a, e_2, _b;
            if (input && this.freeInput) {
                // Split the tags by the tagDelimiters if configured
                var newTags = this.splitTagInput(input);
                // Check tag validation for all of the individual values
                var allValid = true;
                try {
                    for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                        var newTag = newTags_1_1.value;
                        var valid = this.validateTag(newTag);
                        if (!valid) {
                            allValid = false;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                            _a.call(newTags_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // Add the tags if all are valid
                if (allValid) {
                    try {
                        for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                            var newTag = newTags_2_1.value;
                            this.addTag(this.createTag(newTag));
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                _b.call(newTags_2);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        TagInputComponent.prototype.backspace = function () {
            if (this.disabled) {
                return;
            }
            if (!this.isValidTagIndex(this.selectedIndex)) {
                this.selectTagAt(this.tags.length - 1);
            }
            else {
                this.removeTagAt(this.selectedIndex);
            }
        };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        TagInputComponent.prototype.moveSelection = function (delta) {
            if (this.disabled) {
                return;
            }
            if (this.isValidSelectIndex(this.selectedIndex)) {
                this.selectedIndex += delta;
                // Do wrapping of selection when out of bounds
                if (this.selectedIndex < 0) {
                    this.selectedIndex = this.tags.length;
                }
                else if (this.selectedIndex > this.tags.length) {
                    this.selectedIndex = 0;
                }
            }
        };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        TagInputComponent.prototype.getTagDisplay = function (tag) {
            if (typeof this.display === 'function') {
                return this.display(tag);
            }
            if (typeof this.display === 'string') {
                return tag[this.display];
            }
            return tag;
        };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        TagInputComponent.prototype.isSelected = function (index) {
            return index === this.selectedIndex;
        };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        TagInputComponent.prototype.selectTagAt = function (tagIndex) {
            if (this.disabled) {
                return;
            }
            if (this.isValidTagIndex(tagIndex)) {
                this.selectedIndex = tagIndex;
            }
        };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        TagInputComponent.prototype.selectInput = function () {
            if (this.disabled) {
                return;
            }
            this.selectedIndex = this.tags.length;
        };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        TagInputComponent.prototype.removeTagAt = function (tagIndex) {
            if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                return;
            }
            // Check that the tagIndex is in range
            if (this.isValidTagIndex(tagIndex)) {
                var tag = this.tags[tagIndex];
                var tagRemovingEvent = new TagInputEvent(tag);
                this.tagRemoving.emit(tagRemovingEvent);
                if (!tagRemovingEvent.defaultPrevented()) {
                    // Select input first to avoid issues with dropping focus
                    this.selectInput();
                    // Remove the tag
                    this.tags = this.tags.filter(function (_tag, index) { return index !== tagIndex; });
                    this.setTagsValue(this._tags);
                    // Set focus again since indices have changed
                    this.selectInput();
                    this.tagRemoved.emit(new TagInputEvent(tag));
                    this.validate();
                }
            }
        };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        TagInputComponent.prototype.canRemoveTagAt = function (tagIndex) {
            return this.tags.length > this.minTags || !this.enforceTagLimits;
        };
        /**
         * Returns true if the input field should be available.
         */
        TagInputComponent.prototype.isInputVisible = function () {
            return this.tags.length < this.maxTags || !this.enforceTagLimits;
        };
        /**
         * Returns true if any part of the control has focus.
         */
        TagInputComponent.prototype.hasFocus = function () {
            return this.isValidSelectIndex(this.selectedIndex);
        };
        TagInputComponent.prototype.toggle = function () {
            this.typeahead && this.typeahead.open ? this.typeahead.open = false : this.inputClickHandler();
        };
        TagInputComponent.prototype.clear = function () {
            if (this.disabled) {
                return;
            }
            this.tags = [];
            this.setTagsValue(this._tags);
            this.setInputValue('');
            this.focus();
        };
        TagInputComponent.prototype.setInputValue = function (text) {
            this.input = text;
            this.inputChange.emit(text);
        };
        TagInputComponent.prototype.setTagsValue = function (tags) {
            this._onChangeHandler(tags);
            this.tagsChange.emit(tags);
        };
        TagInputComponent.prototype.connectTypeahead = function (typeahead) {
            var _this = this;
            if (this._subscription) {
                this._subscription.unsubscribe();
                this._subscription = null;
            }
            this.typeahead = typeahead;
            if (this.typeahead) {
                // Set up event handler for selected options
                this._subscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                // Set up event handler for the highlighted element
                // Added a delay to move it out of the current change detection cycle
                this._subscription.add(this.typeahead.highlightedElementChange.pipe(tick())
                    .subscribe(function (element) { return _this.highlightedElement = element; }));
            }
        };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         */
        TagInputComponent.prototype.validateTag = function (tagValue) {
            var inputPattern = null;
            this.inputValid = true;
            if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                inputPattern = {
                    given: tagValue,
                    pattern: this.tagPattern
                };
                this.inputValid = false;
            }
            this.validationErrors['inputPattern'] = inputPattern;
            return this.inputValid;
        };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         */
        TagInputComponent.prototype.createTag = function (tagValue) {
            var tag = null;
            if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                tag = this.createTagHandler(tagValue);
            }
            else if (typeof this.display === 'string') {
                tag = {};
                tag[this.display] = tagValue;
            }
            else {
                tag = tagValue;
            }
            return tag;
        };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         */
        TagInputComponent.prototype.addTag = function (tag) {
            if (tag) {
                // Verify that the new tag can be displayed
                var displayValue = this.getTagDisplay(tag);
                if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                    var tagAddingEvent = new TagInputEvent(tag);
                    this.tagAdding.emit(tagAddingEvent);
                    if (!tagAddingEvent.defaultPrevented()) {
                        this.tags = __spread(this.tags, [tag]);
                        this.setTagsValue(this._tags);
                        this.tagAdded.emit(new TagInputEvent(tag));
                        this.validate();
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         */
        TagInputComponent.prototype.isValidTagIndex = function (tagIndex) {
            return tagIndex >= 0 && tagIndex < this.tags.length;
        };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         */
        TagInputComponent.prototype.isValidSelectIndex = function (index) {
            return index >= 0 && index <= this.tags.length;
        };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         */
        TagInputComponent.prototype.getKeyChar = function (event) {
            switch (event.which) {
                case keycodes.SPACE:
                    return ' ';
            }
            return event.key;
        };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         */
        TagInputComponent.prototype.splitTagInput = function (input) {
            var tagValues = [input];
            if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                var escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                var delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
            }
            return tagValues;
        };
        __decorate([
            core.Input(), core.HostBinding('attr.id'),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], TagInputComponent.prototype, "tags", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "input", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], TagInputComponent.prototype, "display", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "addOnPaste", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "enforceTagLimits", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "freeInput", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "readonlyInput", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TagInputComponent.prototype, "maxTags", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TagInputComponent.prototype, "minTags", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "showTypeaheadOnClick", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "tagDelimiters", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", RegExp)
        ], TagInputComponent.prototype, "tagPattern", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TagInputComponent.prototype, "tagTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], TagInputComponent.prototype, "tagClass", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "validationErrors", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "autocomplete", void 0);
        __decorate([
            core.Input('createTag'),
            __metadata("design:type", Function)
        ], TagInputComponent.prototype, "createTagHandler", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], TagInputComponent.prototype, "icon", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TagInputComponent.prototype, "clearButton", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TagInputComponent.prototype, "clearButtonAriaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagsChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "inputChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagAdding", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagAdded", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagInvalidated", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagRemoving", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagRemoved", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "tagClick", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TagInputComponent.prototype, "inputFocus", void 0);
        __decorate([
            core.ContentChildren(TypeaheadComponent),
            __metadata("design:type", core.QueryList)
        ], TagInputComponent.prototype, "typeaheadQuery", void 0);
        __decorate([
            core.ViewChild('tagInput', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], TagInputComponent.prototype, "tagInput", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], TagInputComponent.prototype, "keyHandler", null);
        __decorate([
            core.HostListener('focusout'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TagInputComponent.prototype, "focusOutHandler", null);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TagInputComponent.prototype, "onClick", null);
        TagInputComponent = __decorate([
            core.Component({
                selector: 'ux-tag-input',
                exportAs: 'ux-tag-input',
                template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\"\n    [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\"\n    [class.ux-tag-input-clear-inset]=\"_showClearButton\"\n    [class.ux-tag-input-icon-inset]=\"icon\"\n    (click)=\"toggle()\">\n\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i); $event.stopPropagation()\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate || defaultTagTemplate\"\n                      [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n               [ngModel]=\"input\"\n               (ngModelChange)=\"setInputValue($event)\"\n               [autocomplete]=\"autocomplete\"\n               [class.invalid]=\"!inputValid\"\n               [attr.aria-activedescendant]=\"highlightedElement?.id\"\n               [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n               [attr.aria-controls]=\"typeahead?.id\"\n               [attr.aria-label]=\"ariaLabel\"\n               aria-multiline=\"false\"\n               [placeholder]=\"disabled ? '' : (placeholder || '')\"\n               [disabled]=\"disabled\"\n               [focusIf]=\"isSelected(tags.length)\"\n               (click)=\"toggle(); $event.stopPropagation()\"\n               (focus)=\"inputFocusHandler(); inputFocus.emit($event)\"\n               (paste)=\"inputPasteHandler($event)\"\n               [readonly]=\"readonlyInput\">\n    </li>\n</ol>\n\n<!-- Insert the custom icon if provided -->\n<div class=\"ux-tag-icons\" *ngIf=\"icon || _showClearButton\" (click)=\"toggle(); $event.stopPropagation()\">\n\n    <!-- Clear All Button -->\n    <i uxFocusIndicator\n       class=\"ux-tag-icon ux-icon ux-icon-close ux-select-clear-icon\"\n       [attr.tabindex]=\"disabled ? -1 : 0\"\n       [attr.aria-label]=\"clearButtonAriaLabel\"\n       *ngIf=\"_showClearButton\"\n       (click)=\"clear(); $event.stopPropagation()\"\n       (keydown.enter)=\"clear(); $event.stopPropagation()\">\n    </i>\n\n    <!-- Custom Icon -->\n    <div *ngIf=\"icon\" class=\"ux-custom-icon\">\n        <ng-container [ngTemplateOutlet]=\"icon\"></ng-container>\n    </div>\n</div>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{ api.getTagDisplay(tag) }}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n            uxFocusIndicator\n            type=\"button\"\n            class=\"ux-tag-remove\"\n            aria-label=\"Remove Item\"\n            [disabled]=\"disabled\"\n            (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <ux-icon name=\"close\"></ux-icon>\n    </button>\n</ng-template>",
                providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                host: {
                    '[class.disabled]': 'disabled',
                    '[class.focus]': 'hasFocus()',
                    '[class.invalid]': '!valid || !inputValid'
                }
            }),
            __param(1, core.Inject(common.DOCUMENT)),
            __metadata("design:paramtypes", [core.ElementRef, Object, TypeaheadKeyService])
        ], TagInputComponent);
        return TagInputComponent;
    }());
    var TagInputModule = /** @class */ (function () {
        function TagInputModule() {
        }
        TagInputModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    FocusIfModule,
                    IconModule,
                    TypeaheadModule
                ],
                exports: [
                    TagInputComponent
                ],
                declarations: [
                    TagInputComponent
                ]
            })
        ], TagInputModule);
        return TagInputModule;
    }());
    var uniqueId$9 = 0;
    var SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    var SelectComponent = /** @class */ (function () {
        function SelectComponent(_element, _platform, _document, _typeaheadKeyService) {
            this._element = _element;
            this._platform = _platform;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            /** A unique id for the component. */
            this.id = "ux-select-" + ++uniqueId$9;
            /**
             * Controls whether the value of the single select control can be cleared by deleting the selected value in the
             * input field. This does not affect the initial state of the control, so specify a value for `value` if null should
             * never be allowed.
             */
            this.allowNull = false;
            /** Controls the disabled state of the tag input. */
            this.disabled = false;
            /** The positioning of the typeahead dropdown in relation to its parent. */
            this.dropDirection = 'down';
            /** The maximum height of the typeahead dropdown, as a CSS value. */
            this.maxHeight = '250px';
            /**
             * Controls whether the user can select more than one option in the select control. If set to true, selected
             * options will appear as tags in the input area. If set to false, the selected value will appear as editable text
             * in the input area.
             */
            this.multiple = false;
            /**
             * The number of options to request in a page. This should ideally be more than twice the number of items which
             * fit into the height of the dropdown, but this is not required.
             */
            this.pageSize = 20;
            /** The placeholder text which appears in the text input area when it is empty. */
            this.placeholder = '';
            /**
             * Defines the `autocomplete` property on the `input` element which can be used to prevent the browser from
             * displaying autocomplete suggestions.
             */
            this.autocomplete = 'off';
            /** If `true` the input field will be readonly and selection can only occur by using the dropdown. */
            this.readonlyInput = false;
            /** Determine if we should show the clear all button */
            this.clearButton = false;
            /** Determine an aria label for the clear button */
            this.clearButtonAriaLabel = 'Reset selection';
            /** Emits when `value` changes. */
            this.valueChange = new core.EventEmitter();
            /** Emits when `input` changes. */
            this.inputChange = new core.EventEmitter();
            /** Emits when `dropdownOpen` changes. */
            this.dropdownOpenChange = new core.EventEmitter();
            /** Emits when recently selected options change. */
            this.recentOptionsChange = new core.EventEmitter();
            this._value$ = new rxjs.ReplaySubject(1);
            this._hasValue = false;
            this._input$ = new rxjs.BehaviorSubject('');
            this._dropdownOpen = false;
            this._userInput = false;
            this._onChange = function (_) { };
            this._onTouched = function () { };
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: function () {
                return this._value;
            },
            /** The selected option (for single select) or array of options (for multiple select). */
            set: function (value) {
                this._value$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: function () {
                return this._input$.value;
            },
            /** The text in the input area. This is used to filter the options dropdown. */
            set: function (value) {
                this._input$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: function () {
                return this._dropdownOpen;
            },
            /** The status of the typeahead dropdown. */
            set: function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        SelectComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Emit change events
            this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                _this._value = value;
                _this._hasValue = !!value;
            });
            // Changes to the input field
            this._input$.pipe(operators.skip(1), operators.filter(function () { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); }), operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.value = null;
                _this.valueChange.next(null),
                    _this._onChange(null);
            });
            // Set up filter from input
            this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
            // open the dropdown once the filter debounce has elapsed
            this.filter$.pipe(operators.filter(function () { return _this._userInput; }), operators.take(1), operators.takeUntil(this._onDestroy))
                .subscribe(function () {
                _this.dropdownOpen = true;
                _this._userInput = false;
            });
            // Update the single-select input when the model changes
            this._value$.pipe(operators.distinctUntilChanged(), operators.delay(0), operators.filter(function (value) { return value !== null && !_this.multiple; }), operators.takeUntil(this._onDestroy)).subscribe(function (value) {
                var inputValue = _this.getDisplay(value);
                // check if the input value has changed and if so the emit
                if (inputValue !== _this.input) {
                    _this.input = inputValue;
                    _this.inputChange.emit(_this.input);
                }
            });
        };
        SelectComponent.prototype.ngOnChanges = function (changes) {
            if (changes.multiple && !changes.multiple.firstChange && changes.multiple.currentValue !== changes.multiple.previousValue) {
                this.input = '';
            }
        };
        SelectComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        SelectComponent.prototype.writeValue = function (obj) {
            if (obj !== undefined && obj !== this.value) {
                this.value = obj;
            }
        };
        SelectComponent.prototype.registerOnChange = function (fn) {
            this._onChange = fn;
        };
        SelectComponent.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        SelectComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        SelectComponent.prototype.inputClickHandler = function () {
            this.selectInputText();
            this.dropdownOpen = true;
        };
        SelectComponent.prototype.inputBlurHandler = function () {
            var _this = this;
            // If a click on the typeahead is in progress, just refocus the input.
            // This works around an issue in IE where clicking a scrollbar drops focus.
            if (this.singleTypeahead && this.singleTypeahead.clicking) {
                this.singleInput.nativeElement.focus();
                return;
            }
            // Close dropdown and reset text input if focus is lost
            setTimeout(function () {
                if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                    _this.dropdownOpen = false;
                    if (!_this.multiple) {
                        _this.input = _this.getDisplay(_this.value);
                    }
                }
            }, 200);
        };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        SelectComponent.prototype.inputKeyHandler = function (event) {
            // Standard keys for typeahead (up/down/esc)
            this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
            if (event.keyCode === keycodes.ENTER) {
                if (this._dropdownOpen) {
                    // Set the highlighted option as the value and close
                    this.singleTypeahead.selectHighlighted();
                }
                else {
                    this.dropdownOpen = true;
                }
                // Update the input field. If dropdown isn't open then reset it to the previous value.
                this.input = this.getDisplay(this.value);
                event.preventDefault();
            }
            // when the user types and the value is not empty then we should open the dropdown except for non printable keys.
            if (event.key.length === 1) {
                this._userInput = true;
                this._dropdownOpen = true;
            }
        };
        /** This gets called whenever the user types in the input */
        SelectComponent.prototype.onInputChange = function (input) {
            this.inputChange.emit(input);
        };
        /** Whenever a single select item is selected emit the values */
        SelectComponent.prototype._singleOptionSelected = function (event) {
            if (event.option && event.option !== this.value) {
                this.value = event.option;
                this.dropdownOpen = false;
                this.valueChange.emit(this.value);
                this._onChange(this.value);
            }
        };
        /** Whenever a multi-select item is selected emit the values */
        SelectComponent.prototype._multipleOptionSelected = function (selection) {
            // update the internal selection
            this._value$.next(selection);
            this.valueChange.emit(this.value);
            this._onChange(this.value);
        };
        /**
         * Returns the display value of the given option.
         */
        SelectComponent.prototype.getDisplay = function (option) {
            if (option === null || option === undefined) {
                return '';
            }
            if (typeof this.display === 'function') {
                return this.display(option);
            }
            if (typeof this.display === 'string' && typeof option === 'object' && option.hasOwnProperty(this.display)) {
                return option[this.display];
            }
            return option;
        };
        /** Toggle the dropdown open state */
        SelectComponent.prototype.toggle = function () {
            // if the select is disabled then do not show the dropdown
            if (this.disabled) {
                return;
            }
            if (this.dropdownOpen) {
                this.dropdownOpen = false;
            }
            else {
                this.inputClickHandler();
            }
        };
        /** Handle input focus events */
        SelectComponent.prototype.onFocus = function () {
            // mark form control as touched
            this._onTouched();
            // if the input is readonly we do not want to select the text on focus
            if (this.readonlyInput) {
                // cast the select input element
                var element_1 = this.singleInput.nativeElement;
                // firefox requires a delay before clearing the selection (other browsers don't)
                this._platform.FIREFOX ? requestAnimationFrame(function () { return element_1.setSelectionRange(0, 0); }) : element_1.setSelectionRange(0, 0);
            }
        };
        SelectComponent.prototype.clear = function () {
            if (this.disabled) {
                return;
            }
            // clear the value and input text
            this.value = null;
            this.input = null;
            this.selectInputText();
            // emit the latest values
            this.valueChange.emit(this.value);
            this._onChange(this.value);
            this.inputChange.emit(this.input);
        };
        SelectComponent.prototype.selectInputText = function () {
            if (!this.readonlyInput) {
                this.singleInput.nativeElement.select();
            }
        };
        __decorate([
            core.Input(), core.HostBinding('attr.id'),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SelectComponent.prototype, "value", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], SelectComponent.prototype, "input", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectComponent.prototype, "dropdownOpen", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "options", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "display", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "key", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SelectComponent.prototype, "allowNull", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SelectComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "dropDirection", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "maxHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SelectComponent.prototype, "multiple", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SelectComponent.prototype, "pageSize", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], SelectComponent.prototype, "tagTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "autocomplete", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], SelectComponent.prototype, "loadingTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], SelectComponent.prototype, "noOptionsTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SelectComponent.prototype, "readonlyInput", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], SelectComponent.prototype, "clearButton", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SelectComponent.prototype, "clearButtonAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], SelectComponent.prototype, "optionTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], SelectComponent.prototype, "recentOptions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SelectComponent.prototype, "recentOptionsMaxCount", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "valueChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "inputChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "dropdownOpenChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectComponent.prototype, "recentOptionsChange", void 0);
        __decorate([
            core.ContentChild('icon', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], SelectComponent.prototype, "icon", void 0);
        __decorate([
            core.ViewChild('singleInput', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], SelectComponent.prototype, "singleInput", void 0);
        __decorate([
            core.ViewChild('tagInput', { static: false }),
            __metadata("design:type", TagInputComponent)
        ], SelectComponent.prototype, "tagInput", void 0);
        __decorate([
            core.ViewChild('multipleTypeahead', { static: false }),
            __metadata("design:type", TypeaheadComponent)
        ], SelectComponent.prototype, "multipleTypeahead", void 0);
        __decorate([
            core.ViewChild('singleTypeahead', { static: false }),
            __metadata("design:type", TypeaheadComponent)
        ], SelectComponent.prototype, "singleTypeahead", void 0);
        SelectComponent = __decorate([
            core.Component({
                selector: 'ux-select, ux-combobox, ux-dropdown',
                template: "<ux-tag-input\r\n    *ngIf=\"multiple\"\r\n    #tagInput=\"ux-tag-input\"\r\n    [id]=\"id + '-input'\"\r\n    [tags]=\"_value$ | async\"\r\n    (tagsChange)=\"_multipleOptionSelected($event)\"\r\n    [(input)]=\"input\"\r\n    (inputChange)=\"onInputChange($event)\"\r\n    [ariaLabel]=\"ariaLabel\"\r\n    [autocomplete]=\"autocomplete\"\r\n    [addOnPaste]=\"false\"\r\n    [disabled]=\"disabled\"\r\n    [display]=\"display\"\r\n    [freeInput]=\"false\"\r\n    [placeholder]=\"placeholder || ''\"\r\n    [tagTemplate]=\"tagTemplate\"\r\n    (inputFocus)=\"onFocus()\"\r\n    [showTypeaheadOnClick]=\"true\"\r\n    [readonlyInput]=\"readonlyInput\"\r\n    [icon]=\"icon\"\r\n    [clearButton]=\"clearButton\"\r\n    [clearButtonAriaLabel]=\"clearButtonAriaLabel\">\r\n\r\n    <ux-typeahead #multipleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [disabledOptions]=\"_value$ | async\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"true\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\"\r\n        [recentOptions]=\"recentOptions\"\r\n        [recentOptionsMaxCount]=\"recentOptionsMaxCount\"\r\n        (recentOptionsChange)=\"recentOptionsChange.emit($event)\">\r\n    </ux-typeahead>\r\n\r\n</ux-tag-input>\r\n\r\n<div *ngIf=\"!multiple\"\r\n    class=\"ux-select-container\"\r\n    [class.disabled]=\"disabled\"\r\n    role=\"combobox\"\r\n    [attr.aria-expanded]=\"dropdownOpen\"\r\n    aria-haspopup=\"listbox\">\r\n\r\n    <input #singleInput type=\"text\"\r\n        [attr.id]=\"id + '-input'\"\r\n        class=\"form-control\"\r\n        [class.ux-tag-input-clear-inset]=\"clearButton && allowNull && _hasValue\"\r\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\r\n        aria-autocomplete=\"list\"\r\n        [attr.aria-controls]=\"singleTypeahead.id\"\r\n        [attr.aria-label]=\"ariaLabel\"\r\n        aria-multiline=\"false\"\r\n        [autocomplete]=\"autocomplete\"\r\n        [(ngModel)]=\"input\"\r\n        (ngModelChange)=\"onInputChange($event)\"\r\n        [placeholder]=\"placeholder || ''\"\r\n        [disabled]=\"disabled\"\r\n        (click)=\"toggle()\"\r\n        (focus)=\"onFocus()\"\r\n        (blur)=\"inputBlurHandler()\"\r\n        (keydown)=\"inputKeyHandler($event)\"\r\n        [readonly]=\"readonlyInput\">\r\n\r\n    <div class=\"ux-select-icons\">\r\n        <i *ngIf=\"clearButton && allowNull && _hasValue\"\r\n           uxFocusIndicator\r\n           [attr.tabindex]=\"disabled ? -1 : 0\"\r\n           [attr.aria-label]=\"clearButtonAriaLabel\"\r\n           class=\"ux-select-icon ux-icon ux-icon-close ux-select-clear-icon\"\r\n           (click)=\"clear(); $event.stopPropagation()\"\r\n           (keydown.enter)=\"clear(); $event.stopPropagation()\">\r\n        </i>\r\n        <i *ngIf=\"!icon\"\r\n           class=\"ux-select-icon ux-icon ux-select-chevron-icon\"\r\n           [class.ux-icon-up]=\"dropDirection === 'up'\"\r\n           [class.ux-icon-down]=\"dropDirection === 'down'\"\r\n           (click)=\"toggle(); $event.stopPropagation()\">\r\n        </i>\r\n        <div *ngIf=\"icon\" class=\"ux-custom-icon\">\r\n            <ng-container [ngTemplateOutlet]=\"icon\"></ng-container>\r\n        </div>\r\n    </div>\r\n\r\n    <ux-typeahead #singleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [active]=\"_value$ | async\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"false\"\r\n        [openOnFilterChange]=\"false\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\"\r\n        [recentOptions]=\"recentOptions\"\r\n        [recentOptionsMaxCount]=\"recentOptionsMaxCount\"\r\n        (optionSelected)=\"_singleOptionSelected($event)\"\r\n        (highlightedElementChange)=\"highlightedElement = $event\"\r\n        (recentOptionsChange)=\"recentOptionsChange.emit($event)\">\r\n\r\n    </ux-typeahead>\r\n\r\n</div>\r\n",
                providers: [SELECT_VALUE_ACCESSOR],
                host: {
                    '[class.ux-select-custom-icon]': '!!icon',
                    '[class.ux-select-disabled]': 'disabled'
                }
            }),
            __param(2, core.Inject(common.DOCUMENT)),
            __metadata("design:paramtypes", [core.ElementRef,
                platform.Platform, Object, TypeaheadKeyService])
        ], SelectComponent);
        return SelectComponent;
    }());
    var SelectModule = /** @class */ (function () {
        function SelectModule() {
        }
        SelectModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    forms.FormsModule,
                    InfiniteScrollModule,
                    TagInputModule,
                    TypeaheadModule,
                    platform.PlatformModule
                ],
                exports: [SelectComponent],
                declarations: [SelectComponent]
            })
        ], SelectModule);
        return SelectModule;
    }());
    var BaseSearchComponent = /** @class */ (function () {
        function BaseSearchComponent(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "id", {
            get: function () {
                return "ux-search-builder-search-component-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: function () {
                return this._valid;
            },
            set: function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        BaseSearchComponent.prototype.ngOnDestroy = function () {
            this.valid = true;
        };
        /**
         * Perform any required validation on the value
         */
        BaseSearchComponent.prototype.validate = function () {
            // if a custom validation function has been provided then use it
            this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
        };
        BaseSearchComponent = __decorate([
            core.Component({
                selector: 'ux-base-search',
                template: ''
            }),
            __metadata("design:paramtypes", [SearchBuilderService])
        ], BaseSearchComponent);
        return BaseSearchComponent;
    }());
    var SearchDateRangeComponent = /** @class */ (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: function (fromValue) {
                // create new object based on the current value
                var value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: function (toValue) {
                // create new object based on the current value
                var value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        SearchDateRangeComponent.prototype.validate = function () {
            // check if there is a config validation function
            if (this.config.validation) {
                return _super.prototype.validate.call(this);
            }
            // create copies of the dates so we can modify time value (to ignore it)
            var from = new Date(this.value.from);
            var to = new Date(this.value.to);
            // set the time to the same so we dont compare it
            from.setHours(0, 0, 0, 0);
            to.setHours(0, 0, 0, 0);
            // valid if the from date is less than or equal to the to date
            this.valid = from <= to;
        };
        SearchDateRangeComponent = __decorate([
            core.Component({
                selector: 'ux-search-date-range',
                template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <ux-icon name=\"calendar\"></ux-icon>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\" [focusIf]=\"focus\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <ux-icon name=\"calendar\"></ux-icon>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
            })
        ], SearchDateRangeComponent);
        return SearchDateRangeComponent;
    }(BaseSearchComponent));
    var SearchDateComponent = /** @class */ (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        SearchDateComponent.prototype.ngOnInit = function () {
            // by default set to the current date if not specified
            if (!this.value) {
                this.value = new Date();
            }
        };
        SearchDateComponent = __decorate([
            core.Component({
                selector: 'ux-search-date',
                template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <ux-icon name=\"calendar\"></ux-icon>\n    </span>\n    <input type=\"text\"\n        class=\"form-control\"\n        aria-label=\"Selected date\"\n        [placeholder]=\"placeholder\"\n        #popover=\"ux-popover\"\n        [ngModel]=\"value | date:'dd MMMM yyyy'\"\n        [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\"\n        popoverClass=\"date-time-picker-popover\"\n        [focusIf]=\"focus\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
            })
        ], SearchDateComponent);
        return SearchDateComponent;
    }(BaseSearchComponent));
    var SearchSelectComponent = /** @class */ (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent = __decorate([
            core.Component({
                selector: 'ux-search-select',
                template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\"\n           [options]=\"options\"\n           [multiple]=\"multiple\"\n           [placeholder]=\"placeholder\"\n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\"\n           [focusIf]=\"focus\">\n</ux-select>"
            })
        ], SearchSelectComponent);
        return SearchSelectComponent;
    }(BaseSearchComponent));
    var SearchTextComponent = /** @class */ (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent = __decorate([
            core.Component({
                selector: 'ux-search-text',
                template: "<label *ngIf=\"label\" class=\"form-label\" [attr.for]=\"id\">{{ label }}</label>\n<input [attr.id]=\"id\" class=\"form-control\" [placeholder]=\"placeholder\" [(ngModel)]=\"value\" [focusIf]=\"focus\">"
            })
        ], SearchTextComponent);
        return SearchTextComponent;
    }(BaseSearchComponent));
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new SearchBuilderFocusService();
    }
    var SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER = {
        provide: SearchBuilderFocusService,
        deps: [[new core.Optional(), new core.SkipSelf(), SearchBuilderFocusService]],
        useFactory: SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER_FACTORY
    };
    var SearchBuilderModule = /** @class */ (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    DateTimePickerModule,
                    FocusIfModule,
                    forms.FormsModule,
                    IconModule,
                    PopoverModule,
                    SelectModule,
                ],
                exports: [
                    SearchBuilderComponent,
                    SearchBuilderGroupComponent,
                    BaseSearchComponent
                ],
                declarations: [
                    SearchBuilderComponent,
                    SearchBuilderGroupComponent,
                    SearchTextComponent,
                    SearchDateComponent,
                    SearchDateRangeComponent,
                    SearchBuilderOutletDirective,
                    SearchSelectComponent,
                    BaseSearchComponent
                ],
                entryComponents: [
                    SearchTextComponent,
                    SearchDateComponent,
                    SearchDateRangeComponent,
                    SearchSelectComponent
                ],
                providers: [
                    SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER
                ]
            })
        ], SearchBuilderModule);
        return SearchBuilderModule;
    }());
    var SelectionStrategy = /** @class */ (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        SelectionStrategy.prototype.setSelectionService = function (selectionService) {
            this.selectionService = selectionService;
        };
        SelectionStrategy.prototype.mousedown = function (event, data) { };
        SelectionStrategy.prototype.click = function (event, data) { };
        SelectionStrategy.prototype.keydown = function (event, data) { };
        /**
         * Select the item - default behavior
         */
        SelectionStrategy.prototype.select = function () {
            var _a;
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            (_a = this.selectionService).select.apply(_a, __spread(data));
        };
        /**
         * Replace the current selection with the list of items specified
         */
        SelectionStrategy.prototype.selectOnly = function () {
            var _a;
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            (_a = this.selectionService).selectOnly.apply(_a, __spread(data));
        };
        /**
         * Toggle the item's selected state - default behavior
         */
        SelectionStrategy.prototype.toggle = function () {
            var _a;
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            (_a = this.selectionService).toggle.apply(_a, __spread(data));
        };
        /**
         * Deselect the item - default behavior
         */
        SelectionStrategy.prototype.deselect = function () {
            var _a;
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            (_a = this.selectionService).deselect.apply(_a, __spread(data));
        };
        /**
         * Select all items - default behavior
         */
        SelectionStrategy.prototype.selectAll = function () {
            this.select.apply(this, __spread(this.selectionService.dataset));
        };
        /**
         * Deselect all items - default behavior
         */
        SelectionStrategy.prototype.deselectAll = function () {
            // call deselect on all items in the dataset
            this.selectionService.deselectAll();
        };
        SelectionStrategy.prototype.destroy = function () { };
        return SelectionStrategy;
    }());
    var RowSelectionStrategy = /** @class */ (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // store the most recently selected row
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        RowSelectionStrategy.prototype.mousedown = function (event) {
            event.preventDefault();
        };
        /**
         * When a row is clicked we want to handle selection
         */
        RowSelectionStrategy.prototype.click = function (event, data) {
            // determine which modifier keys are pressed
            var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
            // if the shift key is pressed we want to perform a multiple selection
            if (shiftKey) {
                return this.multipleSelect(data);
            }
            // if the control key is pressed we want to perform an additive toggle selection
            if (ctrlKey) {
                return this.toggle(data);
            }
            // perform a single selection where all other rows are deselected
            this.singleSelect(data);
        };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        RowSelectionStrategy.prototype.keydown = function (event, data) {
            switch (event.which) {
                case keycodes.UP_ARROW:
                case keycodes.DOWN_ARROW:
                    event.preventDefault();
                    this.navigate(event, data);
                    break;
                case keycodes.SPACE:
                    event.preventDefault();
                    this.selectionService.strategy.toggle(data);
                    // also activate the item
                    this.selectionService.activate(data);
                    break;
            }
        };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        RowSelectionStrategy.prototype.toggle = function (data) {
            _super.prototype.toggle.call(this, data);
            // store or clear the selection
            this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
        };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         */
        RowSelectionStrategy.prototype.singleSelect = function (data) {
            // deselect all other rows if neither modifier key is pressed
            this.deselectAll();
            // select the current row
            this.select(data);
            // store the current item as the selection start
            this.setSelectionStart(data);
        };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        RowSelectionStrategy.prototype.multipleSelect = function (data) {
            // if no selection currently exists then perform initial selection
            if (!this._selection.start) {
                // select the row
                this.select(data);
                // store the starting point
                return this.setSelectionStart(data);
            }
            // if a multiple selection already took place - clear the previous selection
            if (this._selection.start && this._selection.end) {
                this.deselect.apply(this, __spread(this.getSelectedItems()));
            }
            // set the new selection end point
            this.setSelectionEnd(data);
            // select all the items in the range
            this.select.apply(this, __spread(this.getSelectedItems()));
        };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         */
        RowSelectionStrategy.prototype.setSelectionStart = function (data) {
            this._selection.start = data;
            this._selection.end = null;
            // activate the item
            this.selectionService.activate(data);
        };
        /**
         * Set the selection end point
         */
        RowSelectionStrategy.prototype.setSelectionEnd = function (data) {
            this._selection.end = data;
            // activate the item
            this.selectionService.activate(data);
        };
        /**
         * Clear both start and end selection points
         */
        RowSelectionStrategy.prototype.clearSelection = function (deactivate) {
            if (deactivate === void 0) {
                deactivate = true;
            }
            // reset the selected item
            this._selection = { start: null, end: null };
            // remove the current active item
            if (deactivate) {
                this.selectionService.deactivate();
            }
        };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         */
        RowSelectionStrategy.prototype.getSelectedItems = function () {
            // get the latest dataset
            var dataset = this.selectionService.dataset;
            // get the indexes of the start and end point
            var startIdx = dataset.indexOf(this._selection.start);
            var endIdx = dataset.indexOf(this._selection.end);
            // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
            return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
        };
        /**
         * Activate the sibling item when arrow keys are pressed
         */
        RowSelectionStrategy.prototype.navigate = function (event, data) {
            // determine which modifier keys are pressed
            var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
            // if no modifier keys are pressed then deselect all and clear the selection
            if (!ctrlKey && !shiftKey) {
                this.deselectAll();
                this.clearSelection(false);
            }
            // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
            var sibling = this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
            // if the shift key is pressed then we also want to toggle the state if the item
            if (shiftKey && sibling) {
                // if there is no current selection start then select the current row
                if (!this._selection.start) {
                    this.multipleSelect(data);
                }
                this.multipleSelect(sibling);
            }
        };
        return RowSelectionStrategy;
    }(SelectionStrategy));
    var RowAltSelectionStrategy = /** @class */ (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RowAltSelectionStrategy.prototype.keydown = function (event, data) {
            switch (event.which) {
                case keycodes.UP_ARROW:
                case keycodes.DOWN_ARROW:
                    event.preventDefault();
                    this.handleCursorKey(event, data);
                    break;
                case keycodes.SPACE:
                    event.preventDefault();
                    this.selectionService.strategy.toggle(data);
                    break;
            }
        };
        /**
         * Select the sibling item when arrow keys are pressed
         */
        RowAltSelectionStrategy.prototype.handleCursorKey = function (event, data) {
            // determine which modifier keys are pressed
            var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
            // if no modifier keys are pressed then deselect all and clear the selection
            if (!ctrlKey && !shiftKey) {
                this.deselectAll();
                this.clearSelection(false);
            }
            if (ctrlKey) {
                this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
            }
            else {
                var sibling = this.selectionService.getSibling(event.which === keycodes.UP_ARROW);
                this.multipleSelect(sibling ? sibling : data);
            }
        };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));
    var SimpleSelectionStrategy = /** @class */ (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        SimpleSelectionStrategy.prototype.click = function (_event, data) {
            this.toggle(data);
        };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        SimpleSelectionStrategy.prototype.keydown = function (event, data) {
            switch (event.which) {
                case keycodes.UP_ARROW:
                    event.preventDefault();
                    this.selectionService.activateSibling(true);
                    return;
                case keycodes.DOWN_ARROW:
                    event.preventDefault();
                    this.selectionService.activateSibling(false);
                    return;
                case keycodes.SPACE:
                    event.preventDefault();
                    return this.toggle(data);
            }
        };
        /**
         * Override the standard toggle function to always activate the item
         */
        SimpleSelectionStrategy.prototype.toggle = function (data) {
            _super.prototype.toggle.call(this, data);
            this.selectionService.activate(data);
        };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));
    var SelectionService = /** @class */ (function () {
        function SelectionService() {
            /** The active selection strategy that defines how selections can be made */
            this.strategy = new SimpleSelectionStrategy(this);
            /** Define if selections can be performed on any items */
            this.isEnabled = true;
            /** Define if the mouse can be used to perform selections */
            this.isClickEnabled = true;
            /** Define if the keyboard can be used to perform selections */
            this.isKeyboardEnabled = true;
            /** Define the currently focused item */
            this.focus$ = new rxjs.BehaviorSubject(null);
            /** Define the currently active item */
            this.active$ = new rxjs.BehaviorSubject(null);
            /** Store the current list of selected items as an array */
            this.selection$ = new rxjs.BehaviorSubject([]);
            /** Store the current set of selectable items */
            this._dataset = [];
            /** Store the selection strategy that should be destroyed */
            this._strategyToDestroy = this.strategy;
            /** Store the current selection in a set */
            this._selection = new Set();
            /** Store the current disabled items in a set */
            this._disabled = new Set();
        }
        Object.defineProperty(SelectionService.prototype, "dataset", {
            /** Get the current set of selectable items */
            get: function () {
                return this._dataset;
            },
            /** Store the current set of selectable items and ensure an item can be focused */
            set: function (dataset) {
                this._dataset = dataset;
                if (this._dataset.indexOf(this._active) === -1) {
                    this.setFirstItemFocusable();
                }
            },
            enumerable: true,
            configurable: true
        });
        SelectionService.prototype.ngOnDestroy = function () {
            // destroy the active stategy
            if (this._strategyToDestroy) {
                this._strategyToDestroy.destroy();
            }
            // complete all observables
            this.focus$.complete();
            this.active$.complete();
            this.selection$.complete();
        };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        SelectionService.prototype.select = function () {
            var _this = this;
            var selections = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                selections[_i] = arguments[_i];
            }
            // filter out any disabled items
            selections = selections.filter(function (item) { return !_this._disabled.has(item); });
            // add each selection to the set
            selections.forEach(function (selection) { return _this._selection.add(selection); });
            // propagate the changes
            this.selectionHasMutated();
        };
        /**
         * Deselect all currently selected items and replace with a new selection
         */
        SelectionService.prototype.selectOnly = function () {
            var _this = this;
            var selection = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                selection[_i] = arguments[_i];
            }
            // filter out any disabled items
            selection = selection.filter(function (item) { return !_this._disabled.has(item); });
            // remove all currently selected items
            this._selection.clear();
            // select only the specified item
            selection.forEach(function (item) { return _this._selection.add(item); });
            // emit the changes
            this.selectionHasMutated();
        };
        /**
         * Remove an item from the list of selected items
         */
        SelectionService.prototype.deselect = function () {
            var _this = this;
            var selections = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                selections[_i] = arguments[_i];
            }
            // remove each item from the set
            selections.forEach(function (selection) { return _this._selection.delete(selection); });
            // propagate the changes
            this.selectionHasMutated();
        };
        /**
         * Remove all items from the list of selected items
         */
        SelectionService.prototype.deselectAll = function () {
            // remove all items in the array
            this.deselect.apply(this, __spread(this._dataset));
            // clear the set in case any items have been removed from the DOM but are still selected
            this._selection.clear();
        };
        /**
         * Toggle the selected state of any specified items
         */
        SelectionService.prototype.toggle = function () {
            var _this = this;
            var selections = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                selections[_i] = arguments[_i];
            }
            selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
        };
        /**
         * Determine whether or not a specific item is currently selected
         */
        SelectionService.prototype.isSelected = function (data) {
            return this._selection.has(data);
        };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        SelectionService.prototype.getSelectionState = function (data) {
            var _this = this;
            return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
        };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        SelectionService.prototype.setStrategy = function (mode) {
            if (this._strategyToDestroy) {
                // Destroy previous strategy if it was created internally
                this._strategyToDestroy.destroy();
                this._strategyToDestroy = null;
            }
            if (mode instanceof SelectionStrategy) {
                // Custom strategy - pass in the service instance
                this.strategy = mode;
                this.strategy.setSelectionService(this);
            }
            else {
                switch (mode.toLowerCase().trim()) {
                    case 'simple':
                        this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                        break;
                    case 'row':
                        this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                        break;
                    case 'row-alt':
                        this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                        break;
                    default:
                        throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                }
            }
        };
        /**
         * Set the current active item
         */
        SelectionService.prototype.activate = function (data) {
            this._active = data;
            this.active$.next(this._active);
        };
        /**
         * Deactive all items
         */
        SelectionService.prototype.deactivate = function () {
            this._active = null;
            this.active$.next(this._active);
        };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        SelectionService.prototype.getSibling = function (previous) {
            if (previous === void 0) {
                previous = false;
            }
            // check if there is a current active item
            if (!this._active) {
                return;
            }
            // get the index of the current item
            var idx = this.dataset.indexOf(this._active);
            var target = this.dataset[previous ? idx - 1 : idx + 1];
            return target;
        };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        SelectionService.prototype.activateSibling = function (previous) {
            if (previous === void 0) {
                previous = false;
            }
            var target = this.getSibling(previous);
            // check if the target exists
            if (target) {
                this.activate(target);
            }
            return target;
        };
        SelectionService.prototype.setDisabled = function (disabled) {
            // store the current disabled state
            this.isEnabled = !disabled;
            // clear any stateful data
            this._active = null;
            this.active$.next(this._active);
            this._selection.clear();
            // emit the selection change information
            this.selectionHasMutated();
        };
        /** Store the disabled state of an item */
        SelectionService.prototype.setItemDisabled = function (item, isDisabled) {
            // update the internal list of disabled items
            if (isDisabled && !this._disabled.has(item)) {
                this._disabled.add(item);
            }
            else if (!isDisabled) {
                this._disabled.delete(item);
            }
        };
        SelectionService.prototype.selectionHasMutated = function () {
            this.selection$.next(Array.from(this._selection));
        };
        SelectionService.prototype.setFirstItemFocusable = function () {
            if (this._dataset.length > 0) {
                this.focus$.next(this._dataset[0]);
                this._active = this._dataset[0];
            }
            else {
                this._active = null;
            }
        };
        SelectionService = __decorate([
            core.Injectable()
        ], SelectionService);
        return SelectionService;
    }());
    var SelectListItemComponent = /** @class */ (function () {
        function SelectListItemComponent(_selection, elementRef, focusIndicatorService) {
            var _this = this;
            this._selection = _selection;
            this.tabindex = -1;
            /** Unsubscribe from all subscriptions on destroy */
            this._onDestroy = new rxjs.Subject();
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
            _selection.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (data) { return data === _this.data; })).subscribe(function (active) {
                _selection.focus$.next(active);
                elementRef.nativeElement.focus();
            });
            // make this item tabbable or not based on the focused element
            _selection.focus$.pipe(operators.takeUntil(this._onDestroy), tick())
                .subscribe(function (focused) { return _this.tabindex = focused === _this.data ? 0 : -1; });
        }
        Object.defineProperty(SelectListItemComponent.prototype, "selected", {
            get: function () {
                return this._selection.isSelected(this.data);
            },
            set: function (isSelected) {
                isSelected ? this._selection.select(this.data) : this._selection.deselect(this.data);
            },
            enumerable: true,
            configurable: true
        });
        SelectListItemComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this._focusIndicator.destroy();
        };
        SelectListItemComponent.prototype.onMouseDown = function (event) {
            this._selection.strategy.mousedown(event, this.data);
        };
        SelectListItemComponent.prototype.onClick = function (event) {
            this._selection.strategy.click(event, this.data);
        };
        SelectListItemComponent.prototype.onKeydown = function (event) {
            this._selection.strategy.keydown(event, this.data);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SelectListItemComponent.prototype, "data", void 0);
        __decorate([
            core.HostBinding('tabindex'),
            __metadata("design:type", Number)
        ], SelectListItemComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.selected'),
            core.HostBinding('attr.aria-selected'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectListItemComponent.prototype, "selected", null);
        __decorate([
            core.HostListener('mousedown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], SelectListItemComponent.prototype, "onMouseDown", null);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], SelectListItemComponent.prototype, "onClick", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SelectListItemComponent.prototype, "onKeydown", null);
        SelectListItemComponent = __decorate([
            core.Component({
                selector: 'ux-select-list-item',
                template: "<ng-content></ng-content>",
                host: {
                    role: 'listitem'
                }
            }),
            __metadata("design:paramtypes", [SelectionService, core.ElementRef, FocusIndicatorService])
        ], SelectListItemComponent);
        return SelectListItemComponent;
    }());
    var SelectionItemDirective = /** @class */ (function () {
        function SelectionItemDirective(_selectionService, _elementRef, focusIndicatorService, _managedFocusContainerService) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            /** Defines the tab index of the row */
            this.tabindex = null;
            /** Defines whether or not this item is currently selected. */
            this.selectedChange = new core.EventEmitter();
            /** Store the current focused state of the item */
            this.active = false;
            /** Store the current selected state */
            this._selected = false;
            /** Store the disabled state */
            this._isDisabled = false;
            /** Store the tab indexed if using the managed focus container */
            this._managedTabIndex = -1;
            /** Automatically unsubscribe when the component is destroyed */
            this._onDestroy = new rxjs.Subject();
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            /** Defines whether or not this item is currently selected. */
            set: function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "uxSelectionDisabled", {
            /** Determine whether or not this item can be selected */
            set: function (isDisabled) {
                // if this item was selected then deselect it
                if (this._selected && isDisabled) {
                    this.deselect();
                }
                // inform the selection service of the disabled state
                this._selectionService.setItemDisabled(this.uxSelectionItem, isDisabled);
                // store the current disabled state
                this._isDisabled = isDisabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        SelectionItemDirective.prototype.ngOnInit = function () {
            var _this = this;
            // if there is no associated data then throw an error
            if (!this.uxSelectionItem) {
                throw new Error('The uxSelectionItem directive must have data associated with it.');
            }
            // subscribe to selection changes on this item
            this._selectionService.getSelectionState(this.uxSelectionItem).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (selected) {
                // store the selected state
                _this._selected = selected;
                // emit the selected state
                _this.selectedChange.emit(selected);
            });
            this._selected = this._selectionService.isSelected(this.uxSelectionItem);
            this.selectedChange.emit(this._selected);
            // subscribe to changes to the active state
            this._selectionService.active$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                // store the focus state
                _this.active = active;
                // if it is active then focus the element
                if (active === true) {
                    _this._selectionService.focus$.next(_this.uxSelectionItem);
                    _this._elementRef.nativeElement.focus();
                }
            });
            // Subscribe to changes to the focus target
            // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
            this._selectionService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focusTarget) {
                _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
            });
            // Watch for focus within the container element and manage tabindex of descendants
            this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
        };
        SelectionItemDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this._focusIndicator.destroy();
            this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
        };
        SelectionItemDirective.prototype.click = function (event) {
            if (!this._isDisabled && this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                this._selectionService.strategy.click(event, this.uxSelectionItem);
            }
        };
        SelectionItemDirective.prototype.mousedown = function (event) {
            if (!this._isDisabled && this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
            }
        };
        SelectionItemDirective.prototype.keydown = function (event) {
            // if the space key (selection key) is pressed and we are disabled then we should block
            // the event from propagating. However if this is a key such as arrow presses then we do
            // still want this to propagate to allow keyboard navigation for accessibility purposes.
            var isDisabled = this._isDisabled && event.keyCode === keycodes.SPACE;
            if (!isDisabled && this._selectionService.isEnabled && this._selectionService.isKeyboardEnabled) {
                this._selectionService.strategy.keydown(event, this.uxSelectionItem);
            }
        };
        SelectionItemDirective.prototype.focus = function () {
            // If tabbed to from outside the component, activate.
            if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                this._selectionService.activate(this.uxSelectionItem);
            }
        };
        /**
         * Select this item using the current strategy
         */
        SelectionItemDirective.prototype.select = function () {
            if (!this._isDisabled && this._selectionService.isEnabled) {
                this._selectionService.strategy.select(this.uxSelectionItem);
            }
        };
        /**
         * Deselect this item using the current strategy
         */
        SelectionItemDirective.prototype.deselect = function () {
            if (!this._isDisabled && this._selectionService.isEnabled) {
                this._selectionService.strategy.deselect(this.uxSelectionItem);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SelectionItemDirective.prototype, "uxSelectionItem", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('class.ux-selection-selected'),
            core.HostBinding('attr.aria-selected'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectionItemDirective.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SelectionItemDirective.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectionItemDirective.prototype, "uxSelectionDisabled", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectionItemDirective.prototype, "selectedChange", void 0);
        __decorate([
            core.HostBinding('class.ux-selection-focused'),
            __metadata("design:type", Boolean)
        ], SelectionItemDirective.prototype, "active", void 0);
        __decorate([
            core.HostBinding('attr.tabindex'),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [])
        ], SelectionItemDirective.prototype, "attrTabIndex", null);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], SelectionItemDirective.prototype, "click", null);
        __decorate([
            core.HostListener('mousedown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [MouseEvent]),
            __metadata("design:returntype", void 0)
        ], SelectionItemDirective.prototype, "mousedown", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], SelectionItemDirective.prototype, "keydown", null);
        __decorate([
            core.HostListener('focus'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], SelectionItemDirective.prototype, "focus", null);
        SelectionItemDirective = __decorate([
            core.Directive({
                selector: '[uxSelectionItem]',
                exportAs: 'ux-selection-item'
            }),
            __metadata("design:paramtypes", [SelectionService,
                core.ElementRef,
                FocusIndicatorService,
                ManagedFocusContainerService])
        ], SelectionItemDirective);
        return SelectionItemDirective;
    }());
    var SelectionDirective = /** @class */ (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            /** The tabstop of the selection outer element */
            this.tabindex = null;
            /** This event will be triggered when there is a change to the selected items. It will contain an array of the currently selected items. */
            this.uxSelectionChange = new core.EventEmitter();
            /** Unsubscribe from all observables on component destroy */
            this._onDestroy = new rxjs.Subject();
            _selectionService.selection$.pipe(operators.takeUntil(this._onDestroy), operators.debounceTime(0)).subscribe(function (items) {
                if (_this.isSelectionChanged(items)) {
                    _this.uxSelectionChange.emit(items);
                }
                // store the most recent selection
                _this._lastSelection = __spread(items);
            });
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            /** Defines the items that should be selected. */
            set: function (items) {
                var _a;
                (_a = this._selectionService).selectOnly.apply(_a, __spread(items));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            /** Can be used to enabled/disable selection behavior. */
            set: function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            /**
             * Defines the selection behavior. Alternatively, custom selection behavior can be defined by defining a
             * class which extends SelectionStrategy, and providing an instance of the custom class to this property.
             * See below for details of the SelectionStrategy class.
             */
            set: function (mode) {
                this._selectionService.setStrategy(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            /**
             * Can be used to enable/disable click selection on items. This can be used to manually control the selection of an item,
             * for example, binding the selection state to a checkbox.
             */
            set: function (isClickEnabled) {
                this._selectionService.isClickEnabled = isClickEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            /** Can be used to enable/disable keyboard navigation on items. Use this if you wish to provide custom keyboard controls for selection. */
            set: function (isKeyboardEnabled) {
                this._selectionService.isKeyboardEnabled = isKeyboardEnabled;
            },
            enumerable: true,
            configurable: true
        });
        SelectionDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // provide the initial list of selection items
            this.update();
            // if the list changes then inform the service
            this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.update(); });
        };
        SelectionDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Update the dataset to reflect the latest selection items
         */
        SelectionDirective.prototype.update = function () {
            this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
            // Make sure that a tab target has been defined so that the component can be tabbed to.
            if (this._selectionService.focus$.getValue() === null && this._selectionService.dataset.length > 0) {
                this._selectionService.focus$.next(this._selectionService.dataset[0]);
            }
            // The above could trigger a change in the computed tabindex for selection items
            this._cdRef.detectChanges();
        };
        /**
         * Select all the items in the list
         */
        SelectionDirective.prototype.selectAll = function () {
            if (this._selectionService.isEnabled) {
                this._selectionService.strategy.selectAll();
            }
        };
        /**
         * Deselect all currently selected items
         */
        SelectionDirective.prototype.deselectAll = function () {
            if (this._selectionService.isEnabled) {
                this._selectionService.strategy.deselectAll();
            }
        };
        /**
         * Determine if the previous selection is the same as the current selection
         */
        SelectionDirective.prototype.isSelectionChanged = function (selection) {
            // fast, efficient check, if length is different they must have changed
            if (!this._lastSelection && selection || this._lastSelection.length !== selection.length) {
                return true;
            }
            // if both arrays have 0 items then they have not changed
            if (this._lastSelection.length === 0 && selection.length === 0) {
                return false;
            }
            // otherwise do a check on each item
            return !this._lastSelection.every(function (item) { return selection.indexOf(item) !== -1; });
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], SelectionDirective.prototype, "uxSelection", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectionDirective.prototype, "disabled", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SelectionDirective.prototype, "mode", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectionDirective.prototype, "clickSelection", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectionDirective.prototype, "keyboardSelection", null);
        __decorate([
            core.Input(), core.HostBinding('attr.tabindex'),
            __metadata("design:type", Number)
        ], SelectionDirective.prototype, "tabindex", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectionDirective.prototype, "uxSelectionChange", void 0);
        __decorate([
            core.ContentChildren(SelectionItemDirective),
            __metadata("design:type", core.QueryList)
        ], SelectionDirective.prototype, "items", void 0);
        SelectionDirective = __decorate([
            core.Directive({
                selector: '[uxSelection]',
                exportAs: 'ux-selection',
                providers: [SelectionService]
            }),
            __metadata("design:paramtypes", [SelectionService, core.ChangeDetectorRef])
        ], SelectionDirective);
        return SelectionDirective;
    }());
    var SelectionModule = /** @class */ (function () {
        function SelectionModule() {
        }
        SelectionModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                declarations: [SelectionDirective, SelectionItemDirective],
                exports: [SelectionDirective, SelectionItemDirective]
            })
        ], SelectionModule);
        return SelectionModule;
    }());
    var MultipleSelectListStrategy = /** @class */ (function (_super) {
        __extends(MultipleSelectListStrategy, _super);
        function MultipleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** Prevent the browser from highlighting text on shift click */
        MultipleSelectListStrategy.prototype.mousedown = function (event) {
            event.preventDefault();
        };
        MultipleSelectListStrategy.prototype.click = function (event, data) {
            // activate the clicked item
            this.selectionService.activate(data);
            // if the shift key is pressed we want to perform a multiple selection
            if (event.shiftKey) {
                return this.multipleSelect(data);
            }
            // otherwise perform a single toggle selection
            if (this.selectionService.isSelected(data)) {
                this.deselect(data);
                this._lastSelection = null;
            }
            else {
                this.select(data);
                this._lastSelection = data;
            }
        };
        MultipleSelectListStrategy.prototype.keydown = function (event, data) {
            switch (event.which) {
                case keycodes.UP_ARROW: {
                    event.preventDefault();
                    var sibling = this.selectionService.activateSibling(true);
                    if (event.shiftKey) {
                        this.select(data, sibling);
                        this._lastSelection = sibling;
                    }
                    break;
                }
                case keycodes.DOWN_ARROW: {
                    event.preventDefault();
                    var sibling = this.selectionService.activateSibling(false);
                    if (event.shiftKey) {
                        this.select(data, sibling);
                        this._lastSelection = sibling;
                    }
                    break;
                }
                case keycodes.SPACE:
                case keycodes.ENTER:
                    event.preventDefault();
                    this.toggle(data);
                    this._lastSelection = this.selectionService.isSelected(data) ? data : null;
                    break;
            }
        };
        MultipleSelectListStrategy.prototype.multipleSelect = function (data) {
            // if there is no start item selected
            if (!this._lastSelection) {
                this.select(data);
                this._lastSelection = data;
                return;
            }
            // if there already is a start item then find the items in the range
            this.select.apply(this, __spread(this.getSelectedItems(this._lastSelection, data)));
            // store the selection end point
            this._lastSelection = data;
        };
        MultipleSelectListStrategy.prototype.getSelectedItems = function (start, end) {
            // get the latest dataset
            var dataset = this.selectionService.dataset;
            // get the indexes of the start and end point
            var startIdx = dataset.indexOf(start);
            var endIdx = dataset.indexOf(end);
            // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
            return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
        };
        return MultipleSelectListStrategy;
    }(SelectionStrategy));
    var SingleSelectListStrategy = /** @class */ (function (_super) {
        __extends(SingleSelectListStrategy, _super);
        function SingleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingleSelectListStrategy.prototype.click = function (_event, data) {
            // activate the clicked item
            this.selectionService.activate(data);
            // toggle the selected state of the item
            if (!this.selectionService.isSelected(data)) {
                this.selectOnly(data);
            }
            else {
                this.deselect(data);
            }
        };
        SingleSelectListStrategy.prototype.keydown = function (event, data) {
            switch (event.which) {
                case keycodes.UP_ARROW: {
                    event.preventDefault();
                    this.selectionService.activateSibling(true);
                    break;
                }
                case keycodes.DOWN_ARROW: {
                    event.preventDefault();
                    this.selectionService.activateSibling(false);
                    break;
                }
                case keycodes.SPACE:
                case keycodes.ENTER:
                    event.preventDefault();
                    this.click(null, data);
                    break;
            }
        };
        return SingleSelectListStrategy;
    }(SelectionStrategy));
    var SelectListComponent = /** @class */ (function () {
        function SelectListComponent(_selection) {
            var _this = this;
            this._selection = _selection;
            /** Emit when the selection changes */
            this.selectedChange = new core.EventEmitter();
            /** Automatically unsubscribe all observables */
            this._onDestroy = new rxjs.Subject();
            // set the selection strategy to single by default
            this._selection.setStrategy(new SingleSelectListStrategy());
            // emit the selection changes when they occur
            this._selection.selection$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (selection) { return _this.selectedChange.emit(selection); });
        }
        Object.defineProperty(SelectListComponent.prototype, "multiple", {
            /** Determine if we allow multiple items to be selected */
            set: function (multiple) {
                this._selection.strategy.deselectAll();
                this._selection.setStrategy(multiple ? new MultipleSelectListStrategy() : new SingleSelectListStrategy());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectListComponent.prototype, "selected", {
            /** Set the selected items */
            set: function (selected) {
                var _a;
                // if the selection entered is the same as the current selection then do nothing
                if (this._selection.selection$.value === selected) {
                    return;
                }
                // if selected is an array and has not items and there are no items currently selected also do nothing
                if (Array.isArray(selected) && selected.length === 0 && this._selection.selection$.value.length === 0) {
                    return;
                }
                // select only the specified items
                if (Array.isArray(selected)) {
                    (_a = this._selection).selectOnly.apply(_a, __spread(selected));
                }
                else {
                    this._selection.selectOnly(selected);
                }
            },
            enumerable: true,
            configurable: true
        });
        SelectListComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // supply the initial item set
            this._selection.dataset = this.items.map(function (item) { return item.data; });
            // if the item set changes update the list
            this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this._selection.dataset = _this.items.map(function (item) { return item.data; }); });
        };
        SelectListComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], SelectListComponent.prototype, "multiple", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SelectListComponent.prototype, "selected", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], SelectListComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.ContentChildren(SelectListItemComponent),
            __metadata("design:type", core.QueryList)
        ], SelectListComponent.prototype, "items", void 0);
        SelectListComponent = __decorate([
            core.Component({
                selector: 'ux-select-list',
                template: "<ng-content></ng-content>",
                providers: [SelectionService],
                host: {
                    role: 'list'
                }
            }),
            __metadata("design:paramtypes", [SelectionService])
        ], SelectListComponent);
        return SelectListComponent;
    }());
    var SelectListModule = /** @class */ (function () {
        function SelectListModule() {
        }
        SelectListModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule
                ],
                declarations: [
                    SelectListComponent,
                    SelectListItemComponent
                ],
                exports: [
                    SelectListComponent,
                    SelectListItemComponent
                ],
            })
        ], SelectListModule);
        return SelectListModule;
    }());
    var InputDropdownComponent = /** @class */ (function () {
        function InputDropdownComponent() {
            /** Define the placeholder for the filter input */
            this.placeholder = 'Type to filter...';
            /** Aria label of the filter field. If not specified, the placeholder will be used. */
            this.ariaLabel = '';
            /** Emit when the selected item is changed */
            this.selectedChange = new core.EventEmitter();
            /** Emit when the filter text is changed */
            this.filterChange = new core.EventEmitter();
            /** Emits when `dropdownOpen` changes. */
            this.dropdownOpenChange = new core.EventEmitter();
            /** The status of the dropdown. */
            this.dropdownOpen = false;
            /** Store the current filter text */
            this._filterText = '';
            /** Store the change callback provided by Angular Forms */
            this.onChange = function () { };
            /** Store the touched callback provided by Angular Forms */
            this.onTouched = function () { };
            /** Unsubscribe from all observables on component destroy */
            this._onDestroy$ = new rxjs.Subject();
        }
        InputDropdownComponent_1 = InputDropdownComponent;
        Object.defineProperty(InputDropdownComponent.prototype, "maxHeight", {
            /** Define the max height of the dropdown */
            set: function (value) {
                this._maxHeight = coercion.coerceCssPixelValue(value);
            },
            enumerable: true,
            configurable: true
        });
        InputDropdownComponent.prototype.ngOnChanges = function (changes) {
            // if the dropdownOpen state changes via the input we should show or hide the input accordingly
            if (changes.dropdownOpen && !changes.dropdownOpen.firstChange && changes.dropdownOpen.currentValue !== changes.dropdownOpen.previousValue) {
                changes.dropdownOpen.currentValue ? this.menuTrigger.openMenu() : this.menuTrigger.closeMenu();
            }
            if (changes.selected) {
                // if an item is programmatically selected we should close the menu if it is open
                if (this.menuTrigger && !changes.selected.firstChange) {
                    this.menuTrigger.closeMenu();
                }
                this.selectedChange.emit(changes.selected.currentValue);
                this.onChange(changes.selected.currentValue);
                this.onTouched();
            }
        };
        InputDropdownComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // if the user has initially set the dropdownOpen input to true we should open the menu
            // once we have access to the ViewChild menu trigger directive
            if (this.dropdownOpen) {
                // trigger menu open on the next tick to avoid expression changed issues)
                Promise.resolve().then(function () { return _this.menuTrigger.openMenu(); });
            }
        };
        InputDropdownComponent.prototype.ngOnDestroy = function () {
            this._onDestroy$.next();
            this._onDestroy$.complete();
        };
        InputDropdownComponent.prototype.resetFilter = function (event) {
            this._filterText = '';
            this.filterChange.emit(this._filterText);
            this.filterInputElement.nativeElement.focus();
            event.stopPropagation();
        };
        InputDropdownComponent.prototype.registerOnChange = function (onChange) {
            this.onChange = onChange;
        };
        InputDropdownComponent.prototype.registerOnTouched = function (onTouched) {
            this.onTouched = onTouched;
        };
        InputDropdownComponent.prototype.writeValue = function (value) {
            this.selected = value;
        };
        InputDropdownComponent.prototype.resetValue = function (event) {
            this.writeValue(undefined);
            event.stopPropagation();
        };
        InputDropdownComponent.prototype.onMenuOpen = function () {
            this._focusFilter();
            if (this.dropdownOpen !== true) {
                this.dropdownOpen = true;
                this.dropdownOpenChange.emit(this.dropdownOpen);
            }
        };
        InputDropdownComponent.prototype.onMenuClose = function () {
            if (this.dropdownOpen !== false) {
                this.dropdownOpen = false;
                this.dropdownOpenChange.emit(this.dropdownOpen);
            }
        };
        InputDropdownComponent.prototype._focusFilter = function () {
            if (this.filterInputElement) {
                this.filterInputElement.nativeElement.focus();
            }
        };
        InputDropdownComponent.prototype.inputFocusHandler = function () {
            if (!this.dropdownOpen) {
                this.dropdownOpen = true;
                this.dropdownOpenChange.emit(this.dropdownOpen);
            }
        };
        InputDropdownComponent.prototype.toggleMenu = function () {
            this.dropdownOpen = !this.dropdownOpen;
            this.dropdownOpenChange.emit(this.dropdownOpen);
            this.menuTrigger.toggleMenu();
        };
        var InputDropdownComponent_1;
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], InputDropdownComponent.prototype, "selected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InputDropdownComponent.prototype, "hideFilter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], InputDropdownComponent.prototype, "maxHeight", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InputDropdownComponent.prototype, "allowNull", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], InputDropdownComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], InputDropdownComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], InputDropdownComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], InputDropdownComponent.prototype, "filterChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], InputDropdownComponent.prototype, "dropdownOpenChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], InputDropdownComponent.prototype, "dropdownOpen", void 0);
        __decorate([
            core.ContentChild('displayContent', { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], InputDropdownComponent.prototype, "displayContentRef", void 0);
        __decorate([
            core.ViewChild(MenuTriggerDirective, { static: false }),
            __metadata("design:type", MenuTriggerDirective)
        ], InputDropdownComponent.prototype, "menuTrigger", void 0);
        __decorate([
            core.ViewChild('filterInput', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], InputDropdownComponent.prototype, "filterInputElement", void 0);
        InputDropdownComponent = InputDropdownComponent_1 = __decorate([
            core.Component({
                selector: 'ux-input-dropdown',
                template: "<div class=\"ux-select-container\">\n    <button #button type=\"button\" class=\"form-control\"\n            [uxMenuTriggerFor]=\"menu\">\n        <ng-template #defaultDisplayContent>{{selected ? (selected | json) : '-'}}</ng-template>\n        <ng-container [ngTemplateOutlet]=\"displayContentRef || defaultDisplayContent\"></ng-container>\n    </button>\n    <div class=\"ux-select-icons\">\n        <ux-icon name=\"close\"\n                 uxFocusIndicator\n                 class=\"ux-select-icon ux-select-clear-icon\"\n                 *ngIf=\"allowNull && selected\"\n                 (click)=\"resetValue($event)\"\n                 (keydown.enter)=\"resetValue($event)\"\n                 tabindex=\"0\">\n        </ux-icon>\n        <ux-icon name=\"chevron-down\"\n                 class=\"ux-select-icon ux-select-chevron-icon\"\n                 (click)=\"toggleMenu(); $event.stopPropagation()\">\n        </ux-icon>\n    </div>\n</div>\n\n<ux-menu #menu menuClass=\"select-menu\"\n         (opened)=\"onMenuOpen()\"\n         (closed)=\"onMenuClose()\"\n         [attr.aria-expanded]=\"dropdownOpen\">\n\n    <div [style.max-height]=\"_maxHeight\"\n         [style.width.px]=\"button.offsetWidth\">\n\n        <div *ngIf=\"!hideFilter\"\n             class=\"filter-container\">\n\n            <input #filterInput\n                    type=\"text\"\n                    [placeholder]=\"placeholder\"\n                    class=\"form-control\"\n                    [(ngModel)]=\"_filterText\"\n                    (input)=\"filterChange.emit(_filterText)\"\n                    (click)=\"$event.stopPropagation()\"\n                    [attr.aria-label]=\"ariaLabel || placeholder\"\n                    (focus)=\"inputFocusHandler()\">\n\n            <button type=\"button\"\n                    class=\"btn btn-flat filter-button\"\n                    (click)=\"resetFilter($event)\"\n                    [tabindex]=\"_filterText.length > 0 ? 0 : -1\">\n                <ux-icon [name]=\"_filterText.length === 0 ? 'search' : 'close'\"></ux-icon>\n            </button>\n        </div>\n\n        <ng-content></ng-content>\n\n    </div>\n</ux-menu>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: core.forwardRef(function () { return InputDropdownComponent_1; })
                    }
                ]
            })
        ], InputDropdownComponent);
        return InputDropdownComponent;
    }());
    var InputDropdownModule = /** @class */ (function () {
        function InputDropdownModule() {
        }
        InputDropdownModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, forms.FormsModule, IconModule, MenuModule, AccessibilityModule],
                declarations: [
                    InputDropdownComponent
                ],
                exports: [
                    InputDropdownComponent
                ]
            })
        ], InputDropdownModule);
        return InputDropdownModule;
    }());
    var SidePanelCloseDirective = /** @class */ (function () {
        function SidePanelCloseDirective(_service, _focusOrigin) {
            this._service = _service;
            this._focusOrigin = _focusOrigin;
        }
        SidePanelCloseDirective.prototype.onClick = function (event) {
            // determine the correct origin for the trigger event
            this._focusOrigin.setOrigin(isKeyboardTrigger(event) ? 'keyboard' : 'mouse');
            // close the side panel menu
            this._service.close();
        };
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], SidePanelCloseDirective.prototype, "onClick", null);
        SidePanelCloseDirective = __decorate([
            core.Directive({
                selector: '[uxSidePanelClose]'
            }),
            __metadata("design:paramtypes", [SidePanelService,
                FocusIndicatorOriginService])
        ], SidePanelCloseDirective);
        return SidePanelCloseDirective;
    }());
    var EXPORTS = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = /** @class */ (function () {
        function SidePanelModule() {
        }
        SidePanelModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    a11y.A11yModule,
                    FocusIfModule
                ],
                exports: EXPORTS,
                declarations: EXPORTS
            })
        ], SidePanelModule);
        return SidePanelModule;
    }());
    var SparkComponent = /** @class */ (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: function () {
                return this._theme;
            },
            set: function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: function () {
                return this._trackColor;
            },
            set: function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: function () {
                return this._barColor;
            },
            set: function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: function () {
                return this.values;
            },
            set: function (value) {
                // ensure 'value' is an array at this point
                var values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                var total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the aria label for the spark chart
         */
        SparkComponent.prototype.getAriaLabel = function () {
            if (!Array.isArray(this.ariaLabel)) {
                return this.ariaLabel || this.tooltip;
            }
        };
        /**
         * If this is a multi-value chart and we have multiple aria
         * labels then provide the appropriate label
         */
        SparkComponent.prototype.getSegmentAriaLabel = function (segment) {
            if (Array.isArray(this.ariaLabel)) {
                return this.ariaLabel[segment];
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], SparkComponent.prototype, "barHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "inlineLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "topLeftLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "topRightLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "bottomLeftLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "bottomRightLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "tooltip", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", Object)
        ], SparkComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input('aria-description'),
            __metadata("design:type", String)
        ], SparkComponent.prototype, "ariaDescription", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], SparkComponent.prototype, "theme", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], SparkComponent.prototype, "trackColor", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SparkComponent.prototype, "barColor", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SparkComponent.prototype, "value", null);
        SparkComponent = __decorate([
            core.Component({
                selector: 'ux-spark',
                template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div role=\"progressbar\"\n            [attr.aria-label]=\"getAriaLabel()\"\n            [attr.aria-description]=\"ariaDescription\"\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n            [attr.aria-valuenow]=\"values.length === 1 ? values[0] : undefined\"\n            class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\"\n            [style.height.px]=\"barHeight\"\n            [style.backgroundColor]=\"trackColor\"\n            [uxTooltip]=\"tooltip\">\n\n            <div class=\"ux-spark-bar\"\n                *ngFor=\"let line of values; let idx = index\"\n                [attr.aria-label]=\"getSegmentAriaLabel(idx)\"\n                [style.width.%]=\"line\"\n                [style.backgroundColor]=\"barColor[idx]\">\n            </div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\" [attr.aria-label]=\"ariaLabel\" [attr.aria-description]=\"ariaDescription\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div role=\"progressbar\"\n        [attr.aria-label]=\"getAriaLabel()\"\n        [attr.aria-description]=\"ariaDescription\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n        [attr.aria-valuenow]=\"values.length === 1 ? values[0] : undefined\"\n        class=\"ux-spark ux-spark-theme-{{theme}}\"\n        [class.ux-spark-multi-value]=\"values.length > 1\"\n        [style.height.px]=\"barHeight\"\n        [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n\n        <div class=\"ux-spark-bar\"\n            *ngFor=\"let line of value; let idx = index\"\n            [attr.aria-label]=\"getSegmentAriaLabel(idx)\"\n            [style.width.%]=\"line\"\n            [style.backgroundColor]=\"barColor[idx]\">\n        </div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [ColorService])
        ], SparkComponent);
        return SparkComponent;
    }());
    var SparkModule = /** @class */ (function () {
        function SparkModule() {
        }
        SparkModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    ColorServiceModule,
                    TooltipModule
                ],
                exports: [SparkComponent],
                declarations: [SparkComponent]
            })
        ], SparkModule);
        return SparkModule;
    }());
    var ColumnPickerComponent = /** @class */ (function () {
        function ColumnPickerComponent(
        /** Access the LiveAnnounce to provide accessibility on reordering */
        _liveAnnouncer, 
        /** We are using OnPush change detection so we must manually trigger CD */
        _changeDetectorRef) {
            this._liveAnnouncer = _liveAnnouncer;
            this._changeDetectorRef = _changeDetectorRef;
            /** Define a list of all selected columns */
            this.selected = [];
            /** Define a list of columns that must be selected */
            this.locked = [];
            /** Define a list of columns that are not selected or locked */
            this.deselected = [];
            /** Define a function to get the aria label of reorderable items */
            this.selectedAriaLabel = this.getSelectedAriaLabel;
            /** Define a function that return a column move announcement */
            this.columnMovedAnnouncement = this.getColumnMovedAnnouncement;
            /** Emits when the selected items change */
            this.selectedChange = new core.EventEmitter();
            /** Emits when the deselected items change */
            this.deselectedChange = new core.EventEmitter();
            /** Store the list of deselected columns that can be moved */
            this._deselectedSelection = [];
            /** Store the list of selected columns that can be moved */
            this._selectedSelection = [];
            /** Cache selection during reordering */
            this._selection = [];
        }
        /** Select the currently selected columns */
        ColumnPickerComponent.prototype.addColumns = function (columns) {
            var _this = this;
            if (columns === void 0) {
                columns = this._deselectedSelection;
            }
            // add each item to the selected columns list
            columns.forEach(function (column) { return _this.selected = __spread(_this.selected, [column]); });
            // remove each item from the deselected columns list
            this.deselected = this.deselected.filter(function (column) { return columns.indexOf(column) === -1; });
            // emit the selection changes
            this.selectedChange.emit(this.selected);
            this.deselectedChange.emit(this.deselected);
            // clear the current selection
            this._deselectedSelection = [];
        };
        /** Deselect the currently selected columns */
        ColumnPickerComponent.prototype.removeColumns = function (columns) {
            var _this = this;
            if (columns === void 0) {
                columns = this._selectedSelection;
            }
            // add each item to the deselected columns list
            columns.forEach(function (column) { return _this.deselected = __spread(_this.deselected, [column]); });
            // remove each item from the selected columns list
            this.selected = this.selected.filter(function (column) { return columns.indexOf(column) === -1; });
            // emit the selection changes
            this.selectedChange.emit(this.selected);
            this.deselectedChange.emit(this.deselected);
            // clear the current selection
            this._selectedSelection = [];
        };
        /** Select all deselected columns */
        ColumnPickerComponent.prototype.addAllColumns = function () {
            this.addColumns(this.deselected);
        };
        /** Deselect all selected columns */
        ColumnPickerComponent.prototype.removeAllColumns = function () {
            this.removeColumns(this.selected);
        };
        /** Ensure we don't select while dragging */
        ColumnPickerComponent.prototype.storeSelection = function () {
            this._selection = __spread(this._selectedSelection);
        };
        /** Restore the selection once dragging ends */
        ColumnPickerComponent.prototype.restoreSelection = function () {
            this._selectedSelection = this._selection;
        };
        /** Update when reordering has occured */
        ColumnPickerComponent.prototype.onReorder = function () {
            this.selectedChange.emit(this.selected);
        };
        /** Get an aria label for reorderable items */
        ColumnPickerComponent.prototype.getSelectedAriaLabel = function (column) {
            return column + ". Press Alt up and alt down to reorder.";
        };
        /** Get the announcement to read when a selected column is moved */
        ColumnPickerComponent.prototype.getColumnMovedAnnouncement = function (column, delta) {
            return column + " column moved " + (delta > 0 ? 'down' : 'up');
        };
        /** Perform a reorder with the keyboard */
        ColumnPickerComponent.prototype.move = function (column, delta) {
            var _this = this;
            // perform the move
            var index = this.selected.indexOf(column);
            this.swap(index, index + delta);
            // Announce the move if the order has changed
            if (this.selected.indexOf(column) !== index) {
                this._liveAnnouncer.announce("Column moved " + (delta > 0 ? 'down' : 'up'));
            }
            // emit the changes
            this.selectedChange.emit(this.selected);
            // perform change detection
            this._changeDetectorRef.detectChanges();
            // after the UI has updated focus the element again (ngFor creates new DOM elements)
            setTimeout(function () {
                var columnIndex = _this.selected.indexOf(column);
                var target = _this.selectedElements.toArray()[columnIndex];
                if (target) {
                    // focus the element
                    target.nativeElement.focus();
                }
            });
        };
        /** Provide a trackBy function for the reorderable options */
        ColumnPickerComponent.prototype.selectedTrackBy = function (index, column) {
            return index + column;
        };
        /** Swap two elements in the selected columns array */
        ColumnPickerComponent.prototype.swap = function (source, target) {
            var _a;
            // perform boundary checks
            if (target < 0 || target > this.selected.length - 1) {
                return;
            }
            // create a copy of the array to manipulate
            var selected = __spread(this.selected);
            // swap the array elements
            _a = __read([selected[source], selected[target]], 2), selected[target] = _a[0], selected[source] = _a[1];
            // update the original array
            this.selected = __spread(selected);
        };
        /** Update the order of the items when reordering has changed */
        ColumnPickerComponent.prototype.onReorderChange = function (model) {
            this.selected = __spread(model);
        };
        /** Get the action context, ensuring that functions have a pre-bound context */
        ColumnPickerComponent.prototype._getActionContext = function () {
            return {
                addSelection: this._deselectedSelection,
                removeSelection: this._selectedSelection,
                addColumns: this.addColumns.bind(this),
                removeColumns: this.removeColumns.bind(this),
                addAllColumns: this.addAllColumns.bind(this),
                removeAllColumns: this.removeAllColumns.bind(this)
            };
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], ColumnPickerComponent.prototype, "selected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], ColumnPickerComponent.prototype, "locked", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], ColumnPickerComponent.prototype, "deselected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "selectedTitleTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "deselectedTitleTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "deselectedTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "selectedTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "lockedTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ColumnPickerComponent.prototype, "actionsTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], ColumnPickerComponent.prototype, "selectedAriaLabel", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], ColumnPickerComponent.prototype, "columnMovedAnnouncement", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColumnPickerComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ColumnPickerComponent.prototype, "deselectedChange", void 0);
        __decorate([
            core.ViewChildren('selectedColumn'),
            __metadata("design:type", core.QueryList)
        ], ColumnPickerComponent.prototype, "selectedElements", void 0);
        ColumnPickerComponent = __decorate([
            core.Component({
                selector: 'ux-column-picker',
                template: "<div class=\"column-picker-column\">\n\n    <div class=\"column-picker-stats\">\n\n        <ng-container *ngIf=\"!deselectedTitleTemplate\">\n            {{ _deselectedSelection.length }} of {{ deselected.length }} selected\n        </ng-container>\n\n        <ng-container\n            *ngIf=\"deselectedTitleTemplate\"\n            [ngTemplateOutlet]=\"deselectedTitleTemplate\">\n        </ng-container>\n    </div>\n\n    <div class=\"column-picker-list\" [(uxSelection)]=\"_deselectedSelection\">\n\n        <div *ngFor=\"let column of deselected\"\n             class=\"column-picker-list-item\"\n             [uxSelectionItem]=\"column\">\n\n            <ng-container *ngIf=\"!deselectedTemplate\">{{ column }}</ng-container>\n\n            <ng-container\n                *ngIf=\"deselectedTemplate\"\n                [ngTemplateOutlet]=\"deselectedTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: column }\">\n            </ng-container>\n        </div>\n    </div>\n</div>\n\n<div class=\"column-picker-actions-column\">\n    <!-- Show the default action buttons -->\n    <ng-container *ngIf=\"!actionsTemplate\">\n        <button class=\"btn button-primary btn-block\" [disabled]=\"_deselectedSelection.length === 0\" (click)=\"addColumns()\">\n            <ux-icon name=\"chevron-right\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-primary btn-block m-b-md\" [disabled]=\"_selectedSelection.length === 0\" (click)=\"removeColumns()\">\n            <ux-icon name=\"chevron-left\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-secondary btn-block\" [disabled]=\"deselected.length === 0\" (click)=\"addAllColumns()\">\n            <ux-icon name=\"chevron-right-double\"></ux-icon>\n        </button>\n\n        <button class=\"btn button-secondary btn-block\" [disabled]=\"selected.length === 0\" (click)=\"removeAllColumns()\">\n            <ux-icon name=\"chevron-left-double\"></ux-icon>\n        </button>\n    </ng-container>\n\n    <!-- Allow custom actions template -->\n    <ng-container\n        *ngIf=\"actionsTemplate\"\n        [ngTemplateOutlet]=\"actionsTemplate\"\n        [ngTemplateOutletContext]=\"_getActionContext()\">\n    </ng-container>\n\n</div>\n\n<div class=\"column-picker-column\">\n    <div class=\"column-picker-stats\">\n\n        <ng-container *ngIf=\"!selectedTitleTemplate\">\n            {{ selected.length + locked.length }} columns added\n        </ng-container>\n\n        <ng-container\n            *ngIf=\"selectedTitleTemplate\"\n            [ngTemplateOutlet]=\"selectedTitleTemplate\">\n        </ng-container>\n    </div>\n\n    <div class=\"column-picker-list\">\n\n        <div *ngFor=\"let column of locked\"\n             class=\"column-picker-list-item column-picker-list-item-locked\">\n\n             <ng-container *ngIf=\"!lockedTemplate\">\n                {{ column }} <ux-icon name=\"lock\"></ux-icon>\n            </ng-container>\n\n             <ng-container\n                *ngIf=\"lockedTemplate\"\n                [ngTemplateOutlet]=\"lockedTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: column }\">\n            </ng-container>\n        </div>\n\n        <div [(uxSelection)]=\"_selectedSelection\" uxReorderable [reorderableModel]=\"selected\" (reorderableModelChange)=\"onReorderChange($event)\" (reorderStart)=\"storeSelection()\"\n            (reorderEnd)=\"restoreSelection()\" (reorderEnd)=\"onReorder()\">\n\n            <div *ngFor=\"let column of selected; trackBy: selectedTrackBy; let index = index\"\n                 #selectedColumn\n                 uxFocusIndicator\n                 [programmaticFocusIndicator]=\"true\"\n                 class=\"column-picker-list-item column-picker-list-item-selected\"\n                 [uxSelectionItem]=\"column\"\n                 [uxReorderableModel]=\"column\"\n                 [attr.aria-label]=\"getSelectedAriaLabel(column)\"\n                 (keydown.alt.arrowup)=\"move(column, -1)\"\n                 (keydown.alt.arrowdown)=\"move(column, 1)\">\n\n                 <ng-container *ngIf=\"!selectedTemplate\">\n                    <ux-icon uxReorderableHandle name=\"drag\" class=\"drag-handle-icon\"></ux-icon>\n                    {{ column }}\n                 </ng-container>\n\n                 <ng-container\n                    *ngIf=\"selectedTemplate\"\n                    [ngTemplateOutlet]=\"selectedTemplate\"\n                    [ngTemplateOutletContext]=\"{ $implicit: column }\">\n                </ng-container>\n            </div>\n        </div>\n\n    </div>\n</div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [a11y.LiveAnnouncer,
                core.ChangeDetectorRef])
        ], ColumnPickerComponent);
        return ColumnPickerComponent;
    }());
    var BaseResizableTableService = /** @class */ (function () {
        function BaseResizableTableService() {
            /** Emit an event whenever a column is resized */
            this.onResize$ = new rxjs.Subject();
            /** Store the current width of the table */
            this.tableWidth = 0;
            /** Determine if we are currently resizing */
            this.isResizing$ = new rxjs.BehaviorSubject(false);
            /** Indicate when the columns are ready */
            this.isInitialised$ = new rxjs.BehaviorSubject(false);
            /** Store the percentage widths of each column */
            this.columns = [];
        }
        /** Cleanup when service is disposed */
        BaseResizableTableService.prototype.ngOnDestroy = function () {
            this.onResize$.complete();
        };
        /** Update the resizing state */
        BaseResizableTableService.prototype.setResizing = function (isResizing) {
            this.isResizing$.next(isResizing);
        };
        /** Get the width of a column in a specific unit */
        BaseResizableTableService.prototype.getColumnWidth = function (index, unit, columns) {
            if (columns === void 0) {
                columns = this.columns;
            }
            switch (unit) {
                case ColumnUnit.Percentage:
                    return columns[index];
                case ColumnUnit.Pixel:
                    return (this.tableWidth / 100) * columns[index];
            }
        };
        return BaseResizableTableService;
    }());
    var ColumnUnit;
    (function (ColumnUnit) {
        ColumnUnit[ColumnUnit["Pixel"] = 0] = "Pixel";
        ColumnUnit[ColumnUnit["Percentage"] = 1] = "Percentage";
    })(ColumnUnit || (ColumnUnit = {}));
    var ResizableTableType;
    (function (ResizableTableType) {
        ResizableTableType[ResizableTableType["Standard"] = 0] = "Standard";
        ResizableTableType[ResizableTableType["Expand"] = 1] = "Expand";
    })(ResizableTableType || (ResizableTableType = {}));
    var ResizableTableService = /** @class */ (function (_super) {
        __extends(ResizableTableService, _super);
        function ResizableTableService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** Define the type of resizing we should use */
            _this.type = ResizableTableType.Standard;
            return _this;
        }
        /** Store the size of each column */
        ResizableTableService.prototype.setColumns = function (columns) {
            var _this = this;
            // store the current columns
            this._columns = columns;
            // store the sizes
            this.columns = columns.map(function (column) { return (column.getNaturalWidth() / _this.tableWidth) * 100; });
            // check if there is any overflow
            this.columns = this.ensureNoOverflow(this.columns);
            // ensure all the columns fit
            this._columns.forEach(function (column, idx) {
                if (!column.disabled) {
                    _this.resizeColumn(idx, 0, false);
                }
            });
            // indicate we are now initialised
            if (this.isInitialised$.value === false) {
                this.isInitialised$.next(true);
            }
        };
        /** Set all resizable columns to the same width */
        ResizableTableService.prototype.setUniformWidths = function () {
            var _this = this;
            // set any disabled columns to their specified width
            this.columns = this._columns.map(function (column) { return column.disabled ? (column.getNaturalWidth() / _this.tableWidth) * 100 : 0; });
            // check to see if we've reached 100% of the table width
            var totalWidth = this.columns.reduce(function (partial, columnWidth) { return partial + columnWidth; });
            if (totalWidth > 100) {
                // remove overflow
                this.columns = this.ensureNoOverflow(this.columns);
            }
            else {
                // get the list of resizable columns
                var resizableColumns = this._columns.toArray().filter(function (column) { return !column.disabled; });
                // work out what we need to add to each column to make up the full width
                var newWidth_1 = (100 - totalWidth) / resizableColumns.length;
                // set the non-disabled columns to the new width
                this.columns = this._columns.map(function (column, idx) { return column.disabled ? _this.columns[idx] : newWidth_1; });
            }
            // do the resizing
            this._columns.forEach(function (column, idx) {
                if (!column.disabled) {
                    _this.resizeColumn(idx, 0, false);
                }
            });
        };
        ResizableTableService.prototype.ensureNoOverflow = function (columns) {
            var _this = this;
            // get the total width
            var total = columns.reduce(function (width, column) { return width + column; });
            // if we have no overflow then we don't need to do anything
            if (total <= 100) {
                return columns;
            }
            // if there is overflow identify which columns can be resized
            var variableColumns = this._columns.filter(function (column) { return !column.disabled && _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns) > column.minWidth; });
            // if there are no columns that can be resized then stop here
            if (variableColumns.length === 0) {
                return columns;
            }
            // determine the total width of the variable columns
            var totalWidth = this._columns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns); }, 0);
            // determine to the width of all the variable columns
            var variableColumnsWidth = variableColumns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns); }, 0);
            // determine how much the columns are currently too large (ignoring fixed columns)
            var targetWidth = this.tableWidth - (totalWidth - variableColumnsWidth);
            // determine how much we need to reduce a column by
            var difference = variableColumnsWidth - targetWidth;
            // find the column with the largest size
            var target = variableColumns.reduce(function (widest, column) {
                var columnWidth = _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel, columns);
                var widestWidth = _this.getColumnWidth(widest.getCellIndex(), ColumnUnit$1.Pixel, columns);
                return columnWidth > widestWidth ? column : widest;
            });
            // perform the resize
            columns = this.setColumnWidth(target.getCellIndex(), this.getColumnWidth(target.getCellIndex(), ColumnUnit$1.Pixel, columns) - difference, ColumnUnit$1.Pixel, columns);
            // check if we are still over the limit (allow some variance for javascript double precision)
            if (columns.reduce(function (width, column) { return width + column; }) > 100.01) {
                return this.ensureNoOverflow(columns);
            }
            return columns;
        };
        /** Allow setting the column size in any unit */
        ResizableTableService.prototype.setColumnWidth = function (index, value, unit, columns) {
            if (columns === void 0) {
                columns = this.columns;
            }
            // create a new array so we keep the instance array immutable
            var sizes = __spread(columns);
            switch (unit) {
                case ColumnUnit$1.Percentage:
                    sizes[index] = value;
                    break;
                case ColumnUnit$1.Pixel:
                    sizes[index] = (value / this.tableWidth) * 100;
                    break;
            }
            // update the instance variable
            return sizes;
        };
        /** Resize a column by a specific pixel amount */
        ResizableTableService.prototype.resizeColumn = function (index, delta, isDragging) {
            if (isDragging === void 0) {
                isDragging = true;
            }
            // get the sibling column that will also be resized
            var sibling = this.getSiblingColumn(index);
            // if there is no sibling that can be resized then stop here
            if (!sibling) {
                return;
            }
            // create a new array for the sizes
            var columns = __spread(this.columns);
            // resize the column to the desired size
            columns = this.setColumnWidth(index, Math.round(this.getColumnWidth(index, ColumnUnit$1.Pixel) + delta), ColumnUnit$1.Pixel, columns);
            columns = this.setColumnWidth(sibling, Math.round(this.getColumnWidth(sibling, ColumnUnit$1.Pixel) - delta), ColumnUnit$1.Pixel, columns);
            // if the move is not possible then stop here
            if (!this.isWidthValid(index, this.getColumnWidth(index, ColumnUnit$1.Pixel, columns)) || !this.isWidthValid(sibling, this.getColumnWidth(sibling, ColumnUnit$1.Pixel, columns))) {
                return;
            }
            // check that we add up to exactly 100%
            var total = columns.reduce(function (count, column) { return column + count; }, 0);
            // if the columns to not add to 100 ensure we make them
            if (total !== 100) {
                // get the column with a variable width
                var target = this.getVariableColumn(100 - total);
                if (target && !isDragging) {
                    columns[this._columns.toArray().indexOf(target)] += (100 - total);
                }
                else {
                    columns[index] += (100 - total);
                }
            }
            // store the new sizes
            this.columns = columns;
            // emit the resize event for each column
            this.onResize$.next();
        };
        ResizableTableService.prototype.getVariableColumn = function (delta) {
            var _this = this;
            // get all variable width columns that are not disabled
            var variableColumns = this._columns.filter(function (column) { return !column.isFixedWidth && !column.disabled; });
            // find one that is greater than its min width by enough
            return variableColumns.reverse().find(function (column) { return _this.getColumnWidth(column.getCellIndex(), ColumnUnit$1.Pixel) >= column.minWidth + delta; });
        };
        ResizableTableService.prototype.getColumn = function (index) {
            return this._columns ? this._columns.toArray()[index] : null;
        };
        ResizableTableService.prototype.getColumnDisabled = function (index) {
            return this.getColumn(index) ? this.getColumn(index).disabled : false;
        };
        /** Determine whether a column is above or below its minimum width */
        ResizableTableService.prototype.isWidthValid = function (index, width) {
            // get the column at a given position
            var column = this.getColumnInstance(index);
            // determine if the specified width is greater than the min width
            return column && width >= column.minWidth;
        };
        /** Get the next column in the sequence of columns */
        ResizableTableService.prototype.getSiblingColumn = function (index) {
            // find the first sibling that is not disabled
            for (var idx = index + 1; idx < this.columns.length; idx++) {
                var sibling = this.getColumnInstance(idx);
                if (!sibling || !sibling.disabled) {
                    return idx;
                }
            }
            return null;
        };
        /** Get the column class from our query list */
        ResizableTableService.prototype.getColumnInstance = function (index) {
            return this._columns ? this._columns.toArray()[index] : null;
        };
        ResizableTableService = __decorate([
            core.Injectable()
        ], ResizableTableService);
        return ResizableTableService;
    }(BaseResizableTableService));
    var ColumnUnit$1;
    (function (ColumnUnit) {
        ColumnUnit[ColumnUnit["Pixel"] = 0] = "Pixel";
        ColumnUnit[ColumnUnit["Percentage"] = 1] = "Percentage";
    })(ColumnUnit$1 || (ColumnUnit$1 = {}));
    var RESIZABLE_TABLE_SERVICE_TOKEN = new core.InjectionToken('RESIZABLE_TABLE_SERVICE_TOKEN');
    var ResizableTableCellDirective = /** @class */ (function () {
        function ResizableTableCellDirective(_elementRef, _renderer, _table) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._table = _table;
            /** Unsubscribe from all subscriptions on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        ResizableTableCellDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._minWidth = parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
            // if the table has already been initialised then we should set the initial size
            if (this._table.isInitialised$.value) {
                this.setColumnWidth();
                this.setColumnFlex();
            }
            // update the sizes when columns are resized
            rxjs.combineLatest([this._table.onResize$, this._table.isResizing$]).pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.setColumnWidth();
                _this.setColumnFlex();
            });
        };
        ResizableTableCellDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Get the column index this cell is part of */
        ResizableTableCellDirective.prototype.getCellIndex = function () {
            return this._elementRef.nativeElement.cellIndex;
        };
        /** Set the width of the column */
        ResizableTableCellDirective.prototype.setColumnWidth = function () {
            var width = this._table.isResizing$.value || this._table.getColumnDisabled(this.getCellIndex()) ?
                this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel) + "px" :
                this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%";
            if (this._table.type === ResizableTableType.Expand) {
                var minWidth = Math.max(this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel), this._minWidth);
                this._renderer.setStyle(this._elementRef.nativeElement, 'min-width', minWidth + "px");
            }
            this._renderer.setStyle(this._elementRef.nativeElement, 'width', width);
        };
        /** Set the flex value of the column */
        ResizableTableCellDirective.prototype.setColumnFlex = function () {
            // if we are resizing then always return 'none' to allow free movement
            if (this._table.isResizing$.value || this._table.getColumnDisabled(this.getCellIndex())) {
                this._renderer.setStyle(this._elementRef.nativeElement, 'flex', 'none');
                return;
            }
            var flex = this._table.isInitialised$.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%" : '';
            this._renderer.setStyle(this._elementRef.nativeElement, 'flex', flex);
        };
        ResizableTableCellDirective = __decorate([
            core.Directive({
                selector: '[uxResizableTableCell]'
            }),
            __param(2, core.Inject(RESIZABLE_TABLE_SERVICE_TOKEN)),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2, BaseResizableTableService])
        ], ResizableTableCellDirective);
        return ResizableTableCellDirective;
    }());
    var ResizableTableColumnComponent = /** @class */ (function () {
        function ResizableTableColumnComponent(_elementRef, _table, _renderer) {
            this._elementRef = _elementRef;
            this._table = _table;
            this._renderer = _renderer;
            /** Disabled the column resizing */
            this.disabled = false;
            /** Emit the current column width */
            this.widthChange = new core.EventEmitter();
            /** Determine if this column is a variable width column */
            this.isFixedWidth = false;
            /** Emit when all observables should be unsubscribed */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(ResizableTableColumnComponent.prototype, "width", {
            get: function () {
                return this._width;
            },
            /** Define the width of a column */
            set: function (width) {
                // there may be cases where columns are created with an `*ngFor` and a width
                // may be specified on *some* columns and not others. This this setter will
                // still be called whenever the value is empty and this will mark this column
                // as having a fixed width, even though it doesn't. So we should only proceed
                // whenever there is an actual numeric value passed in.
                if (width === null || width === undefined) {
                    return;
                }
                // ensure width is a valid number
                this._width = coercion.coerceNumberProperty(width);
                // note that this column has a fixed width
                this.isFixedWidth = true;
                // if we have not initialised then set the element width
                if (!this._table.isInitialised$.value) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'width', this._width + "px");
                }
                else {
                    // if it is initialised then resize the column
                    var currentWidth = this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel);
                    // resize the column by the difference in size
                    if (isNaN(currentWidth)) {
                        this._table.resizeColumn(this.getCellIndex(), this._width, false);
                    }
                    else {
                        this._table.resizeColumn(this.getCellIndex(), this._width - currentWidth, false);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableColumnComponent.prototype, "minWidth", {
            /** Get the minimum width allowed by the column */
            get: function () {
                // determine the minimum width of the column based on its computed CSS value
                var computed = parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
                // if it is disabled use its current width - otherwise use its CSS min width if it is valid
                return this.disabled ? this._elementRef.nativeElement.offsetWidth : isNaN(computed) ? 0 : computed;
            },
            enumerable: true,
            configurable: true
        });
        ResizableTableColumnComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // initially emit the size when we have initialised
            this._table.isInitialised$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (isInitialised) { return isInitialised; }))
                .subscribe(function () {
                // get the current min-width
                _this._minWidth = parseFloat(getComputedStyle(_this._elementRef.nativeElement).minWidth);
                var width = _this._table.getColumnWidth(_this.getCellIndex(), ColumnUnit$1.Pixel);
                if (!isNaN(width)) {
                    _this.widthChange.emit(width);
                }
            });
            // ensure the correct width gets emitted on column size change
            this._table.onResize$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.setColumnWidth();
                _this.setColumnFlex();
                // get the current table width
                var width = _this._table.getColumnWidth(_this.getCellIndex(), ColumnUnit$1.Pixel);
                // check if the width actually changed - otherwise don't emit
                if (!isNaN(width) && (_this._width === undefined || Math.max(width, _this._width) - Math.min(width, _this._width) >= 1)) {
                    _this.widthChange.emit(width);
                }
            });
        };
        /** Cleanup when component is destroyed */
        ResizableTableColumnComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Get the natural pixel width of the column */
        ResizableTableColumnComponent.prototype.getNaturalWidth = function () {
            return this._width || this._elementRef.nativeElement.offsetWidth;
        };
        /** When the dragging starts */
        ResizableTableColumnComponent.prototype.onDragStart = function (event) {
            // determine the mouse position within the handle
            this._offset = event.clientX - event.target.getBoundingClientRect().left;
        };
        /** When the mouse is moved */
        ResizableTableColumnComponent.prototype.onDragMove = function (event, handle) {
            // get the current mouse position
            var mouseX = event.pageX - pageXOffset;
            // position of the drag handle
            var left = handle.getBoundingClientRect().left;
            // determine how much the mouse has moved since the last update
            var delta = mouseX - (left + this._offset);
            // perform resizing
            this._table.resizeColumn(this.getCellIndex(), delta);
            // set the resizing state
            this._table.setResizing(true);
        };
        /** When the dragging ends */
        ResizableTableColumnComponent.prototype.onDragEnd = function () {
            this._table.setResizing(false);
        };
        /** Shrink the column when the left arrow key is pressed */
        ResizableTableColumnComponent.prototype.onMoveLeft = function () {
            this._table.resizeColumn(this.getCellIndex(), -10);
        };
        /** Grow the column when the right arrow key is pressed */
        ResizableTableColumnComponent.prototype.onMoveRight = function () {
            this._table.resizeColumn(this.getCellIndex(), 10);
        };
        /** Get the column index this cell is part of */
        ResizableTableColumnComponent.prototype.getCellIndex = function () {
            return this._elementRef.nativeElement.cellIndex;
        };
        /** The percentage width of the column */
        ResizableTableColumnComponent.prototype.setColumnWidth = function () {
            if (this.disabled && this._width !== undefined) {
                this._renderer.setStyle(this._elementRef.nativeElement, 'width', this._width + "px");
                this._renderer.setStyle(this._elementRef.nativeElement, 'max-width', this._width + "px");
                return;
            }
            if (!this._table.isInitialised$.value) {
                return;
            }
            var width = this._table.isResizing$.value ?
                this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel) + "px" :
                this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%";
            if (this._table.type === ResizableTableType.Expand) {
                var minWidth = Math.max(this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Pixel), this._minWidth);
                this._renderer.setStyle(this._elementRef.nativeElement, 'min-width', minWidth + "px");
            }
            this._renderer.setStyle(this._elementRef.nativeElement, 'width', width);
            this._renderer.setStyle(this._elementRef.nativeElement, 'max-width', null);
        };
        /** The flex width of the column */
        ResizableTableColumnComponent.prototype.setColumnFlex = function () {
            // if we are resizing then always return 'none' to allow free movement
            if (this._table.isResizing$.value || this.disabled) {
                this._renderer.setStyle(this._elementRef.nativeElement, 'flex', 'none');
            }
            var flex = this._table.isInitialised$.value ? "0 1 " + this._table.getColumnWidth(this.getCellIndex(), ColumnUnit$1.Percentage) + "%" : '';
            this._renderer.setStyle(this._elementRef.nativeElement, 'flex', flex);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ResizableTableColumnComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], ResizableTableColumnComponent.prototype, "width", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ResizableTableColumnComponent.prototype, "widthChange", void 0);
        ResizableTableColumnComponent = __decorate([
            core.Component({
                selector: '[uxResizableTableColumn]',
                template: "<ng-content></ng-content>\n\n<div #handle\n     uxDrag\n     uxFocusIndicator\n     tabindex=\"0\"\n     aria-label=\"Column resize handle. Use arrow keys to change the column width.\"\n     class=\"ux-resizable-table-column-handle\"\n     *ngIf=\"!disabled\"\n     (onDragStart)=\"onDragStart($event)\"\n     (onDrag)=\"onDragMove($event, handle)\"\n     (onDragEnd)=\"onDragEnd()\"\n     (keydown.ArrowLeft)=\"onMoveLeft()\"\n     (keydown.ArrowRight)=\"onMoveRight()\">\n\n     <div class=\"ux-resizable-table-column-handle-icon\"></div>\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'ux-resizable-table-column'
                }
            }),
            __param(1, core.Inject(RESIZABLE_TABLE_SERVICE_TOKEN)),
            __metadata("design:paramtypes", [core.ElementRef, BaseResizableTableService, core.Renderer2])
        ], ResizableTableColumnComponent);
        return ResizableTableColumnComponent;
    }());
    var BaseResizableTableDirective = /** @class */ (function () {
        function BaseResizableTableDirective(_elementRef, _table, _renderer, resize) {
            var _this = this;
            this._elementRef = _elementRef;
            this._table = _table;
            this._renderer = _renderer;
            /** Unsubscribe from the observables */
            this._onDestroy = new rxjs.Subject();
            /** Store the initialised state of the table */
            this._initialised = false;
            // watch for the table being resized
            resize.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                // store the latest table size
                _table.tableWidth = _this.getScrollWidth();
                // run the initial logic if the table is fully visible
                _this.onTableReady();
            });
        }
        /** Cleanup after the component is destroyed */
        BaseResizableTableDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Set all resizable columns to the same width */
        BaseResizableTableDirective.prototype.setUniformWidths = function () {
            this._table.setUniformWidths();
        };
        /** Get the smallest tbody width taking into account scrollbars (uxFixedHeaderTable) */
        BaseResizableTableDirective.prototype.getScrollWidth = function () {
            return Array.from(this._elementRef.nativeElement.tBodies)
                .reduce(function (width, tbody) { return Math.min(width, tbody.scrollWidth); }, this._elementRef.nativeElement.offsetWidth);
        };
        BaseResizableTableDirective = __decorate([
            __param(1, core.Inject(RESIZABLE_TABLE_SERVICE_TOKEN)),
            __metadata("design:paramtypes", [core.ElementRef, BaseResizableTableService, core.Renderer2, ResizeService])
        ], BaseResizableTableDirective);
        return BaseResizableTableDirective;
    }());
    var ResizableExpandingTableService = /** @class */ (function (_super) {
        __extends(ResizableExpandingTableService, _super);
        function ResizableExpandingTableService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** Define the type of resizing we should use */
            _this.type = ResizableTableType.Expand;
            return _this;
        }
        /** Store the size of each column */
        ResizableExpandingTableService.prototype.setColumns = function (columns) {
            var _this = this;
            // store the current columns
            this._columns = columns;
            // store the sizes
            this.columns = columns.map(function (column) { return (column.getNaturalWidth() / _this.tableWidth) * 100; });
            // ensure all the columns fit
            this._columns.forEach(function (column, idx) {
                if (!column.disabled) {
                    _this.columns = _this.setColumnWidth(idx, _this.columns[idx], ColumnUnit$2.Percentage, _this.columns);
                }
            });
            // indicate we are now initialised
            if (this.isInitialised$.value === false) {
                this.isInitialised$.next(true);
            }
        };
        /** Set all resizable columns to the same width */
        ResizableExpandingTableService.prototype.setUniformWidths = function () {
            var _this = this;
            // set any disabled columns to their specified width
            this.columns = this._columns.map(function (column) { return column.disabled ? (column.getNaturalWidth() / _this.tableWidth) * 100 : 0; });
            // check to see if we've reached 100% of the table width
            var totalWidth = this.columns.reduce(function (partial, columnWidth) { return partial + columnWidth; });
            if (totalWidth > 98) {
                // remove overflow
                this.columns = this.ensureNoOverflow(this.columns);
            }
            else {
                // get the list of resizable columns
                var resizableColumns = this._columns.toArray().filter(function (column) { return !column.disabled; });
                // work out what we need to add to each column to make up the full width
                var newWidth_1 = (98 - totalWidth) / resizableColumns.length;
                // set the non-disabled columns to the new width
                this.columns = this._columns.map(function (column, idx) { return column.disabled ? _this.columns[idx] : newWidth_1; });
            }
            // do the resizing
            this._columns.forEach(function (column, idx) {
                if (!column.disabled) {
                    _this.resizeColumn(idx, 0, false);
                }
            });
        };
        ResizableExpandingTableService.prototype.ensureNoOverflow = function (columns) {
            var _this = this;
            // get the total width
            var total = columns.reduce(function (width, column) { return width + column; });
            // if we have no overflow then we don't need to do anything
            if (total <= 100) {
                return columns;
            }
            // if there is overflow identify which columns can be resized
            var variableColumns = this._columns.filter(function (column) { return !column.disabled && _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns) > column.minWidth; });
            // if there are no columns that can be resized then stop here
            if (variableColumns.length === 0) {
                return columns;
            }
            // determine the total width of the variable columns
            var totalWidth = this._columns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns); }, 0);
            // determine to the width of all the variable columns
            var variableColumnsWidth = variableColumns.reduce(function (width, column) { return width + _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns); }, 0);
            // determine how much the columns are currently too large (ignoring fixed columns)
            var targetWidth = this.tableWidth - (totalWidth - variableColumnsWidth);
            // determine how much we need to reduce a column by
            var difference = variableColumnsWidth - targetWidth;
            // find the column with the largest size
            var target = variableColumns.reduce(function (widest, column) {
                var columnWidth = _this.getColumnWidth(column.getCellIndex(), ColumnUnit$2.Pixel, columns);
                var widestWidth = _this.getColumnWidth(widest.getCellIndex(), ColumnUnit$2.Pixel, columns);
                return columnWidth > widestWidth ? column : widest;
            });
            // perform the resize
            columns = this.setColumnWidth(target.getCellIndex(), this.getColumnWidth(target.getCellIndex(), ColumnUnit$2.Pixel, columns) - difference, ColumnUnit$2.Pixel, columns);
            // check if we are still over the limit (allow some variance for javascript double precision)
            if (columns.reduce(function (width, column) { return width + column; }) > 100.01) {
                return this.ensureNoOverflow(columns);
            }
            return columns;
        };
        /** Allow setting the column size in any unit */
        ResizableExpandingTableService.prototype.setColumnWidth = function (index, value, unit, columns) {
            if (columns === void 0) {
                columns = this.columns;
            }
            // create a new array so we keep the instance array immutable
            var sizes = __spread(columns);
            switch (unit) {
                case ColumnUnit$2.Percentage:
                    sizes[index] = value;
                    break;
                case ColumnUnit$2.Pixel:
                    sizes[index] = (value / this.tableWidth) * 100;
                    break;
            }
            // update the instance variable
            return sizes;
        };
        /** Resize a column by a specific pixel amount */
        ResizableExpandingTableService.prototype.resizeColumn = function (index, delta, isDragging) {
            if (isDragging === void 0) {
                isDragging = true;
            }
            var columns;
            // convert the delta to a percentage value
            var percentageDelta = (delta / this.tableWidth) * 100;
            columns = this.setColumnWidth(index, (this.columns[index] || 0) + percentageDelta, ColumnUnit$2.Percentage, this.columns);
            this.columns = columns;
            // emit the resize event for each column
            this.onResize$.next();
        };
        ResizableExpandingTableService.prototype.getColumn = function (index) {
            return this._columns ? this._columns.toArray()[index] : null;
        };
        ResizableExpandingTableService.prototype.getColumnDisabled = function (index) {
            return this.getColumn(index) ? this.getColumn(index).disabled : false;
        };
        ResizableExpandingTableService = __decorate([
            core.Injectable()
        ], ResizableExpandingTableService);
        return ResizableExpandingTableService;
    }(BaseResizableTableService));
    var ColumnUnit$2;
    (function (ColumnUnit) {
        ColumnUnit[ColumnUnit["Pixel"] = 0] = "Pixel";
        ColumnUnit[ColumnUnit["Percentage"] = 1] = "Percentage";
    })(ColumnUnit$2 || (ColumnUnit$2 = {}));
    var ResizableExpandingTableDirective = /** @class */ (function (_super) {
        __extends(ResizableExpandingTableDirective, _super);
        function ResizableExpandingTableDirective(elementRef, table, renderer, resize, _platformId) {
            var _this = _super.call(this, elementRef, table, renderer, resize) || this;
            _this._platformId = _platformId;
            /** Has horizontal overflow */
            _this._overflowX = false;
            return _this;
        }
        ResizableExpandingTableDirective.prototype.ngAfterViewInit = function () {
            var e_1, _a;
            var _this = this;
            if (common.isPlatformBrowser(this._platformId)) {
                var tableHeaders_1 = this._elementRef.nativeElement.querySelectorAll('thead > tr');
                var _loop_1 = function (body) {
                    rxjs.fromEvent(body, 'scroll').pipe(operators.takeUntil(this_1._onDestroy)).subscribe(function () {
                        Array.from(tableHeaders_1).forEach(function (thead) { return _this._renderer.setStyle(thead, 'margin-left', "-" + body.scrollLeft + "px"); });
                    });
                };
                var this_1 = this;
                try {
                    for (var _b = __values(Array.from(this._elementRef.nativeElement.tBodies)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var body = _c.value;
                        _loop_1(body);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                /** checks if the table is resizing and allows for a class to be added for when moving from
                 overflow to no overflow */
                rxjs.merge(this._table.onResize$, this.columns.changes).pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this._overflowX = _this._elementRef.nativeElement.tBodies[0].scrollWidth > _this._elementRef.nativeElement.tBodies[0].offsetWidth;
                });
            }
        };
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         */
        ResizableExpandingTableDirective.prototype.onTableReady = function () {
            var _this = this;
            // if we have already initialised or the table width is currently 0 then do nothing
            if (this._initialised || this.getScrollWidth() === 0) {
                // if the table has been initialized but the width is now 0
                // for example, due to the element being hidden (eg. in a collapsed accordion)
                // we would need to re-run this logic whenever the width is back over 0
                // to do this we can mark the table as not having been initialized
                if (this._initialised && this.getScrollWidth() === 0) {
                    this._initialised = false;
                }
                return;
            }
            // ensure we initially set the table width
            this._table.tableWidth = this.getScrollWidth();
            // set the columns - prevent expression changed error
            Promise.resolve().then(function () {
                // initially set the columns
                _this._table.setColumns(_this.columns);
                // force relayout to occur to ensure the UI is consistent with the internal state
                _this.updateLayout();
            });
            // watch for any future changes to the columns
            this.columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                return Promise.resolve().then(function () { return _this._table.setColumns(_this.columns); });
            });
            this._initialised = true;
        };
        /** Force the layout to recalculate */
        ResizableExpandingTableDirective.prototype.updateLayout = function () {
            var _this = this;
            Promise.resolve().then(function () { return _this.columns.forEach(function (_column, index) { return _this._table.resizeColumn(index, 0); }); });
        };
        __decorate([
            core.ContentChildren(ResizableTableColumnComponent, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], ResizableExpandingTableDirective.prototype, "columns", void 0);
        ResizableExpandingTableDirective = __decorate([
            core.Directive({
                selector: '[uxResizableExpandingTable]',
                exportAs: 'ux-resizable-expanding-table',
                providers: [
                    {
                        provide: RESIZABLE_TABLE_SERVICE_TOKEN,
                        useClass: ResizableExpandingTableService
                    }
                ],
                host: {
                    'class': 'ux-resizable-expanding-table',
                    '[class.ux-resizable-expanding-table-overflow]': '_overflowX'
                }
            }),
            __param(1, core.Inject(RESIZABLE_TABLE_SERVICE_TOKEN)), __param(4, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [core.ElementRef, ResizableExpandingTableService, core.Renderer2, ResizeService, Object])
        ], ResizableExpandingTableDirective);
        return ResizableExpandingTableDirective;
    }(BaseResizableTableDirective));
    var ResizableTableDirective = /** @class */ (function (_super) {
        __extends(ResizableTableDirective, _super);
        function ResizableTableDirective(elementRef, table, renderer, resize) {
            var _this = _super.call(this, elementRef, table, renderer, resize) || this;
            // we should hide any horizontal overflow when we are resizing
            _this._table.isResizing$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.setOverflow.bind(_this));
            return _this;
        }
        /**
         * If this is being used within a modal the table width may initially be zero. This can cause some issues when it does actually appear
         * visibily on screen. We should only setup the table once we actually have a width/
         */
        ResizableTableDirective.prototype.onTableReady = function () {
            var _this = this;
            // if we have already initialised or the table width is currently 0 then do nothing
            if (this._initialised || this.getScrollWidth() === 0) {
                return;
            }
            // ensure we initially set the table width
            this._table.tableWidth = this.getScrollWidth();
            // set the columns - prevent expression changed error
            Promise.resolve().then(function () {
                // initially set the columns
                _this._table.setColumns(_this.columns);
                // force relayout to occur to ensure the UI is consistent with the internal state
                _this.updateLayout();
            });
            // watch for any future changes to the columns
            this.columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                return Promise.resolve().then(function () { return _this._table.setColumns(_this.columns); });
            });
            this._initialised = true;
        };
        /** Force the layout to recalculate */
        ResizableTableDirective.prototype.updateLayout = function () {
            var _this = this;
            Promise.resolve().then(function () { return _this.columns.forEach(function (_column, index) { return _this._table.resizeColumn(index, 0); }); });
        };
        /**
         * We should hide any horizontal overflow whenever we are resizing, this is because when we are dragging a column
         * we must set the column widths in pixel values as percentages cause some jankiness when moving them. However pixel
         * values are less precise and can in some cases cause overflow, so we should hide overflow when we are resizing
         */
        ResizableTableDirective.prototype.setOverflow = function (isResizing) {
            var _this = this;
            Array.from(this._elementRef.nativeElement.tBodies)
                .forEach(function (tbody) { return _this._renderer.setStyle(tbody, 'overflow-x', isResizing ? 'hidden' : null); });
        };
        __decorate([
            core.ContentChildren(ResizableTableColumnComponent, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], ResizableTableDirective.prototype, "columns", void 0);
        ResizableTableDirective = __decorate([
            core.Directive({
                selector: '[uxResizableTable]',
                exportAs: 'ux-resizable-table',
                providers: [
                    {
                        provide: RESIZABLE_TABLE_SERVICE_TOKEN,
                        useClass: ResizableTableService
                    }
                ],
                host: {
                    class: 'ux-resizable-table'
                }
            }),
            __param(1, core.Inject(RESIZABLE_TABLE_SERVICE_TOKEN)),
            __metadata("design:paramtypes", [core.ElementRef, ResizableTableService, core.Renderer2, ResizeService])
        ], ResizableTableDirective);
        return ResizableTableDirective;
    }(BaseResizableTableDirective));
    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        TableModule = __decorate([
            core.NgModule({
                imports: [
                    a11y.A11yModule,
                    AccessibilityModule,
                    common.CommonModule,
                    DragModule,
                    IconModule,
                    ResizeModule,
                    ReorderableModule,
                    SelectionModule
                ],
                declarations: [
                    ResizableTableDirective,
                    ResizableExpandingTableDirective,
                    ResizableTableColumnComponent,
                    ResizableTableCellDirective,
                    ColumnPickerComponent,
                ],
                exports: [
                    ResizableTableDirective,
                    ResizableExpandingTableDirective,
                    ResizableTableColumnComponent,
                    ResizableTableCellDirective,
                    ColumnPickerComponent,
                ]
            })
        ], TableModule);
        return TableModule;
    }());
    var uniqueId$a = 0;
    var TimelineEventComponent = /** @class */ (function () {
        function TimelineEventComponent() {
            /** Define the id for the event */
            this.id = "ux-timeline-event-" + uniqueId$a++;
        }
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TimelineEventComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TimelineEventComponent.prototype, "badgeColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], TimelineEventComponent.prototype, "badgeTitle", void 0);
        TimelineEventComponent = __decorate([
            core.Component({
                selector: 'ux-timeline-event',
                template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\" [attr.aria-describedby]=\"id\">\r\n    <span>{{ badgeTitle }}</span>\r\n</div>\r\n\r\n<div class=\"timeline-panel\" [id]=\"id\">\r\n    <ng-content></ng-content>\r\n</div>\r\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], TimelineEventComponent);
        return TimelineEventComponent;
    }());
    var TimelineComponent = /** @class */ (function () {
        function TimelineComponent() {
        }
        TimelineComponent = __decorate([
            core.Component({
                selector: 'ux-timeline',
                template: "<div class=\"timeline\">\r\n    <div class=\"timeline-connector\"></div>\r\n    <ux-icon class=\"timeline-arrow\" name=\"chevron-down\"></ux-icon>\r\n    <ng-content></ng-content>\r\n</div>\r\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], TimelineComponent);
        return TimelineComponent;
    }());
    var TimelineModule = /** @class */ (function () {
        function TimelineModule() {
        }
        TimelineModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    IconModule
                ],
                exports: [
                    TimelineComponent,
                    TimelineEventComponent
                ],
                declarations: [
                    TimelineComponent,
                    TimelineEventComponent
                ]
            })
        ], TimelineModule);
        return TimelineModule;
    }());
    var TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    var uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = /** @class */ (function () {
        function ToggleSwitchComponent() {
            /** Provide a default unique id value for the toggle switch */
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            /** Specify a unique id for the element. */
            this.id = this._toggleSwitchId;
            /** Binding for the state of the switch; `true` for "on" and `false` for "off." */
            this.value = false;
            /** Specify a tabindex. */
            this.tabindex = 0;
            /** If set to `false` the switch will not be updated when clicking on it, can be used if something else is updating the state of the switch. */
            this.clickable = true;
            /** If this value is set to `true` then the toggle switch will be disabled. */
            this.disabled = false;
            /** Specify an aria label for the input element */
            this.ariaLabel = '';
            /** Specify an aria labelledby property for the input element */
            this.ariaLabelledby = null;
            /** Emits when `value` has been changed. */
            this.valueChange = new core.EventEmitter();
            /** Determine if the underlying input component has been focused with the keyboard */
            this._focused = false;
            /** Used to inform Angular forms that the component has been touched */
            this.onTouchedCallback = function () { };
            /** Used to inform Angular forms that the component value has changed */
            this.onChangeCallback = function () { };
        }
        ToggleSwitchComponent.prototype.toggle = function () {
            if (!this.disabled && this.clickable) {
                this.value = !this.value;
                // emit the value
                this.valueChange.emit(this.value);
                // update the value if used within a form control
                this.onChangeCallback(this.value);
                // mark the component as touched
                this.onTouchedCallback();
            }
        };
        ToggleSwitchComponent.prototype.writeValue = function (value) {
            this.value = !!value;
        };
        ToggleSwitchComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        ToggleSwitchComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        ToggleSwitchComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ToggleSwitchComponent.prototype, "id", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ToggleSwitchComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ToggleSwitchComponent.prototype, "value", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], ToggleSwitchComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ToggleSwitchComponent.prototype, "clickable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ToggleSwitchComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input('aria-label'),
            __metadata("design:type", String)
        ], ToggleSwitchComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Input('aria-labelledby'),
            __metadata("design:type", String)
        ], ToggleSwitchComponent.prototype, "ariaLabelledby", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], ToggleSwitchComponent.prototype, "valueChange", void 0);
        ToggleSwitchComponent = __decorate([
            core.Component({
                selector: 'ux-toggleswitch',
                template: "<label [attr.for]=\"(id || _toggleSwitchId) + '-input'\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"_focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           uxFocusIndicator\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"(id || _toggleSwitchId) + '-input'\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (indicator)=\"_focused = $event\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                providers: [TOGGLESWITCH_VALUE_ACCESSOR],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], ToggleSwitchComponent);
        return ToggleSwitchComponent;
    }());
    var ToggleSwitchModule = /** @class */ (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    forms.FormsModule
                ],
                exports: [
                    ToggleSwitchComponent
                ],
                declarations: [
                    ToggleSwitchComponent
                ]
            })
        ], ToggleSwitchModule);
        return ToggleSwitchModule;
    }());
    var ToolbarSearchButtonDirective = /** @class */ (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Emit whenever the button is clicked */
            this.clicked = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            /** Get the width of the button element */
            get: function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        ToolbarSearchButtonDirective.prototype.clickHandler = function () {
            this.clicked.emit();
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ToolbarSearchButtonDirective.prototype, "clicked", void 0);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchButtonDirective.prototype, "clickHandler", null);
        ToolbarSearchButtonDirective = __decorate([
            core.Directive({
                selector: '[uxToolbarSearchButton]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ToolbarSearchButtonDirective);
        return ToolbarSearchButtonDirective;
    }());
    var TOOLBAR_SEARCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToolbarSearchFieldDirective; }),
        multi: true
    };
    var ToolbarSearchFieldDirective = /** @class */ (function () {
        function ToolbarSearchFieldDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Emit whenever the escape key is pressed */
            this.cancel = new core.EventEmitter();
            /** Emit whenever the enter key is pressed */
            this.submitted = new core.EventEmitter();
            /** For use with the Forms and ReactiveForms */
            this.onTouchedCallback = function () { };
            /** Call this function with the latest value to update ngModel or formControl name */
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            /** Get the current value of the input control */
            get: function () {
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        ToolbarSearchFieldDirective.prototype.focus = function () {
            var _this = this;
            // mark the control as dirty
            this.onTouchedCallback();
            // focus the input control after a delay to ensure the element is present
            requestAnimationFrame(function () { return _this._elementRef.nativeElement.focus(); });
        };
        ToolbarSearchFieldDirective.prototype.blur = function () {
            var _this = this;
            // blur the input control after a delay to ensure the element is present
            requestAnimationFrame(function () { return _this._elementRef.nativeElement.blur(); });
        };
        /** Clear the input, if we have an ngModel reset its value otherwise just set the input value to empty */
        ToolbarSearchFieldDirective.prototype.clear = function () {
            this.setValue('');
        };
        ToolbarSearchFieldDirective.prototype.onEnter = function () {
            this.submitted.emit(this.text);
        };
        ToolbarSearchFieldDirective.prototype.onEscape = function () {
            this._elementRef.nativeElement.blur();
            this.cancel.emit();
        };
        ToolbarSearchFieldDirective.prototype.onInput = function () {
            this.setValue(this.text);
        };
        /** Update the input value based on ngModel or formControl */
        ToolbarSearchFieldDirective.prototype.writeValue = function (value) {
            this.setValue(value);
        };
        /** Register a function to update form control */
        ToolbarSearchFieldDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /** Register a function to mark form control as touched */
        ToolbarSearchFieldDirective.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /** Update the value in all required places */
        ToolbarSearchFieldDirective.prototype.setValue = function (value) {
            // ngModel/form control can set the default value to null or undefined, which can show in the input. Replace with empty string
            if (!value) {
                value = '';
            }
            // update the form value if there is one in use
            this.onChangeCallback(value);
            // update the content of the input control
            this._elementRef.nativeElement.value = value;
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ToolbarSearchFieldDirective.prototype, "cancel", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ToolbarSearchFieldDirective.prototype, "submitted", void 0);
        __decorate([
            core.HostListener('keydown.enter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchFieldDirective.prototype, "onEnter", null);
        __decorate([
            core.HostListener('keydown.escape'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchFieldDirective.prototype, "onEscape", null);
        __decorate([
            core.HostListener('input'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchFieldDirective.prototype, "onInput", null);
        ToolbarSearchFieldDirective = __decorate([
            core.Directive({
                selector: '[uxToolbarSearchField]',
                providers: [TOOLBAR_SEARCH_VALUE_ACCESSOR]
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ToolbarSearchFieldDirective);
        return ToolbarSearchFieldDirective;
    }());
    var ToolbarSearchComponent = /** @class */ (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _renderer, _platformId) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._renderer = _renderer;
            this._platformId = _platformId;
            /** The direction in which the search box will expand. If the search button is aligned to the right edge of the container, specify left. */
            this.direction = 'right';
            /** Whether the color scheme is inverted. For use when the component is hosted on a dark background, e.g. the masthead. */
            this.inverse = false;
            /** Indicate whether or not the search field should always be expanded */
            this.alwaysExpanded = false;
            /** Emitted when the expanded state changes */
            this.expandedChange = new core.EventEmitter();
            /**
             * Emitted when a search query has been submitted, either by pressing enter when the search field has focus, or by clicking the search button
             * when the search field contains text. The event contains the search text.
             */
            this.search = new core.EventEmitter();
            /** Store the CSS position value as this may change to absolute */
            this._position = 'relative';
            /** Store the active background color */
            this._backgroundColor = 'transparent';
            /** Store the expanded state */
            this._expanded = false;
            /** Unsubscribe from all subscriptions on component destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: function () {
                return this.alwaysExpanded || this._expanded;
            },
            /** Whether the input field is visible. Use this to collapse or expand the control in response to other events. */
            set: function (value) {
                this._expanded = value;
                this.expandedChange.emit(this.expanded);
                if (this.expanded) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            /*
             * The background color of the component. Color names from the Color Palette can be used here.
             * Specify this when a transparent background would cause display issues, such as background items showing through the search field.
             */
            set: function (value) {
                this._backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "_expandedAnimation", {
            /** Return the correct animation based on the expanded state */
            get: function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        ToolbarSearchComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // Subscribe to the submitted event on the input field, triggering the search event
            this.field.submitted.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (text) { return _this.search.emit(text); });
            // Subscribe to cancel events coming from the input field
            this.field.cancel.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.expanded = false; });
            // Subscribe to the button click event
            this.button.clicked.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                _this.expanded && _this.field.text ? _this.search.emit(_this.field.text) : _this.expanded = !_this.expanded;
            });
            // Create placeholder element to avoid changing layout when switching to position: absolute
            // If the platform is a server we dont want to do this as we can't access getComputedStyle
            if (!common.isPlatformServer(this._platformId)) {
                this.createPlaceholder();
            }
        };
        ToolbarSearchComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            /**
             * We programmatically created the placeholder node so Angular is not aware of its existence
             * so we must manually destroy it otherwise the reference will be retained.
             * Note, the `destroyNode` function may be null or undefined as mentioned in the
             * Angular API docs (https://angular.io/api/core/Renderer2#destroyNode) so
             * we must check that the function is available before attempting to call it
            */
            if (this._placeholder && this._renderer && this._renderer.destroyNode) {
                this._renderer.destroyNode(this._placeholder);
            }
        };
        ToolbarSearchComponent.prototype.animationStart = function (event) {
            if (event.toState === 'expanded') {
                this._position = 'absolute';
                this.setPlaceholderVisible(true);
            }
        };
        ToolbarSearchComponent.prototype.animationDone = function (event) {
            if (event.toState === 'collapsed') {
                this._position = 'relative';
                this.setPlaceholderVisible(false);
            }
        };
        /** Programmatically create a placeholder element */
        ToolbarSearchComponent.prototype.createPlaceholder = function () {
            // Get width and height of the component
            var styles = getComputedStyle(this._elementRef.nativeElement);
            // Create invisible div with the same dimensions
            this._placeholder = this._renderer.createElement('div');
            this._renderer.setStyle(this._placeholder, 'display', 'none');
            this._renderer.setStyle(this._placeholder, 'width', this.button.width + 'px');
            this._renderer.setStyle(this._placeholder, 'height', styles.height);
            this._renderer.setStyle(this._placeholder, 'visibility', 'hidden');
            // Add as a sibling
            this._renderer.insertBefore(this._elementRef.nativeElement.parentNode, this._placeholder, this._elementRef.nativeElement);
        };
        /** Update the visibility of the placeholder node */
        ToolbarSearchComponent.prototype.setPlaceholderVisible = function (isVisible) {
            this._renderer.setStyle(this._placeholder, 'display', isVisible ? 'inline-block' : 'none');
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], ToolbarSearchComponent.prototype, "direction", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], ToolbarSearchComponent.prototype, "inverse", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], ToolbarSearchComponent.prototype, "alwaysExpanded", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], ToolbarSearchComponent.prototype, "expanded", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], ToolbarSearchComponent.prototype, "background", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ToolbarSearchComponent.prototype, "expandedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], ToolbarSearchComponent.prototype, "search", void 0);
        __decorate([
            core.ContentChild(ToolbarSearchFieldDirective, { static: true }),
            __metadata("design:type", ToolbarSearchFieldDirective)
        ], ToolbarSearchComponent.prototype, "field", void 0);
        __decorate([
            core.ContentChild(ToolbarSearchButtonDirective, { static: false }),
            __metadata("design:type", ToolbarSearchButtonDirective)
        ], ToolbarSearchComponent.prototype, "button", void 0);
        __decorate([
            core.HostListener('@expanded.start', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchComponent.prototype, "animationStart", null);
        __decorate([
            core.HostListener('@expanded.done', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], ToolbarSearchComponent.prototype, "animationDone", null);
        ToolbarSearchComponent = __decorate([
            core.Component({
                selector: 'ux-toolbar-search',
                template: "<ng-content></ng-content>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('expanded', [
                        animations.state('collapsed', animations.style({ width: '{{initialWidth}}' }), { params: { initialWidth: '30px' } }),
                        animations.state('expanded', animations.style({ width: '100%' })),
                        animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                    ])
                ],
                host: {
                    '[class.expanded]': 'expanded',
                    '[class.left]': 'direction === "left"',
                    '[class.right]': 'direction === "right"',
                    '[class.inverse]': 'inverse',
                    '[style.position]': '_position',
                    '[style.background-color]': '_backgroundColor',
                    '[@expanded]': '_expandedAnimation'
                }
            }),
            __param(3, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [core.ElementRef,
                ColorService,
                core.Renderer2,
                Object])
        ], ToolbarSearchComponent);
        return ToolbarSearchComponent;
    }());
    var DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = /** @class */ (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                exports: DECLARATIONS$6,
                declarations: DECLARATIONS$6,
                providers: [],
            })
        ], ToolbarSearchModule);
        return ToolbarSearchModule;
    }());
    var VirtualForService = /** @class */ (function () {
        function VirtualForService() {
            /** Store the size of each item */
            this.itemSize = 0;
            /** Emit the current dataset */
            this.dataset = new rxjs.ReplaySubject(1);
            /** Emit the visible range */
            this.range = new rxjs.ReplaySubject(1);
        }
        VirtualForService = __decorate([
            core.Injectable()
        ], VirtualForService);
        return VirtualForService;
    }());
    /**
     * This implementation is inspired by the CDK virtual for:
     * https://github.com/angular/material2/blob/master/src/cdk/scrolling/virtual-for-of.ts
     * However the CDK requires a container component which limits use in places such
     * as fixed header tables, so this is a more generic implementation that does not
     * require a parent element but instead uses an attribute on the parent container instead
     */
    var VirtualForDirective = /** @class */ (function () {
        function VirtualForDirective(
        /** A reference to the container element where we will insert elements. */
        _viewContainerRef, 
        /** The template for all items */
        _templateRef, 
        /** Gets the set of Angular differs for detecting changes. */
        _differs, 
        /** Get the renderer to perform DOM manipulation */
        _renderer, 
        /** A service to share values between the container and child elements */
        _virtualScroll) {
            this._viewContainerRef = _viewContainerRef;
            this._templateRef = _templateRef;
            this._differs = _differs;
            this._renderer = _renderer;
            this._virtualScroll = _virtualScroll;
            /** Provide a trackBy function to optimize rendering */
            this.uxVirtualForTrackBy = this.defaultTrackBy;
            /** Indicate whether we need to perform a view update */
            this._isDirty = false;
            /** Store a cache of recently disposed views for reuse */
            this._templateCache = [];
            /** Limit the size of the cache as it can use a lot of memory */
            this._cacheSize = 20;
            /** Unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
            // While marked as optional, it isn't. We do this so we can provide a more helpful error message
            if (!this._virtualScroll) {
                throw new Error('The "uxVirtualFor" directive requires the "uxVirtualForContainer" directive to be added to the parent element.');
            }
        }
        Object.defineProperty(VirtualForDirective.prototype, "uxVirtualForOf", {
            /** Store the list of items to display */
            set: function (dataset) {
                // emit the latest dataset
                this._virtualScroll.dataset.next(dataset);
                // store a local version of the dataset
                this._dataset = dataset;
                // if this is an update and not the initial dataset then we should
                // forcibly redraw the list of items. In cases where the length of
                // the dataset change would trigger a re-renderer as the scroll position
                // would change, however if we are performing sorting then it would not
                // so we must ensure we update everytime the dataset changes.
                if (this._renderedRange) {
                    this.onRangeChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        VirtualForDirective.prototype.ngOnInit = function () {
            var _this = this;
            // update the UI whenever the range changes
            this._virtualScroll.range.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(this.isRangeSame)).subscribe(function (range) {
                _this._renderedRange = range;
                _this.onRangeChange();
            });
        };
        VirtualForDirective.prototype.ngDoCheck = function () {
            if (this._isDirty && this._differ) {
                // check if there area any changes
                var changes = this.getChanges();
                if (changes) {
                    this.applyChanges(changes);
                }
                else {
                    this.updateContexts();
                }
                // now that we have rendered any change we should store this so we don't perform unneeded updates
                this._isDirty = false;
            }
        };
        VirtualForDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** If an itemSize is not specified we need to calculate it */
        VirtualForDirective.prototype.getHeight = function (context, length) {
            // create a temporary view
            var view = this.createView(0);
            // set the implicit value to the item value
            view.context.$implicit = context;
            view.context.count = length;
            view.context.even = true;
            view.context.odd = false;
            view.context.first = true;
            view.context.last = length === 1;
            // run change detection
            view.detectChanges();
            // get the size of the view
            var height = view.rootNodes[0].offsetHeight;
            // destroy the view
            this._viewContainerRef.remove(0);
            view.destroy();
            return height;
        };
        /** Determine if the range has changed (performance optimization) */
        VirtualForDirective.prototype.isRangeSame = function (previous, current) {
            return previous.start === current.start && previous.end === current.end;
        };
        VirtualForDirective.prototype.onRangeChange = function () {
            // store the visible range
            this._renderedItems = this._dataset.slice(this._renderedRange.start, this._renderedRange.end);
            // create the Angular differ if we haven't previously done so
            if (!this._differ) {
                this._differ = this._differs.find(this._renderedItems).create(this.uxVirtualForTrackBy);
            }
            // mark the view for re-render
            this._isDirty = true;
        };
        /** Determine which items have changed */
        VirtualForDirective.prototype.getChanges = function () {
            return this._differ.diff(this._renderedItems);
        };
        /** Insert, move and remove any items within the view */
        VirtualForDirective.prototype.applyChanges = function (changes) {
            var _this = this;
            // Go through each changes and either add or rearrange accordingly
            changes.forEachOperation(function (record, previousIndex, currentIndex) {
                // check if a new item was added
                if (previousIndex === null) {
                    // create the new embedded view
                    var view = _this.createView(currentIndex);
                    // set the implicit value to the item value
                    view.context.$implicit = record.item;
                }
                else if (currentIndex === null) { // check if the item should be removed
                    var view = _this._viewContainerRef.detach(currentIndex);
                    var index = _this._viewContainerRef.indexOf(view);
                    // if there is space in the cache then store the detached view
                    if (_this._templateCache.length < _this._cacheSize) {
                        _this._templateCache.push(view);
                    }
                    else {
                        index === -1 ? view.destroy() : _this._viewContainerRef.remove(index);
                    }
                }
                else { // the position of the item has changed
                    // get the view from its current position
                    var view = _this._viewContainerRef.get(previousIndex);
                    // move it to the new position
                    _this._viewContainerRef.move(view, currentIndex);
                    // update the implicit value (the rest will stay the same)
                    view.context.$implicit = record.item;
                }
            });
            // Ensure the implicit value is correct for any items whose identity changed
            changes.forEachIdentityChange(function (record) {
                var view = _this._viewContainerRef.get(record.currentIndex);
                if (view) {
                    view.context.$implicit = record.item;
                }
            });
            this.updateContexts();
        };
        VirtualForDirective.prototype.updateContexts = function () {
            var _this = this;
            var _loop_1 = function (idx) {
                // get the view at a given position
                var view = this_1._viewContainerRef.get(idx);
                // update the properties
                view.context.index = this_1._renderedRange.start + idx;
                view.context.count = this_1._dataset.length;
                view.context.first = view.context.index === 0;
                view.context.last = view.context.index === view.context.count - 1;
                view.context.even = view.context.index % 2 === 0;
                view.context.odd = !view.context.even;
                // update the position in the DOM
                view.rootNodes.forEach(function (node) {
                    _this._renderer.setStyle(node, 'position', 'absolute');
                    _this._renderer.setStyle(node, 'width', '100%');
                    _this._renderer.setStyle(node, 'top', '0');
                    _this._renderer.setStyle(node, 'transform', "translateY(" + view.context.index * _this._virtualScroll.itemSize + "px");
                });
                view.detectChanges();
            };
            var this_1 = this;
            // update all the other context properties
            for (var idx = 0; idx < this._viewContainerRef.length; idx++) {
                _loop_1(idx);
            }
        };
        VirtualForDirective.prototype.createView = function (index) {
            // get a checked EmbeddedViewRef is there is one
            var cachedTemplate = this._templateCache.pop();
            if (cachedTemplate) {
                // replace existing context with the defaults
                cachedTemplate.context.$implicit = null;
                cachedTemplate.context.index = -1;
                cachedTemplate.context.count = -1;
                cachedTemplate.context.first = false;
                cachedTemplate.context.last = false;
                cachedTemplate.context.even = false;
                cachedTemplate.context.odd = false;
                // insert the view
                this._viewContainerRef.insert(cachedTemplate, index);
                // return the cached EmbeddedViewRef
                return cachedTemplate;
            }
            // otherwise create a new view and insert it
            return this._viewContainerRef.createEmbeddedView(this._templateRef, {
                $implicit: null,
                index: -1,
                count: -1,
                first: false,
                last: false,
                even: false,
                odd: false,
            }, index);
        };
        VirtualForDirective.prototype.defaultTrackBy = function (index) {
            return index;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], VirtualForDirective.prototype, "uxVirtualForOf", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], VirtualForDirective.prototype, "uxVirtualForTrackBy", void 0);
        VirtualForDirective = __decorate([
            core.Directive({
                selector: '[uxVirtualFor][uxVirtualForOf]',
            }),
            __param(4, core.Optional()),
            __metadata("design:paramtypes", [core.ViewContainerRef,
                core.TemplateRef,
                core.IterableDiffers,
                core.Renderer2,
                VirtualForService])
        ], VirtualForDirective);
        return VirtualForDirective;
    }());
    var VirtualForContainerComponent = /** @class */ (function () {
        function VirtualForContainerComponent(
        /** Get the ElementRef of the container element */
        _elementRef, 
        /** A service to share values between the container and child elements */
        _virtualScroll, 
        /** Handle key presses if there is a tabbable list */
        _tabbableList) {
            this._elementRef = _elementRef;
            this._virtualScroll = _virtualScroll;
            this._tabbableList = _tabbableList;
            /** Keep a local reference of the dataset */
            this._dataset = [];
            /** Indicate if the component has finished initialising */
            this._initialized = false;
            /** Unsubscribe from all observables */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(VirtualForContainerComponent.prototype, "itemSize", {
            get: function () {
                return this._virtualScroll.itemSize;
            },
            /** Define the height of each virtual item */
            set: function (itemSize) {
                var _this = this;
                this._virtualScroll.itemSize = itemSize;
                if (this._initialized) {
                    requestAnimationFrame(function () {
                        _this.updateContainer();
                        _this.virtualFor.updateContexts();
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VirtualForContainerComponent.prototype, "_isTable", {
            /** Determine if this is a table */
            get: function () {
                return this._elementRef.nativeElement.tagName === 'TABLE' || this._elementRef.nativeElement.tagName === 'TBODY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VirtualForContainerComponent.prototype, "_isList", {
            /** Determine if this is a list */
            get: function () {
                return this._elementRef.nativeElement.tagName === 'OL' || this._elementRef.nativeElement.tagName === 'UL';
            },
            enumerable: true,
            configurable: true
        });
        VirtualForContainerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // subscribe to changes to the dataset
            this._virtualScroll.dataset.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (dataset) {
                // store the latest dataset
                _this._dataset = dataset;
                // update the container properties
                requestAnimationFrame(function () {
                    _this.updateContainer();
                    // mark the component as ready
                    _this._initialized = true;
                });
            });
        };
        VirtualForContainerComponent.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        VirtualForContainerComponent.prototype.updateContainer = function () {
            if (this.itemSize === 0 && this._dataset.length > 0) {
                this.itemSize = this.virtualFor.getHeight(this._dataset[0], this._dataset.length);
            }
            // calculate the total height of all the items
            this._totalHeight = this._dataset.length * this.itemSize;
            // get the actual height of the container element
            var height = this.getContainerHeight();
            // determine the number of items it takes to fill the container height (multiply by 2 to give us some buffer items)
            var itemCount = Math.ceil((height / this.itemSize) * 2);
            /** Determine the number of items we have as a top buffer */
            var topBufferCount = Math.ceil((height / this.itemSize) * 0.5);
            // get the scroll offset
            var scrollOffset = this.getScrollOffset();
            // determine the start index based on the scroll offset
            var startIdx = Math.max(Math.floor(scrollOffset / this.itemSize) - Math.floor(topBufferCount), 0);
            // determine the end index based on the start and the number of items to display
            var endIdx = Math.min(startIdx + itemCount, this._dataset.length);
            // update the range
            this._range = { start: startIdx, end: endIdx };
            // emit the new visible range
            this._virtualScroll.range.next(this._range);
        };
        /** If cells are automatically getting their height detected you may want to update the size */
        VirtualForContainerComponent.prototype.recalculateCellSize = function () {
            this.itemSize = 0;
        };
        VirtualForContainerComponent.prototype.onKeydown = function (event, keyCode) {
            var _this = this;
            if (!this._tabbableList) {
                return;
            }
            switch (keyCode) {
                case keycodes.PAGE_UP:
                    this._tabbableList.focusKeyManager.setFirstItemActive();
                    event.preventDefault();
                    break;
                case keycodes.PAGE_DOWN:
                    this._tabbableList.focusKeyManager.setLastItemActive();
                    event.preventDefault();
                    break;
                case keycodes.HOME:
                    // ensure the QueryList doesn't do any updates until we have finished
                    this._tabbableList.shouldFocusOnChange = false;
                    // scroll to the top of the container
                    this._elementRef.nativeElement.scrollTop = 0;
                    // after the update the activate the first item
                    requestAnimationFrame(function () {
                        _this._tabbableList.focusKeyManager.setFirstItemActive();
                        _this._tabbableList.shouldFocusOnChange = true;
                    });
                    event.preventDefault();
                    break;
                case keycodes.END:
                    // ensure the QueryList doesn't do any updates until we have finished
                    this._tabbableList.shouldFocusOnChange = false;
                    // scroll to the bottom of the container
                    this._elementRef.nativeElement.scrollTop = this._elementRef.nativeElement.scrollHeight;
                    // after the update the activate the last item
                    requestAnimationFrame(function () {
                        _this._tabbableList.focusKeyManager.setLastItemActive();
                        _this._tabbableList.shouldFocusOnChange = true;
                    });
                    event.preventDefault();
                    break;
            }
        };
        VirtualForContainerComponent.prototype.getScrollOffset = function () {
            return this._elementRef.nativeElement.scrollTop;
        };
        VirtualForContainerComponent.prototype.getContainerHeight = function () {
            return this._elementRef.nativeElement.clientHeight;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], VirtualForContainerComponent.prototype, "itemSize", null);
        __decorate([
            core.ContentChild(VirtualForDirective, { static: false }),
            __metadata("design:type", VirtualForDirective)
        ], VirtualForContainerComponent.prototype, "virtualFor", void 0);
        __decorate([
            core.HostListener('scroll'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], VirtualForContainerComponent.prototype, "updateContainer", null);
        __decorate([
            core.HostListener('keydown', ['$event', '$event.keyCode']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent, Number]),
            __metadata("design:returntype", void 0)
        ], VirtualForContainerComponent.prototype, "onKeydown", null);
        VirtualForContainerComponent = __decorate([
            core.Component({
                selector: '[uxVirtualForContainer]',
                template: "<!-- Display the appropriate top spacer -->\n<tr class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"_isTable\">\n</tr>\n\n<li class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"_isList\">\n</li>\n\n<div class=\"ux-virtual-scroll-spacer\"\n    [style.height.px]=\"_totalHeight\"\n    [style.padding.px]=\"0\"\n    [style.margin.px]=\"0\"\n    [style.border]=\"'none'\"\n    *ngIf=\"!_isTable && !_isList\">\n</div>\n\n\n<ng-content></ng-content>\n",
                providers: [VirtualForService],
                host: {
                    '[style.position]': '"relative"'
                }
            }),
            __param(2, core.Self()), __param(2, core.Optional()),
            __metadata("design:paramtypes", [core.ElementRef,
                VirtualForService,
                TabbableListService])
        ], VirtualForContainerComponent);
        return VirtualForContainerComponent;
    }());
    var VirtualScrollCellDirective = /** @class */ (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective = __decorate([
            core.Directive({
                selector: '[uxVirtualScrollCell]'
            })
        ], VirtualScrollCellDirective);
        return VirtualScrollCellDirective;
    }());
    var VirtualScrollLoadButtonDirective = /** @class */ (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective = __decorate([
            core.Directive({
                selector: '[uxVirtualScrollLoadButton]'
            })
        ], VirtualScrollLoadButtonDirective);
        return VirtualScrollLoadButtonDirective;
    }());
    var VirtualScrollLoadingDirective = /** @class */ (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective = __decorate([
            core.Directive({
                selector: '[uxVirtualScrollLoading]'
            })
        ], VirtualScrollLoadingDirective);
        return VirtualScrollLoadingDirective;
    }());
    var VirtualScrollComponent = /** @class */ (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            /** Provide the collection of items to display */
            this.collection = rxjs.Observable.create();
            /** Indicate whether pages should be loaded on scroll or button click */
            this.loadOnScroll = true;
            /** Emit when we need to load another page */
            this.loading = new core.EventEmitter();
            this.cells = new rxjs.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            this._buffer = 5;
            this._onDestroy = new rxjs.Subject();
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (event) { return _this._height = event.height; });
        }
        VirtualScrollComponent.prototype.ngOnInit = function () {
            if (!this.cellHeight) {
                throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
            }
            // subscribe to the collection
            this.setupObservable();
            // load the first page of data
            this.loadNextPage();
        };
        VirtualScrollComponent.prototype.ngAfterContentInit = function () {
            // re-render cells now that we can display any loading indicator or loading button
            this.renderCells();
        };
        VirtualScrollComponent.prototype.ngOnChanges = function (changes) {
            if (changes.collection && changes.collection.currentValue !== changes.collection.previousValue && !changes.collection.isFirstChange()) {
                this.setupObservable();
                this.reset();
            }
        };
        VirtualScrollComponent.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        VirtualScrollComponent.prototype.setupObservable = function () {
            var _this = this;
            // if there is a current subscription, unsubscribe
            if (this._subscription && this._subscription.unsubscribe) {
                this._subscription.unsubscribe();
            }
            this._subscription = this.collection.subscribe(function (collection) {
                _this.data = __spread(_this.data, collection);
                _this.renderCells();
                _this.isLoading = false;
            }, null, function () {
                _this.loadingComplete = true;
            });
        };
        VirtualScrollComponent.prototype.renderCells = function () {
            this.cells.next(this.getVisibleCells());
            if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                var remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                // if the current cells take up less than the height of the component then load the next page
                if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                    this.loadNextPage();
                }
            }
        };
        VirtualScrollComponent.prototype.getVisibleCells = function () {
            // store the initial element height
            if (!this._height) {
                this._height = this._elementRef.nativeElement.offsetHeight;
            }
            // perform some calculations
            var scrollTop = this._elementRef.nativeElement.scrollTop;
            var startCell = Math.floor(scrollTop / this.cellHeight);
            var endCell = Math.ceil(this._height / this.cellHeight);
            // we want to add some buffer cells on both the top and bottom of the visible list
            var startBuffer = Math.max(0, startCell - this._buffer);
            var endBuffer = startCell + (startCell - startBuffer) + Math.min(this.data.length, endCell + this._buffer);
            // update the scroll position
            this.scrollTop = (scrollTop - (scrollTop % this.cellHeight)) - ((startCell - startBuffer) * this.cellHeight);
            // return a sublist of items visible on the screen
            var cells = this.data.slice(startBuffer, endBuffer);
            // now map these cells to a virtual cell interface
            return cells.map(function (cell, index) { return ({ data: cell, index: startBuffer + index }); });
        };
        VirtualScrollComponent.prototype.getTotalHeight = function () {
            return this.cellHeight * this.data.length;
        };
        VirtualScrollComponent.prototype.loadNextPage = function () {
            this.isLoading = true;
            this.loading.next(this.pageNumber);
            this.pageNumber++;
        };
        VirtualScrollComponent.prototype.reset = function () {
            // reset all values
            this.scrollTop = 0;
            this.data = [];
            this._height = undefined;
            this.pageNumber = 0;
            this.loadingComplete = false;
            // set scroll position
            this._elementRef.nativeElement.scrollTop = 0;
            // clear the current cells
            this.renderCells();
            // reload first page
            this.loadNextPage();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", rxjs.Observable)
        ], VirtualScrollComponent.prototype, "collection", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], VirtualScrollComponent.prototype, "cellHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], VirtualScrollComponent.prototype, "loadOnScroll", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], VirtualScrollComponent.prototype, "loading", void 0);
        __decorate([
            core.ContentChild(VirtualScrollCellDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], VirtualScrollComponent.prototype, "cellTemplate", void 0);
        __decorate([
            core.ContentChild(VirtualScrollLoadingDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], VirtualScrollComponent.prototype, "loadingIndicatorTemplate", void 0);
        __decorate([
            core.ContentChild(VirtualScrollLoadButtonDirective, { read: core.TemplateRef, static: false }),
            __metadata("design:type", core.TemplateRef)
        ], VirtualScrollComponent.prototype, "loadButtonTemplate", void 0);
        __decorate([
            core.HostListener('scroll'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], VirtualScrollComponent.prototype, "renderCells", null);
        VirtualScrollComponent = __decorate([
            core.Component({
                selector: 'ux-virtual-scroll',
                template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell.data, index: cell.index }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n\n</div>"
            }),
            __metadata("design:paramtypes", [core.ElementRef, ResizeService])
        ], VirtualScrollComponent);
        return VirtualScrollComponent;
    }());
    var DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective,
        VirtualForContainerComponent,
        VirtualForDirective,
    ];
    var VirtualScrollModule = /** @class */ (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule,
                    common.CommonModule,
                    ResizeModule
                ],
                exports: DECLARATIONS$7,
                declarations: DECLARATIONS$7
            })
        ], VirtualScrollModule);
        return VirtualScrollModule;
    }());
    var AutoGrowDirective = /** @class */ (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        AutoGrowDirective.prototype.ngAfterViewInit = function () {
            this.update();
        };
        AutoGrowDirective.prototype.update = function () {
            // perform sizing
            this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
            this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
            // get the new total height and element height
            var scrollHeight = this._elementRef.nativeElement.scrollHeight;
            var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
            // determine what the maximum allowed height is
            var maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
            // if there is a max height specifed we want to show the scrollbars
            if (maximum < scrollHeight) {
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
            }
            else {
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
            }
        };
        __decorate([
            core.HostListener('input'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], AutoGrowDirective.prototype, "update", null);
        AutoGrowDirective = __decorate([
            core.Directive({
                selector: '[uxAutoGrow]'
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], AutoGrowDirective);
        return AutoGrowDirective;
    }());
    var AutoGrowModule = /** @class */ (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule = __decorate([
            core.NgModule({
                exports: [AutoGrowDirective],
                declarations: [AutoGrowDirective]
            })
        ], AutoGrowModule);
        return AutoGrowModule;
    }());
    var FixedHeaderTableDirective = /** @class */ (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer, _resizeService) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._resizeService = _resizeService;
            /** Emit when the table tries to load more data */
            this.tablePaging = new core.EventEmitter();
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(FixedHeaderTableDirective.prototype, "dataset", {
            /** Allow dataset changes to trigger re-layout */
            set: function (_dataset) {
                var _this = this;
                requestAnimationFrame(function () { return _this.setLayout(); });
            },
            enumerable: true,
            configurable: true
        });
        FixedHeaderTableDirective.prototype.ngOnInit = function () {
            var _this = this;
            // add class to the table
            this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
            // locate the important elements
            this._tableHead = this._elementRef.nativeElement.querySelector('thead');
            this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
            // bind to scroll events on the table body
            this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
            // resize the table header to account for scrollbar
            this.setLayout();
            // if a resize occurs perform a relayout (this can be useful when displaying tables in modals)
            this._resizeService.addResizeListener(this._elementRef.nativeElement).pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.setLayout(); });
            // trigger the loading of the first page
            this.tablePaging.emit();
        };
        FixedHeaderTableDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        FixedHeaderTableDirective.prototype.getTable = function () {
            return this._elementRef.nativeElement;
        };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         */
        FixedHeaderTableDirective.prototype.setLayout = function () {
            if (!this._tableBody || !this._tableHead) {
                return;
            }
            // calculate the size of the scrollbar
            var scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
            // add padding to the header to account for this
            this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
            // set the desired height of the table body
            this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
        };
        /**
         * Handle scroll events
         */
        FixedHeaderTableDirective.prototype.onScroll = function () {
            // determine if we are scrolled to the bottom and if so load the next page
            var scrollTop = this._tableBody.scrollTop;
            var scrollHeight = this._tableBody.scrollHeight - this._tableBody.offsetHeight;
            var delta = Math.max(scrollTop, scrollHeight) - Math.min(scrollTop, scrollHeight);
            // its possible for the difference to be a value < 1 when we are at the bottom. Account for this:
            if (delta < 1) {
                this.tablePaging.emit();
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], FixedHeaderTableDirective.prototype, "dataset", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FixedHeaderTableDirective.prototype, "tableHeight", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], FixedHeaderTableDirective.prototype, "tablePaging", void 0);
        FixedHeaderTableDirective = __decorate([
            core.Directive({
                selector: '[uxFixedHeaderTable]',
                exportAs: 'ux-fixed-header-table'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                ResizeService])
        ], FixedHeaderTableDirective);
        return FixedHeaderTableDirective;
    }());
    var FixedHeaderTableModule = /** @class */ (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule = __decorate([
            core.NgModule({
                imports: [
                    ResizeModule
                ],
                exports: [
                    FixedHeaderTableDirective
                ],
                declarations: [
                    FixedHeaderTableDirective
                ]
            })
        ], FixedHeaderTableModule);
        return FixedHeaderTableModule;
    }());
    var FloatLabelDirective = /** @class */ (function () {
        function FloatLabelDirective(_elementRef, _renderer, _autofillMonitor) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._autofillMonitor = _autofillMonitor;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
            this._subscription = new rxjs.Subscription();
        }
        Object.defineProperty(FloatLabelDirective.prototype, "input", {
            get: function () {
                return this._input;
            },
            set: function (input) {
                var _this = this;
                // remove any previous autofill subscriptions
                if (this._input) {
                    this._autofillMonitor.stopMonitoring(this._input);
                }
                this._subscription.unsubscribe();
                this._input = input;
                // if the input is null then don't need to subscribe to autofillMonitor
                if (!input) {
                    return;
                }
                // create a new autofillMonitor subscription
                this._subscription = this._autofillMonitor.monitor(input).subscribe(function (event) {
                    if (!_this.raised && event.isAutofilled) {
                        _this.raised = true;
                    }
                    if (_this.raised && !event.isAutofilled && !_this.hasText()) {
                        _this.raised = false;
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        FloatLabelDirective.prototype.ngOnInit = function () {
            this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
            // Check initial input value
            this.raised = this.hasText();
            // Ensure that the `for` attribute is set
            if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
            }
        };
        FloatLabelDirective.prototype.ngOnChanges = function () {
            if (!(this.mode === 'focus' && this._focused)) {
                this.raised = this.hasText();
            }
        };
        FloatLabelDirective.prototype.ngOnDestroy = function () {
            // Unsubscribe event handles
            this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
            this._autofillMonitor.stopMonitoring(this._input);
            this._subscription.unsubscribe();
        };
        FloatLabelDirective.prototype.hasText = function () {
            if (this.value === undefined) {
                return !!this.input.value;
            }
            return !!this.value;
        };
        FloatLabelDirective.prototype.inputFocus = function () {
            if (this.mode === 'focus') {
                this._focused = true;
                this.raised = true;
            }
        };
        FloatLabelDirective.prototype.inputBlur = function () {
            if (this.mode === 'focus') {
                this._focused = false;
                this.raised = this.hasText();
            }
        };
        FloatLabelDirective.prototype.inputChange = function () {
            if (this.mode === 'input') {
                this.raised = this.hasText();
            }
        };
        __decorate([
            core.Input('uxFloatLabel'),
            __metadata("design:type", HTMLInputElement),
            __metadata("design:paramtypes", [HTMLInputElement])
        ], FloatLabelDirective.prototype, "input", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FloatLabelDirective.prototype, "value", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FloatLabelDirective.prototype, "mode", void 0);
        __decorate([
            core.HostBinding('class.ux-float-label-raised'),
            __metadata("design:type", Boolean)
        ], FloatLabelDirective.prototype, "raised", void 0);
        FloatLabelDirective = __decorate([
            core.Directive({
                selector: '[uxFloatLabel]',
                host: {
                    'class': 'ux-float-label'
                }
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                textField.AutofillMonitor])
        ], FloatLabelDirective);
        return FloatLabelDirective;
    }());
    var FloatLabelModule = /** @class */ (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule = __decorate([
            core.NgModule({
                imports: [],
                exports: [FloatLabelDirective],
                declarations: [FloatLabelDirective],
                providers: [],
            })
        ], FloatLabelModule);
        return FloatLabelModule;
    }());
    var HelpCenterService = /** @class */ (function () {
        function HelpCenterService() {
            this.items = new rxjs.BehaviorSubject([]);
        }
        HelpCenterService.prototype.registerItem = function (item) {
            // get the current items
            var items = this.items.getValue();
            // add the new item to the list
            items.push(item);
            // update the observable
            this.items.next(items);
        };
        HelpCenterService.prototype.unregisterItem = function (item) {
            // get the current items
            var items = this.items.getValue();
            // remove the item being unregistered
            items = items.filter(function (itm) { return itm !== item; });
            // update the observable
            this.items.next(items);
        };
        HelpCenterService = __decorate([
            core.Injectable()
        ], HelpCenterService);
        return HelpCenterService;
    }());
    var HelpCenterItemDirective = /** @class */ (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        HelpCenterItemDirective.prototype.ngOnInit = function () {
            // register the item in the service
            this._helpCenterService.registerItem(this.uxHelpCenterItem);
        };
        HelpCenterItemDirective.prototype.ngOnDestroy = function () {
            // remove this item when it is destroyed
            this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], HelpCenterItemDirective.prototype, "uxHelpCenterItem", void 0);
        HelpCenterItemDirective = __decorate([
            core.Directive({ selector: '[uxHelpCenterItem]' }),
            __metadata("design:paramtypes", [HelpCenterService])
        ], HelpCenterItemDirective);
        return HelpCenterItemDirective;
    }());
    /**
     * Note: This is a workaround for the Angular 7 providedIn: 'root'
     * issue.
     *
     * This provider allows us to have only a single instance
     * of the service throughout out entire application
     * regardless of how many times this module is imported.
     */
    function HELP_CENTER_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new HelpCenterService();
    }
    var HELP_CENTER_SERVICE_PROVIDER = {
        provide: HelpCenterService,
        deps: [[new core.Optional(), new core.SkipSelf(), HelpCenterService]],
        useFactory: HELP_CENTER_SERVICE_PROVIDER_FACTORY
    };
    var HelpCenterModule = /** @class */ (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule = __decorate([
            core.NgModule({
                exports: [
                    HelpCenterItemDirective
                ],
                declarations: [
                    HelpCenterItemDirective
                ],
                providers: [
                    HELP_CENTER_SERVICE_PROVIDER
                ]
            })
        ], HelpCenterModule);
        return HelpCenterModule;
    }());
    var HoverActionService = /** @class */ (function () {
        function HoverActionService() {
            this.active = new rxjs.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        HoverActionService.prototype.register = function (action) {
            this._actions.push(action);
        };
        HoverActionService.prototype.unregister = function (action) {
            this._actions = this._actions.filter(function (actn) { return actn !== action; });
        };
        HoverActionService.prototype.setFocusState = function (focus) {
            this._focused = focus;
            this.updateVisibility();
        };
        HoverActionService.prototype.setHoverState = function (hover) {
            this._hovered = hover;
            this.updateVisibility();
        };
        HoverActionService.prototype.updateVisibility = function () {
            this.active.next(this._focused || this._hovered || this.actionHasFocus());
        };
        HoverActionService.prototype.actionHasFocus = function () {
            return !!this.getFocusedAction();
        };
        HoverActionService.prototype.getFocusedAction = function () {
            return this._actions.find(function (action) { return action.focused; });
        };
        HoverActionService = __decorate([
            core.Injectable()
        ], HoverActionService);
        return HoverActionService;
    }());
    var HoverActionContainerDirective = /** @class */ (function () {
        function HoverActionContainerDirective(_elementRef, _managedFocusContainerService, _hoverActionService) {
            this._elementRef = _elementRef;
            this._managedFocusContainerService = _managedFocusContainerService;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            this._onDestroy = new rxjs.Subject();
        }
        HoverActionContainerDirective.prototype.ngOnInit = function () {
            var _this = this;
            // Watch for focus within the container element and manage tabindex of descendants
            this._managedFocusContainerService.register(this._elementRef.nativeElement, this);
            // Track focus and update state for the child directives
            this._managedFocusContainerService.hasFocus(this._elementRef.nativeElement)
                .pipe(operators.takeUntil(this._onDestroy)).subscribe(function (active) {
                _this.active = active;
                _this._hoverActionService.setFocusState(active);
            });
        };
        HoverActionContainerDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this._managedFocusContainerService.unregister(this._elementRef.nativeElement, this);
        };
        HoverActionContainerDirective.prototype.onHover = function () {
            this._hoverActionService.setHoverState(true);
        };
        HoverActionContainerDirective.prototype.onLeave = function () {
            this._hoverActionService.setHoverState(false);
        };
        __decorate([
            core.Input(),
            core.HostBinding('tabindex'),
            __metadata("design:type", Number)
        ], HoverActionContainerDirective.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.hover-action-container-active'),
            __metadata("design:type", Boolean)
        ], HoverActionContainerDirective.prototype, "active", void 0);
        __decorate([
            core.HostListener('mouseenter'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], HoverActionContainerDirective.prototype, "onHover", null);
        __decorate([
            core.HostListener('mouseleave'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], HoverActionContainerDirective.prototype, "onLeave", null);
        HoverActionContainerDirective = __decorate([
            core.Directive({
                selector: '[uxHoverActionContainer]',
                providers: [HoverActionService]
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                ManagedFocusContainerService,
                HoverActionService])
        ], HoverActionContainerDirective);
        return HoverActionContainerDirective;
    }());
    var HoverActionDirective = /** @class */ (function () {
        function HoverActionDirective(_elementRef, _hoverActionService, focusIndicatorService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            this.focused = false;
            this._onDestroy = new rxjs.Subject();
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement);
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this._hoverActionService.active.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (active) { return _this.active = active; });
        }
        HoverActionDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
            this._hoverActionService.unregister(this);
            this._focusIndicator.destroy();
        };
        HoverActionDirective.prototype.focus = function () {
            this._elementRef.nativeElement.focus();
        };
        HoverActionDirective.prototype.onFocus = function () {
            this.focused = true;
            this._hoverActionService.updateVisibility();
        };
        HoverActionDirective.prototype.onBlur = function () {
            this.focused = false;
            this._hoverActionService.updateVisibility();
        };
        __decorate([
            core.Input(),
            core.HostBinding('tabindex'),
            __metadata("design:type", Number)
        ], HoverActionDirective.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.hover-action-active'),
            __metadata("design:type", Boolean)
        ], HoverActionDirective.prototype, "active", void 0);
        __decorate([
            core.HostBinding('class.hover-action-focused'),
            __metadata("design:type", Boolean)
        ], HoverActionDirective.prototype, "focused", void 0);
        __decorate([
            core.HostListener('focus'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], HoverActionDirective.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], HoverActionDirective.prototype, "onBlur", null);
        HoverActionDirective = __decorate([
            core.Directive({
                selector: '[uxHoverAction]'
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                HoverActionService,
                FocusIndicatorService])
        ], HoverActionDirective);
        return HoverActionDirective;
    }());
    var DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = /** @class */ (function () {
        function HoverActionModule() {
        }
        HoverActionModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule
                ],
                exports: DECLARATIONS$8,
                declarations: DECLARATIONS$8
            })
        ], HoverActionModule);
        return HoverActionModule;
    }());
    var LayoutSwitcherItemDirective = /** @class */ (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        LayoutSwitcherItemDirective.prototype.getLayout = function () {
            return this._templateRef;
        };
        LayoutSwitcherItemDirective.prototype.getConfig = function () {
            return this._config;
        };
        LayoutSwitcherItemDirective.prototype.activate = function () {
            this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
        };
        LayoutSwitcherItemDirective.prototype.deactivate = function () {
            var index = this._viewContainerRef.indexOf(this._embeddedView);
            this._viewContainerRef.remove(index);
            this._embeddedView = null;
        };
        __decorate([
            core.Input('uxLayoutSwitcherItem'),
            __metadata("design:type", Object)
        ], LayoutSwitcherItemDirective.prototype, "_config", void 0);
        LayoutSwitcherItemDirective = __decorate([
            core.Directive({
                selector: '[uxLayoutSwitcherItem]'
            }),
            __metadata("design:paramtypes", [core.TemplateRef, core.ViewContainerRef])
        ], LayoutSwitcherItemDirective);
        return LayoutSwitcherItemDirective;
    }());
    var LayoutSwitcherDirective = /** @class */ (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        LayoutSwitcherDirective.prototype.ngOnChanges = function (changes) {
            // if the active group has changed then render the appropriate layout
            if (changes.group.currentValue !== changes.group.previousValue) {
                this.updateActiveLayout();
            }
        };
        LayoutSwitcherDirective.prototype.getActiveLayout = function () {
            var _this = this;
            // if there are currently no layouts then do nothing
            if (!this._layouts) {
                return null;
            }
            // otherwise find layouts that match the active group and that meet the constraints
            return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                var minWidth = layout.getConfig().minWidth || 0;
                var maxWidth = layout.getConfig().maxWidth || Infinity;
                return _this._width >= minWidth && _this._width < maxWidth;
            });
        };
        LayoutSwitcherDirective.prototype.updateActiveLayout = function () {
            // get the layout that should be shown
            var layout = this.getActiveLayout();
            // check if we are currently showing the layout
            if (this._activeLayout === layout) {
                return;
            }
            // remove the current layout
            if (this._activeLayout) {
                this._activeLayout.deactivate();
            }
            // store the new active layout
            this._activeLayout = layout;
            // if there is an active layout then activate
            if (this._activeLayout) {
                this._activeLayout.activate();
            }
        };
        LayoutSwitcherDirective.prototype.ngAfterContentInit = function () {
            // store the initial current element width
            this._width = this._elementRef.nativeElement.offsetWidth;
            // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
            requestAnimationFrame(this.updateActiveLayout.bind(this));
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], LayoutSwitcherDirective.prototype, "group", void 0);
        __decorate([
            core.ContentChildren(LayoutSwitcherItemDirective),
            __metadata("design:type", core.QueryList)
        ], LayoutSwitcherDirective.prototype, "_layouts", void 0);
        LayoutSwitcherDirective = __decorate([
            core.Directive({
                selector: '[uxLayoutSwitcher]'
            }),
            __metadata("design:paramtypes", [core.ElementRef, ResizeService,
                core.ViewContainerRef])
        ], LayoutSwitcherDirective);
        return LayoutSwitcherDirective;
    }());
    var DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = /** @class */ (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule = __decorate([
            core.NgModule({
                imports: [
                    ResizeModule
                ],
                exports: DECLARATIONS$9,
                declarations: DECLARATIONS$9,
                providers: [],
            })
        ], LayoutSwitcherModule);
        return LayoutSwitcherModule;
    }());
    var MenuNavigationService = /** @class */ (function () {
        function MenuNavigationService() {
            /** Store a list of items that belong to this menu */
            this.menuItems = [];
            /** Store the current active menu item */
            this.active$ = new rxjs.BehaviorSubject(null);
        }
        /** Add an item to this menu */
        MenuNavigationService.prototype.register = function (menuItem) {
            this.menuItems = __spread(this.menuItems, [menuItem]);
        };
        /** Remove an item from the list of menu items */
        MenuNavigationService.prototype.unregister = function (menuItem) {
            this.menuItems = this.menuItems.filter(function (_menuItem) { return _menuItem !== menuItem; });
        };
        MenuNavigationService = __decorate([
            core.Injectable()
        ], MenuNavigationService);
        return MenuNavigationService;
    }());
    var MenuNavigationItemDirective = /** @class */ (function () {
        function MenuNavigationItemDirective(_menuNavigationService, _elementRef, focusIndicatorService) {
            var _this = this;
            this._menuNavigationService = _menuNavigationService;
            this._elementRef = _elementRef;
            /** Emit when this menu is activated */
            this.activated = new core.EventEmitter();
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
            // register this item with the menu - this allows for nested menus as we each uxMenuNavigation will create its own service
            _menuNavigationService.register(this);
            // create the focus indicator
            this._focusIndicator = focusIndicatorService.monitor(_elementRef.nativeElement, { programmaticFocusIndicator: true, checkChildren: false });
            /** Subscribe to the current active index */
            _menuNavigationService.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (item) { return item === _this; })).subscribe(function () { return _this.setActive(); });
        }
        MenuNavigationItemDirective.prototype.ngOnDestroy = function () {
            this._menuNavigationService.unregister(this);
            this._onDestroy.unsubscribe();
            this._focusIndicator.destroy();
        };
        MenuNavigationItemDirective.prototype.setActive = function () {
            this._elementRef.nativeElement.focus();
            this.activated.emit();
        };
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuNavigationItemDirective.prototype, "activated", void 0);
        MenuNavigationItemDirective = __decorate([
            core.Directive({
                selector: '[uxMenuNavigationItem]'
            }),
            __metadata("design:paramtypes", [MenuNavigationService, core.ElementRef, FocusIndicatorService])
        ], MenuNavigationItemDirective);
        return MenuNavigationItemDirective;
    }());
    var MenuNavigationToggleDirective = /** @class */ (function () {
        function MenuNavigationToggleDirective(elementRef, focusIndicatorService) {
            /** Define the position the menu appears relative to the button */
            this.menuPosition = 'bottom';
            /** Emit when the menu open state changes */
            this.menuOpenChange = new core.EventEmitter();
            /** Emits whenever a key that opens the menu is pressed */
            this.keyEnter = new core.EventEmitter();
            this._focusIndicator = focusIndicatorService.monitor(elementRef.nativeElement);
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            /** Define if the menu is open */
            get: function () {
                return this._menuOpen;
            },
            set: function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        MenuNavigationToggleDirective.prototype.ngOnDestroy = function () {
            this._focusIndicator.destroy();
        };
        MenuNavigationToggleDirective.prototype.focus = function (origin) {
            this._focusIndicator.focus(origin);
        };
        MenuNavigationToggleDirective.prototype.keydownHandler = function (event) {
            var _this = this;
            if (this.isKeyMatch(event.which)) {
                // Open the menu
                this.menuOpen = true;
                // Allow the menu to init, then send the event to give it focus
                setTimeout(function () { return _this.keyEnter.emit(); });
                event.preventDefault();
                event.stopPropagation();
            }
        };
        MenuNavigationToggleDirective.prototype.isKeyMatch = function (key) {
            switch (key) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    return true;
                case keycodes.UP_ARROW:
                    return this.menuPosition === 'top';
                case keycodes.DOWN_ARROW:
                    return this.menuPosition === 'bottom';
                case keycodes.LEFT_ARROW:
                    return this.menuPosition === 'left';
                case keycodes.RIGHT_ARROW:
                    return this.menuPosition === 'right';
            }
            return false;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], MenuNavigationToggleDirective.prototype, "menuOpen", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuNavigationToggleDirective.prototype, "menuPosition", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuNavigationToggleDirective.prototype, "menuOpenChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuNavigationToggleDirective.prototype, "keyEnter", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], MenuNavigationToggleDirective.prototype, "keydownHandler", null);
        MenuNavigationToggleDirective = __decorate([
            core.Directive({
                selector: '[uxMenuNavigationToggle]',
                exportAs: 'uxMenuNavigationToggle'
            }),
            __metadata("design:paramtypes", [core.ElementRef, FocusIndicatorService])
        ], MenuNavigationToggleDirective);
        return MenuNavigationToggleDirective;
    }());
    var MenuNavigationDirective = /** @class */ (function () {
        function MenuNavigationDirective(_menuNavigationService) {
            this._menuNavigationService = _menuNavigationService;
            /** Define the position of the toggle button relative to the menu */
            this.toggleButtonPosition = 'top';
            /** Emit when the menu is no longer focused */
            this.navigatedOut = new core.EventEmitter();
            /** Determine if the menu currently has focus */
            this._isFocused = false;
            /** Unsubscribe from all observables on destroy */
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            /** Get the index of the currently active item */
            get: function () {
                return this.menuItems.indexOf(this._menuNavigationService.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuNavigationDirective.prototype, "menuItems", {
            // get the list of menu items
            get: function () {
                return this._menuNavigationService.menuItems;
            },
            enumerable: true,
            configurable: true
        });
        MenuNavigationDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this.toggleButton) {
                this.toggleButton.keyEnter.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function () { return _this.focusFirst(); });
            }
        };
        MenuNavigationDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        MenuNavigationDirective.prototype.focusFirst = function () {
            this.moveFirst();
        };
        MenuNavigationDirective.prototype.onFocusIn = function () {
            this._isFocused = true;
        };
        MenuNavigationDirective.prototype.onFocusOut = function () {
            this._isFocused = false;
        };
        MenuNavigationDirective.prototype.keydownHandler = function (event) {
            // Only handle events when focus in within the list of menu items
            if (this._isFocused === false) {
                return;
            }
            var handled = false;
            switch (event.which) {
                case keycodes.UP_ARROW:
                    this.movePrevious(event);
                    handled = true;
                    break;
                case keycodes.DOWN_ARROW:
                    this.moveNext(event);
                    handled = true;
                    break;
                case keycodes.LEFT_ARROW:
                    if (this.toggleButtonPosition === 'left') {
                        this.moveToToggleButton(event);
                        handled = true;
                    }
                    break;
                case keycodes.RIGHT_ARROW:
                    if (this.toggleButtonPosition === 'right') {
                        this.moveToToggleButton(event);
                        handled = true;
                    }
                    break;
                case keycodes.HOME:
                    this.moveFirst();
                    handled = true;
                    break;
                case keycodes.END:
                    this.moveLast();
                    handled = true;
                    break;
                case keycodes.ESCAPE:
                    this.moveToToggleButton(event);
                    handled = true;
                    break;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        MenuNavigationDirective.prototype.moveNext = function (event) {
            // Do nothing if there's no active menu item registered
            if (this.activeIndex < 0) {
                return;
            }
            var nextIndex = this.activeIndex + 1;
            if (nextIndex < this.menuItems.length) {
                // Activate the next menu item
                // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                this._menuNavigationService.active$.next(this.menuItems[nextIndex]);
            }
            else {
                // Check if focus went out of bounds in the direction of the origin toggle button
                if (this.toggleButtonPosition === 'bottom') {
                    this.moveToToggleButton(event);
                }
            }
        };
        MenuNavigationDirective.prototype.movePrevious = function (event) {
            // Do nothing if there's no active menu item registered
            if (this.activeIndex < 0) {
                return;
            }
            var nextIndex = this.activeIndex - 1;
            if (nextIndex >= 0) {
                // Activate the previous menu item
                // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                this._menuNavigationService.active$.next(this.menuItems[nextIndex]);
            }
            else {
                // Check if focus went out of bounds in the direction of the origin toggle button
                if (this.toggleButtonPosition === 'top') {
                    this.moveToToggleButton(event);
                }
            }
        };
        MenuNavigationDirective.prototype.moveFirst = function () {
            if (this.menuItems.length > 0) {
                this._menuNavigationService.active$.next(this.menuItems[0]);
            }
        };
        MenuNavigationDirective.prototype.moveLast = function () {
            if (this.menuItems.length > 0) {
                this._menuNavigationService.active$.next(this.menuItems[this.menuItems.length - 1]);
            }
        };
        MenuNavigationDirective.prototype.moveToToggleButton = function (event) {
            if (this.toggleButton) {
                this.toggleButton.focus('keyboard');
                this.toggleButton.menuOpen = false;
            }
            this.navigatedOut.emit(event);
        };
        __decorate([
            core.Input(),
            __metadata("design:type", MenuNavigationToggleDirective)
        ], MenuNavigationDirective.prototype, "toggleButton", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], MenuNavigationDirective.prototype, "toggleButtonPosition", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], MenuNavigationDirective.prototype, "navigatedOut", void 0);
        __decorate([
            core.HostListener('focusin'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuNavigationDirective.prototype, "onFocusIn", null);
        __decorate([
            core.HostListener('focusout'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MenuNavigationDirective.prototype, "onFocusOut", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], MenuNavigationDirective.prototype, "keydownHandler", null);
        MenuNavigationDirective = __decorate([
            core.Directive({
                selector: '[uxMenuNavigation]',
                exportAs: 'uxMenuNavigation',
                providers: [MenuNavigationService]
            }),
            __metadata("design:paramtypes", [MenuNavigationService])
        ], MenuNavigationDirective);
        return MenuNavigationDirective;
    }());
    var EXPORTS$1 = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = /** @class */ (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule = __decorate([
            core.NgModule({
                imports: [
                    AccessibilityModule
                ],
                exports: EXPORTS$1,
                declarations: EXPORTS$1,
            })
        ], MenuNavigationModule);
        return MenuNavigationModule;
    }());
    var OverflowDirective = /** @class */ (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /** Allow overflow to be within a range before emitting */
            this.tolerance = 0;
            /** Emit when there is a change to the overflow state - horizontal or vertical */
            this.uxOverflowObserver = new core.EventEmitter();
            /** Emit when there is a change to overflow on the horizontal axis */
            this.uxOverflowHorizontalObserver = new core.EventEmitter();
            /** Emit when there is a change to overflow on the vertical axis */
            this.uxOverflowVerticalObserver = new core.EventEmitter();
            /** Store the overflow state on both axis */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /** Unsubscribe from all the observables */
            this._onDestroy = new rxjs.Subject();
        }
        /** Set up the trigger if specified */
        OverflowDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this.trigger) {
                this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
            }
        };
        /** Perform an intial check for overflow */
        OverflowDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            requestAnimationFrame(function () { return _this.checkForOverflow(); });
        };
        /** Unsubscribe from the trigger */
        OverflowDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Programmatically trigger check for overflow */
        OverflowDirective.prototype.checkForOverflow = function () {
            var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
            var horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
            var verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
            if (horizontalOverflow !== this._state.horizontalOverflow) {
                this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
            }
            if (verticalOverflow !== this._state.verticalOverflow) {
                this.uxOverflowVerticalObserver.emit(verticalOverflow);
            }
            if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
            }
            // store the state
            this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
        };
        __decorate([
            core.Input(),
            __metadata("design:type", rxjs.Observable)
        ], OverflowDirective.prototype, "trigger", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], OverflowDirective.prototype, "tolerance", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OverflowDirective.prototype, "uxOverflowObserver", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OverflowDirective.prototype, "uxOverflowHorizontalObserver", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], OverflowDirective.prototype, "uxOverflowVerticalObserver", void 0);
        OverflowDirective = __decorate([
            core.Directive({
                selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                exportAs: 'ux-overflow-observer'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], OverflowDirective);
        return OverflowDirective;
    }());
    var ObserversModule = /** @class */ (function () {
        function ObserversModule() {
        }
        ObserversModule = __decorate([
            core.NgModule({
                exports: [OverflowDirective],
                declarations: [OverflowDirective]
            })
        ], ObserversModule);
        return ObserversModule;
    }());
    var TreeGridState = /** @class */ (function () {
        function TreeGridState(level, setSize, positionInSet) {
            this.level = level;
            this.setSize = setSize;
            this.positionInSet = positionInSet;
            this.loading$ = new rxjs.BehaviorSubject(false);
        }
        return TreeGridState;
    }());
    var TreeGridService = /** @class */ (function () {
        function TreeGridService() {
            var _this = this;
            /** The raw table data */
            this.data$ = new rxjs.BehaviorSubject([]);
            /** The flattened table data */
            this.rows$ = new rxjs.BehaviorSubject([]);
            /** Ensure we destroy all observables correctly */
            this._onDestroy = new rxjs.Subject();
            this.data$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (data) { return _this.rows$.next(_this.getFlattenedTree(data)); });
        }
        /** Unsubscribe from all observables */
        TreeGridService.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        /** Set the expanded state of a row */
        TreeGridService.prototype.setExpanded = function (item, expanded) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!expanded)
                                return [3 /*break*/, 2];
                            return [4 /*yield*/, this.getChildren(item)];
                        case 1:
                            _a.sent();
                            this.insertChildren(item);
                            return [3 /*break*/, 3];
                        case 2:
                            this.removeChildren(item);
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /** A function to flatten tree data */
        TreeGridService.prototype.getFlattenedTree = function (data, parent) {
            var _this = this;
            // flatten the nodes at this level
            return data.reduce(function (previous, item, index) {
                item.state = new TreeGridState(parent ? parent.state.level + 1 : 0, data.length, index + 1);
                // Convert any child nodes
                var children = (item.children && item.expanded) ? _this.getFlattenedTree(item.children, item) : [];
                // return the nodes in a flattened array
                return __spread(previous, [item], children);
            }, []);
        };
        /** Load any children dynamically */
        TreeGridService.prototype.getChildren = function (item) {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!(!item.children && this.loadChildren))
                                return [3 /*break*/, 4];
                            item.state.loading$.next(true);
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, , 3, 4]);
                            _a = item;
                            return [4 /*yield*/, this.getNormalizedChildren(this.loadChildren(item))];
                        case 2:
                            _a.children = _b.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            item.state.loading$.next(false);
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /** We want to support an array, a promise and an observable. This will return all types as a promise */
        TreeGridService.prototype.getNormalizedChildren = function (response) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!rxjs.isObservable(response))
                                return [3 /*break*/, 2];
                            return [4 /*yield*/, response.toPromise()];
                        case 1: return [2 /*return*/, _a.sent()];
                        case 2:
                            if (!(response instanceof Promise))
                                return [3 /*break*/, 4];
                            return [4 /*yield*/, response];
                        case 3: return [2 /*return*/, _a.sent()];
                        case 4:
                            // if it is an array then make it an observable
                            return [2 /*return*/, response];
                    }
                });
            });
        };
        /** Insert the children into the flattened tree at the correct location */
        TreeGridService.prototype.insertChildren = function (parent) {
            if (!parent.children) {
                return;
            }
            var row = this.rows$.getValue();
            var index = row.indexOf(parent);
            if (index < 0) {
                return;
            }
            // Skip duplicates - this could happen if an already expanded child has been inserted
            var uniqueChildren = parent.children.filter(function (child) { return row.indexOf(child) === -1; });
            var childRows = this.getFlattenedTree(uniqueChildren, parent);
            row.splice.apply(row, __spread([index + 1, 0], childRows));
        };
        /** Remove all rows from the flattened tree */
        TreeGridService.prototype.removeChildren = function (parent) {
            var rows = this.rows$.getValue();
            var index = rows.indexOf(parent);
            if (index < 0) {
                return;
            }
            while (index + 1 < rows.length && rows[index + 1].state.level > parent.state.level) {
                rows.splice(index + 1, 1);
            }
        };
        TreeGridService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [])
        ], TreeGridService);
        return TreeGridService;
    }());
    var TreeGridRowDirective = /** @class */ (function () {
        function TreeGridRowDirective(changeDetector, _treeGridService) {
            var _this = this;
            this._treeGridService = _treeGridService;
            this.expandedChange = new core.EventEmitter();
            this.loading = false;
            this.isExpanded = false;
            this._expanded$ = new rxjs.BehaviorSubject(false);
            this._onDestroy = new rxjs.Subject();
            this._expanded$.pipe(operators.skip(1), tick(), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                _this.expandedChange.emit(expanded);
                _this._treeGridService.setExpanded(_this.item, expanded);
                _this.isExpanded = expanded;
                changeDetector.detectChanges();
            });
        }
        Object.defineProperty(TreeGridRowDirective.prototype, "expanded", {
            get: function () {
                return this._expanded$.getValue();
            },
            set: function (expanded) {
                this._expanded$.next(!!expanded);
            },
            enumerable: true,
            configurable: true
        });
        TreeGridRowDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.item || !this.item.state) {
                throw new Error('uxTreeGridRow should be configured with an object emitted by uxTreeGrid.rows.');
            }
            this.item.state.loading$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (loading) { return _this.loading = loading; });
        };
        TreeGridRowDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        TreeGridRowDirective.prototype.collapse = function (event) {
            this.expanded = false;
            if (event) {
                event.preventDefault();
            }
        };
        TreeGridRowDirective.prototype.expand = function (event) {
            // take into account whether or not the item can expanded
            this.expanded = this.canExpand && true;
            if (event) {
                event.preventDefault();
            }
        };
        TreeGridRowDirective.prototype.toggle = function () {
            this.expanded ? this.collapse() : this.expand();
        };
        __decorate([
            core.Input('uxTreeGridRow'),
            __metadata("design:type", Object)
        ], TreeGridRowDirective.prototype, "item", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], TreeGridRowDirective.prototype, "canExpand", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], TreeGridRowDirective.prototype, "expanded", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TreeGridRowDirective.prototype, "expandedChange", void 0);
        __decorate([
            core.HostBinding('class.treegrid-row-loading'),
            __metadata("design:type", Boolean)
        ], TreeGridRowDirective.prototype, "loading", void 0);
        __decorate([
            core.HostBinding('class.treegrid-row-expanded'),
            __metadata("design:type", Boolean)
        ], TreeGridRowDirective.prototype, "isExpanded", void 0);
        __decorate([
            core.HostListener('keydown.ArrowLeft', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Event]),
            __metadata("design:returntype", void 0)
        ], TreeGridRowDirective.prototype, "collapse", null);
        __decorate([
            core.HostListener('keydown.ArrowRight', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Event]),
            __metadata("design:returntype", void 0)
        ], TreeGridRowDirective.prototype, "expand", null);
        TreeGridRowDirective = __decorate([
            core.Directive({
                selector: '[uxTreeGridRow]',
                exportAs: 'uxTreeGridRow',
                host: {
                    '[class.treegrid-row]': 'true'
                }
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef, TreeGridService])
        ], TreeGridRowDirective);
        return TreeGridRowDirective;
    }());
    var TreeGridIndentDirective = /** @class */ (function () {
        function TreeGridIndentDirective(_row) {
            this._row = _row;
        }
        Object.defineProperty(TreeGridIndentDirective.prototype, "indentation", {
            /** The padding value applied to each level */
            get: function () {
                return this._row && this._row.item ? 7 + (this._row.item.state.level * (this.uxTreeGridIndent || 25)) : 7;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], TreeGridIndentDirective.prototype, "uxTreeGridIndent", void 0);
        __decorate([
            core.HostBinding('style.padding-left.px'),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [])
        ], TreeGridIndentDirective.prototype, "indentation", null);
        TreeGridIndentDirective = __decorate([
            core.Directive({
                selector: '[uxTreeGridIndent]',
            }),
            __metadata("design:paramtypes", [TreeGridRowDirective])
        ], TreeGridIndentDirective);
        return TreeGridIndentDirective;
    }());
    var TreeGridDirective = /** @class */ (function () {
        function TreeGridDirective(_treeGridService) {
            this._treeGridService = _treeGridService;
            this.rowsChange = new core.EventEmitter();
            this._onDestroy = new rxjs.Subject();
        }
        Object.defineProperty(TreeGridDirective.prototype, "data", {
            set: function (data) {
                this._treeGridService.data$.next(data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeGridDirective.prototype, "loadChildren", {
            set: function (loadChildren) {
                this._treeGridService.loadChildren = loadChildren;
            },
            enumerable: true,
            configurable: true
        });
        TreeGridDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._treeGridService.rows$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (rows) { return _this.rowsChange.emit(rows); });
        };
        TreeGridDirective.prototype.ngOnDestroy = function () {
            this._onDestroy.next();
            this._onDestroy.complete();
        };
        __decorate([
            core.Input('uxTreeGrid'),
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [Array])
        ], TreeGridDirective.prototype, "data", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], TreeGridDirective.prototype, "loadChildren", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], TreeGridDirective.prototype, "rows", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], TreeGridDirective.prototype, "rowsChange", void 0);
        TreeGridDirective = __decorate([
            core.Directive({
                selector: '[uxTreeGrid]',
                providers: [TreeGridService],
                host: {
                    class: 'treegrid'
                }
            }),
            __metadata("design:paramtypes", [TreeGridService])
        ], TreeGridDirective);
        return TreeGridDirective;
    }());
    var TreeGridModule = /** @class */ (function () {
        function TreeGridModule() {
        }
        TreeGridModule = __decorate([
            core.NgModule({
                declarations: [
                    TreeGridDirective,
                    TreeGridRowDirective,
                    TreeGridIndentDirective
                ],
                exports: [
                    TreeGridDirective,
                    TreeGridRowDirective,
                    TreeGridIndentDirective
                ]
            })
        ], TreeGridModule);
        return TreeGridModule;
    }());
    var StringFilterPipe = /** @class */ (function () {
        function StringFilterPipe() {
        }
        StringFilterPipe.prototype.transform = function (items, value) {
            if (!items) {
                return [];
            }
            return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
        };
        StringFilterPipe = __decorate([
            core.Pipe({
                name: 'stringFilter'
            }),
            core.Injectable()
        ], StringFilterPipe);
        return StringFilterPipe;
    }());
    var StringFilterModule = /** @class */ (function () {
        function StringFilterModule() {
        }
        StringFilterModule = __decorate([
            core.NgModule({
                exports: [StringFilterPipe],
                declarations: [StringFilterPipe]
            })
        ], StringFilterModule);
        return StringFilterModule;
    }());
    var ɵ0 = function onChange() { };
    var timelineDefaultOptions = {
        timeline: {
            backgroundColor: '#f1f2f3',
            selectionColor: 'rgba(198, 23, 157, 0.15)',
            onChange: ɵ0,
            keyboard: {
                step: 2592000000 // 30 days
            },
            handles: {
                backgroundColor: '#000',
                foregroundColor: '#dcdedf',
                focusIndicatorColor: 'rgba(0, 115, 231, 0.5)'
            },
            range: {
                lower: null,
                upper: null,
                minimum: 0,
                maximum: Infinity
            },
            state: {
                lowerHandleFocus: false,
                upperHandleFocus: false,
                rangeHandleFocus: false
            }
        }
    };
    var TimelineChartPlugin = /** @class */ (function () {
        function TimelineChartPlugin() {
        }
        /** Register this plugin */
        TimelineChartPlugin.register = function () {
            /**
             * We have to register this plugin globally because
             * ng2-charts doesn't support plugins on an invidual
             * basis. We must check in all lifecycle hooks that
             * it is an timeline chart before performing any actions.
             *
             * We also need to have it inside the class otherwise it
             * will be included in every application by default.
             * Having it here allows it to be tree-shaken.
             */
            if (!this._isRegistered) {
                if (!window.Chart) {
                    throw new Error('Please import Chart.js to use the timeline chart.');
                }
                // register the plugin
                window.Chart.pluginService.register(new TimelineChartPlugin());
                this._isRegistered = true;
            }
        };
        /**
         * When chart is initialised store the chart instance and context
         * for use outside lifecycle hooks.
         *
         * We should also supply default options for any options that have
         * not been specified by the consuming application.
         *
         * We also need to add some event listeners for events that Chart.js
         * does not inform us of.
         */
        TimelineChartPlugin.prototype.beforeInit = function (chart) {
            var _this = this;
            // provide the default options for any missing properties
            if (this.getEnabled(chart)) {
                // chart.config.options.timeline = { ...timelineDefaultOptions.timeline, ...this.getOptions(chart) };
                chart.config.options.timeline = this.getOptionsWithDefaults(this.getOptions(chart));
                // get the range
                var _a = this.getRange(chart), lower = _a.lower, upper = _a.upper;
                // ensure we have an initial range set
                if (lower === null || upper === null) {
                    throw new Error('Timeline Chart - Ensure that both an upper and lower range are initially provided.');
                }
                // setup the function
                chart.config.options.timeline.state.onMouseDown = function () { return _this.onMouseDown(chart); };
                chart.config.options.timeline.state.onMouseUp = function () { return _this.onMouseUp(chart); };
                // add mouse down and mouseup event listeners
                chart.canvas.addEventListener('mousedown', chart.config.options.timeline.state.onMouseDown);
                document.addEventListener('mouseup', chart.config.options.timeline.state.onMouseUp);
            }
        };
        /**
         * We want to setup some additional functionality
         * after the chart has initialized.
         */
        TimelineChartPlugin.prototype.afterInit = function (chart) {
            if (this.getEnabled(chart)) {
                // add accessibility attributes and elements to the chart
                this.setupAccessibility(chart);
                // intially call the onChange function
                this.triggerOnChange(chart);
            }
        };
        /**
         * The timeline chart should have a subtle background
         * color behind the main chart area (excluding the axis area).
         * Suprisingly Chart.js does not support this out of the box
         * so we need to add this functionality but it should be behind
         * all chart elements.
         */
        TimelineChartPlugin.prototype.beforeDraw = function (chart) {
            if (this.getEnabled(chart)) {
                this.drawBackgroundColor(chart);
            }
        };
        /**
         * Once the Chart elements have been drawn we want to draw the drag
         * handles and the overlay showing the selected region
         */
        TimelineChartPlugin.prototype.afterDraw = function (chart) {
            if (this.getEnabled(chart)) {
                this.drawSelection(chart);
                this.drawHandles(chart);
            }
        };
        /**
         * We want to update the cursor whenever the mouse is over
         * one of the drag handles. We have do calculate this manually
         * as there are no DOM element to add CSS to.
         */
        TimelineChartPlugin.prototype.afterEvent = function (chart, event) {
            // skip this if timeline is not enabled
            if (!this.getEnabled(chart)) {
                return;
            }
            switch (event.type) {
                case 'mousemove':
                    this.setCursor(chart, event);
                    this.setRangeOnDrag(chart, event);
                    // store the latest mouse position
                    this.setState(chart, { mouseX: event.x });
                    break;
                case 'mouseout':
                    this.resetCursor(chart);
                    break;
            }
        };
        /**
         * Unbind from the event listeners we manually set up
         */
        TimelineChartPlugin.prototype.destroy = function (chart) {
            if (this.getEnabled(chart)) {
                document.removeEventListener('mouseup', chart.config.options.timeline.state.onMouseUp, true);
            }
        };
        /** Get the timeline options from the chart instance */
        TimelineChartPlugin.prototype.getOptions = function (chart) {
            return chart.config.options.timeline;
        };
        /** Determine if this chart is using the timeline */
        TimelineChartPlugin.prototype.getEnabled = function (chart) {
            return !!this.getOptions(chart);
        };
        /** Get the timeline range from the chart instance */
        TimelineChartPlugin.prototype.getRange = function (chart) {
            return this.getOptions(chart).range;
        };
        /** Get the chart area but include any padding */
        TimelineChartPlugin.prototype.getChartArea = function (chart) {
            var _a = chart.chartArea, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
            var padding = chart.config.options.layout && chart.config.options.layout.padding ? chart.config.options.layout.padding : 0;
            if (typeof padding === 'number') {
                return { top: top - padding, right: right - padding, left: left - padding, bottom: bottom - padding };
            }
            else if (typeof padding === 'object') {
                return { top: top - padding.top, right: right - padding.right, left: left - padding.left, bottom: bottom - padding.bottom };
            }
            return chart.chartArea;
        };
        /** Get stored state inside the chart options */
        TimelineChartPlugin.prototype.getState = function (chart) {
            return this.getOptions(chart).state;
        };
        /** Store state inside the chart options */
        TimelineChartPlugin.prototype.setState = function (chart, state) {
            // store the latest state
            chart.config.options.timeline.state = __assign(__assign({}, chart.config.options.timeline.state), state);
            // trigger a chart re-render
            chart.update();
        };
        /** Call the callback with the latest range */
        TimelineChartPlugin.prototype.triggerOnChange = function (chart) {
            // get the current date range
            var _a = this.getRange(chart), lower = _a.lower, upper = _a.upper;
            // get the callback function
            var onChange = this.getOptions(chart).onChange;
            // call the callback with the lower and upper values
            requestAnimationFrame(function () { return onChange(lower, upper); });
            // get the handle elements
            var _b = this.getState(chart), lowerHandleElement = _b.lowerHandleElement, upperHandleElement = _b.upperHandleElement;
            // update the aria properties
            lowerHandleElement.setAttribute('aria-valuemin', new Date(this.getHandleMinimum(chart, exports.TimelineHandle.Lower)).toDateString());
            lowerHandleElement.setAttribute('aria-valuenow', lower.toDateString());
            lowerHandleElement.setAttribute('aria-valuemax', new Date(this.getHandleMaximum(chart, exports.TimelineHandle.Lower)).toDateString());
            upperHandleElement.setAttribute('aria-valuemin', new Date(this.getHandleMinimum(chart, exports.TimelineHandle.Upper)).toDateString());
            upperHandleElement.setAttribute('aria-valuenow', upper.toDateString());
            upperHandleElement.setAttribute('aria-valuemax', new Date(this.getHandleMaximum(chart, exports.TimelineHandle.Upper)).toDateString());
        };
        /** To make the chart accessible add some internal elements that can be focused */
        TimelineChartPlugin.prototype.setupAccessibility = function (chart) {
            var _this = this;
            // create the invisible elements
            var lowerHandle = document.createElement('div');
            var upperHandle = document.createElement('div');
            var rangeHandle = document.createElement('div');
            // make the items focusable
            lowerHandle.setAttribute('tabindex', '0');
            upperHandle.setAttribute('tabindex', '0');
            rangeHandle.setAttribute('tabindex', '0');
            // insert the elements
            chart.canvas.appendChild(lowerHandle);
            chart.canvas.appendChild(upperHandle);
            chart.canvas.appendChild(rangeHandle);
            // add the event handlers
            lowerHandle.addEventListener('focus', function () { return _this.setState(chart, { lowerHandleFocus: true }); });
            lowerHandle.addEventListener('blur', function () { return _this.setState(chart, { lowerHandleFocus: false }); });
            lowerHandle.addEventListener('keydown', function (event) { return _this.onKeydown(chart, event, exports.TimelineHandle.Lower); });
            upperHandle.addEventListener('focus', function () { return _this.setState(chart, { upperHandleFocus: true }); });
            upperHandle.addEventListener('blur', function () { return _this.setState(chart, { upperHandleFocus: false }); });
            upperHandle.addEventListener('keydown', function (event) { return _this.onKeydown(chart, event, exports.TimelineHandle.Upper); });
            rangeHandle.addEventListener('focus', function () { return _this.setState(chart, { rangeHandleFocus: true }); });
            rangeHandle.addEventListener('blur', function () { return _this.setState(chart, { rangeHandleFocus: false }); });
            rangeHandle.addEventListener('keydown', function (event) { return _this.onRangeKeydown(chart, event); });
            // store the items in the state object
            this.setState(chart, { lowerHandleElement: lowerHandle, upperHandleElement: upperHandle, rangeHandleElement: rangeHandle });
        };
        /** Handle keyboard accessibility events */
        TimelineChartPlugin.prototype.onKeydown = function (chart, event, handle) {
            // get the current value for the given handle
            var value = this.getHandleValue(chart, handle).getTime();
            var step = this.getOptions(chart).keyboard.step;
            var _a = __read(this.getChartRange(chart), 2), minimum = _a[0], maximum = _a[1];
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this.setHandleValue(chart, handle, new Date(value - step));
                    event.preventDefault();
                    break;
                case keycodes.HOME:
                    this.setHandleValue(chart, handle, new Date(minimum));
                    event.preventDefault();
                    break;
                case keycodes.RIGHT_ARROW:
                    this.setHandleValue(chart, handle, new Date(value + step));
                    event.preventDefault();
                    break;
                case keycodes.END:
                    this.setHandleValue(chart, handle, new Date(maximum));
                    event.preventDefault();
                    break;
            }
        };
        /**
         * Handle range changes made with the keyboard as these are exempt from
         * many of the validation checks that are required when dragging only one
         * handle at a time.
         */
        TimelineChartPlugin.prototype.onRangeKeydown = function (chart, event) {
            // get the current handle values
            var lowerValue = this.getHandleValue(chart, exports.TimelineHandle.Lower).getTime();
            var upperValue = this.getHandleValue(chart, exports.TimelineHandle.Upper).getTime();
            var step = this.getOptions(chart).keyboard.step;
            var difference = upperValue - lowerValue;
            // get the chart boundaries
            var _a = __read(this.getChartRange(chart), 2), minimum = _a[0], maximum = _a[1];
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    lowerValue = Math.max(lowerValue - step, minimum);
                    upperValue = lowerValue + difference;
                    event.preventDefault();
                    break;
                case keycodes.RIGHT_ARROW:
                    upperValue = Math.min(upperValue + step, maximum);
                    lowerValue = upperValue - difference;
                    event.preventDefault();
                    break;
                case keycodes.HOME:
                    lowerValue = minimum;
                    upperValue = lowerValue + difference;
                    event.preventDefault();
                    break;
                case keycodes.END:
                    upperValue = maximum;
                    lowerValue = upperValue - difference;
                    event.preventDefault();
                    break;
            }
            // store the new values
            chart.config.options.timeline.range[exports.TimelineHandle.Lower] = new Date(lowerValue);
            chart.config.options.timeline.range[exports.TimelineHandle.Upper] = new Date(upperValue);
            // update the chart
            chart.update();
            // emit the latest range
            this.triggerOnChange(chart);
        };
        /**
         * When the mouse is first pressed within a chart we should see if we are
         * currently over a drag handle to start the dragging
         */
        TimelineChartPlugin.prototype.onMouseDown = function (chart) {
            // ensure we only proceed when we have a chart context
            if (!chart.ctx) {
                return;
            }
            // get the position from the chart area
            var top = this.getChartArea(chart).top;
            // get the properties from the state
            var mouseX = this.getState(chart).mouseX;
            // check if the event started within a drag handle
            var handle = this.isWithinHandle(chart, { x: mouseX, y: top });
            // if it did then we are now dragging the handle and should store it
            this.setState(chart, { handle: handle !== null ? handle : null });
        };
        /** When the mouse is released we are no longer dragging */
        TimelineChartPlugin.prototype.onMouseUp = function (chart) {
            if (chart.canvas) {
                this.setState(chart, { handle: null });
            }
        };
        /** Update the range when dragged */
        TimelineChartPlugin.prototype.setRangeOnDrag = function (chart, event) {
            var _a = this.getState(chart), handle = _a.handle, mouseX = _a.mouseX;
            // if we are not dragging then do nothing
            if (!handle) {
                return;
            }
            // get the chart area
            var _b = this.getChartArea(chart), left = _b.left, right = _b.right;
            // get the current range
            var _c = this.getRange(chart), lower = _c.lower, upper = _c.upper;
            // get the difference in x position since the last mouse position
            var delta = event.x - mouseX;
            // get the width of the chart area
            var width = right - left;
            // get the time range on the x-axis
            var _d = __read(this.getChartRange(chart), 2), minimum = _d[0], maximum = _d[1];
            // determine how much of the time range was spanned in the move
            var percentageDiff = (delta / width) * 100;
            // calculate the time difference in the movement
            var valueDiff = (((maximum - minimum) / 100) * percentageDiff);
            if (handle === exports.TimelineHandle.Lower) {
                this.setHandleValue(chart, exports.TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
            }
            if (handle === exports.TimelineHandle.Upper) {
                this.setHandleValue(chart, exports.TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
            }
            if (handle === exports.TimelineHandle.Range) {
                // get the current range
                var range = upper.getTime() - lower.getTime();
                // update the values
                if (valueDiff < 0) {
                    this.setHandleValue(chart, exports.TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
                    this.setHandleValue(chart, exports.TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
                }
                else {
                    this.setHandleValue(chart, exports.TimelineHandle.Lower, new Date(lower.getTime() + valueDiff));
                    this.setHandleValue(chart, exports.TimelineHandle.Upper, new Date(upper.getTime() + valueDiff));
                }
                // calculate the new range
                var currentRange = chart.config.options.timeline.range.upper.getTime() - chart.config.options.timeline.range.lower.getTime();
                // ensure the range is still the same
                if (currentRange !== range) {
                    if (valueDiff < 0) {
                        this.setHandleValue(chart, exports.TimelineHandle.Upper, new Date(chart.config.options.timeline.range.upper.getTime() + (range - currentRange)));
                    }
                    else {
                        this.setHandleValue(chart, exports.TimelineHandle.Lower, new Date(chart.config.options.timeline.range.lower.getTime() + (currentRange - range)));
                    }
                }
            }
        };
        /**
         * Draw the background color in the region that sits behind all the chart content
         */
        TimelineChartPlugin.prototype.drawBackgroundColor = function (chart) {
            // get the region that the chart is drawn on (excluding axis)
            var _a = this.getChartArea(chart), top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
            // fill the background color
            chart.ctx.save();
            chart.ctx.fillStyle = this.getOptions(chart).backgroundColor;
            chart.ctx.fillRect(left, top, right - left, bottom - top);
            chart.ctx.restore();
        };
        /** Draw the overlay that indicates the selected region */
        TimelineChartPlugin.prototype.drawSelection = function (chart) {
            // get the region that the chart is drawn on (excluding axis)
            var _a = this.getChartArea(chart), top = _a.top, bottom = _a.bottom;
            // get the fill color
            var selectionColor = this.getOptions(chart).selectionColor;
            // get the focus indicator color
            var focusIndicatorColor = this.getOptions(chart).handles.focusIndicatorColor;
            // get the lower and upper handle render regions
            var lower = this.getHandleArea(chart, exports.TimelineHandle.Lower);
            var upper = this.getHandleArea(chart, exports.TimelineHandle.Upper);
            // draw selection region
            chart.ctx.save();
            chart.ctx.fillStyle = selectionColor;
            chart.ctx.fillRect(lower.left, 0, upper.right - lower.left, bottom - top);
            // check if we are focused on the range handle
            if (this.isHandleFocused(chart, exports.TimelineHandle.Range)) {
                chart.ctx.strokeStyle = focusIndicatorColor;
                var handleWidth = 4;
                var lineWidth = 2;
                chart.ctx.lineWidth = lineWidth;
                chart.ctx.strokeRect(lower.left + handleWidth + lineWidth, lineWidth / 2, (upper.right - lower.left) - ((handleWidth + lineWidth) * 2), (bottom - top) - lineWidth);
            }
            chart.ctx.restore();
        };
        /** Darw the drag handles */
        TimelineChartPlugin.prototype.drawHandles = function (chart) {
            var _this = this;
            // get the region that the chart is drawn on (excluding axis)
            var _a = this.getChartArea(chart), top = _a.top, bottom = _a.bottom;
            // get the handle colors
            var _b = this.getOptions(chart).handles, backgroundColor = _b.backgroundColor, foregroundColor = _b.foregroundColor, focusIndicatorColor = _b.focusIndicatorColor;
            // draw each handle
            [exports.TimelineHandle.Lower, exports.TimelineHandle.Upper].forEach(function (handle) {
                // get the area of the handle
                var area = _this.getHandleArea(chart, handle);
                var handleWidth = 5;
                var chartHeight = bottom - top;
                chart.ctx.save();
                // if the handle is focused draw an outline
                if (_this.isHandleFocused(chart, handle)) {
                    chart.ctx.fillStyle = focusIndicatorColor;
                    chart.ctx.fillRect(area.left - 2, 0, handleWidth + 4, chartHeight);
                }
                // draw the handle
                chart.ctx.fillStyle = backgroundColor;
                chart.ctx.fillRect(area.left, 0, handleWidth, chartHeight);
                // draw the 3 drag handles within the drag handle
                chart.ctx.fillStyle = foregroundColor;
                // calculate size and position
                var width = 3;
                var height = 3;
                var x = area.left + (handleWidth - width) / 2;
                var midpoint = area.top + (chartHeight / 2);
                var topY = midpoint - (height * 2.5);
                var middleY = midpoint - (height / 2);
                var bottomY = midpoint + (height * 1.5);
                chart.ctx.fillRect(x, topY, width, height);
                chart.ctx.fillRect(x, middleY, width, height);
                chart.ctx.fillRect(x, bottomY, width, height);
                chart.ctx.restore();
            });
        };
        /**
         * Update the CSS cursor on the canvas element if we are hovering over a drag handle
         */
        TimelineChartPlugin.prototype.setCursor = function (chart, event) {
            // get the handle if we are hovering over one
            var handle = this.getState(chart).handle || this.isWithinHandle(chart, event);
            if (handle === exports.TimelineHandle.Lower || handle === exports.TimelineHandle.Upper) {
                chart.canvas.style.cursor = 'ew-resize';
            }
            else if (handle === exports.TimelineHandle.Range) {
                chart.canvas.style.cursor = 'move';
            }
            else {
                this.resetCursor(chart);
            }
        };
        // restore the cursor to the default
        TimelineChartPlugin.prototype.resetCursor = function (chart) {
            if (chart.canvas.style.cursor !== '') {
                chart.canvas.style.cursor = '';
            }
        };
        TimelineChartPlugin.prototype.isHandleFocused = function (chart, handle) {
            if (handle === exports.TimelineHandle.Lower) {
                return this.getState(chart).lowerHandleFocus;
            }
            if (handle === exports.TimelineHandle.Upper) {
                return this.getState(chart).upperHandleFocus;
            }
            if (handle === exports.TimelineHandle.Range) {
                return this.getState(chart).rangeHandleFocus;
            }
            return false;
        };
        /** Determine if a position is within one of the drag handles */
        TimelineChartPlugin.prototype.isWithinHandle = function (chart, event) {
            // get the lower and upper handle render regions
            var lower = this.getHandleArea(chart, exports.TimelineHandle.Lower);
            var upper = this.getHandleArea(chart, exports.TimelineHandle.Upper);
            // get the position co-ordinates
            var x = event.x, y = event.y;
            if (x >= lower.left && x <= lower.right && y >= lower.top && y <= lower.bottom) {
                return exports.TimelineHandle.Lower;
            }
            if (x >= upper.left && x <= upper.right && y >= upper.top && y <= upper.bottom) {
                return exports.TimelineHandle.Upper;
            }
            if (x > lower.right && x < upper.left && y >= lower.top && y <= lower.bottom) {
                return exports.TimelineHandle.Range;
            }
            return null;
        };
        /** Get the area a specific handle covers within the chart */
        TimelineChartPlugin.prototype.getHandleArea = function (chart, handle) {
            // get the region that the chart is drawn on (excluding axis)
            var _a = this.getChartArea(chart), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;
            // perform some calculations on the chart area
            var width = right - left;
            // get the minimum and maximum ticks on the chart
            var _b = __read(this.getChartRange(chart), 2), minimum = _b[0], maximum = _b[1];
            // get the lower and upper range values
            var _c = this.getOptions(chart).range, lower = _c.lower, upper = _c.upper;
            if (handle === exports.TimelineHandle.Lower) {
                var percentage = ((lower.getTime() - minimum) / (maximum - minimum) * 100);
                var position = left + ((width / 100) * percentage);
                return { top: top, left: position - 5, right: position, bottom: bottom };
            }
            if (handle === exports.TimelineHandle.Upper) {
                var percentage = ((upper.getTime() - minimum) / (maximum - minimum) * 100);
                var position = left + ((width / 100) * percentage);
                return { top: top, left: position, right: position + 5, bottom: bottom };
            }
        };
        /**
         * Get the minimum and maximum values on the x-axis
         */
        TimelineChartPlugin.prototype.getChartRange = function (chart) {
            // get the current data
            var data = chart.getDatasetMeta(0).data;
            // get the range on the x-axis
            var minimum = data[0]._xScale.min;
            var maximum = data[0]._xScale.max;
            return [minimum, maximum];
        };
        /** Get the value for a given handle */
        TimelineChartPlugin.prototype.getHandleValue = function (chart, handle) {
            var _a = this.getOptions(chart).range, lower = _a.lower, upper = _a.upper;
            return handle === exports.TimelineHandle.Lower ? lower : upper;
        };
        TimelineChartPlugin.prototype.setHandleValue = function (chart, handle, value) {
            // perform lower handle validation
            if (handle === exports.TimelineHandle.Lower) {
                value = new Date(Math.min(Math.max(this.getHandleMinimum(chart, handle), value.getTime()), this.getHandleMaximum(chart, handle)));
            }
            // perform upper handle validation
            if (handle === exports.TimelineHandle.Upper) {
                value = new Date(Math.max(Math.min(this.getHandleMaximum(chart, handle), value.getTime()), this.getHandleMinimum(chart, handle)));
            }
            // store the new value
            chart.config.options.timeline.range[handle] = value;
            // update the chart
            chart.update();
            // emit the latest range
            this.triggerOnChange(chart);
        };
        TimelineChartPlugin.prototype.getHandleMinimum = function (chart, handle) {
            // get the minimum distance
            var minDistance = this.getOptions(chart).range.minimum || 0;
            var maxDistance = this.getOptions(chart).range.maximum || Infinity;
            // get the chart boundaries
            var _a = __read(this.getChartRange(chart), 1), minimum = _a[0];
            // get the current date range
            var _b = this.getRange(chart), lower = _b.lower, upper = _b.upper;
            if (handle === exports.TimelineHandle.Lower) {
                return Math.max((upper.getTime() - maxDistance), minimum);
            }
            if (handle === exports.TimelineHandle.Upper) {
                return lower.getTime() + minDistance;
            }
        };
        TimelineChartPlugin.prototype.getHandleMaximum = function (chart, handle) {
            // get the minimum distance
            var minDistance = this.getOptions(chart).range.minimum || 0;
            var maxDistance = this.getOptions(chart).range.maximum || Infinity;
            // get the chart boundaries
            var _a = __read(this.getChartRange(chart), 2), maximum = _a[1];
            // get the current date range
            var _b = this.getRange(chart), lower = _b.lower, upper = _b.upper;
            if (handle === exports.TimelineHandle.Lower) {
                return upper.getTime() - minDistance;
            }
            if (handle === exports.TimelineHandle.Upper) {
                return Math.min((lower.getTime() + maxDistance), maximum);
            }
        };
        TimelineChartPlugin.prototype.getOptionsWithDefaults = function (options) {
            var merge = function (target, source) {
                var e_1, _a;
                try {
                    for (var _b = __values(Object.keys(source)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        if (source[key] instanceof Object && !(source[key] instanceof Date) && typeof source[key] !== 'function') {
                            Object.assign(source[key], merge(target[key], source[key]));
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return Object.assign(target || {}, source);
            };
            return merge(__assign({}, timelineDefaultOptions.timeline), options);
        };
        /** We only want to register the plugin once per application */
        TimelineChartPlugin._isRegistered = false;
        return TimelineChartPlugin;
    }());
    /**
     * Directly exporting a file that is not an Angular component, module, etc..
     * can cause build issues. We can use a module that instantiates the plugin
     * instead of directly exporting the Chart.js plugin.
     */
    var TimelineChartModule = /** @class */ (function () {
        function TimelineChartModule() {
            TimelineChartPlugin.register();
        }
        TimelineChartModule = __decorate([
            core.NgModule({}),
            __metadata("design:paramtypes", [])
        ], TimelineChartModule);
        return TimelineChartModule;
    }());
    (function (TimelineHandle) {
        TimelineHandle["Lower"] = "lower";
        TimelineHandle["Upper"] = "upper";
        TimelineHandle["Range"] = "range";
    })(exports.TimelineHandle || (exports.TimelineHandle = {}));
    var CookieAdapter = /** @class */ (function () {
        function CookieAdapter() {
        }
        CookieAdapter.prototype.getItem = function (key) {
            if (document.cookie) {
                // get all the cookies for this site
                var cookies = document.cookie.split(';');
                // process the cookies into a from we can easily manage
                var match = cookies
                    .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                    .find(function (cookie) { return cookie.key === key; });
                return match ? match.value : null;
            }
            return null;
        };
        CookieAdapter.prototype.setItem = function (key, value) {
            document.cookie = key + "=" + value + "; path=/";
        };
        CookieAdapter.prototype.removeItem = function (key) {
            document.cookie.split(';').forEach(function (cookie) {
                var eqPos = cookie.indexOf('=');
                var name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                if (name === key) {
                    document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                }
            });
        };
        CookieAdapter.prototype.clear = function () {
            var _this = this;
            // call remove item on each cookie
            document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                .forEach(function (cookie) { return _this.removeItem(cookie); });
        };
        CookieAdapter.prototype.getSupported = function () {
            // cookies are supported in all browsers
            return this;
        };
        return CookieAdapter;
    }());
    var LocalStorageAdapter = /** @class */ (function () {
        function LocalStorageAdapter() {
        }
        LocalStorageAdapter.prototype.getItem = function (key) {
            return localStorage.getItem(key);
        };
        LocalStorageAdapter.prototype.setItem = function (key, value) {
            localStorage.setItem(key, value);
        };
        LocalStorageAdapter.prototype.removeItem = function (key) {
            localStorage.removeItem(key);
        };
        LocalStorageAdapter.prototype.clear = function () {
            localStorage.clear();
        };
        LocalStorageAdapter.prototype.getSupported = function () {
            // if local storage variable does not exist fall back to cookies
            if (!localStorage) {
                return new CookieAdapter();
            }
            // try to make a test save to local storage to see if there are any exceptions
            try {
                localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                localStorage.removeItem('ux-persistent-data-service');
                return this;
            }
            catch (err) {
                return new CookieAdapter();
            }
        };
        return LocalStorageAdapter;
    }());
    var SessionStorageAdapter = /** @class */ (function () {
        function SessionStorageAdapter() {
        }
        SessionStorageAdapter.prototype.getItem = function (key) {
            return sessionStorage.getItem(key);
        };
        SessionStorageAdapter.prototype.setItem = function (key, value) {
            sessionStorage.setItem(key, value);
        };
        SessionStorageAdapter.prototype.removeItem = function (key) {
            sessionStorage.removeItem(key);
        };
        SessionStorageAdapter.prototype.clear = function () {
            sessionStorage.clear();
        };
        SessionStorageAdapter.prototype.getSupported = function () {
            // if local storage variable does not exist fall back to cookies
            if (!sessionStorage) {
                return new CookieAdapter();
            }
            // try to make a test save to local storage to see if there are any exceptions
            try {
                sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                sessionStorage.removeItem('ux-persistent-data-service');
                return this;
            }
            catch (err) {
                return new CookieAdapter();
            }
        };
        return SessionStorageAdapter;
    }());
    var PersistentDataService = /** @class */ (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        PersistentDataService.prototype.setItem = function (key, value, type) {
            if (type === void 0) {
                type = exports.PersistentDataStorageType.LocalStorage;
            }
            this.getAdapter(type).setItem(key, value);
        };
        /**
         * Get a stored value from persistent storage
         */
        PersistentDataService.prototype.getItem = function (key, type) {
            if (type === void 0) {
                type = exports.PersistentDataStorageType.LocalStorage;
            }
            return this.getAdapter(type).getItem(key);
        };
        /**
         * Remove a stored value from persistent storage
         */
        PersistentDataService.prototype.removeItem = function (key, type) {
            if (type === void 0) {
                type = exports.PersistentDataStorageType.LocalStorage;
            }
            this.getAdapter(type).removeItem(key);
        };
        /**
         * Remove a stored value from persistent storage
         */
        PersistentDataService.prototype.clear = function (type) {
            if (type === void 0) {
                type = exports.PersistentDataStorageType.LocalStorage;
            }
            this.getAdapter(type).clear();
        };
        /**
         * Return the appropriate adapter based on the type requested
         */
        PersistentDataService.prototype.getAdapter = function (type) {
            switch (type) {
                case exports.PersistentDataStorageType.Cookie:
                    return new CookieAdapter();
                case exports.PersistentDataStorageType.LocalStorage:
                    var localStorageAdapter = new LocalStorageAdapter();
                    return localStorageAdapter.getSupported();
                case exports.PersistentDataStorageType.SessionStorage:
                    var sessionStorageAdapter = new SessionStorageAdapter();
                    return sessionStorageAdapter.getSupported();
            }
        };
        PersistentDataService = __decorate([
            core.Injectable()
        ], PersistentDataService);
        return PersistentDataService;
    }());
    (function (PersistentDataStorageType) {
        PersistentDataStorageType[PersistentDataStorageType["LocalStorage"] = 0] = "LocalStorage";
        PersistentDataStorageType[PersistentDataStorageType["Cookie"] = 1] = "Cookie";
        PersistentDataStorageType[PersistentDataStorageType["SessionStorage"] = 2] = "SessionStorage";
    })(exports.PersistentDataStorageType || (exports.PersistentDataStorageType = {}));
    var PersistentDataModule = /** @class */ (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule = __decorate([
            core.NgModule({
                providers: [PersistentDataService],
            })
        ], PersistentDataModule);
        return PersistentDataModule;
    }());
    var StorageAdapter = /** @class */ (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());
    exports.ACCESSIBILITY_OPTIONS_TOKEN = ACCESSIBILITY_OPTIONS_TOKEN;
    exports.AccessibilityModule = AccessibilityModule;
    exports.AccessibilityOptionsService = AccessibilityOptionsService;
    exports.AccordionComponent = AccordionComponent;
    exports.AccordionModule = AccordionModule;
    exports.AccordionPanelComponent = AccordionPanelComponent;
    exports.AccordionPanelHeadingDirective = AccordionPanelHeadingDirective;
    exports.AccordionService = AccordionService;
    exports.AlertComponent = AlertComponent;
    exports.AlertIconDirective = AlertIconDirective;
    exports.AlertModule = AlertModule;
    exports.AudioService = AudioService;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.AutoGrowModule = AutoGrowModule;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.COLOR_SET_TOKEN = COLOR_SET_TOKEN;
    exports.CONDUITS = CONDUITS;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CheckboxComponent = CheckboxComponent;
    exports.CheckboxModule = CheckboxModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ColorContrastDirective = ColorContrastDirective;
    exports.ColorPickerColor = ColorPickerColor;
    exports.ColorPickerComponent = ColorPickerComponent;
    exports.ColorPickerModule = ColorPickerModule;
    exports.ColorService = ColorService;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColumnPickerComponent = ColumnPickerComponent;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.Conduit = Conduit;
    exports.ConduitComponent = ConduitComponent;
    exports.ConduitModule = ConduitModule;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZone = ConduitZone;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ContrastService = ContrastService;
    exports.CookieAdapter = CookieAdapter;
    exports.DRAG_SERVICE_PROVIDER = DRAG_SERVICE_PROVIDER;
    exports.DRAG_SERVICE_PROVIDER_FACTORY = DRAG_SERVICE_PROVIDER_FACTORY;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardGrabHandleDirective = DashboardGrabHandleDirective;
    exports.DashboardModule = DashboardModule;
    exports.DashboardService = DashboardService;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DateFormatterPipe = DateFormatterPipe;
    exports.DateFormatterPipeModule = DateFormatterPipeModule;
    exports.DateRangeOptions = DateRangeOptions;
    exports.DateRangePickerComponent = DateRangePickerComponent;
    exports.DateRangePickerDirective = DateRangePickerDirective;
    exports.DateRangePickerModule = DateRangePickerModule;
    exports.DateRangeService = DateRangeService;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DefaultFocusIndicatorDirective = DefaultFocusIndicatorDirective;
    exports.DragDirective = DragDirective;
    exports.DragModule = DragModule;
    exports.DragService = DragService;
    exports.DropDirective = DropDirective;
    exports.DurationPipe = DurationPipe;
    exports.DurationPipeModule = DurationPipeModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxContentDirective = EboxContentDirective;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxModule = EboxModule;
    exports.FOCUS_ORIGIN_SERVICE_PROVIDER = FOCUS_ORIGIN_SERVICE_PROVIDER;
    exports.FOCUS_ORIGIN_SERVICE_PROVIDER_FACTORY = FOCUS_ORIGIN_SERVICE_PROVIDER_FACTORY;
    exports.FRAME_EXTRACTION_SERVICE_PROVIDER = FRAME_EXTRACTION_SERVICE_PROVIDER;
    exports.FRAME_EXTRACTION_SERVICE_PROVIDER_FACTORY = FRAME_EXTRACTION_SERVICE_PROVIDER_FACTORY;
    exports.Facet = Facet;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetCheckListItemComponent = FacetCheckListItemComponent;
    exports.FacetClearButtonDirective = FacetClearButtonDirective;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetService = FacetService;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadListItemComponent = FacetTypeaheadListItemComponent;
    exports.FacetsModule = FacetsModule;
    exports.FileSizePipe = FileSizePipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FilterModule = FilterModule;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterService = FilterService;
    exports.FilterTypeaheadHighlight = FilterTypeaheadHighlight;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.FocusIndicator = FocusIndicator;
    exports.FocusIndicatorDirective = FocusIndicatorDirective;
    exports.FocusIndicatorOptionsDirective = FocusIndicatorOptionsDirective;
    exports.FocusIndicatorOrigin = FocusIndicatorOrigin;
    exports.FocusIndicatorOriginDirective = FocusIndicatorOriginDirective;
    exports.FocusIndicatorOriginService = FocusIndicatorOriginService;
    exports.FocusIndicatorService = FocusIndicatorService;
    exports.FocusWithinDirective = FocusWithinDirective;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.HELP_CENTER_SERVICE_PROVIDER = HELP_CENTER_SERVICE_PROVIDER;
    exports.HELP_CENTER_SERVICE_PROVIDER_FACTORY = HELP_CENTER_SERVICE_PROVIDER_FACTORY;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HierarchyBarCollapsedComponent = HierarchyBarCollapsedComponent;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.HierarchyBarNodeIconDirective = HierarchyBarNodeIconDirective;
    exports.HierarchyBarStandardComponent = HierarchyBarStandardComponent;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.ICON_OPTIONS_TOKEN = ICON_OPTIONS_TOKEN;
    exports.IconComponent = IconComponent;
    exports.IconModule = IconModule;
    exports.IconService = IconService;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.InputDropdownComponent = InputDropdownComponent;
    exports.InputDropdownModule = InputDropdownModule;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LocalFocusIndicatorOptions = LocalFocusIndicatorOptions;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.ManagedFocusContainerDirective = ManagedFocusContainerDirective;
    exports.ManagedFocusContainerService = ManagedFocusContainerService;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardStepIconDirective = MarqueeWizardStepIconDirective;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerCustomControlDirective = MediaPlayerCustomControlDirective;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.MenuComponent = MenuComponent;
    exports.MenuDividerComponent = MenuDividerComponent;
    exports.MenuItemComponent = MenuItemComponent;
    exports.MenuModule = MenuModule;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.MenuNavigationToggleDirective = MenuNavigationToggleDirective;
    exports.MenuTabbableItemDirective = MenuTabbableItemDirective;
    exports.MenuTriggerDirective = MenuTriggerDirective;
    exports.NAVIGATION_MODULE_OPTIONS = NAVIGATION_MODULE_OPTIONS;
    exports.NOTIFICATION_SERVICE_PROVIDER = NOTIFICATION_SERVICE_PROVIDER;
    exports.NOTIFICATION_SERVICE_PROVIDER_FACTORY = NOTIFICATION_SERVICE_PROVIDER_FACTORY;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NavigationLinkDirective = NavigationLinkDirective;
    exports.NavigationModule = NavigationModule;
    exports.NavigationService = NavigationService;
    exports.NestedDonutChartComponent = NestedDonutChartComponent;
    exports.NestedDonutChartModule = NestedDonutChartModule;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.ObserversModule = ObserversModule;
    exports.OrganizationChartComponent = OrganizationChartComponent;
    exports.OrganizationChartModule = OrganizationChartModule;
    exports.OverflowDirective = OverflowDirective;
    exports.PAGINATION_CONTROL_VALUE_ACCESSOR = PAGINATION_CONTROL_VALUE_ACCESSOR;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationModule = PaginationModule;
    exports.PartitionMapComponent = PartitionMapComponent;
    exports.PartitionMapModule = PartitionMapModule;
    exports.PartitionMapSegmentEventsDirective = PartitionMapSegmentEventsDirective;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.PopoverModule = PopoverModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.ProgressBarModule = ProgressBarModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RADIO_GROUP_CONTROL_VALUE_ACCESSOR = RADIO_GROUP_CONTROL_VALUE_ACCESSOR;
    exports.REORDERABLE_SERVICE_PROVIDER = REORDERABLE_SERVICE_PROVIDER;
    exports.REORDERABLE_SERVICE_PROVIDER_FACTORY = REORDERABLE_SERVICE_PROVIDER_FACTORY;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.RadioButtonGroupDirective = RadioButtonGroupDirective;
    exports.RadioButtonModule = RadioButtonModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableService = ReorderableService;
    exports.ResizableExpandingTableDirective = ResizableExpandingTableDirective;
    exports.ResizableTableCellDirective = ResizableTableCellDirective;
    exports.ResizableTableColumnComponent = ResizableTableColumnComponent;
    exports.ResizableTableDirective = ResizableTableDirective;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ResizeService = ResizeService;
    exports.SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER = SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER;
    exports.SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER_FACTORY = SEARCH_BUILDER_FOCUS_SERVICE_PROVIDER_FACTORY;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SankeyChart = SankeyChart;
    exports.SankeyChartComponent = SankeyChartComponent;
    exports.SankeyChartModule = SankeyChartModule;
    exports.SankeyNodeDirective = SankeyNodeDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderFocusService = SearchBuilderFocusService;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.SearchBuilderService = SearchBuilderService;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SelectComponent = SelectComponent;
    exports.SelectListComponent = SelectListComponent;
    exports.SelectListItemComponent = SelectListItemComponent;
    exports.SelectListModule = SelectListModule;
    exports.SelectModule = SelectModule;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderModule = SliderModule;
    exports.SparkComponent = SparkComponent;
    exports.SparkModule = SparkModule;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SplitterAccessibilityDirective = SplitterAccessibilityDirective;
    exports.StepChangingEvent = StepChangingEvent;
    exports.StorageAdapter = StorageAdapter;
    exports.StringFilterModule = StringFilterModule;
    exports.StringFilterPipe = StringFilterPipe;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TOOLBAR_SEARCH_VALUE_ACCESSOR = TOOLBAR_SEARCH_VALUE_ACCESSOR;
    exports.TYPEAHEAD_KEY_SERVICE_PROVIDER = TYPEAHEAD_KEY_SERVICE_PROVIDER;
    exports.TYPEAHEAD_KEY_SERVICE_PROVIDER_FACTORY = TYPEAHEAD_KEY_SERVICE_PROVIDER_FACTORY;
    exports.TabComponent = TabComponent;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabbableListDirective = TabbableListDirective;
    exports.TabbableListItemDirective = TabbableListItemDirective;
    exports.TabbableListService = TabbableListService;
    exports.TableModule = TableModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetModule = TabsetModule;
    exports.TabsetService = TabsetService;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputModule = TagInputModule;
    exports.ThemeColor = ThemeColor;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimePickerModule = TimePickerModule;
    exports.TimelineChartModule = TimelineChartModule;
    exports.TimelineChartPlugin = TimelineChartPlugin;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.TimelineModule = TimelineModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipService = TooltipService;
    exports.TreeGridDirective = TreeGridDirective;
    exports.TreeGridIndentDirective = TreeGridIndentDirective;
    exports.TreeGridModule = TreeGridModule;
    exports.TreeGridRowDirective = TreeGridRowDirective;
    exports.TreeGridState = TreeGridState;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadModule = TypeaheadModule;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.VirtualForContainerComponent = VirtualForContainerComponent;
    exports.VirtualForDirective = VirtualForDirective;
    exports.VirtualForService = VirtualForService;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.WizardComponent = WizardComponent;
    exports.WizardModule = WizardModule;
    exports.WizardStepComponent = WizardStepComponent;
    exports.colorSets = colorSets;
    exports.compareDays = compareDays;
    exports.dateComparator = dateComparator;
    exports.dateRange = dateRange;
    exports.defaultConduitProps = defaultConduitProps;
    exports.defaultOptions = defaultOptions;
    exports.differenceBetweenDates = differenceBetweenDates;
    exports.getIconType = getIconType;
    exports.getStartOfDay = getStartOfDay;
    exports.gridify = gridify;
    exports.hpeIconset = hpeIconset;
    exports.isDateAfter = isDateAfter;
    exports.isDateBefore = isDateBefore;
    exports.isKeyboardTrigger = isKeyboardTrigger;
    exports.isMouseTrigger = isMouseTrigger;
    exports.meridians = meridians;
    exports.months = months;
    exports.monthsShort = monthsShort;
    exports.range = range;
    exports.tick = tick;
    exports.timezoneComparator = timezoneComparator;
    exports.timezones = timezones;
    exports.uxIconset = uxIconset;
    exports.weekdays = weekdays;
    exports.weekdaysShort = weekdaysShort;
    exports.ɵ0 = ɵ0;
    exports.ɵa = KEPPEL_COLOR_SET;
    exports.ɵb = MICRO_FOCUS_COLOR_SET;
    exports.ɵba = exports["ɵba"];
    exports.ɵbb = sidePanelStateAnimation;
    exports.ɵbc = MarqueeWizardService;
    exports.ɵbd = MediaPlayerService;
    exports.ɵbe = PageHeaderService;
    exports.ɵbf = PageHeaderNavigationService;
    exports.ɵbg = PageHeaderNavigationItemComponent;
    exports.ɵbh = PageHeaderNavigationDropdownItemComponent;
    exports.ɵbi = PageHeaderNavigationSecondaryItemDirective;
    exports.ɵbj = SankeyFocusManager;
    exports.ɵbk = RESIZABLE_TABLE_SERVICE_TOKEN;
    exports.ɵbl = BaseResizableTableService;
    exports.ɵbm = BaseResizableTableDirective;
    exports.ɵbn = ResizeService;
    exports.ɵbo = ResizableExpandingTableService;
    exports.ɵbp = ResizableTableService;
    exports.ɵbq = HoverActionService;
    exports.ɵbr = MenuNavigationService;
    exports.ɵbs = TreeGridService;
    exports.ɵd = DashboardGrabHandleService;
    exports.ɵe = HeaderComponent;
    exports.ɵf = DayViewComponent;
    exports.ɵg = DayViewService;
    exports.ɵh = MonthViewComponent;
    exports.ɵi = MonthViewService;
    exports.ɵj = YearViewComponent;
    exports.ɵk = YearViewService;
    exports.ɵl = TimeViewComponent;
    exports.ɵm = WeekDaySortPipe;
    exports.ɵn = TypeaheadService;
    exports.ɵo = PopoverOrientationService;
    exports.ɵp = TypeaheadHighlightDirective;
    exports.ɵq = TypeaheadOptionsListComponent;
    exports.ɵr = MENU_OPTIONS_TOKEN;
    exports.ɵt = FloatingActionButtonsService;
    exports.ɵu = HierarchyBarService;
    exports.ɵv = HierarchyBarNodeComponent;
    exports.ɵw = HierarchyBarPopoverComponent;
    exports.ɵx = HierarchyBarPopoverItemComponent;
    exports.ɵy = commonIcons;
    exports.ɵz = SidePanelService;
    Object.defineProperty(exports, '__esModule', { value: true });
})));
//# sourceMappingURL=ux-aspects-ux-aspects.umd.js.map
